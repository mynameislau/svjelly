(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.svjellymaker = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/Lau/www/svjelly/libs/p2.js":[function(require,module,exports){
(function (global){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 p2.js authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&false)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.p2=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
var Scalar = _dereq_('./Scalar');

module.exports = Line;

/**
 * Container for line-related functions
 * @class Line
 */
function Line(){};

/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
Line.lineInt = function(l1,l2,precision){
    precision = precision || 0;
    var i = [0,0]; // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2*b1;
    if (!Scalar.eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
};

/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
Line.segmentsIntersect = function(p1, p2, q1, q2){
   var dx = p2[0] - p1[0];
   var dy = p2[1] - p1[1];
   var da = q2[0] - q1[0];
   var db = q2[1] - q1[1];

   // segments are parallel
   if(da*dy - db*dx == 0)
      return false;

   var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx)
   var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy)

   return (s>=0 && s<=1 && t>=0 && t<=1);
};


},{"./Scalar":4}],2:[function(_dereq_,module,exports){
module.exports = Point;

/**
 * Point related functions
 * @class Point
 */
function Point(){};

/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
Point.area = function(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));
};

Point.left = function(a,b,c){
    return Point.area(a,b,c) > 0;
};

Point.leftOn = function(a,b,c) {
    return Point.area(a, b, c) >= 0;
};

Point.right = function(a,b,c) {
    return Point.area(a, b, c) < 0;
};

Point.rightOn = function(a,b,c) {
    return Point.area(a, b, c) <= 0;
};

var tmpPoint1 = [],
    tmpPoint2 = [];

/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
Point.collinear = function(a,b,c,thresholdAngle) {
    if(!thresholdAngle)
        return Point.area(a, b, c) == 0;
    else {
        var ab = tmpPoint1,
            bc = tmpPoint2;

        ab[0] = b[0]-a[0];
        ab[1] = b[1]-a[1];
        bc[0] = c[0]-b[0];
        bc[1] = c[1]-b[1];

        var dot = ab[0]*bc[0] + ab[1]*bc[1],
            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),
            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),
            angle = Math.acos(dot/(magA*magB));
        return angle < thresholdAngle;
    }
};

Point.sqdist = function(a,b){
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
};

},{}],3:[function(_dereq_,module,exports){
var Line = _dereq_("./Line")
,   Point = _dereq_("./Point")
,   Scalar = _dereq_("./Scalar")

module.exports = Polygon;

/**
 * Polygon class.
 * @class Polygon
 * @constructor
 */
function Polygon(){

    /**
     * Vertices that this polygon consists of. An array of array of numbers, example: [[0,0],[1,0],..]
     * @property vertices
     * @type {Array}
     */
    this.vertices = [];
}

/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
Polygon.prototype.at = function(i){
    var v = this.vertices,
        s = v.length;
    return v[i < 0 ? i % s + s : i % s];
};

/**
 * Get first vertex
 * @method first
 * @return {Array}
 */
Polygon.prototype.first = function(){
    return this.vertices[0];
};

/**
 * Get last vertex
 * @method last
 * @return {Array}
 */
Polygon.prototype.last = function(){
    return this.vertices[this.vertices.length-1];
};

/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
Polygon.prototype.clear = function(){
    this.vertices.length = 0;
};

/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
Polygon.prototype.append = function(poly,from,to){
    if(typeof(from) == "undefined") throw new Error("From is not given!");
    if(typeof(to) == "undefined")   throw new Error("To is not given!");

    if(to-1 < from)                 throw new Error("lol1");
    if(to > poly.vertices.length)   throw new Error("lol2");
    if(from < 0)                    throw new Error("lol3");

    for(var i=from; i<to; i++){
        this.vertices.push(poly.vertices[i]);
    }
};

/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
Polygon.prototype.makeCCW = function(){
    var br = 0,
        v = this.vertices;

    // find bottom right point
    for (var i = 1; i < this.vertices.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] == v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }

    // reverse poly if clockwise
    if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {
        this.reverse();
    }
};

/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
Polygon.prototype.reverse = function(){
    var tmp = [];
    for(var i=0, N=this.vertices.length; i!==N; i++){
        tmp.push(this.vertices.pop());
    }
    this.vertices = tmp;
};

/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
Polygon.prototype.isReflex = function(i){
    return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));
};

var tmpLine1=[],
    tmpLine2=[];

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
Polygon.prototype.canSee = function(a,b) {
    var p, dist, l1=tmpLine1, l2=tmpLine2;

    if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {
        return false;
    }
    dist = Point.sqdist(this.at(a), this.at(b));
    for (var i = 0; i !== this.vertices.length; ++i) { // for each edge
        if ((i + 1) % this.vertices.length === a || i === a) // ignore incident edges
            continue;
        if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) { // if diag intersects an edge
            l1[0] = this.at(a);
            l1[1] = this.at(b);
            l2[0] = this.at(i);
            l2[1] = this.at(i + 1);
            p = Line.lineInt(l1,l2);
            if (Point.sqdist(this.at(a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }

    return true;
};

/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
Polygon.prototype.copy = function(i,j,targetPoly){
    var p = targetPoly || new Polygon();
    p.clear();
    if (i < j) {
        // Insert all vertices from i to j
        for(var k=i; k<=j; k++)
            p.vertices.push(this.vertices[k]);

    } else {

        // Insert vertices 0 to j
        for(var k=0; k<=j; k++)
            p.vertices.push(this.vertices[k]);

        // Insert vertices i to end
        for(var k=i; k<this.vertices.length; k++)
            p.vertices.push(this.vertices[k]);
    }

    return p;
};

/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
Polygon.prototype.getCutEdges = function() {
    var min=[], tmp1=[], tmp2=[], tmpPoly = new Polygon();
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < this.vertices.length; ++i) {
        if (this.isReflex(i)) {
            for (var j = 0; j < this.vertices.length; ++j) {
                if (this.canSee(i, j)) {
                    tmp1 = this.copy(i, j, tmpPoly).getCutEdges();
                    tmp2 = this.copy(j, i, tmpPoly).getCutEdges();

                    for(var k=0; k<tmp2.length; k++)
                        tmp1.push(tmp2[k]);

                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        min.push([this.at(i), this.at(j)]);
                    }
                }
            }
        }
    }

    return min;
};

/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
Polygon.prototype.decomp = function(){
    var edges = this.getCutEdges();
    if(edges.length > 0)
        return this.slice(edges);
    else
        return [this];
};

/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
Polygon.prototype.slice = function(cutEdges){
    if(cutEdges.length == 0) return [this];
    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length==2 && cutEdges[0][0] instanceof Array){

        var polys = [this];

        for(var i=0; i<cutEdges.length; i++){
            var cutEdge = cutEdges[i];
            // Cut all polys
            for(var j=0; j<polys.length; j++){
                var poly = polys[j];
                var result = poly.slice(cutEdge);
                if(result){
                    // Found poly! Cut and quit
                    polys.splice(j,1);
                    polys.push(result[0],result[1]);
                    break;
                }
            }
        }

        return polys;
    } else {

        // Was given one edge
        var cutEdge = cutEdges;
        var i = this.vertices.indexOf(cutEdge[0]);
        var j = this.vertices.indexOf(cutEdge[1]);

        if(i != -1 && j != -1){
            return [this.copy(i,j),
                    this.copy(j,i)];
        } else {
            return false;
        }
    }
};

/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
Polygon.prototype.isSimple = function(){
    var path = this.vertices;
    // Check
    for(var i=0; i<path.length-1; i++){
        for(var j=0; j<i-1; j++){
            if(Line.segmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){
                return false;
            }
        }
    }

    // Check the segment between the last and the first point to all others
    for(var i=1; i<path.length-2; i++){
        if(Line.segmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){
            return false;
        }
    }

    return true;
};

function getIntersectionPoint(p1, p2, q1, q2, delta){
    delta = delta || 0;
   var a1 = p2[1] - p1[1];
   var b1 = p1[0] - p2[0];
   var c1 = (a1 * p1[0]) + (b1 * p1[1]);
   var a2 = q2[1] - q1[1];
   var b2 = q1[0] - q2[0];
   var c2 = (a2 * q1[0]) + (b2 * q1[1]);
   var det = (a1 * b2) - (a2 * b1);

   if(!Scalar.eq(det,0,delta))
      return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det]
   else
      return [0,0]
}

/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
Polygon.prototype.quickDecomp = function(result,reflexVertices,steinerPoints,delta,maxlevel,level){
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof(result)!="undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];

    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points
    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars
    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers
    var lowerPoly=new Polygon(), upperPoly=new Polygon(); // polygons
    var poly = this,
        v = this.vertices;

    if(v.length < 3) return result;

    level++;
    if(level > maxlevel){
        console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }

    for (var i = 0; i < this.vertices.length; ++i) {
        if (poly.isReflex(i)) {
            reflexVertices.push(poly.vertices[i]);
            upperDist = lowerDist = Number.MAX_VALUE;


            for (var j = 0; j < this.vertices.length; ++j) {
                if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j))
                        && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1)); // find the point of intersection
                    if (Point.right(poly.at(i + 1), poly.at(i), p)) { // make sure it's inside the poly
                        d = Point.sqdist(poly.vertices[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1))
                        && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                    p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));
                    if (Point.left(poly.at(i - 1), poly.at(i), p)) {
                        d = Point.sqdist(poly.vertices[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }

            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex == (upperIndex + 1) % this.vertices.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+this.vertices.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);

                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    lowerPoly.append(poly, i, upperIndex+1);
                    lowerPoly.vertices.push(p);
                    upperPoly.vertices.push(p);
                    if (lowerIndex != 0){
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        upperPoly.append(poly,lowerIndex,poly.vertices.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    upperPoly.append(poly,0,i+1);
                } else {
                    if (i != 0){
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        lowerPoly.append(poly,i,poly.vertices.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    lowerPoly.append(poly,0,upperIndex+1);
                    lowerPoly.vertices.push(p);
                    upperPoly.vertices.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    upperPoly.append(poly,lowerIndex,i+1);
                }
            } else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+this.vertices.length+")\n");

                if (lowerIndex > upperIndex) {
                    upperIndex += this.vertices.length;
                }
                closestDist = Number.MAX_VALUE;

                if(upperIndex < lowerIndex){
                    return result;
                }

                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j))
                            && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                        d = Point.sqdist(poly.at(i), poly.at(j));
                        if (d < closestDist) {
                            closestDist = d;
                            closestIndex = j % this.vertices.length;
                        }
                    }
                }

                if (i < closestIndex) {
                    lowerPoly.append(poly,i,closestIndex+1);
                    if (closestIndex != 0){
                        upperPoly.append(poly,closestIndex,v.length);
                    }
                    upperPoly.append(poly,0,i+1);
                } else {
                    if (i != 0){
                        lowerPoly.append(poly,i,v.length);
                    }
                    lowerPoly.append(poly,0,closestIndex+1);
                    upperPoly.append(poly,closestIndex,i+1);
                }
            }

            // solve smallest poly first
            if (lowerPoly.vertices.length < upperPoly.vertices.length) {
                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
            } else {
                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
            }

            return result;
        }
    }
    result.push(this);

    return result;
};

/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
Polygon.prototype.removeCollinearPoints = function(precision){
    var num = 0;
    for(var i=this.vertices.length-1; this.vertices.length>3 && i>=0; --i){
        if(Point.collinear(this.at(i-1),this.at(i),this.at(i+1),precision)){
            // Remove the middle point
            this.vertices.splice(i%this.vertices.length,1);
            i--; // Jump one point forward. Otherwise we may get a chain removal
            num++;
        }
    }
    return num;
};

},{"./Line":1,"./Point":2,"./Scalar":4}],4:[function(_dereq_,module,exports){
module.exports = Scalar;

/**
 * Scalar functions
 * @class Scalar
 */
function Scalar(){}

/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
Scalar.eq = function(a,b,precision){
    precision = precision || 0;
    return Math.abs(a-b) < precision;
};

},{}],5:[function(_dereq_,module,exports){
module.exports = {
    Polygon : _dereq_("./Polygon"),
    Point : _dereq_("./Point"),
};

},{"./Point":2,"./Polygon":3}],6:[function(_dereq_,module,exports){
module.exports={
  "name": "p2",
  "version": "0.6.1",
  "description": "A JavaScript 2D physics engine.",
  "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
  "keywords": [
    "p2.js",
    "p2",
    "physics",
    "engine",
    "2d"
  ],
  "main": "./src/p2.js",
  "engines": {
    "node": "*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/schteppe/p2.js.git"
  },
  "bugs": {
    "url": "https://github.com/schteppe/p2.js/issues"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "devDependencies": {
    "grunt": "~0.4.0",
    "grunt-contrib-jshint": "~0.9.2",
    "grunt-contrib-nodeunit": "~0.1.2",
    "grunt-contrib-uglify": "~0.4.0",
    "grunt-contrib-watch": "~0.5.0",
    "grunt-browserify": "~2.0.1",
    "grunt-contrib-concat": "^0.4.0"
  },
  "dependencies": {
    "poly-decomp": "0.1.0"
  }
}

},{}],7:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = AABB;

/**
 * Axis aligned bounding box class.
 * @class AABB
 * @constructor
 * @param {Object}  [options]
 * @param {Array}   [options.upperBound]
 * @param {Array}   [options.lowerBound]
 */
function AABB(options){

    /**
     * The lower bound of the bounding box.
     * @property lowerBound
     * @type {Array}
     */
    this.lowerBound = vec2.create();
    if(options && options.lowerBound){
        vec2.copy(this.lowerBound, options.lowerBound);
    }

    /**
     * The upper bound of the bounding box.
     * @property upperBound
     * @type {Array}
     */
    this.upperBound = vec2.create();
    if(options && options.upperBound){
        vec2.copy(this.upperBound, options.upperBound);
    }
}

var tmp = vec2.create();

/**
 * Set the AABB bounds from a set of points.
 * @method setFromPoints
 * @param {Array} points An array of vec2's.
 */
AABB.prototype.setFromPoints = function(points, position, angle, skinSize){
    var l = this.lowerBound,
        u = this.upperBound;

    if(typeof(angle) !== "number"){
        angle = 0;
    }

    // Set to the first point
    if(angle !== 0){
        vec2.rotate(l, points[0], angle);
    } else {
        vec2.copy(l, points[0]);
    }
    vec2.copy(u, l);

    // Compute cosines and sines just once
    var cosAngle = Math.cos(angle),
        sinAngle = Math.sin(angle);
    for(var i = 1; i<points.length; i++){
        var p = points[i];

        if(angle !== 0){
            var x = p[0],
                y = p[1];
            tmp[0] = cosAngle * x -sinAngle * y;
            tmp[1] = sinAngle * x +cosAngle * y;
            p = tmp;
        }

        for(var j=0; j<2; j++){
            if(p[j] > u[j]){
                u[j] = p[j];
            }
            if(p[j] < l[j]){
                l[j] = p[j];
            }
        }
    }

    // Add offset
    if(position){
        vec2.add(this.lowerBound, this.lowerBound, position);
        vec2.add(this.upperBound, this.upperBound, position);
    }

    if(skinSize){
        this.lowerBound[0] -= skinSize;
        this.lowerBound[1] -= skinSize;
        this.upperBound[0] += skinSize;
        this.upperBound[1] += skinSize;
    }
};

/**
 * Copy bounds from an AABB to this AABB
 * @method copy
 * @param  {AABB} aabb
 */
AABB.prototype.copy = function(aabb){
    vec2.copy(this.lowerBound, aabb.lowerBound);
    vec2.copy(this.upperBound, aabb.upperBound);
};

/**
 * Extend this AABB so that it covers the given AABB too.
 * @method extend
 * @param  {AABB} aabb
 */
AABB.prototype.extend = function(aabb){
    // Loop over x and y
    var i = 2;
    while(i--){
        // Extend lower bound
        var l = aabb.lowerBound[i];
        if(this.lowerBound[i] > l){
            this.lowerBound[i] = l;
        }

        // Upper
        var u = aabb.upperBound[i];
        if(this.upperBound[i] < u){
            this.upperBound[i] = u;
        }
    }
};

/**
 * Returns true if the given AABB overlaps this AABB.
 * @method overlaps
 * @param  {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.overlaps = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&
           ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));
};

},{"../math/vec2":31,"../utils/Utils":50}],8:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Body = _dereq_('../objects/Body');

module.exports = Broadphase;

/**
 * Base class for broadphase implementations.
 * @class Broadphase
 * @constructor
 */
function Broadphase(type){

    this.type = type;

    /**
     * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().
     * @property result
     * @type {Array}
     */
    this.result = [];

    /**
     * The world to search for collision pairs in. To change it, use .setWorld()
     * @property world
     * @type {World}
     * @readOnly
     */
    this.world = null;

    /**
     * The bounding volume type to use in the broadphase algorithms.
     * @property {Number} boundingVolumeType
     */
    this.boundingVolumeType = Broadphase.AABB;
}

/**
 * Axis aligned bounding box type.
 * @static
 * @property {Number} AABB
 */
Broadphase.AABB = 1;

/**
 * Bounding circle type.
 * @static
 * @property {Number} BOUNDING_CIRCLE
 */
Broadphase.BOUNDING_CIRCLE = 2;

/**
 * Set the world that we are searching for collision pairs in
 * @method setWorld
 * @param  {World} world
 */
Broadphase.prototype.setWorld = function(world){
    this.world = world;
};

/**
 * Get all potential intersecting body pairs.
 * @method getCollisionPairs
 * @param  {World} world The world to search in.
 * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).
 */
Broadphase.prototype.getCollisionPairs = function(world){
    throw new Error("getCollisionPairs must be implemented in a subclass!");
};

var dist = vec2.create();

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.boundingRadiusCheck = function(bodyA, bodyB){
    vec2.sub(dist, bodyA.position, bodyB.position);
    var d2 = vec2.squaredLength(dist),
        r = bodyA.boundingRadius + bodyB.boundingRadius;
    return d2 <= r*r;
};

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.aabbCheck = function(bodyA, bodyB){
    return bodyA.getAABB().overlaps(bodyB.getAABB());
};

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB){
    var result;

    switch(this.boundingVolumeType){
    case Broadphase.BOUNDING_CIRCLE:
        result =  Broadphase.boundingRadiusCheck(bodyA,bodyB);
        break;
    case Broadphase.AABB:
        result = Broadphase.aabbCheck(bodyA,bodyB);
        break;
    default:
        throw new Error('Bounding volume type not recognized: '+this.boundingVolumeType);
    }
    return result;
};

/**
 * Check whether two bodies are allowed to collide at all.
 * @method  canCollide
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.canCollide = function(bodyA, bodyB){

    // Cannot collide static bodies
    if(bodyA.type === Body.STATIC && bodyB.type === Body.STATIC){
        return false;
    }

    // Cannot collide static vs kinematic bodies
    if( (bodyA.type === Body.KINEMATIC && bodyB.type === Body.STATIC) ||
        (bodyA.type === Body.STATIC    && bodyB.type === Body.KINEMATIC)){
        return false;
    }

    // Cannot collide kinematic vs kinematic
    if(bodyA.type === Body.KINEMATIC && bodyB.type === Body.KINEMATIC){
        return false;
    }

    // Cannot collide both sleeping bodies
    if(bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING){
        return false;
    }

    // Cannot collide if one is static and the other is sleeping
    if( (bodyA.sleepState === Body.SLEEPING && bodyB.type === Body.STATIC) ||
        (bodyB.sleepState === Body.SLEEPING && bodyA.type === Body.STATIC)){
        return false;
    }

    return true;
};

Broadphase.NAIVE = 1;
Broadphase.SAP = 2;

},{"../math/vec2":31,"../objects/Body":32}],9:[function(_dereq_,module,exports){
var Circle = _dereq_('../shapes/Circle')
,   Plane = _dereq_('../shapes/Plane')
,   Particle = _dereq_('../shapes/Particle')
,   Broadphase = _dereq_('../collision/Broadphase')
,   vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = GridBroadphase;

/**
 * Broadphase that uses axis-aligned bins.
 * @class GridBroadphase
 * @constructor
 * @extends Broadphase
 * @param {object} [options]
 * @param {number} [options.xmin]   Lower x bound of the grid
 * @param {number} [options.xmax]   Upper x bound
 * @param {number} [options.ymin]   Lower y bound
 * @param {number} [options.ymax]   Upper y bound
 * @param {number} [options.nx]     Number of bins along x axis
 * @param {number} [options.ny]     Number of bins along y axis
 * @todo Should have an option for dynamic scene size
 */
function GridBroadphase(options){
    Broadphase.apply(this);

    options = Utils.defaults(options,{
        xmin:   -100,
        xmax:   100,
        ymin:   -100,
        ymax:   100,
        nx:     10,
        ny:     10
    });

    this.xmin = options.xmin;
    this.ymin = options.ymin;
    this.xmax = options.xmax;
    this.ymax = options.ymax;
    this.nx = options.nx;
    this.ny = options.ny;

    this.binsizeX = (this.xmax-this.xmin) / this.nx;
    this.binsizeY = (this.ymax-this.ymin) / this.ny;
}
GridBroadphase.prototype = new Broadphase();
GridBroadphase.prototype.constructor = GridBroadphase;

/**
 * Get collision pairs.
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
GridBroadphase.prototype.getCollisionPairs = function(world){
    var result = [],
        bodies = world.bodies,
        Ncolliding = bodies.length,
        binsizeX = this.binsizeX,
        binsizeY = this.binsizeY,
        nx = this.nx,
        ny = this.ny,
        xmin = this.xmin,
        ymin = this.ymin,
        xmax = this.xmax,
        ymax = this.ymax;

    // Todo: make garbage free
    var bins=[], Nbins=nx*ny;
    for(var i=0; i<Nbins; i++){
        bins.push([]);
    }

    var xmult = nx / (xmax-xmin);
    var ymult = ny / (ymax-ymin);

    // Put all bodies into bins
    for(var i=0; i!==Ncolliding; i++){
        var bi = bodies[i];
        var aabb = bi.aabb;
        var lowerX = Math.max(aabb.lowerBound[0], xmin);
        var lowerY = Math.max(aabb.lowerBound[1], ymin);
        var upperX = Math.min(aabb.upperBound[0], xmax);
        var upperY = Math.min(aabb.upperBound[1], ymax);
        var xi1 = Math.floor(xmult * (lowerX - xmin));
        var yi1 = Math.floor(ymult * (lowerY - ymin));
        var xi2 = Math.floor(xmult * (upperX - xmin));
        var yi2 = Math.floor(ymult * (upperY - ymin));

        // Put in bin
        for(var j=xi1; j<=xi2; j++){
            for(var k=yi1; k<=yi2; k++){
                var xi = j;
                var yi = k;
                var idx = xi*(ny-1) + yi;
                if(idx >= 0 && idx < Nbins){
                    bins[ idx ].push(bi);
                }
            }
        }
    }

    // Check each bin
    for(var i=0; i!==Nbins; i++){
        var bin = bins[i];

        for(var j=0, NbodiesInBin=bin.length; j!==NbodiesInBin; j++){
            var bi = bin[j];
            for(var k=0; k!==j; k++){
                var bj = bin[k];
                if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                    result.push(bi,bj);
                }
            }
        }
    }
    return result;
};

},{"../collision/Broadphase":8,"../math/vec2":31,"../shapes/Circle":38,"../shapes/Particle":42,"../shapes/Plane":43,"../utils/Utils":50}],10:[function(_dereq_,module,exports){
var Circle = _dereq_('../shapes/Circle'),
    Plane = _dereq_('../shapes/Plane'),
    Shape = _dereq_('../shapes/Shape'),
    Particle = _dereq_('../shapes/Particle'),
    Broadphase = _dereq_('../collision/Broadphase'),
    vec2 = _dereq_('../math/vec2');

module.exports = NaiveBroadphase;

/**
 * Naive broadphase implementation. Does N^2 tests.
 *
 * @class NaiveBroadphase
 * @constructor
 * @extends Broadphase
 */
function NaiveBroadphase(){
    Broadphase.call(this, Broadphase.NAIVE);
}
NaiveBroadphase.prototype = new Broadphase();
NaiveBroadphase.prototype.constructor = NaiveBroadphase;

/**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
NaiveBroadphase.prototype.getCollisionPairs = function(world){
    var bodies = world.bodies,
        result = this.result;

    result.length = 0;

    for(var i=0, Ncolliding=bodies.length; i!==Ncolliding; i++){
        var bi = bodies[i];

        for(var j=0; j<i; j++){
            var bj = bodies[j];

            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                result.push(bi,bj);
            }
        }
    }

    return result;
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    var bodies = world.bodies;
    for(var i = 0; i < bodies.length; i++){
        var b = bodies[i];

        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":8,"../math/vec2":31,"../shapes/Circle":38,"../shapes/Particle":42,"../shapes/Plane":43,"../shapes/Shape":45}],11:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   sub = vec2.sub
,   add = vec2.add
,   dot = vec2.dot
,   Utils = _dereq_('../utils/Utils')
,   TupleDictionary = _dereq_('../utils/TupleDictionary')
,   Equation = _dereq_('../equations/Equation')
,   ContactEquation = _dereq_('../equations/ContactEquation')
,   FrictionEquation = _dereq_('../equations/FrictionEquation')
,   Circle = _dereq_('../shapes/Circle')
,   Convex = _dereq_('../shapes/Convex')
,   Shape = _dereq_('../shapes/Shape')
,   Body = _dereq_('../objects/Body')
,   Rectangle = _dereq_('../shapes/Rectangle');

module.exports = Narrowphase;

// Temp things
var yAxis = vec2.fromValues(0,1);

var tmp1 = vec2.fromValues(0,0)
,   tmp2 = vec2.fromValues(0,0)
,   tmp3 = vec2.fromValues(0,0)
,   tmp4 = vec2.fromValues(0,0)
,   tmp5 = vec2.fromValues(0,0)
,   tmp6 = vec2.fromValues(0,0)
,   tmp7 = vec2.fromValues(0,0)
,   tmp8 = vec2.fromValues(0,0)
,   tmp9 = vec2.fromValues(0,0)
,   tmp10 = vec2.fromValues(0,0)
,   tmp11 = vec2.fromValues(0,0)
,   tmp12 = vec2.fromValues(0,0)
,   tmp13 = vec2.fromValues(0,0)
,   tmp14 = vec2.fromValues(0,0)
,   tmp15 = vec2.fromValues(0,0)
,   tmp16 = vec2.fromValues(0,0)
,   tmp17 = vec2.fromValues(0,0)
,   tmp18 = vec2.fromValues(0,0)
,   tmpArray = [];

/**
 * Narrowphase. Creates contacts and friction given shapes and transforms.
 * @class Narrowphase
 * @constructor
 */
function Narrowphase(){

    /**
     * @property contactEquations
     * @type {Array}
     */
    this.contactEquations = [];

    /**
     * @property frictionEquations
     * @type {Array}
     */
    this.frictionEquations = [];

    /**
     * Whether to make friction equations in the upcoming contacts.
     * @property enableFriction
     * @type {Boolean}
     */
    this.enableFriction = true;

    /**
     * Whether to make equations enabled in upcoming contacts.
     * @property enabledEquations
     * @type {Boolean}
     */
    this.enabledEquations = true;

    /**
     * The friction slip force to use when creating friction equations.
     * @property slipForce
     * @type {Number}
     */
    this.slipForce = 10.0;

    /**
     * The friction value to use in the upcoming friction equations.
     * @property frictionCoefficient
     * @type {Number}
     */
    this.frictionCoefficient = 0.3;

    /**
     * Will be the .relativeVelocity in each produced FrictionEquation.
     * @property {Number} surfaceVelocity
     */
    this.surfaceVelocity = 0;

    this.reuseObjects = true;
    this.reusableContactEquations = [];
    this.reusableFrictionEquations = [];

    /**
     * The restitution value to use in the next contact equations.
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0;

    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */
    this.stiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */
    this.relaxation = Equation.DEFAULT_RELAXATION;

    /**
     * The stiffness value to use in the next friction equations.
     * @property frictionStiffness
     * @type {Number}
     */
    this.frictionStiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The relaxation value to use in the next friction equations.
     * @property frictionRelaxation
     * @type {Number}
     */
    this.frictionRelaxation = Equation.DEFAULT_RELAXATION;

    /**
     * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.
     * @property enableFrictionReduction
     * @type {Boolean}
     * @deprecated This flag will be removed when the feature is stable enough.
     * @default true
     */
    this.enableFrictionReduction = true;

    /**
     * Keeps track of the colliding bodies last step.
     * @private
     * @property collidingBodiesLastStep
     * @type {TupleDictionary}
     */
    this.collidingBodiesLastStep = new TupleDictionary();

    /**
     * Contact skin size value to use in the next contact equations.
     * @property {Number} contactSkinSize
     * @default 0.01
     */
    this.contactSkinSize = 0.01;
}

var bodiesOverlap_shapePositionA = vec2.create();
var bodiesOverlap_shapePositionB = vec2.create();

/**
 * @method bodiesOverlap
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Narrowphase.prototype.bodiesOverlap = function(bodyA, bodyB){
    var shapePositionA = bodiesOverlap_shapePositionA;
    var shapePositionB = bodiesOverlap_shapePositionB;

    // Loop over all shapes of bodyA
    for(var k=0, Nshapesi=bodyA.shapes.length; k!==Nshapesi; k++){
        var shapeA = bodyA.shapes[k],
            positionA = bodyA.shapeOffsets[k],
            angleA = bodyA.shapeAngles[k];

        bodyA.toWorldFrame(shapePositionA, positionA);

        // All shapes of body j
        for(var l=0, Nshapesj=bodyB.shapes.length; l!==Nshapesj; l++){
            var shapeB = bodyB.shapes[l],
                positionB = bodyB.shapeOffsets[l],
                angleB = bodyB.shapeAngles[l];

            bodyB.toWorldFrame(shapePositionB, positionB);

            if(this[shapeA.type | shapeB.type](
                bodyA,
                shapeA,
                shapePositionA,
                shapeA.angle + bodyA.angle,
                bodyB,
                shapeB,
                shapePositionB,
                shapeB.angle + bodyB.angle,
                true
            )){
                return true;
            }
        }
    }

    return false;
};

/**
 * Check if the bodies were in contact since the last reset().
 * @method collidedLastStep
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Narrowphase.prototype.collidedLastStep = function(bodyA, bodyB){
    var id1 = bodyA.id|0,
        id2 = bodyB.id|0;
    return !!this.collidingBodiesLastStep.get(id1, id2);
};

/**
 * Throws away the old equations and gets ready to create new
 * @method reset
 */
Narrowphase.prototype.reset = function(){
    this.collidingBodiesLastStep.reset();

    var eqs = this.contactEquations;
    var l = eqs.length;
    while(l--){
        var eq = eqs[l],
            id1 = eq.bodyA.id,
            id2 = eq.bodyB.id;
        this.collidingBodiesLastStep.set(id1, id2, true);
    }

    if(this.reuseObjects){
        var ce = this.contactEquations,
            fe = this.frictionEquations,
            rfe = this.reusableFrictionEquations,
            rce = this.reusableContactEquations;
        Utils.appendArray(rce,ce);
        Utils.appendArray(rfe,fe);
    }

    // Reset
    this.contactEquations.length = this.frictionEquations.length = 0;
};

/**
 * Creates a ContactEquation, either by reusing an existing object or creating a new one.
 * @method createContactEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {ContactEquation}
 */
Narrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB){
    var c = this.reusableContactEquations.length ? this.reusableContactEquations.pop() : new ContactEquation(bodyA,bodyB);
    c.bodyA = bodyA;
    c.bodyB = bodyB;
    c.shapeA = shapeA;
    c.shapeB = shapeB;
    c.restitution = this.restitution;
    c.firstImpact = !this.collidedLastStep(bodyA,bodyB);
    c.stiffness = this.stiffness;
    c.relaxation = this.relaxation;
    c.needsUpdate = true;
    c.enabled = this.enabledEquations;
    c.offset = this.contactSkinSize;

    return c;
};

/**
 * Creates a FrictionEquation, either by reusing an existing object or creating a new one.
 * @method createFrictionEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {FrictionEquation}
 */
Narrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB){
    var c = this.reusableFrictionEquations.length ? this.reusableFrictionEquations.pop() : new FrictionEquation(bodyA,bodyB);
    c.bodyA = bodyA;
    c.bodyB = bodyB;
    c.shapeA = shapeA;
    c.shapeB = shapeB;
    c.setSlipForce(this.slipForce);
    c.frictionCoefficient = this.frictionCoefficient;
    c.relativeVelocity = this.surfaceVelocity;
    c.enabled = this.enabledEquations;
    c.needsUpdate = true;
    c.stiffness = this.frictionStiffness;
    c.relaxation = this.frictionRelaxation;
    c.contactEquations.length = 0;
    return c;
};

/**
 * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.
 * @method createFrictionFromContact
 * @param  {ContactEquation} contactEquation
 * @return {FrictionEquation}
 */
Narrowphase.prototype.createFrictionFromContact = function(c){
    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
    vec2.copy(eq.contactPointA, c.contactPointA);
    vec2.copy(eq.contactPointB, c.contactPointB);
    vec2.rotate90cw(eq.t, c.normalA);
    eq.contactEquations.push(c);
    return eq;
};

// Take the average N latest contact point on the plane.
Narrowphase.prototype.createFrictionFromAverage = function(numContacts){
    var c = this.contactEquations[this.contactEquations.length - 1];
    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    vec2.set(eq.contactPointA, 0, 0);
    vec2.set(eq.contactPointB, 0, 0);
    vec2.set(eq.t, 0, 0);
    for(var i=0; i!==numContacts; i++){
        c = this.contactEquations[this.contactEquations.length - 1 - i];
        if(c.bodyA === bodyA){
            vec2.add(eq.t, eq.t, c.normalA);
            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);
        } else {
            vec2.sub(eq.t, eq.t, c.normalA);
            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);
            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);
        }
        eq.contactEquations.push(c);
    }

    var invNumContacts = 1/numContacts;
    vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
    vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
    vec2.normalize(eq.t, eq.t);
    vec2.rotate90cw(eq.t, eq.t);
    return eq;
};

/**
 * Convex/line narrowphase
 * @method convexLine
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexOffset
 * @param  {Number}     convexAngle
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param {boolean}     justTest
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.CONVEX] =
Narrowphase.prototype.convexLine = function(
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

/**
 * Line/rectangle narrowphase
 * @method lineRectangle
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param  {Body}       rectangleBody
 * @param  {Rectangle}  rectangleShape
 * @param  {Array}      rectangleOffset
 * @param  {Number}     rectangleAngle
 * @param  {Boolean}    justTest
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.RECTANGLE] =
Narrowphase.prototype.lineRectangle = function(
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    rectangleBody,
    rectangleShape,
    rectangleOffset,
    rectangleAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape){
    vec2.set(convexShape.vertices[0], -capsuleShape.length * 0.5, -capsuleShape.radius);
    vec2.set(convexShape.vertices[1],  capsuleShape.length * 0.5, -capsuleShape.radius);
    vec2.set(convexShape.vertices[2],  capsuleShape.length * 0.5,  capsuleShape.radius);
    vec2.set(convexShape.vertices[3], -capsuleShape.length * 0.5,  capsuleShape.radius);
}

var convexCapsule_tempRect = new Rectangle(1,1),
    convexCapsule_tempVec = vec2.create();

/**
 * Convex/capsule narrowphase
 * @method convexCapsule
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexPosition
 * @param  {Number}     convexAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] =
Narrowphase.prototype[Shape.CAPSULE | Shape.RECTANGLE] =
Narrowphase.prototype.convexCapsule = function(
    convexBody,
    convexShape,
    convexPosition,
    convexAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){

    // Check the circles
    // Add offsets!
    var circlePos = convexCapsule_tempVec;
    vec2.set(circlePos, capsuleShape.length/2,0);
    vec2.rotate(circlePos,circlePos,capsuleAngle);
    vec2.add(circlePos,circlePos,capsulePosition);
    var result1 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);

    vec2.set(circlePos,-capsuleShape.length/2, 0);
    vec2.rotate(circlePos,circlePos,capsuleAngle);
    vec2.add(circlePos,circlePos,capsulePosition);
    var result2 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);

    if(justTest && (result1 || result2)){
        return true;
    }

    // Check center rect
    var r = convexCapsule_tempRect;
    setConvexToCapsuleShapeMiddle(r,capsuleShape);
    var result = this.convexConvex(convexBody,convexShape,convexPosition,convexAngle, capsuleBody,r,capsulePosition,capsuleAngle, justTest);

    return result + result1 + result2;
};

/**
 * Capsule/line narrowphase
 * @method lineCapsule
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      linePosition
 * @param  {Number}     lineAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.LINE] =
Narrowphase.prototype.lineCapsule = function(
    lineBody,
    lineShape,
    linePosition,
    lineAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

var capsuleCapsule_tempVec1 = vec2.create();
var capsuleCapsule_tempVec2 = vec2.create();
var capsuleCapsule_tempRect1 = new Rectangle(1,1);

/**
 * Capsule/capsule narrowphase
 * @method capsuleCapsule
 * @param  {Body}       bi
 * @param  {Capsule}    si
 * @param  {Array}      xi
 * @param  {Number}     ai
 * @param  {Body}       bj
 * @param  {Capsule}    sj
 * @param  {Array}      xj
 * @param  {Number}     aj
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] =
Narrowphase.prototype.capsuleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){

    var enableFrictionBefore;

    // Check the circles
    // Add offsets!
    var circlePosi = capsuleCapsule_tempVec1,
        circlePosj = capsuleCapsule_tempVec2;

    var numContacts = 0;


    // Need 4 circle checks, between all
    for(var i=0; i<2; i++){

        vec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);
        vec2.rotate(circlePosi,circlePosi,ai);
        vec2.add(circlePosi,circlePosi,xi);

        for(var j=0; j<2; j++){

            vec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);
            vec2.rotate(circlePosj,circlePosj,aj);
            vec2.add(circlePosj,circlePosj,xj);

            // Temporarily turn off friction
            if(this.enableFrictionReduction){
                enableFrictionBefore = this.enableFriction;
                this.enableFriction = false;
            }

            var result = this.circleCircle(bi,si,circlePosi,ai, bj,sj,circlePosj,aj, justTest, si.radius, sj.radius);

            if(this.enableFrictionReduction){
                this.enableFriction = enableFrictionBefore;
            }

            if(justTest && result){
                return true;
            }

            numContacts += result;
        }
    }

    if(this.enableFrictionReduction){
        // Temporarily turn off friction
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    // Check circles against the center rectangles
    var rect = capsuleCapsule_tempRect1;
    setConvexToCapsuleShapeMiddle(rect,si);
    var result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);

    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest && result1){
        return true;
    }
    numContacts += result1;

    if(this.enableFrictionReduction){
        // Temporarily turn off friction
        var enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    setConvexToCapsuleShapeMiddle(rect,sj);
    var result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);

    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest && result2){
        return true;
    }
    numContacts += result2;

    if(this.enableFrictionReduction){
        if(numContacts && this.enableFriction){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

/**
 * Line/line narrowphase
 * @method lineLine
 * @param  {Body}       bodyA
 * @param  {Line}       shapeA
 * @param  {Array}      positionA
 * @param  {Number}     angleA
 * @param  {Body}       bodyB
 * @param  {Line}       shapeB
 * @param  {Array}      positionB
 * @param  {Number}     angleB
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.LINE] =
Narrowphase.prototype.lineLine = function(
    bodyA,
    shapeA,
    positionA,
    angleA,
    bodyB,
    shapeB,
    positionB,
    angleB,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

/**
 * Plane/line Narrowphase
 * @method planeLine
 * @param  {Body}   planeBody
 * @param  {Plane}  planeShape
 * @param  {Array}  planeOffset
 * @param  {Number} planeAngle
 * @param  {Body}   lineBody
 * @param  {Line}   lineShape
 * @param  {Array}  lineOffset
 * @param  {Number} lineAngle
 */
Narrowphase.prototype[Shape.PLANE | Shape.LINE] =
Narrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle,
                                           lineBody,  lineShape,  lineOffset,  lineAngle, justTest){
    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldVertex01 = tmp3,
        worldVertex11 = tmp4,
        worldEdge = tmp5,
        worldEdgeUnit = tmp6,
        dist = tmp7,
        worldNormal = tmp8,
        worldTangent = tmp9,
        verts = tmpArray,
        numContacts = 0;

    // Get start and end points
    vec2.set(worldVertex0, -lineShape.length/2, 0);
    vec2.set(worldVertex1,  lineShape.length/2, 0);

    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
    vec2.rotate(worldVertex11, worldVertex1, lineAngle);

    add(worldVertex01, worldVertex01, lineOffset);
    add(worldVertex11, worldVertex11, lineOffset);

    vec2.copy(worldVertex0,worldVertex01);
    vec2.copy(worldVertex1,worldVertex11);

    // Get vector along the line
    sub(worldEdge, worldVertex1, worldVertex0);
    vec2.normalize(worldEdgeUnit, worldEdge);

    // Get tangent to the edge.
    vec2.rotate90cw(worldTangent, worldEdgeUnit);

    vec2.rotate(worldNormal, yAxis, planeAngle);

    // Check line ends
    verts[0] = worldVertex0;
    verts[1] = worldVertex1;
    for(var i=0; i<verts.length; i++){
        var v = verts[i];

        sub(dist, v, planeOffset);

        var d = dot(dist,worldNormal);

        if(d < 0){

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(planeBody,lineBody,planeShape,lineShape);
            numContacts++;

            vec2.copy(c.normalA, worldNormal);
            vec2.normalize(c.normalA,c.normalA);

            // distance vector along plane normal
            vec2.scale(dist, worldNormal, d);

            // Vector from plane center to contact
            sub(c.contactPointA, v, dist);
            sub(c.contactPointA, c.contactPointA, planeBody.position);

            // From line center to contact
            sub(c.contactPointB, v,    lineOffset);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(!this.enableFrictionReduction){
                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(justTest){
        return false;
    }

    if(!this.enableFrictionReduction){
        if(numContacts && this.enableFriction){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =
Narrowphase.prototype.particleCapsule = function(
    particleBody,
    particleShape,
    particlePosition,
    particleAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){
    return this.circleLine(particleBody,particleShape,particlePosition,particleAngle, capsuleBody,capsuleShape,capsulePosition,capsuleAngle, justTest, capsuleShape.radius, 0);
};

/**
 * Circle/line Narrowphase
 * @method circleLine
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} lineBody
 * @param  {Line} lineShape
 * @param  {Array} lineOffset
 * @param  {Number} lineAngle
 * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.
 * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.
 * @param {Number} circleRadius If set, this value overrides the circle shape radius.
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] =
Narrowphase.prototype.circleLine = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest,
    lineRadius,
    circleRadius
){
    var lineRadius = lineRadius || 0,
        circleRadius = typeof(circleRadius)!=="undefined" ? circleRadius : circleShape.radius,

        orthoDist = tmp1,
        lineToCircleOrthoUnit = tmp2,
        projectedPoint = tmp3,
        centerDist = tmp4,
        worldTangent = tmp5,
        worldEdge = tmp6,
        worldEdgeUnit = tmp7,
        worldVertex0 = tmp8,
        worldVertex1 = tmp9,
        worldVertex01 = tmp10,
        worldVertex11 = tmp11,
        dist = tmp12,
        lineToCircle = tmp13,
        lineEndToLineRadius = tmp14,

        verts = tmpArray;

    // Get start and end points
    vec2.set(worldVertex0, -lineShape.length/2, 0);
    vec2.set(worldVertex1,  lineShape.length/2, 0);

    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
    vec2.rotate(worldVertex11, worldVertex1, lineAngle);

    add(worldVertex01, worldVertex01, lineOffset);
    add(worldVertex11, worldVertex11, lineOffset);

    vec2.copy(worldVertex0,worldVertex01);
    vec2.copy(worldVertex1,worldVertex11);

    // Get vector along the line
    sub(worldEdge, worldVertex1, worldVertex0);
    vec2.normalize(worldEdgeUnit, worldEdge);

    // Get tangent to the edge.
    vec2.rotate90cw(worldTangent, worldEdgeUnit);

    // Check distance from the plane spanned by the edge vs the circle
    sub(dist, circleOffset, worldVertex0);
    var d = dot(dist, worldTangent); // Distance from center of line to circle center
    sub(centerDist, worldVertex0, lineOffset);

    sub(lineToCircle, circleOffset, lineOffset);

    var radiusSum = circleRadius + lineRadius;

    if(Math.abs(d) < radiusSum){

        // Now project the circle onto the edge
        vec2.scale(orthoDist, worldTangent, d);
        sub(projectedPoint, circleOffset, orthoDist);

        // Add the missing line radius
        vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
        vec2.normalize(lineToCircleOrthoUnit,lineToCircleOrthoUnit);
        vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
        add(projectedPoint,projectedPoint,lineToCircleOrthoUnit);

        // Check if the point is within the edge span
        var pos =  dot(worldEdgeUnit, projectedPoint);
        var pos0 = dot(worldEdgeUnit, worldVertex0);
        var pos1 = dot(worldEdgeUnit, worldVertex1);

        if(pos > pos0 && pos < pos1){
            // We got contact!

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);

            vec2.scale(c.normalA, orthoDist, -1);
            vec2.normalize(c.normalA, c.normalA);

            vec2.scale( c.contactPointA, c.normalA,  circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);

            sub(c.contactPointB, projectedPoint, lineOffset);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }

            return 1;
        }
    }

    // Add corner
    verts[0] = worldVertex0;
    verts[1] = worldVertex1;

    for(var i=0; i<verts.length; i++){
        var v = verts[i];

        sub(dist, v, circleOffset);

        if(vec2.squaredLength(dist) < Math.pow(radiusSum, 2)){

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);

            vec2.copy(c.normalA, dist);
            vec2.normalize(c.normalA,c.normalA);

            // Vector from circle to contact point is the normal times the circle radius
            vec2.scale(c.contactPointA, c.normalA, circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);

            sub(c.contactPointB, v, lineOffset);
            vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);
            add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }

            return 1;
        }
    }

    return 0;
};

/**
 * Circle/capsule Narrowphase
 * @method circleCapsule
 * @param  {Body}   bi
 * @param  {Circle} si
 * @param  {Array}  xi
 * @param  {Number} ai
 * @param  {Body}   bj
 * @param  {Line}   sj
 * @param  {Array}  xj
 * @param  {Number} aj
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =
Narrowphase.prototype.circleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){
    return this.circleLine(bi,si,xi,ai, bj,sj,xj,aj, justTest, sj.radius);
};

/**
 * Circle/convex Narrowphase.
 * @method circleConvex
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Boolean} justTest
 * @param  {Number} circleRadius
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =
Narrowphase.prototype[Shape.CIRCLE | Shape.RECTANGLE] =
Narrowphase.prototype.circleConvex = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest,
    circleRadius
){
    var circleRadius = typeof(circleRadius)==="number" ? circleRadius : circleShape.radius;

    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldEdge = tmp3,
        worldEdgeUnit = tmp4,
        worldNormal = tmp5,
        centerDist = tmp6,
        convexToCircle = tmp7,
        orthoDist = tmp8,
        projectedPoint = tmp9,
        dist = tmp10,
        worldVertex = tmp11,

        closestEdge = -1,
        closestEdgeDistance = null,
        closestEdgeOrthoDist = tmp12,
        closestEdgeProjectedPoint = tmp13,
        candidate = tmp14,
        candidateDist = tmp15,
        minCandidate = tmp16,

        found = false,
        minCandidateDistance = Number.MAX_VALUE;

    var numReported = 0;

    // New algorithm:
    // 1. Check so center of circle is not inside the polygon. If it is, this wont work...
    // 2. For each edge
    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
    // 2. 2. Check if point is inside.

    var verts = convexShape.vertices;

    // Check all edges first
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);
        sub(worldEdge, worldVertex1, worldVertex0);

        vec2.normalize(worldEdgeUnit, worldEdge);

        // Get tangent to the edge. Points out of the Convex
        vec2.rotate90cw(worldNormal, worldEdgeUnit);

        // Get point on circle, closest to the polygon
        vec2.scale(candidate,worldNormal,-circleShape.radius);
        add(candidate,candidate,circleOffset);

        if(pointInConvex(candidate,convexShape,convexOffset,convexAngle)){

            vec2.sub(candidateDist,worldVertex0,candidate);
            var candidateDistance = Math.abs(vec2.dot(candidateDist,worldNormal));

            if(candidateDistance < minCandidateDistance){
                vec2.copy(minCandidate,candidate);
                minCandidateDistance = candidateDistance;
                vec2.scale(closestEdgeProjectedPoint,worldNormal,candidateDistance);
                vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,candidate);
                found = true;
            }
        }
    }

    if(found){

        if(justTest){
            return true;
        }

        var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);
        vec2.sub(c.normalA, minCandidate, circleOffset);
        vec2.normalize(c.normalA, c.normalA);

        vec2.scale(c.contactPointA,  c.normalA, circleRadius);
        add(c.contactPointA, c.contactPointA, circleOffset);
        sub(c.contactPointA, c.contactPointA, circleBody.position);

        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c.contactPointB, c.contactPointB, convexOffset);
        sub(c.contactPointB, c.contactPointB, convexBody.position);

        this.contactEquations.push(c);

        if(this.enableFriction){
            this.frictionEquations.push( this.createFrictionFromContact(c) );
        }

        return 1;
    }

    // Check all vertices
    if(circleRadius > 0){
        for(var i=0; i<verts.length; i++){
            var localVertex = verts[i];
            vec2.rotate(worldVertex, localVertex, convexAngle);
            add(worldVertex, worldVertex, convexOffset);

            sub(dist, worldVertex, circleOffset);
            if(vec2.squaredLength(dist) < Math.pow(circleRadius, 2)){

                if(justTest){
                    return true;
                }

                var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);

                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA,c.normalA);

                // Vector from circle to contact point is the normal times the circle radius
                vec2.scale(c.contactPointA, c.normalA, circleRadius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);

                sub(c.contactPointB, worldVertex, convexOffset);
                add(c.contactPointB, c.contactPointB, convexOffset);
                sub(c.contactPointB, c.contactPointB, convexBody.position);

                this.contactEquations.push(c);

                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }

                return 1;
            }
        }
    }

    return 0;
};

var pic_worldVertex0 = vec2.create(),
    pic_worldVertex1 = vec2.create(),
    pic_r0 = vec2.create(),
    pic_r1 = vec2.create();

/*
 * Check if a point is in a polygon
 */
function pointInConvex(worldPoint,convexShape,convexOffset,convexAngle){
    var worldVertex0 = pic_worldVertex0,
        worldVertex1 = pic_worldVertex1,
        r0 = pic_r0,
        r1 = pic_r1,
        point = worldPoint,
        verts = convexShape.vertices,
        lastCross = null;
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        // Transform vertices to world
        // @todo The point should be transformed to local coordinates in the convex, no need to transform each vertex
        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);

        sub(r0, worldVertex0, point);
        sub(r1, worldVertex1, point);
        var cross = vec2.crossLength(r0,r1);

        if(lastCross===null){
            lastCross = cross;
        }

        // If we got a different sign of the distance vector, the point is out of the polygon
        if(cross*lastCross <= 0){
            return false;
        }
        lastCross = cross;
    }
    return true;
}

/**
 * Particle/convex Narrowphase
 * @method particleConvex
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 * @todo use pointInConvex and code more similar to circleConvex
 * @todo don't transform each vertex, but transform the particle position to convex-local instead
 */
Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =
Narrowphase.prototype[Shape.PARTICLE | Shape.RECTANGLE] =
Narrowphase.prototype.particleConvex = function(
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest
){
    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldEdge = tmp3,
        worldEdgeUnit = tmp4,
        worldTangent = tmp5,
        centerDist = tmp6,
        convexToparticle = tmp7,
        orthoDist = tmp8,
        projectedPoint = tmp9,
        dist = tmp10,
        worldVertex = tmp11,
        closestEdge = -1,
        closestEdgeDistance = null,
        closestEdgeOrthoDist = tmp12,
        closestEdgeProjectedPoint = tmp13,
        r0 = tmp14, // vector from particle to vertex0
        r1 = tmp15,
        localPoint = tmp16,
        candidateDist = tmp17,
        minEdgeNormal = tmp18,
        minCandidateDistance = Number.MAX_VALUE;

    var numReported = 0,
        found = false,
        verts = convexShape.vertices;

    // Check if the particle is in the polygon at all
    if(!pointInConvex(particleOffset,convexShape,convexOffset,convexAngle)){
        return 0;
    }

    if(justTest){
        return true;
    }

    // Check edges first
    var lastCross = null;
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        // Transform vertices to world
        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);

        // Get world edge
        sub(worldEdge, worldVertex1, worldVertex0);
        vec2.normalize(worldEdgeUnit, worldEdge);

        // Get tangent to the edge. Points out of the Convex
        vec2.rotate90cw(worldTangent, worldEdgeUnit);

        // Check distance from the infinite line (spanned by the edge) to the particle
        sub(dist, particleOffset, worldVertex0);
        var d = dot(dist, worldTangent);
        sub(centerDist, worldVertex0, convexOffset);

        sub(convexToparticle, particleOffset, convexOffset);

        vec2.sub(candidateDist,worldVertex0,particleOffset);
        var candidateDistance = Math.abs(vec2.dot(candidateDist,worldTangent));

        if(candidateDistance < minCandidateDistance){
            minCandidateDistance = candidateDistance;
            vec2.scale(closestEdgeProjectedPoint,worldTangent,candidateDistance);
            vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,particleOffset);
            vec2.copy(minEdgeNormal,worldTangent);
            found = true;
        }
    }

    if(found){
        var c = this.createContactEquation(particleBody,convexBody,particleShape,convexShape);

        vec2.scale(c.normalA, minEdgeNormal, -1);
        vec2.normalize(c.normalA, c.normalA);

        // Particle has no extent to the contact point
        vec2.set(c.contactPointA,  0, 0);
        add(c.contactPointA, c.contactPointA, particleOffset);
        sub(c.contactPointA, c.contactPointA, particleBody.position);

        // From convex center to point
        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c.contactPointB, c.contactPointB, convexOffset);
        sub(c.contactPointB, c.contactPointB, convexBody.position);

        this.contactEquations.push(c);

        if(this.enableFriction){
            this.frictionEquations.push( this.createFrictionFromContact(c) );
        }

        return 1;
    }


    return 0;
};

/**
 * Circle/circle Narrowphase
 * @method circleCircle
 * @param  {Body} bodyA
 * @param  {Circle} shapeA
 * @param  {Array} offsetA
 * @param  {Number} angleA
 * @param  {Body} bodyB
 * @param  {Circle} shapeB
 * @param  {Array} offsetB
 * @param  {Number} angleB
 * @param {Boolean} justTest
 * @param {Number} [radiusA] Optional radius to use for shapeA
 * @param {Number} [radiusB] Optional radius to use for shapeB
 */
Narrowphase.prototype[Shape.CIRCLE] =
Narrowphase.prototype.circleCircle = function(
    bodyA,
    shapeA,
    offsetA,
    angleA,
    bodyB,
    shapeB,
    offsetB,
    angleB,
    justTest,
    radiusA,
    radiusB
){

    var dist = tmp1,
        radiusA = radiusA || shapeA.radius,
        radiusB = radiusB || shapeB.radius;

    sub(dist,offsetA,offsetB);
    var r = radiusA + radiusB;
    if(vec2.squaredLength(dist) > Math.pow(r,2)){
        return 0;
    }

    if(justTest){
        return true;
    }

    var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
    sub(c.normalA, offsetB, offsetA);
    vec2.normalize(c.normalA,c.normalA);

    vec2.scale( c.contactPointA, c.normalA,  radiusA);
    vec2.scale( c.contactPointB, c.normalA, -radiusB);

    add(c.contactPointA, c.contactPointA, offsetA);
    sub(c.contactPointA, c.contactPointA, bodyA.position);

    add(c.contactPointB, c.contactPointB, offsetB);
    sub(c.contactPointB, c.contactPointB, bodyB.position);

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }
    return 1;
};

/**
 * Plane/Convex Narrowphase
 * @method planeConvex
 * @param  {Body} planeBody
 * @param  {Plane} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 */
Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] =
Narrowphase.prototype[Shape.PLANE | Shape.RECTANGLE] =
Narrowphase.prototype.planeConvex = function(
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest
){
    var worldVertex = tmp1,
        worldNormal = tmp2,
        dist = tmp3;

    var numReported = 0;
    vec2.rotate(worldNormal, yAxis, planeAngle);

    for(var i=0; i!==convexShape.vertices.length; i++){
        var v = convexShape.vertices[i];
        vec2.rotate(worldVertex, v, convexAngle);
        add(worldVertex, worldVertex, convexOffset);

        sub(dist, worldVertex, planeOffset);

        if(dot(dist,worldNormal) <= 0){

            if(justTest){
                return true;
            }

            // Found vertex
            numReported++;

            var c = this.createContactEquation(planeBody,convexBody,planeShape,convexShape);

            sub(dist, worldVertex, planeOffset);

            vec2.copy(c.normalA, worldNormal);

            var d = dot(dist, c.normalA);
            vec2.scale(dist, c.normalA, d);

            // rj is from convex center to contact
            sub(c.contactPointB, worldVertex, convexBody.position);


            // ri is from plane center to contact
            sub( c.contactPointA, worldVertex, dist);
            sub( c.contactPointA, c.contactPointA, planeBody.position);

            this.contactEquations.push(c);

            if(!this.enableFrictionReduction){
                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(this.enableFrictionReduction){
        if(this.enableFriction && numReported){
            this.frictionEquations.push(this.createFrictionFromAverage(numReported));
        }
    }

    return numReported;
};

/**
 * Narrowphase for particle vs plane
 * @method particlePlane
 * @param  {Body}       particleBody
 * @param  {Particle}   particleShape
 * @param  {Array}      particleOffset
 * @param  {Number}     particleAngle
 * @param  {Body}       planeBody
 * @param  {Plane}      planeShape
 * @param  {Array}      planeOffset
 * @param  {Number}     planeAngle
 * @param {Boolean}     justTest
 */
Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =
Narrowphase.prototype.particlePlane = function(
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    justTest
){
    var dist = tmp1,
        worldNormal = tmp2;

    planeAngle = planeAngle || 0;

    sub(dist, particleOffset, planeOffset);
    vec2.rotate(worldNormal, yAxis, planeAngle);

    var d = dot(dist, worldNormal);

    if(d > 0){
        return 0;
    }
    if(justTest){
        return true;
    }

    var c = this.createContactEquation(planeBody,particleBody,planeShape,particleShape);

    vec2.copy(c.normalA, worldNormal);
    vec2.scale( dist, c.normalA, d );
    // dist is now the distance vector in the normal direction

    // ri is the particle position projected down onto the plane, from the plane center
    sub( c.contactPointA, particleOffset, dist);
    sub( c.contactPointA, c.contactPointA, planeBody.position);

    // rj is from the body center to the particle center
    sub( c.contactPointB, particleOffset, particleBody.position );

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }
    return 1;
};

/**
 * Circle/Particle Narrowphase
 * @method circleParticle
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Boolean} justTest
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =
Narrowphase.prototype.circleParticle = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    justTest
){
    var dist = tmp1;

    sub(dist, particleOffset, circleOffset);
    if(vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)){
        return 0;
    }
    if(justTest){
        return true;
    }

    var c = this.createContactEquation(circleBody,particleBody,circleShape,particleShape);
    vec2.copy(c.normalA, dist);
    vec2.normalize(c.normalA,c.normalA);

    // Vector from circle to contact point is the normal times the circle radius
    vec2.scale(c.contactPointA, c.normalA, circleShape.radius);
    add(c.contactPointA, c.contactPointA, circleOffset);
    sub(c.contactPointA, c.contactPointA, circleBody.position);

    // Vector from particle center to contact point is zero
    sub(c.contactPointB, particleOffset, particleBody.position);

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }

    return 1;
};

var planeCapsule_tmpCircle = new Circle(1),
    planeCapsule_tmp1 = vec2.create(),
    planeCapsule_tmp2 = vec2.create(),
    planeCapsule_tmp3 = vec2.create();

/**
 * @method planeCapsule
 * @param  {Body} planeBody
 * @param  {Circle} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} capsuleBody
 * @param  {Particle} capsuleShape
 * @param  {Array} capsuleOffset
 * @param  {Number} capsuleAngle
 * @param {Boolean} justTest
 */
Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =
Narrowphase.prototype.planeCapsule = function(
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    capsuleBody,
    capsuleShape,
    capsuleOffset,
    capsuleAngle,
    justTest
){
    var end1 = planeCapsule_tmp1,
        end2 = planeCapsule_tmp2,
        circle = planeCapsule_tmpCircle,
        dst = planeCapsule_tmp3;

    // Compute world end positions
    vec2.set(end1, -capsuleShape.length/2, 0);
    vec2.rotate(end1,end1,capsuleAngle);
    add(end1,end1,capsuleOffset);

    vec2.set(end2,  capsuleShape.length/2, 0);
    vec2.rotate(end2,end2,capsuleAngle);
    add(end2,end2,capsuleOffset);

    circle.radius = capsuleShape.radius;

    var enableFrictionBefore;

    // Temporarily turn off friction
    if(this.enableFrictionReduction){
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    // Do Narrowphase as two circles
    var numContacts1 = this.circlePlane(capsuleBody,circle,end1,0, planeBody,planeShape,planeOffset,planeAngle, justTest),
        numContacts2 = this.circlePlane(capsuleBody,circle,end2,0, planeBody,planeShape,planeOffset,planeAngle, justTest);

    // Restore friction
    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest){
        return numContacts1 || numContacts2;
    } else {
        var numTotal = numContacts1 + numContacts2;
        if(this.enableFrictionReduction){
            if(numTotal){
                this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
            }
        }
        return numTotal;
    }
};

/**
 * Creates ContactEquations and FrictionEquations for a collision.
 * @method circlePlane
 * @param  {Body}    bi     The first body that should be connected to the equations.
 * @param  {Circle}  si     The circle shape participating in the collision.
 * @param  {Array}   xi     Extra offset to take into account for the Shape, in addition to the one in circleBody.position. Will *not* be rotated by circleBody.angle (maybe it should, for sake of homogenity?). Set to null if none.
 * @param  {Body}    bj     The second body that should be connected to the equations.
 * @param  {Plane}   sj     The Plane shape that is participating
 * @param  {Array}   xj     Extra offset for the plane shape.
 * @param  {Number}  aj     Extra angle to apply to the plane
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =
Narrowphase.prototype.circlePlane = function(   bi,si,xi,ai, bj,sj,xj,aj, justTest ){
    var circleBody = bi,
        circleShape = si,
        circleOffset = xi, // Offset from body center, rotated!
        planeBody = bj,
        shapeB = sj,
        planeOffset = xj,
        planeAngle = aj;

    planeAngle = planeAngle || 0;

    // Vector from plane to circle
    var planeToCircle = tmp1,
        worldNormal = tmp2,
        temp = tmp3;

    sub(planeToCircle, circleOffset, planeOffset);

    // World plane normal
    vec2.rotate(worldNormal, yAxis, planeAngle);

    // Normal direction distance
    var d = dot(worldNormal, planeToCircle);

    if(d > circleShape.radius){
        return 0; // No overlap. Abort.
    }

    if(justTest){
        return true;
    }

    // Create contact
    var contact = this.createContactEquation(planeBody,circleBody,sj,si);

    // ni is the plane world normal
    vec2.copy(contact.normalA, worldNormal);

    // rj is the vector from circle center to the contact point
    vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);
    add(contact.contactPointB, contact.contactPointB, circleOffset);
    sub(contact.contactPointB, contact.contactPointB, circleBody.position);

    // ri is the distance from plane center to contact.
    vec2.scale(temp, contact.normalA, d);
    sub(contact.contactPointA, planeToCircle, temp ); // Subtract normal distance vector from the distance vector
    add(contact.contactPointA, contact.contactPointA, planeOffset);
    sub(contact.contactPointA, contact.contactPointA, planeBody.position);

    this.contactEquations.push(contact);

    if(this.enableFriction){
        this.frictionEquations.push( this.createFrictionFromContact(contact) );
    }

    return 1;
};

/**
 * Convex/convex Narrowphase.See <a href="http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/">this article</a> for more info.
 * @method convexConvex
 * @param  {Body} bi
 * @param  {Convex} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Convex} sj
 * @param  {Array} xj
 * @param  {Number} aj
 */
Narrowphase.prototype[Shape.CONVEX] =
Narrowphase.prototype[Shape.CONVEX | Shape.RECTANGLE] =
Narrowphase.prototype[Shape.RECTANGLE] =
Narrowphase.prototype.convexConvex = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest, precision ){
    var sepAxis = tmp1,
        worldPoint = tmp2,
        worldPoint0 = tmp3,
        worldPoint1 = tmp4,
        worldEdge = tmp5,
        projected = tmp6,
        penetrationVec = tmp7,
        dist = tmp8,
        worldNormal = tmp9,
        numContacts = 0,
        precision = typeof(precision) === 'number' ? precision : 0;

    var found = Narrowphase.findSeparatingAxis(si,xi,ai,sj,xj,aj,sepAxis);
    if(!found){
        return 0;
    }

    // Make sure the separating axis is directed from shape i to shape j
    sub(dist,xj,xi);
    if(dot(sepAxis,dist) > 0){
        vec2.scale(sepAxis,sepAxis,-1);
    }

    // Find edges with normals closest to the separating axis
    var closestEdge1 = Narrowphase.getClosestEdge(si,ai,sepAxis,true), // Flipped axis
        closestEdge2 = Narrowphase.getClosestEdge(sj,aj,sepAxis);

    if(closestEdge1 === -1 || closestEdge2 === -1){
        return 0;
    }

    // Loop over the shapes
    for(var k=0; k<2; k++){

        var closestEdgeA = closestEdge1,
            closestEdgeB = closestEdge2,
            shapeA =  si, shapeB =  sj,
            offsetA = xi, offsetB = xj,
            angleA = ai, angleB = aj,
            bodyA = bi, bodyB = bj;

        if(k === 0){
            // Swap!
            var tmp;
            tmp = closestEdgeA;
            closestEdgeA = closestEdgeB;
            closestEdgeB = tmp;

            tmp = shapeA;
            shapeA = shapeB;
            shapeB = tmp;

            tmp = offsetA;
            offsetA = offsetB;
            offsetB = tmp;

            tmp = angleA;
            angleA = angleB;
            angleB = tmp;

            tmp = bodyA;
            bodyA = bodyB;
            bodyB = tmp;
        }

        // Loop over 2 points in convex B
        for(var j=closestEdgeB; j<closestEdgeB+2; j++){

            // Get world point
            var v = shapeB.vertices[(j+shapeB.vertices.length)%shapeB.vertices.length];
            vec2.rotate(worldPoint, v, angleB);
            add(worldPoint, worldPoint, offsetB);

            var insideNumEdges = 0;

            // Loop over the 3 closest edges in convex A
            for(var i=closestEdgeA-1; i<closestEdgeA+2; i++){

                var v0 = shapeA.vertices[(i  +shapeA.vertices.length)%shapeA.vertices.length],
                    v1 = shapeA.vertices[(i+1+shapeA.vertices.length)%shapeA.vertices.length];

                // Construct the edge
                vec2.rotate(worldPoint0, v0, angleA);
                vec2.rotate(worldPoint1, v1, angleA);
                add(worldPoint0, worldPoint0, offsetA);
                add(worldPoint1, worldPoint1, offsetA);

                sub(worldEdge, worldPoint1, worldPoint0);

                vec2.rotate90cw(worldNormal, worldEdge); // Normal points out of convex 1
                vec2.normalize(worldNormal,worldNormal);

                sub(dist, worldPoint, worldPoint0);

                var d = dot(worldNormal,dist);

                if((i === closestEdgeA && d <= precision) || (i !== closestEdgeA && d <= 0)){
                    insideNumEdges++;
                }
            }

            if(insideNumEdges >= 3){

                if(justTest){
                    return true;
                }

                // worldPoint was on the "inside" side of each of the 3 checked edges.
                // Project it to the center edge and use the projection direction as normal

                // Create contact
                var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
                numContacts++;

                // Get center edge from body A
                var v0 = shapeA.vertices[(closestEdgeA)   % shapeA.vertices.length],
                    v1 = shapeA.vertices[(closestEdgeA+1) % shapeA.vertices.length];

                // Construct the edge
                vec2.rotate(worldPoint0, v0, angleA);
                vec2.rotate(worldPoint1, v1, angleA);
                add(worldPoint0, worldPoint0, offsetA);
                add(worldPoint1, worldPoint1, offsetA);

                sub(worldEdge, worldPoint1, worldPoint0);

                vec2.rotate90cw(c.normalA, worldEdge); // Normal points out of convex A
                vec2.normalize(c.normalA,c.normalA);

                sub(dist, worldPoint, worldPoint0); // From edge point to the penetrating point
                var d = dot(c.normalA,dist);             // Penetration
                vec2.scale(penetrationVec, c.normalA, d);     // Vector penetration

                sub(c.contactPointA, worldPoint, offsetA);
                sub(c.contactPointA, c.contactPointA, penetrationVec);
                add(c.contactPointA, c.contactPointA, offsetA);
                sub(c.contactPointA, c.contactPointA, bodyA.position);

                sub(c.contactPointB, worldPoint, offsetB);
                add(c.contactPointB, c.contactPointB, offsetB);
                sub(c.contactPointB, c.contactPointB, bodyB.position);

                this.contactEquations.push(c);

                // Todo reduce to 1 friction equation if we have 2 contact points
                if(!this.enableFrictionReduction){
                    if(this.enableFriction){
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
    }

    if(this.enableFrictionReduction){
        if(this.enableFriction && numContacts){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

// .projectConvex is called by other functions, need local tmp vectors
var pcoa_tmp1 = vec2.fromValues(0,0);

/**
 * Project a Convex onto a world-oriented axis
 * @method projectConvexOntoAxis
 * @static
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Array} worldAxis
 * @param  {Array} result
 */
Narrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result){
    var max=null,
        min=null,
        v,
        value,
        localAxis = pcoa_tmp1;

    // Convert the axis to local coords of the body
    vec2.rotate(localAxis, worldAxis, -convexAngle);

    // Get projected position of all vertices
    for(var i=0; i<convexShape.vertices.length; i++){
        v = convexShape.vertices[i];
        value = dot(v,localAxis);
        if(max === null || value > max){
            max = value;
        }
        if(min === null || value < min){
            min = value;
        }
    }

    if(min > max){
        var t = min;
        min = max;
        max = t;
    }

    // Project the position of the body onto the axis - need to add this to the result
    var offset = dot(convexOffset, worldAxis);

    vec2.set( result, min + offset, max + offset);
};

// .findSeparatingAxis is called by other functions, need local tmp vectors
var fsa_tmp1 = vec2.fromValues(0,0)
,   fsa_tmp2 = vec2.fromValues(0,0)
,   fsa_tmp3 = vec2.fromValues(0,0)
,   fsa_tmp4 = vec2.fromValues(0,0)
,   fsa_tmp5 = vec2.fromValues(0,0)
,   fsa_tmp6 = vec2.fromValues(0,0);

/**
 * Find a separating axis between the shapes, that maximizes the separating distance between them.
 * @method findSeparatingAxis
 * @static
 * @param  {Convex}     c1
 * @param  {Array}      offset1
 * @param  {Number}     angle1
 * @param  {Convex}     c2
 * @param  {Array}      offset2
 * @param  {Number}     angle2
 * @param  {Array}      sepAxis     The resulting axis
 * @return {Boolean}                Whether the axis could be found.
 */
Narrowphase.findSeparatingAxis = function(c1,offset1,angle1,c2,offset2,angle2,sepAxis){
    var maxDist = null,
        overlap = false,
        found = false,
        edge = fsa_tmp1,
        worldPoint0 = fsa_tmp2,
        worldPoint1 = fsa_tmp3,
        normal = fsa_tmp4,
        span1 = fsa_tmp5,
        span2 = fsa_tmp6;

    if(c1 instanceof Rectangle && c2 instanceof Rectangle){

        for(var j=0; j!==2; j++){
            var c = c1,
                angle = angle1;
            if(j===1){
                c = c2;
                angle = angle2;
            }

            for(var i=0; i!==2; i++){

                // Get the world edge
                if(i === 0){
                    vec2.set(normal, 0, 1);
                } else if(i === 1) {
                    vec2.set(normal, 1, 0);
                }
                if(angle !== 0){
                    vec2.rotate(normal, normal, angle);
                }

                // Project hulls onto that normal
                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);

                // Order by span position
                var a=span1,
                    b=span2,
                    swapped = false;
                if(span1[0] > span2[0]){
                    b=span1;
                    a=span2;
                    swapped = true;
                }

                // Get separating distance
                var dist = b[0] - a[1];
                overlap = (dist <= 0);

                if(maxDist===null || dist > maxDist){
                    vec2.copy(sepAxis, normal);
                    maxDist = dist;
                    found = overlap;
                }
            }
        }

    } else {

        for(var j=0; j!==2; j++){
            var c = c1,
                angle = angle1;
            if(j===1){
                c = c2;
                angle = angle2;
            }

            for(var i=0; i!==c.vertices.length; i++){
                // Get the world edge
                vec2.rotate(worldPoint0, c.vertices[i], angle);
                vec2.rotate(worldPoint1, c.vertices[(i+1)%c.vertices.length], angle);

                sub(edge, worldPoint1, worldPoint0);

                // Get normal - just rotate 90 degrees since vertices are given in CCW
                vec2.rotate90cw(normal, edge);
                vec2.normalize(normal,normal);

                // Project hulls onto that normal
                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);

                // Order by span position
                var a=span1,
                    b=span2,
                    swapped = false;
                if(span1[0] > span2[0]){
                    b=span1;
                    a=span2;
                    swapped = true;
                }

                // Get separating distance
                var dist = b[0] - a[1];
                overlap = (dist <= 0);

                if(maxDist===null || dist > maxDist){
                    vec2.copy(sepAxis, normal);
                    maxDist = dist;
                    found = overlap;
                }
            }
        }
    }


    /*
    // Needs to be tested some more
    for(var j=0; j!==2; j++){
        var c = c1,
            angle = angle1;
        if(j===1){
            c = c2;
            angle = angle2;
        }

        for(var i=0; i!==c.axes.length; i++){

            var normal = c.axes[i];

            // Project hulls onto that normal
            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);

            // Order by span position
            var a=span1,
                b=span2,
                swapped = false;
            if(span1[0] > span2[0]){
                b=span1;
                a=span2;
                swapped = true;
            }

            // Get separating distance
            var dist = b[0] - a[1];
            overlap = (dist <= Narrowphase.convexPrecision);

            if(maxDist===null || dist > maxDist){
                vec2.copy(sepAxis, normal);
                maxDist = dist;
                found = overlap;
            }
        }
    }
    */

    return found;
};

// .getClosestEdge is called by other functions, need local tmp vectors
var gce_tmp1 = vec2.fromValues(0,0)
,   gce_tmp2 = vec2.fromValues(0,0)
,   gce_tmp3 = vec2.fromValues(0,0);

/**
 * Get the edge that has a normal closest to an axis.
 * @method getClosestEdge
 * @static
 * @param  {Convex}     c
 * @param  {Number}     angle
 * @param  {Array}      axis
 * @param  {Boolean}    flip
 * @return {Number}             Index of the edge that is closest. This index and the next spans the resulting edge. Returns -1 if failed.
 */
Narrowphase.getClosestEdge = function(c,angle,axis,flip){
    var localAxis = gce_tmp1,
        edge = gce_tmp2,
        normal = gce_tmp3;

    // Convert the axis to local coords of the body
    vec2.rotate(localAxis, axis, -angle);
    if(flip){
        vec2.scale(localAxis,localAxis,-1);
    }

    var closestEdge = -1,
        N = c.vertices.length,
        maxDot = -1;
    for(var i=0; i!==N; i++){
        // Get the edge
        sub(edge, c.vertices[(i+1)%N], c.vertices[i%N]);

        // Get normal - just rotate 90 degrees since vertices are given in CCW
        vec2.rotate90cw(normal, edge);
        vec2.normalize(normal,normal);

        var d = dot(normal,localAxis);
        if(closestEdge === -1 || d > maxDot){
            closestEdge = i % N;
            maxDot = d;
        }
    }

    return closestEdge;
};

var circleHeightfield_candidate = vec2.create(),
    circleHeightfield_dist = vec2.create(),
    circleHeightfield_v0 = vec2.create(),
    circleHeightfield_v1 = vec2.create(),
    circleHeightfield_minCandidate = vec2.create(),
    circleHeightfield_worldNormal = vec2.create(),
    circleHeightfield_minCandidateNormal = vec2.create();

/**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =
Narrowphase.prototype.circleHeightfield = function( circleBody,circleShape,circlePos,circleAngle,
                                                    hfBody,hfShape,hfPos,hfAngle, justTest, radius ){
    var data = hfShape.data,
        radius = radius || circleShape.radius,
        w = hfShape.elementWidth,
        dist = circleHeightfield_dist,
        candidate = circleHeightfield_candidate,
        minCandidate = circleHeightfield_minCandidate,
        minCandidateNormal = circleHeightfield_minCandidateNormal,
        worldNormal = circleHeightfield_worldNormal,
        v0 = circleHeightfield_v0,
        v1 = circleHeightfield_v1;

    // Get the index of the points to test against
    var idxA = Math.floor( (circlePos[0] - radius - hfPos[0]) / w ),
        idxB = Math.ceil(  (circlePos[0] + radius - hfPos[0]) / w );

    /*if(idxB < 0 || idxA >= data.length)
        return justTest ? false : 0;*/

    if(idxA < 0){
        idxA = 0;
    }
    if(idxB >= data.length){
        idxB = data.length-1;
    }

    // Get max and min
    var max = data[idxA],
        min = data[idxB];
    for(var i=idxA; i<idxB; i++){
        if(data[i] < min){
            min = data[i];
        }
        if(data[i] > max){
            max = data[i];
        }
    }

    if(circlePos[1]-radius > max){
        return justTest ? false : 0;
    }

    /*
    if(circlePos[1]+radius < min){
        // Below the minimum point... We can just guess.
        // TODO
    }
    */

    // 1. Check so center of circle is not inside the field. If it is, this wont work...
    // 2. For each edge
    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
    // 2. 2. Check if point is inside.

    var found = false;

    // Check all edges first
    for(var i=idxA; i<idxB; i++){

        // Get points
        vec2.set(v0,     i*w, data[i]  );
        vec2.set(v1, (i+1)*w, data[i+1]);
        vec2.add(v0,v0,hfPos);
        vec2.add(v1,v1,hfPos);

        // Get normal
        vec2.sub(worldNormal, v1, v0);
        vec2.rotate(worldNormal, worldNormal, Math.PI/2);
        vec2.normalize(worldNormal,worldNormal);

        // Get point on circle, closest to the edge
        vec2.scale(candidate,worldNormal,-radius);
        vec2.add(candidate,candidate,circlePos);

        // Distance from v0 to the candidate point
        vec2.sub(dist,candidate,v0);

        // Check if it is in the element "stick"
        var d = vec2.dot(dist,worldNormal);
        if(candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0){

            if(justTest){
                return true;
            }

            found = true;

            // Store the candidate point, projected to the edge
            vec2.scale(dist,worldNormal,-d);
            vec2.add(minCandidate,candidate,dist);
            vec2.copy(minCandidateNormal,worldNormal);

            var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);

            // Normal is out of the heightfield
            vec2.copy(c.normalA, minCandidateNormal);

            // Vector from circle to heightfield
            vec2.scale(c.contactPointB,  c.normalA, -radius);
            add(c.contactPointB, c.contactPointB, circlePos);
            sub(c.contactPointB, c.contactPointB, circleBody.position);

            vec2.copy(c.contactPointA, minCandidate);
            vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push( this.createFrictionFromContact(c) );
            }
        }
    }

    // Check all vertices
    found = false;
    if(radius > 0){
        for(var i=idxA; i<=idxB; i++){

            // Get point
            vec2.set(v0, i*w, data[i]);
            vec2.add(v0,v0,hfPos);

            vec2.sub(dist, circlePos, v0);

            if(vec2.squaredLength(dist) < Math.pow(radius, 2)){

                if(justTest){
                    return true;
                }

                found = true;

                var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);

                // Construct normal - out of heightfield
                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA,c.normalA);

                vec2.scale(c.contactPointB, c.normalA, -radius);
                add(c.contactPointB, c.contactPointB, circlePos);
                sub(c.contactPointB, c.contactPointB, circleBody.position);

                sub(c.contactPointA, v0, hfPos);
                add(c.contactPointA, c.contactPointA, hfPos);
                sub(c.contactPointA, c.contactPointA, hfBody.position);

                this.contactEquations.push(c);

                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(found){
        return 1;
    }

    return 0;

};

var convexHeightfield_v0 = vec2.create(),
    convexHeightfield_v1 = vec2.create(),
    convexHeightfield_tilePos = vec2.create(),
    convexHeightfield_tempConvexShape = new Convex([vec2.create(),vec2.create(),vec2.create(),vec2.create()]);
/**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */
Narrowphase.prototype[Shape.RECTANGLE | Shape.HEIGHTFIELD] =
Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =
Narrowphase.prototype.convexHeightfield = function( convexBody,convexShape,convexPos,convexAngle,
                                                    hfBody,hfShape,hfPos,hfAngle, justTest ){
    var data = hfShape.data,
        w = hfShape.elementWidth,
        v0 = convexHeightfield_v0,
        v1 = convexHeightfield_v1,
        tilePos = convexHeightfield_tilePos,
        tileConvex = convexHeightfield_tempConvexShape;

    // Get the index of the points to test against
    var idxA = Math.floor( (convexBody.aabb.lowerBound[0] - hfPos[0]) / w ),
        idxB = Math.ceil(  (convexBody.aabb.upperBound[0] - hfPos[0]) / w );

    if(idxA < 0){
        idxA = 0;
    }
    if(idxB >= data.length){
        idxB = data.length-1;
    }

    // Get max and min
    var max = data[idxA],
        min = data[idxB];
    for(var i=idxA; i<idxB; i++){
        if(data[i] < min){
            min = data[i];
        }
        if(data[i] > max){
            max = data[i];
        }
    }

    if(convexBody.aabb.lowerBound[1] > max){
        return justTest ? false : 0;
    }

    var found = false;
    var numContacts = 0;

    // Loop over all edges
    // TODO: If possible, construct a convex from several data points (need o check if the points make a convex shape)
    for(var i=idxA; i<idxB; i++){

        // Get points
        vec2.set(v0,     i*w, data[i]  );
        vec2.set(v1, (i+1)*w, data[i+1]);
        vec2.add(v0,v0,hfPos);
        vec2.add(v1,v1,hfPos);

        // Construct a convex
        var tileHeight = 100; // todo
        vec2.set(tilePos, (v1[0] + v0[0])*0.5, (v1[1] + v0[1] - tileHeight)*0.5);

        vec2.sub(tileConvex.vertices[0], v1, tilePos);
        vec2.sub(tileConvex.vertices[1], v0, tilePos);
        vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);
        vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);
        tileConvex.vertices[2][1] -= tileHeight;
        tileConvex.vertices[3][1] -= tileHeight;

        // Do convex collision
        numContacts += this.convexConvex(   convexBody, convexShape, convexPos, convexAngle,
                                            hfBody, tileConvex, tilePos, 0, justTest);
    }

    return numContacts;
};
},{"../equations/ContactEquation":22,"../equations/Equation":23,"../equations/FrictionEquation":24,"../math/vec2":31,"../objects/Body":32,"../shapes/Circle":38,"../shapes/Convex":39,"../shapes/Rectangle":44,"../shapes/Shape":45,"../utils/TupleDictionary":49,"../utils/Utils":50}],12:[function(_dereq_,module,exports){
module.exports = Ray;

var vec2 = _dereq_('../math/vec2');
var RaycastResult = _dereq_('../collision/RaycastResult');
var Shape = _dereq_('../shapes/Shape');
var AABB = _dereq_('../collision/AABB');

/**
 * A line with a start and end point that is used to intersect shapes.
 * @class Ray
 * @constructor
 */
function Ray(options){
    options = options || {};

    /**
     * @property {array} from
     */
    this.from = options.from ? vec2.fromValues(options.from[0], options.from[1]) : vec2.create();

    /**
     * @property {array} to
     */
    this.to = options.to ? vec2.fromValues(options.to[0], options.to[1]) : vec2.create();

    /**
     * @private
     * @property {array} _direction
     */
    this._direction = vec2.create();

    /**
     * The precision of the ray. Used when checking parallelity etc.
     * @property {Number} precision
     */
    this.precision = 0.0001;

    /**
     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
     * @property {Boolean} checkCollisionResponse
     */
    this.checkCollisionResponse = true;

    /**
     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
     * @property {Boolean} skipBackfaces
     */
    this.skipBackfaces = false;

    /**
     * @property {number} collisionMask
     * @default -1
     */
    this.collisionMask = -1;

    /**
     * @property {number} collisionGroup
     * @default -1
     */
    this.collisionGroup = -1;

    /**
     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
     * @property {number} mode
     */
    this.mode = Ray.ANY;

    /**
     * Current result object.
     * @property {RaycastResult} result
     */
    this.result = new RaycastResult();

    /**
     * Will be set to true during intersectWorld() if the ray hit anything.
     * @property {Boolean} hasHit
     */
    this.hasHit = false;

    /**
     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
     * @property {Function} callback
     */
    this.callback = function(result){};
}
Ray.prototype.constructor = Ray;

Ray.CLOSEST = 1;
Ray.ANY = 2;
Ray.ALL = 4;

var tmpAABB = new AABB();
var tmpArray = [];

/**
 * Do itersection against all bodies in the given World.
 * @method intersectWorld
 * @param  {World} world
 * @param  {object} options
 * @return {Boolean} True if the ray hit anything, otherwise false.
 */
Ray.prototype.intersectWorld = function (world, options) {
    this.mode = options.mode || Ray.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionMask = typeof(options.collisionMask) !== 'undefined' ? options.collisionMask : -1;
    this.collisionGroup = typeof(options.collisionGroup) !== 'undefined' ? options.collisionGroup : -1;
    if(options.from){
        vec2.copy(this.from, options.from);
    }
    if(options.to){
        vec2.copy(this.to, options.to);
    }
    this.callback = options.callback || function(){};
    this.hasHit = false;

    this.result.reset();
    this._updateDirection();

    this.getAABB(tmpAABB);
    tmpArray.length = 0;
    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
    this.intersectBodies(tmpArray);

    return this.hasHit;
};

var v1 = vec2.create(),
    v2 = vec2.create();

var intersectBody_worldPosition = vec2.create();

/**
 * Shoot a ray at a body, get back information about the hit.
 * @method intersectBody
 * @private
 * @param {Body} body
 * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
 */
Ray.prototype.intersectBody = function (body, result) {

    if(result){
        this.result = result;
        this._updateDirection();
    }
    var checkCollisionResponse = this.checkCollisionResponse;

    if(checkCollisionResponse && !body.collisionResponse){
        return;
    }

    // if((this.collisionGroup & body.collisionMask)===0 || (body.collisionGroup & this.collisionMask)===0){
    //     return;
    // }

    var worldPosition = intersectBody_worldPosition;

    for (var i = 0, N = body.shapes.length; i < N; i++) {
        var shape = body.shapes[i];

        if(checkCollisionResponse && !shape.collisionResponse){
            continue; // Skip
        }

        // Get world angle and position of the shape
        vec2.copy(worldPosition, body.shapeOffsets[i]);
        vec2.rotate(worldPosition, worldPosition, body.angle);
        vec2.add(worldPosition, worldPosition, body.position);
        var worldAngle = body.shapeAngles[i] + body.angle;

        this.intersectShape(
            shape,
            worldAngle,
            worldPosition,
            body
        );

        if(this.result._shouldStop){
            break;
        }
    }
};

/**
 * @method intersectBodies
 * @param {Array} bodies An array of Body objects.
 * @param {RaycastResult} [result] Deprecated
 */
Ray.prototype.intersectBodies = function (bodies, result) {
    if(result){
        this.result = result;
        this._updateDirection();
    }

    for ( var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i ++ ) {
        this.intersectBody(bodies[i]);
    }
};

/**
 * Updates the _direction vector.
 * @private
 * @method _updateDirection
 */
Ray.prototype._updateDirection = function(){
    var d = this._direction;
    vec2.sub(d, this.to, this.from); // this.to.vsub(this.from, this._direction);
    vec2.normalize(d, d); // this._direction.normalize();
};

/**
 * @method intersectShape
 * @private
 * @param {Shape} shape
 * @param {number} angle
 * @param {array} position
 * @param {Body} body
 */
Ray.prototype.intersectShape = function(shape, angle, position, body){
    var from = this.from;


    // Checking boundingSphere
    var distance = distanceFromIntersection(from, this._direction, position);
    if ( distance > shape.boundingSphereRadius ) {
        return;
    }

    var method = this[shape.type];
    if(method){
        method.call(this, shape, angle, position, body);
    }
};

var vector = vec2.create();
var normal = vec2.create();
var intersectPoint = vec2.create();

var a = vec2.create();
var b = vec2.create();
var c = vec2.create();
var d = vec2.create();

var tmpRaycastResult = new RaycastResult();
var intersectRectangle_direction = vec2.create();
var intersectRectangle_rayStart = vec2.create();
var intersectRectangle_worldNormalMin = vec2.create();
var intersectRectangle_worldNormalMax = vec2.create();
var intersectRectangle_hitPointWorld = vec2.create();
var intersectRectangle_boxMin = vec2.create();
var intersectRectangle_boxMax = vec2.create();

/**
 * @method intersectRectangle
 * @private
 * @param  {Shape} shape
 * @param  {number} angle
 * @param  {array} position
 * @param  {Body} body
 */
Ray.prototype.intersectRectangle = function(shape, angle, position, body){
    var tmin = -Number.MAX_VALUE;
    var tmax = Number.MAX_VALUE;

    var direction = intersectRectangle_direction;
    var rayStart = intersectRectangle_rayStart;
    var worldNormalMin = intersectRectangle_worldNormalMin;
    var worldNormalMax = intersectRectangle_worldNormalMax;
    var hitPointWorld = intersectRectangle_hitPointWorld;
    var boxMin = intersectRectangle_boxMin;
    var boxMax = intersectRectangle_boxMax;

    vec2.set(boxMin, -shape.width * 0.5, -shape.height * 0.5);
    vec2.set(boxMax, shape.width * 0.5, shape.height * 0.5);

    // Transform the ray direction and start to local space
    vec2.rotate(direction, this._direction, -angle);
    body.toLocalFrame(rayStart, this.from);

    if (direction[0] !== 0) {
        var tx1 = (boxMin[0] - rayStart[0]) / direction[0];
        var tx2 = (boxMax[0] - rayStart[0]) / direction[0];

        var tminOld = tmin;
        tmin = Math.max(tmin, Math.min(tx1, tx2));
        if(tmin !== tminOld){
            vec2.set(worldNormalMin, tx1 > tx2 ? 1 : -1, 0);
        }

        var tmaxOld = tmax;
        tmax = Math.min(tmax, Math.max(tx1, tx2));
        if(tmax !== tmaxOld){
            vec2.set(worldNormalMax, tx1 < tx2 ? 1 : -1, 0);
        }
    }

    if (direction[1] !== 0) {
        var ty1 = (boxMin[1] - rayStart[1]) / direction[1];
        var ty2 = (boxMax[1] - rayStart[1]) / direction[1];

        var tminOld = tmin;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        if(tmin !== tminOld){
            vec2.set(worldNormalMin, 0, ty1 > ty2 ? 1 : -1);
        }

        var tmaxOld = tmax;
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        if(tmax !== tmaxOld){
            vec2.set(worldNormalMax, 0, ty1 < ty2 ? 1 : -1);
        }
    }

    if(tmax >= tmin){
        // Hit point
        vec2.set(
            hitPointWorld,
            rayStart[0] + direction[0] * tmin,
            rayStart[1] + direction[1] * tmin
        );

        vec2.rotate(worldNormalMin, worldNormalMin, angle);

        body.toWorldFrame(hitPointWorld, hitPointWorld);

        this.reportIntersection(worldNormalMin, hitPointWorld, shape, body, -1);
        if(this._shouldStop){
            return;
        }

        vec2.rotate(worldNormalMax, worldNormalMax, angle);

        // Hit point
        vec2.set(
            hitPointWorld,
            rayStart[0] + direction[0] * tmax,
            rayStart[1] + direction[1] * tmax
        );
        body.toWorldFrame(hitPointWorld, hitPointWorld);

        this.reportIntersection(worldNormalMax, hitPointWorld, shape, body, -1);
    }
};
Ray.prototype[Shape.RECTANGLE] = Ray.prototype.intersectRectangle;

var intersectPlane_planePointToFrom = vec2.create();
var intersectPlane_dir_scaled_with_t = vec2.create();
var intersectPlane_hitPointWorld = vec2.create();
var intersectPlane_worldNormal = vec2.create();
var intersectPlane_len = vec2.create();

/**
 * @method intersectPlane
 * @private
 * @param  {Shape} shape
 * @param  {number} angle
 * @param  {array} position
 * @param  {Body} body
 */
Ray.prototype.intersectPlane = function(shape, angle, position, body){
    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    var planePointToFrom = intersectPlane_planePointToFrom;
    var dir_scaled_with_t = intersectPlane_dir_scaled_with_t;
    var hitPointWorld = intersectPlane_hitPointWorld;
    var worldNormal = intersectPlane_worldNormal;
    var len = intersectPlane_len;

    // Get plane normal
    vec2.set(worldNormal, 0, 1);
    vec2.rotate(worldNormal, worldNormal, angle);

    vec2.sub(len, from, position); //from.vsub(position, len);
    var planeToFrom = vec2.dot(len, worldNormal); // len.dot(worldNormal);
    vec2.sub(len, to, position); // to.vsub(position, len);
    var planeToTo = vec2.dot(len, worldNormal); // len.dot(worldNormal);

    if(planeToFrom * planeToTo > 0){
        // "from" and "to" are on the same side of the plane... bail out
        return;
    }

    if(vec2.distance(from, to) /* from.distanceTo(to) */ < planeToFrom){
        return;
    }

    var n_dot_dir = vec2.dot(worldNormal, direction); // worldNormal.dot(direction);

    // if (Math.abs(n_dot_dir) < this.precision) {
    //     // No intersection
    //     return;
    // }

    vec2.sub(planePointToFrom, from, position); // from.vsub(position, planePointToFrom);
    var t = -vec2.dot(worldNormal, planePointToFrom) / n_dot_dir; // - worldNormal.dot(planePointToFrom) / n_dot_dir;
    vec2.scale(dir_scaled_with_t, direction, t); // direction.scale(t, dir_scaled_with_t);
    vec2.add(hitPointWorld, from, dir_scaled_with_t); // from.vadd(dir_scaled_with_t, hitPointWorld);

    this.reportIntersection(worldNormal, hitPointWorld, shape, body, -1);
};
Ray.prototype[Shape.PLANE] = Ray.prototype.intersectPlane;

var Ray_intersectSphere_intersectionPoint = vec2.create();
var Ray_intersectSphere_normal = vec2.create();
Ray.prototype.intersectCircle = function(shape, angle, position, body){
    var from = this.from,
        to = this.to,
        r = shape.radius;

    var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
    var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
    var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);

    var delta = Math.pow(b, 2) - 4 * a * c;

    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
    var normal = Ray_intersectSphere_normal;

    if(delta < 0){
        // No intersection
        return;

    } else if(delta === 0){
        // single intersection point
        vec2.lerp(intersectionPoint, from, to, delta); // from.lerp(to, delta, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

    } else {
        var d1 = (- b - Math.sqrt(delta)) / (2 * a);
        var d2 = (- b + Math.sqrt(delta)) / (2 * a);

        vec2.lerp(intersectionPoint, from, to, d1); // from.lerp(to, d1, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

        if(this.result._shouldStop){
            return;
        }

        vec2.lerp(intersectionPoint, from, to, d2); // from.lerp(to, d2, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);
    }
};
Ray.prototype[Shape.CIRCLE] = Ray.prototype.intersectCircle;

/**
 * Get the AABB of the ray.
 * @method getAABB
 * @param  {AABB} aabb
 */
Ray.prototype.getAABB = function(result){
    var to = this.to;
    var from = this.from;
    result.lowerBound[0] = Math.min(to[0], from[0]);
    result.lowerBound[1] = Math.min(to[1], from[1]);
    result.upperBound[0] = Math.max(to[0], from[0]);
    result.upperBound[1] = Math.max(to[1], from[1]);
};

/**
 * @method reportIntersection
 * @private
 * @param  {array} normal
 * @param  {array} hitPointWorld
 * @param  {Shape} shape
 * @param  {Body} body
 * @return {boolean} True if the intersections should continue
 */
Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex){
    var from = this.from;
    var to = this.to;
    var distance = vec2.distance(from, hitPointWorld); // from.distanceTo(hitPointWorld);
    var result = this.result;

    // Skip back faces?
    if(this.skipBackfaces && /* normal.dot(this._direction) */ vec2.dot(normal, this._direction) > 0){
        return;
    }

    result.hitFaceIndex = typeof(hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;

    switch(this.mode){
    case Ray.ALL:
        this.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result.hasHit = true;
        this.callback(result);
        break;

    case Ray.CLOSEST:

        // Store if closer than current closest
        if(distance < result.distance || !result.hasHit){
            this.hasHit = true;
            result.hasHit = true;
            result.set(
                from,
                to,
                normal,
                hitPointWorld,
                shape,
                body,
                distance
            );
        }
        break;

    case Ray.ANY:

        // Report and stop.
        this.hasHit = true;
        result.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result._shouldStop = true;
        break;
    }
};

var v0 = vec2.create(),
    intersect = vec2.create();
function distanceFromIntersection(from, direction, position) {

    // v0 is vector from from to position
    vec2.sub(v0, position, from); // position.vsub(from,v0);
    var dot = vec2.dot(v0, direction); // v0.dot(direction);

    // intersect = direction*dot + from
    vec2.scale(intersect, direction, dot); //direction.mult(dot,intersect);
    vec2.add(intersect, intersect, from); // intersect.vadd(from, intersect);

    var distance = vec2.distance(position, intersect); // position.distanceTo(intersect);

    return distance;
}


},{"../collision/AABB":7,"../collision/RaycastResult":13,"../math/vec2":31,"../shapes/Shape":45}],13:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');

module.exports = RaycastResult;

/**
 * Storage for Ray casting data.
 * @class RaycastResult
 * @constructor
 */
function RaycastResult(){

	/**
	 * @property {array} rayFromWorld
	 */
	this.rayFromWorld = vec2.create();

	/**
	 * @property {array} rayToWorld
	 */
	this.rayToWorld = vec2.create();

	/**
	 * @property {array} hitNormalWorld
	 */
	this.hitNormalWorld = vec2.create();

	/**
	 * @property {array} hitPointWorld
	 */
	this.hitPointWorld = vec2.create();

	/**
	 * @property {boolean} hasHit
	 */
	this.hasHit = false;

	/**
	 * The hit shape, or null.
	 * @property {Shape} shape
	 */
	this.shape = null;

	/**
	 * The hit body, or null.
	 * @property {Body} body
	 */
	this.body = null;

	/**
	 * The index of the hit triangle, if the hit shape was a trimesh.
	 * @property {number} hitFaceIndex
	 * @default -1
	 */
	this.hitFaceIndex = -1;

	/**
	 * Distance to the hit. Will be set to -1 if there was no hit.
	 * @property {number} distance
	 * @default -1
	 */
	this.distance = -1;

	/**
	 * If the ray should stop traversing the bodies.
	 * @private
	 * @property {Boolean} _shouldStop
	 * @default false
	 */
	this._shouldStop = false;
}

/**
 * Reset all result data.
 * @method reset
 */
RaycastResult.prototype.reset = function () {
	vec2.set(this.rayFromWorld, 0, 0);
	vec2.set(this.rayToWorld, 0, 0);
	vec2.set(this.hitNormalWorld, 0, 0);
	vec2.set(this.hitPointWorld, 0, 0);
	this.hasHit = false;
	this.shape = null;
	this.body = null;
	this.hitFaceIndex = -1;
	this.distance = -1;
	this._shouldStop = false;
};

/**
 * @method abort
 */
RaycastResult.prototype.abort = function(){
	this._shouldStop = true;
};

/**
 * @method set
 * @param {array} rayFromWorld
 * @param {array} rayToWorld
 * @param {array} hitNormalWorld
 * @param {array} hitPointWorld
 * @param {Shape} shape
 * @param {Body} body
 * @param {number} distance
 */
RaycastResult.prototype.set = function(
	rayFromWorld,
	rayToWorld,
	hitNormalWorld,
	hitPointWorld,
	shape,
	body,
	distance
){
	vec2.copy(this.rayFromWorld, rayFromWorld);
	vec2.copy(this.rayToWorld, rayToWorld);
	vec2.copy(this.hitNormalWorld, hitNormalWorld);
	vec2.copy(this.hitPointWorld, hitPointWorld);
	this.shape = shape;
	this.body = body;
	this.distance = distance;
};
},{"../math/vec2":31}],14:[function(_dereq_,module,exports){
var Utils = _dereq_('../utils/Utils')
,   Broadphase = _dereq_('../collision/Broadphase');

module.exports = SAPBroadphase;

/**
 * Sweep and prune broadphase along one axis.
 *
 * @class SAPBroadphase
 * @constructor
 * @extends Broadphase
 */
function SAPBroadphase(){
    Broadphase.call(this,Broadphase.SAP);

    /**
     * List of bodies currently in the broadphase.
     * @property axisList
     * @type {Array}
     */
    this.axisList = [];

    /**
     * The axis to sort along. 0 means x-axis and 1 y-axis. If your bodies are more spread out over the X axis, set axisIndex to 0, and you will gain some performance.
     * @property axisIndex
     * @type {Number}
     */
    this.axisIndex = 0;

    var that = this;
    this._addBodyHandler = function(e){
        that.axisList.push(e.body);
    };

    this._removeBodyHandler = function(e){
        // Remove from list
        var idx = that.axisList.indexOf(e.body);
        if(idx !== -1){
            that.axisList.splice(idx,1);
        }
    };
}
SAPBroadphase.prototype = new Broadphase();
SAPBroadphase.prototype.constructor = SAPBroadphase;

/**
 * Change the world
 * @method setWorld
 * @param {World} world
 */
SAPBroadphase.prototype.setWorld = function(world){
    // Clear the old axis array
    this.axisList.length = 0;

    // Add all bodies from the new world
    Utils.appendArray(this.axisList, world.bodies);

    // Remove old handlers, if any
    world
        .off("addBody",this._addBodyHandler)
        .off("removeBody",this._removeBodyHandler);

    // Add handlers to update the list of bodies.
    world.on("addBody",this._addBodyHandler).on("removeBody",this._removeBodyHandler);

    this.world = world;
};

/**
 * Sorts bodies along an axis.
 * @method sortAxisList
 * @param {Array} a
 * @param {number} axisIndex
 * @return {Array}
 */
SAPBroadphase.sortAxisList = function(a, axisIndex){
    axisIndex = axisIndex|0;
    for(var i=1,l=a.length; i<l; i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

SAPBroadphase.prototype.sortList = function(){
    var bodies = this.axisList,
    axisIndex = this.axisIndex;

    // Sort the lists
    SAPBroadphase.sortAxisList(bodies, axisIndex);
};

/**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
SAPBroadphase.prototype.getCollisionPairs = function(world){
    var bodies = this.axisList,
        result = this.result,
        axisIndex = this.axisIndex;

    result.length = 0;

    // Update all AABBs if needed
    var l = bodies.length;
    while(l--){
        var b = bodies[l];
        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }
    }

    // Sort the lists
    this.sortList();

    // Look through the X list
    for(var i=0, N=bodies.length|0; i!==N; i++){
        var bi = bodies[i];

        for(var j=i+1; j<N; j++){
            var bj = bodies[j];

            // Bounds overlap?
            var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);
            if(!overlaps){
                break;
            }

            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                result.push(bi,bj);
            }
        }
    }

    return result;
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    this.sortList();

    var axisIndex = this.axisIndex;
    var axis = 'x';
    if(axisIndex === 1){ axis = 'y'; }
    if(axisIndex === 2){ axis = 'z'; }

    var axisList = this.axisList;
    var lower = aabb.lowerBound[axis];
    var upper = aabb.upperBound[axis];
    for(var i = 0; i < axisList.length; i++){
        var b = axisList[i];

        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":8,"../utils/Utils":50}],15:[function(_dereq_,module,exports){
module.exports = Constraint;

var Utils = _dereq_('../utils/Utils');

/**
 * Base constraint class.
 *
 * @class Constraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} type
 * @param {Object} [options]
 * @param {Object} [options.collideConnected=true]
 */
function Constraint(bodyA, bodyB, type, options){

    /**
     * The type of constraint. May be one of Constraint.DISTANCE, Constraint.GEAR, Constraint.LOCK, Constraint.PRISMATIC or Constraint.REVOLUTE.
     * @property {number} type
     */
    this.type = type;

    options = Utils.defaults(options,{
        collideConnected : true,
        wakeUpBodies : true,
    });

    /**
     * Equations to be solved in this constraint
     *
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * First body participating in the constraint.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second body participating in the constraint.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * Set to true if you want the connected bodies to collide.
     * @property collideConnected
     * @type {Boolean}
     * @default true
     */
    this.collideConnected = options.collideConnected;

    // Wake up bodies when connected
    if(options.wakeUpBodies){
        if(bodyA){
            bodyA.wakeUp();
        }
        if(bodyB){
            bodyB.wakeUp();
        }
    }
}

/**
 * Updates the internal constraint parameters before solve.
 * @method update
 */
Constraint.prototype.update = function(){
    throw new Error("method update() not implmemented in this Constraint subclass!");
};

/**
 * @static
 * @property {number} DISTANCE
 */
Constraint.DISTANCE = 1;

/**
 * @static
 * @property {number} GEAR
 */
Constraint.GEAR = 2;

/**
 * @static
 * @property {number} LOCK
 */
Constraint.LOCK = 3;

/**
 * @static
 * @property {number} PRISMATIC
 */
Constraint.PRISMATIC = 4;

/**
 * @static
 * @property {number} REVOLUTE
 */
Constraint.REVOLUTE = 5;

/**
 * Set stiffness for this constraint.
 * @method setStiffness
 * @param {Number} stiffness
 */
Constraint.prototype.setStiffness = function(stiffness){
    var eqs = this.equations;
    for(var i=0; i !== eqs.length; i++){
        var eq = eqs[i];
        eq.stiffness = stiffness;
        eq.needsUpdate = true;
    }
};

/**
 * Set relaxation for this constraint.
 * @method setRelaxation
 * @param {Number} relaxation
 */
Constraint.prototype.setRelaxation = function(relaxation){
    var eqs = this.equations;
    for(var i=0; i !== eqs.length; i++){
        var eq = eqs[i];
        eq.relaxation = relaxation;
        eq.needsUpdate = true;
    }
};

},{"../utils/Utils":50}],16:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = DistanceConstraint;

/**
 * Constraint that tries to keep the distance between two bodies constant.
 *
 * @class DistanceConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.
 * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
 * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
 * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.
 * @extends Constraint
 *
 * @example
 *     // If distance is not given as an option, then the current distance between the bodies is used.
 *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new DistanceConstraint(bodyA, bodyB);
 *
 * @example
 *     var constraint = new DistanceConstraint(bodyA, bodyB, {
 *         distance: 1,          // Distance to keep between the points
 *         localAnchorA: [1, 0], // Point on bodyA
 *         localAnchorB: [-1, 0] // Point on bodyB
 *     });
 */
function DistanceConstraint(bodyA,bodyB,options){
    options = Utils.defaults(options,{
        localAnchorA:[0,0],
        localAnchorB:[0,0]
    });

    Constraint.call(this,bodyA,bodyB,Constraint.DISTANCE,options);

    /**
     * Local anchor in body A.
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);

    /**
     * Local anchor in body B.
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);

    var localAnchorA = this.localAnchorA;
    var localAnchorB = this.localAnchorB;

    /**
     * The distance to keep.
     * @property distance
     * @type {Number}
     */
    this.distance = 0;

    if(typeof(options.distance) === 'number'){
        this.distance = options.distance;
    } else {
        // Use the current world distance between the world anchor points.
        var worldAnchorA = vec2.create(),
            worldAnchorB = vec2.create(),
            r = vec2.create();

        // Transform local anchors to world
        vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);
        vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);

        vec2.add(r, bodyB.position, worldAnchorB);
        vec2.sub(r, r, worldAnchorA);
        vec2.sub(r, r, bodyA.position);

        this.distance = vec2.length(r);
    }

    var maxForce;
    if(typeof(options.maxForce)==="undefined" ){
        maxForce = Number.MAX_VALUE;
    } else {
        maxForce = options.maxForce;
    }

    var normal = new Equation(bodyA,bodyB,-maxForce,maxForce); // Just in the normal direction
    this.equations = [ normal ];

    /**
     * Max force to apply.
     * @property {number} maxForce
     */
    this.maxForce = maxForce;

    // g = (xi - xj).dot(n)
    // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'

    // ...and if we were to include offset points (TODO for now):
    // g =
    //      (xj + rj - xi - ri).dot(n) - distance
    //
    // dg/dt =
    //      (vj + wj x rj - vi - wi x ri).dot(n) =
    //      { term 2 is near zero } =
    //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =
    //      G * W
    //
    // => G = [-n -rixn n rjxn]

    var r = vec2.create();
    var ri = vec2.create(); // worldAnchorA
    var rj = vec2.create(); // worldAnchorB
    var that = this;
    normal.computeGq = function(){
        var bodyA = this.bodyA,
            bodyB = this.bodyB,
            xi = bodyA.position,
            xj = bodyB.position;

        // Transform local anchors to world
        vec2.rotate(ri, localAnchorA, bodyA.angle);
        vec2.rotate(rj, localAnchorB, bodyB.angle);

        vec2.add(r, xj, rj);
        vec2.sub(r, r, ri);
        vec2.sub(r, r, xi);

        //vec2.sub(r, bodyB.position, bodyA.position);
        return vec2.length(r) - that.distance;
    };

    // Make the contact constraint bilateral
    this.setMaxForce(maxForce);

    /**
     * If the upper limit is enabled or not.
     * @property {Boolean} upperLimitEnabled
     */
    this.upperLimitEnabled = false;

    /**
     * The upper constraint limit.
     * @property {number} upperLimit
     */
    this.upperLimit = 1;

    /**
     * If the lower limit is enabled or not.
     * @property {Boolean} lowerLimitEnabled
     */
    this.lowerLimitEnabled = false;

    /**
     * The lower constraint limit.
     * @property {number} lowerLimit
     */
    this.lowerLimit = 0;

    /**
     * Current constraint position. This is equal to the current distance between the world anchor points.
     * @property {number} position
     */
    this.position = 0;
}
DistanceConstraint.prototype = new Constraint();
DistanceConstraint.prototype.constructor = DistanceConstraint;

/**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */
var n = vec2.create();
var ri = vec2.create(); // worldAnchorA
var rj = vec2.create(); // worldAnchorB
DistanceConstraint.prototype.update = function(){
    var normal = this.equations[0],
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        distance = this.distance,
        xi = bodyA.position,
        xj = bodyB.position,
        normalEquation = this.equations[0],
        G = normal.G;

    // Transform local anchors to world
    vec2.rotate(ri, this.localAnchorA, bodyA.angle);
    vec2.rotate(rj, this.localAnchorB, bodyB.angle);

    // Get world anchor points and normal
    vec2.add(n, xj, rj);
    vec2.sub(n, n, ri);
    vec2.sub(n, n, xi);
    this.position = vec2.length(n);

    var violating = false;
    if(this.upperLimitEnabled){
        if(this.position > this.upperLimit){
            normalEquation.maxForce = 0;
            normalEquation.minForce = -this.maxForce;
            this.distance = this.upperLimit;
            violating = true;
        }
    }

    if(this.lowerLimitEnabled){
        if(this.position < this.lowerLimit){
            normalEquation.maxForce = this.maxForce;
            normalEquation.minForce = 0;
            this.distance = this.lowerLimit;
            violating = true;
        }
    }

    if((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating){
        // No constraint needed.
        normalEquation.enabled = false;
        return;
    }

    normalEquation.enabled = true;

    vec2.normalize(n,n);

    // Caluclate cross products
    var rixn = vec2.crossLength(ri, n),
        rjxn = vec2.crossLength(rj, n);

    // G = [-n -rixn n rjxn]
    G[0] = -n[0];
    G[1] = -n[1];
    G[2] = -rixn;
    G[3] = n[0];
    G[4] = n[1];
    G[5] = rjxn;
};

/**
 * Set the max force to be used
 * @method setMaxForce
 * @param {Number} f
 */
DistanceConstraint.prototype.setMaxForce = function(f){
    var normal = this.equations[0];
    normal.minForce = -f;
    normal.maxForce =  f;
};

/**
 * Get the max force
 * @method getMaxForce
 * @return {Number}
 */
DistanceConstraint.prototype.getMaxForce = function(f){
    var normal = this.equations[0];
    return normal.maxForce;
};

},{"../equations/Equation":23,"../math/vec2":31,"../utils/Utils":50,"./Constraint":15}],17:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   AngleLockEquation = _dereq_('../equations/AngleLockEquation')
,   vec2 = _dereq_('../math/vec2');

module.exports = GearConstraint;

/**
 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
 * @class GearConstraint
 * @constructor
 * @author schteppe
 * @param {Body}            bodyA
 * @param {Body}            bodyB
 * @param {Object}          [options]
 * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).
 * @param {Number}          [options.ratio=1] Gear ratio.
 * @param {Number}          [options.maxTorque] Maximum torque to apply.
 * @extends Constraint
 * @todo Ability to specify world points
 */
function GearConstraint(bodyA, bodyB, options){
    options = options || {};

    Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);

    /**
     * The gear ratio.
     * @property ratio
     * @type {Number}
     */
    this.ratio = typeof(options.ratio) === "number" ? options.ratio : 1;

    /**
     * The relative angle
     * @property angle
     * @type {Number}
     */
    this.angle = typeof(options.angle) === "number" ? options.angle : bodyB.angle - this.ratio * bodyA.angle;

    // Send same parameters to the equation
    options.angle = this.angle;
    options.ratio = this.ratio;

    this.equations = [
        new AngleLockEquation(bodyA,bodyB,options),
    ];

    // Set max torque
    if(typeof(options.maxTorque) === "number"){
        this.setMaxTorque(options.maxTorque);
    }
}
GearConstraint.prototype = new Constraint();
GearConstraint.prototype.constructor = GearConstraint;

GearConstraint.prototype.update = function(){
    var eq = this.equations[0];
    if(eq.ratio !== this.ratio){
        eq.setRatio(this.ratio);
    }
    eq.angle = this.angle;
};

/**
 * Set the max torque for the constraint.
 * @method setMaxTorque
 * @param {Number} torque
 */
GearConstraint.prototype.setMaxTorque = function(torque){
    this.equations[0].setMaxTorque(torque);
};

/**
 * Get the max torque for the constraint.
 * @method getMaxTorque
 * @return {Number}
 */
GearConstraint.prototype.getMaxTorque = function(torque){
    return this.equations[0].maxForce;
};
},{"../equations/AngleLockEquation":21,"../equations/Equation":23,"../math/vec2":31,"./Constraint":15}],18:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   vec2 = _dereq_('../math/vec2')
,   Equation = _dereq_('../equations/Equation');

module.exports = LockConstraint;

/**
 * Locks the relative position between two bodies.
 *
 * @class LockConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.
 * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.
 * @param {number} [options.maxForce]
 * @extends Constraint
 */
function LockConstraint(bodyA, bodyB, options){
    options = options || {};

    Constraint.call(this,bodyA,bodyB,Constraint.LOCK,options);

    var maxForce = ( typeof(options.maxForce)==="undefined" ? Number.MAX_VALUE : options.maxForce );

    var localAngleB = options.localAngleB || 0;

    // Use 3 equations:
    // gx =   (xj - xi - l) * xhat = 0
    // gy =   (xj - xi - l) * yhat = 0
    // gr =   (xi - xj + r) * that = 0
    //
    // ...where:
    //   l is the localOffsetB vector rotated to world in bodyA frame
    //   r is the same vector but reversed and rotated from bodyB frame
    //   xhat, yhat are world axis vectors
    //   that is the tangent of r
    //
    // For the first two constraints, we get
    // G*W = (vj - vi - ldot  ) * xhat
    //     = (vj - vi - wi x l) * xhat
    //
    // Since (wi x l) * xhat = (l x xhat) * wi, we get
    // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]
    //
    // The last constraint gives
    // GW = (vi - vj + wj x r) * that
    //    = [  that   0  -that  (r x t) ]

    var x =     new Equation(bodyA,bodyB,-maxForce,maxForce),
        y =     new Equation(bodyA,bodyB,-maxForce,maxForce),
        rot =   new Equation(bodyA,bodyB,-maxForce,maxForce);

    var l = vec2.create(),
        g = vec2.create(),
        that = this;
    x.computeGq = function(){
        vec2.rotate(l, that.localOffsetB, bodyA.angle);
        vec2.sub(g, bodyB.position, bodyA.position);
        vec2.sub(g, g, l);
        return g[0];
    };
    y.computeGq = function(){
        vec2.rotate(l, that.localOffsetB, bodyA.angle);
        vec2.sub(g, bodyB.position, bodyA.position);
        vec2.sub(g, g, l);
        return g[1];
    };
    var r = vec2.create(),
        t = vec2.create();
    rot.computeGq = function(){
        vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
        vec2.scale(r,r,-1);
        vec2.sub(g,bodyA.position,bodyB.position);
        vec2.add(g,g,r);
        vec2.rotate(t,r,-Math.PI/2);
        vec2.normalize(t,t);
        return vec2.dot(g,t);
    };

    /**
     * The offset of bodyB in bodyA's frame.
     * @property {Array} localOffsetB
     */
    this.localOffsetB = vec2.create();
    if(options.localOffsetB){
        vec2.copy(this.localOffsetB, options.localOffsetB);
    } else {
        // Construct from current positions
        vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);
        vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);
    }

    /**
     * The offset angle of bodyB in bodyA's frame.
     * @property {Number} localAngleB
     */
    this.localAngleB = 0;
    if(typeof(options.localAngleB) === 'number'){
        this.localAngleB = options.localAngleB;
    } else {
        // Construct
        this.localAngleB = bodyB.angle - bodyA.angle;
    }

    this.equations.push(x, y, rot);
    this.setMaxForce(maxForce);
}
LockConstraint.prototype = new Constraint();
LockConstraint.prototype.constructor = LockConstraint;

/**
 * Set the maximum force to be applied.
 * @method setMaxForce
 * @param {Number} force
 */
LockConstraint.prototype.setMaxForce = function(force){
    var eqs = this.equations;
    for(var i=0; i<this.equations.length; i++){
        eqs[i].maxForce =  force;
        eqs[i].minForce = -force;
    }
};

/**
 * Get the max force.
 * @method getMaxForce
 * @return {Number}
 */
LockConstraint.prototype.getMaxForce = function(){
    return this.equations[0].maxForce;
};

var l = vec2.create();
var r = vec2.create();
var t = vec2.create();
var xAxis = vec2.fromValues(1,0);
var yAxis = vec2.fromValues(0,1);
LockConstraint.prototype.update = function(){
    var x =   this.equations[0],
        y =   this.equations[1],
        rot = this.equations[2],
        bodyA = this.bodyA,
        bodyB = this.bodyB;

    vec2.rotate(l,this.localOffsetB,bodyA.angle);
    vec2.rotate(r,this.localOffsetB,bodyB.angle - this.localAngleB);
    vec2.scale(r,r,-1);

    vec2.rotate(t,r,Math.PI/2);
    vec2.normalize(t,t);

    x.G[0] = -1;
    x.G[1] =  0;
    x.G[2] = -vec2.crossLength(l,xAxis);
    x.G[3] =  1;

    y.G[0] =  0;
    y.G[1] = -1;
    y.G[2] = -vec2.crossLength(l,yAxis);
    y.G[4] =  1;

    rot.G[0] =  -t[0];
    rot.G[1] =  -t[1];
    rot.G[3] =  t[0];
    rot.G[4] =  t[1];
    rot.G[5] =  vec2.crossLength(r,t);
};

},{"../equations/Equation":23,"../math/vec2":31,"./Constraint":15}],19:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   ContactEquation = _dereq_('../equations/ContactEquation')
,   Equation = _dereq_('../equations/Equation')
,   vec2 = _dereq_('../math/vec2')
,   RotationalLockEquation = _dereq_('../equations/RotationalLockEquation');

module.exports = PrismaticConstraint;

/**
 * Constraint that only allows bodies to move along a line, relative to each other. See <a href="http://www.iforce2d.net/b2dtut/joints-prismatic">this tutorial</a>.
 *
 * @class PrismaticConstraint
 * @constructor
 * @extends Constraint
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Number}  [options.maxForce]                Max force to be applied by the constraint
 * @param {Array}   [options.localAnchorA]            Body A's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAnchorB]            Body B's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAxisA]              An axis, defined in body A frame, that body B's anchor point may slide along.
 * @param {Boolean} [options.disableRotationalLock]   If set to true, bodyB will be free to rotate around its anchor point.
 * @param {Number}  [options.upperLimit]
 * @param {Number}  [options.lowerLimit]
 * @todo Ability to create using only a point and a worldAxis
 */
function PrismaticConstraint(bodyA, bodyB, options){
    options = options || {};
    Constraint.call(this,bodyA,bodyB,Constraint.PRISMATIC,options);

    // Get anchors
    var localAnchorA = vec2.fromValues(0,0),
        localAxisA = vec2.fromValues(1,0),
        localAnchorB = vec2.fromValues(0,0);
    if(options.localAnchorA){ vec2.copy(localAnchorA, options.localAnchorA); }
    if(options.localAxisA){ vec2.copy(localAxisA,   options.localAxisA); }
    if(options.localAnchorB){ vec2.copy(localAnchorB, options.localAnchorB); }

    /**
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = localAnchorA;

    /**
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = localAnchorB;

    /**
     * @property localAxisA
     * @type {Array}
     */
    this.localAxisA = localAxisA;

    /*

    The constraint violation for the common axis point is

        g = ( xj + rj - xi - ri ) * t   :=  gg*t

    where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.

        gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )

    Note the use of the chain rule. Now we identify the jacobian

        G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]

    The rotational part is just a rotation lock.

     */

    var maxForce = this.maxForce = typeof(options.maxForce)!=="undefined" ? options.maxForce : Number.MAX_VALUE;

    // Translational part
    var trans = new Equation(bodyA,bodyB,-maxForce,maxForce);
    var ri = new vec2.create(),
        rj = new vec2.create(),
        gg = new vec2.create(),
        t =  new vec2.create();
    trans.computeGq = function(){
        // g = ( xj + rj - xi - ri ) * t
        return vec2.dot(gg,t);
    };
    trans.updateJacobian = function(){
        var G = this.G,
            xi = bodyA.position,
            xj = bodyB.position;
        vec2.rotate(ri,localAnchorA,bodyA.angle);
        vec2.rotate(rj,localAnchorB,bodyB.angle);
        vec2.add(gg,xj,rj);
        vec2.sub(gg,gg,xi);
        vec2.sub(gg,gg,ri);
        vec2.rotate(t,localAxisA,bodyA.angle+Math.PI/2);

        G[0] = -t[0];
        G[1] = -t[1];
        G[2] = -vec2.crossLength(ri,t) + vec2.crossLength(t,gg);
        G[3] = t[0];
        G[4] = t[1];
        G[5] = vec2.crossLength(rj,t);
    };
    this.equations.push(trans);

    // Rotational part
    if(!options.disableRotationalLock){
        var rot = new RotationalLockEquation(bodyA,bodyB,-maxForce,maxForce);
        this.equations.push(rot);
    }

    /**
     * The position of anchor A relative to anchor B, along the constraint axis.
     * @property position
     * @type {Number}
     */
    this.position = 0;

    // Is this one used at all?
    this.velocity = 0;

    /**
     * Set to true to enable lower limit.
     * @property lowerLimitEnabled
     * @type {Boolean}
     */
    this.lowerLimitEnabled = typeof(options.lowerLimit)!=="undefined" ? true : false;

    /**
     * Set to true to enable upper limit.
     * @property upperLimitEnabled
     * @type {Boolean}
     */
    this.upperLimitEnabled = typeof(options.upperLimit)!=="undefined" ? true : false;

    /**
     * Lower constraint limit. The constraint position is forced to be larger than this value.
     * @property lowerLimit
     * @type {Number}
     */
    this.lowerLimit = typeof(options.lowerLimit)!=="undefined" ? options.lowerLimit : 0;

    /**
     * Upper constraint limit. The constraint position is forced to be smaller than this value.
     * @property upperLimit
     * @type {Number}
     */
    this.upperLimit = typeof(options.upperLimit)!=="undefined" ? options.upperLimit : 1;

    // Equations used for limits
    this.upperLimitEquation = new ContactEquation(bodyA,bodyB);
    this.lowerLimitEquation = new ContactEquation(bodyA,bodyB);

    // Set max/min forces
    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;

    /**
     * Equation used for the motor.
     * @property motorEquation
     * @type {Equation}
     */
    this.motorEquation = new Equation(bodyA,bodyB);

    /**
     * The current motor state. Enable or disable the motor using .enableMotor
     * @property motorEnabled
     * @type {Boolean}
     */
    this.motorEnabled = false;

    /**
     * Set the target speed for the motor.
     * @property motorSpeed
     * @type {Number}
     */
    this.motorSpeed = 0;

    var that = this;
    var motorEquation = this.motorEquation;
    var old = motorEquation.computeGW;
    motorEquation.computeGq = function(){ return 0; };
    motorEquation.computeGW = function(){
        var G = this.G,
            bi = this.bodyA,
            bj = this.bodyB,
            vi = bi.velocity,
            vj = bj.velocity,
            wi = bi.angularVelocity,
            wj = bj.angularVelocity;
        return this.gmult(G,vi,wi,vj,wj) + that.motorSpeed;
    };
}

PrismaticConstraint.prototype = new Constraint();
PrismaticConstraint.prototype.constructor = PrismaticConstraint;

var worldAxisA = vec2.create(),
    worldAnchorA = vec2.create(),
    worldAnchorB = vec2.create(),
    orientedAnchorA = vec2.create(),
    orientedAnchorB = vec2.create(),
    tmp = vec2.create();

/**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */
PrismaticConstraint.prototype.update = function(){
    var eqs = this.equations,
        trans = eqs[0],
        upperLimit = this.upperLimit,
        lowerLimit = this.lowerLimit,
        upperLimitEquation = this.upperLimitEquation,
        lowerLimitEquation = this.lowerLimitEquation,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        localAxisA = this.localAxisA,
        localAnchorA = this.localAnchorA,
        localAnchorB = this.localAnchorB;

    trans.updateJacobian();

    // Transform local things to world
    vec2.rotate(worldAxisA,      localAxisA,      bodyA.angle);
    vec2.rotate(orientedAnchorA, localAnchorA,    bodyA.angle);
    vec2.add(worldAnchorA,       orientedAnchorA, bodyA.position);
    vec2.rotate(orientedAnchorB, localAnchorB,    bodyB.angle);
    vec2.add(worldAnchorB,       orientedAnchorB, bodyB.position);

    var relPosition = this.position = vec2.dot(worldAnchorB,worldAxisA) - vec2.dot(worldAnchorA,worldAxisA);

    // Motor
    if(this.motorEnabled){
        // G = [ a     a x ri   -a   -a x rj ]
        var G = this.motorEquation.G;
        G[0] = worldAxisA[0];
        G[1] = worldAxisA[1];
        G[2] = vec2.crossLength(worldAxisA,orientedAnchorB);
        G[3] = -worldAxisA[0];
        G[4] = -worldAxisA[1];
        G[5] = -vec2.crossLength(worldAxisA,orientedAnchorA);
    }

    /*
        Limits strategy:
        Add contact equation, with normal along the constraint axis.
        min/maxForce is set so the constraint is repulsive in the correct direction.
        Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.

                 ^
                 |
      upperLimit x
                 |    ------
         anchorB x<---|  B |
                 |    |    |
        ------   |    ------
        |    |   |
        |  A |-->x anchorA
        ------   |
                 x lowerLimit
                 |
                axis
     */


    if(this.upperLimitEnabled && relPosition > upperLimit){
        // Update contact constraint normal, etc
        vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);
        vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
        vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
        vec2.scale(tmp,worldAxisA,upperLimit);
        vec2.add(upperLimitEquation.contactPointA,upperLimitEquation.contactPointA,tmp);
        if(eqs.indexOf(upperLimitEquation) === -1){
            eqs.push(upperLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(upperLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    if(this.lowerLimitEnabled && relPosition < lowerLimit){
        // Update contact constraint normal, etc
        vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);
        vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
        vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
        vec2.scale(tmp,worldAxisA,lowerLimit);
        vec2.sub(lowerLimitEquation.contactPointB,lowerLimitEquation.contactPointB,tmp);
        if(eqs.indexOf(lowerLimitEquation) === -1){
            eqs.push(lowerLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(lowerLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }
};

/**
 * Enable the motor
 * @method enableMotor
 */
PrismaticConstraint.prototype.enableMotor = function(){
    if(this.motorEnabled){
        return;
    }
    this.equations.push(this.motorEquation);
    this.motorEnabled = true;
};

/**
 * Disable the rotational motor
 * @method disableMotor
 */
PrismaticConstraint.prototype.disableMotor = function(){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations.splice(i,1);
    this.motorEnabled = false;
};

/**
 * Set the constraint limits.
 * @method setLimits
 * @param {number} lower Lower limit.
 * @param {number} upper Upper limit.
 */
PrismaticConstraint.prototype.setLimits = function (lower, upper) {
    if(typeof(lower) === 'number'){
        this.lowerLimit = lower;
        this.lowerLimitEnabled = true;
    } else {
        this.lowerLimit = lower;
        this.lowerLimitEnabled = false;
    }

    if(typeof(upper) === 'number'){
        this.upperLimit = upper;
        this.upperLimitEnabled = true;
    } else {
        this.upperLimit = upper;
        this.upperLimitEnabled = false;
    }
};


},{"../equations/ContactEquation":22,"../equations/Equation":23,"../equations/RotationalLockEquation":25,"../math/vec2":31,"./Constraint":15}],20:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   RotationalVelocityEquation = _dereq_('../equations/RotationalVelocityEquation')
,   RotationalLockEquation = _dereq_('../equations/RotationalLockEquation')
,   vec2 = _dereq_('../math/vec2');

module.exports = RevoluteConstraint;

var worldPivotA = vec2.create(),
    worldPivotB = vec2.create(),
    xAxis = vec2.fromValues(1,0),
    yAxis = vec2.fromValues(0,1),
    g = vec2.create();

/**
 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
 * @class RevoluteConstraint
 * @constructor
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.
 * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.
 * @param {Array}   [options.localPivotB] See localPivotA.
 * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.
 * @extends Constraint
 *
 * @example
 *     // This will create a revolute constraint between two bodies with pivot point in between them.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         worldPivot: [0, 0]
 *     });
 *     world.addConstraint(constraint);
 *
 *     // Using body-local pivot points, the constraint could have been constructed like this:
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         localPivotA: [1, 0],
 *         localPivotB: [-1, 0]
 *     });
 */
function RevoluteConstraint(bodyA, bodyB, options){
    options = options || {};
    Constraint.call(this,bodyA,bodyB,Constraint.REVOLUTE,options);

    var maxForce = this.maxForce = typeof(options.maxForce) !== "undefined" ? options.maxForce : Number.MAX_VALUE;

    /**
     * @property {Array} pivotA
     */
    this.pivotA = vec2.create();

    /**
     * @property {Array} pivotB
     */
    this.pivotB = vec2.create();

    if(options.worldPivot){
        // Compute pivotA and pivotB
        vec2.sub(this.pivotA, options.worldPivot, bodyA.position);
        vec2.sub(this.pivotB, options.worldPivot, bodyB.position);
        // Rotate to local coordinate system
        vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);
        vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);
    } else {
        // Get pivotA and pivotB
        vec2.copy(this.pivotA, options.localPivotA);
        vec2.copy(this.pivotB, options.localPivotB);
    }

    // Equations to be fed to the solver
    var eqs = this.equations = [
        new Equation(bodyA,bodyB,-maxForce,maxForce),
        new Equation(bodyA,bodyB,-maxForce,maxForce),
    ];

    var x = eqs[0];
    var y = eqs[1];
    var that = this;

    x.computeGq = function(){
        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
        vec2.add(g, bodyB.position, worldPivotB);
        vec2.sub(g, g, bodyA.position);
        vec2.sub(g, g, worldPivotA);
        return vec2.dot(g,xAxis);
    };

    y.computeGq = function(){
        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
        vec2.add(g, bodyB.position, worldPivotB);
        vec2.sub(g, g, bodyA.position);
        vec2.sub(g, g, worldPivotA);
        return vec2.dot(g,yAxis);
    };

    y.minForce = x.minForce = -maxForce;
    y.maxForce = x.maxForce =  maxForce;

    this.motorEquation = new RotationalVelocityEquation(bodyA,bodyB);

    /**
     * Indicates whether the motor is enabled. Use .enableMotor() to enable the constraint motor.
     * @property {Boolean} motorEnabled
     * @readOnly
     */
    this.motorEnabled = false;

    /**
     * The constraint position.
     * @property angle
     * @type {Number}
     * @readOnly
     */
    this.angle = 0;

    /**
     * Set to true to enable lower limit
     * @property lowerLimitEnabled
     * @type {Boolean}
     */
    this.lowerLimitEnabled = false;

    /**
     * Set to true to enable upper limit
     * @property upperLimitEnabled
     * @type {Boolean}
     */
    this.upperLimitEnabled = false;

    /**
     * The lower limit on the constraint angle.
     * @property lowerLimit
     * @type {Boolean}
     */
    this.lowerLimit = 0;

    /**
     * The upper limit on the constraint angle.
     * @property upperLimit
     * @type {Boolean}
     */
    this.upperLimit = 0;

    this.upperLimitEquation = new RotationalLockEquation(bodyA,bodyB);
    this.lowerLimitEquation = new RotationalLockEquation(bodyA,bodyB);
    this.upperLimitEquation.minForce = 0;
    this.lowerLimitEquation.maxForce = 0;
}
RevoluteConstraint.prototype = new Constraint();
RevoluteConstraint.prototype.constructor = RevoluteConstraint;

/**
 * Set the constraint angle limits.
 * @method setLimits
 * @param {number} lower Lower angle limit.
 * @param {number} upper Upper angle limit.
 */
RevoluteConstraint.prototype.setLimits = function (lower, upper) {
    if(typeof(lower) === 'number'){
        this.lowerLimit = lower;
        this.lowerLimitEnabled = true;
    } else {
        this.lowerLimit = lower;
        this.lowerLimitEnabled = false;
    }

    if(typeof(upper) === 'number'){
        this.upperLimit = upper;
        this.upperLimitEnabled = true;
    } else {
        this.upperLimit = upper;
        this.upperLimitEnabled = false;
    }
};

RevoluteConstraint.prototype.update = function(){
    var bodyA =  this.bodyA,
        bodyB =  this.bodyB,
        pivotA = this.pivotA,
        pivotB = this.pivotB,
        eqs =    this.equations,
        normal = eqs[0],
        tangent= eqs[1],
        x = eqs[0],
        y = eqs[1],
        upperLimit = this.upperLimit,
        lowerLimit = this.lowerLimit,
        upperLimitEquation = this.upperLimitEquation,
        lowerLimitEquation = this.lowerLimitEquation;

    var relAngle = this.angle = bodyB.angle - bodyA.angle;

    if(this.upperLimitEnabled && relAngle > upperLimit){
        upperLimitEquation.angle = upperLimit;
        if(eqs.indexOf(upperLimitEquation) === -1){
            eqs.push(upperLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(upperLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    if(this.lowerLimitEnabled && relAngle < lowerLimit){
        lowerLimitEquation.angle = lowerLimit;
        if(eqs.indexOf(lowerLimitEquation) === -1){
            eqs.push(lowerLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(lowerLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    /*

    The constraint violation is

        g = xj + rj - xi - ri

    ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:

        gdot = vj + wj x rj - vi - wi x ri

    We split this into x and y directions. (let x and y be unit vectors along the respective axes)

        gdot * x = ( vj + wj x rj - vi - wi x ri ) * x
                 = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x
                 = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi
                 = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]
                 = G*W

    ...and similar for y. We have then identified the jacobian entries for x and y directions:

        Gx = [ x   (rj x x)   -x   -(ri x x)]
        Gy = [ y   (rj x y)   -y   -(ri x y)]

     */

    vec2.rotate(worldPivotA, pivotA, bodyA.angle);
    vec2.rotate(worldPivotB, pivotB, bodyB.angle);

    // todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc

    x.G[0] = -1;
    x.G[1] =  0;
    x.G[2] = -vec2.crossLength(worldPivotA,xAxis);
    x.G[3] =  1;
    x.G[4] =  0;
    x.G[5] =  vec2.crossLength(worldPivotB,xAxis);

    y.G[0] =  0;
    y.G[1] = -1;
    y.G[2] = -vec2.crossLength(worldPivotA,yAxis);
    y.G[3] =  0;
    y.G[4] =  1;
    y.G[5] =  vec2.crossLength(worldPivotB,yAxis);
};

/**
 * Enable the rotational motor
 * @method enableMotor
 */
RevoluteConstraint.prototype.enableMotor = function(){
    if(this.motorEnabled){
        return;
    }
    this.equations.push(this.motorEquation);
    this.motorEnabled = true;
};

/**
 * Disable the rotational motor
 * @method disableMotor
 */
RevoluteConstraint.prototype.disableMotor = function(){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations.splice(i,1);
    this.motorEnabled = false;
};

/**
 * Check if the motor is enabled.
 * @method motorIsEnabled
 * @deprecated use property motorEnabled instead.
 * @return {Boolean}
 */
RevoluteConstraint.prototype.motorIsEnabled = function(){
    return !!this.motorEnabled;
};

/**
 * Set the speed of the rotational constraint motor
 * @method setMotorSpeed
 * @param  {Number} speed
 */
RevoluteConstraint.prototype.setMotorSpeed = function(speed){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations[i].relativeVelocity = speed;
};

/**
 * Get the speed of the rotational constraint motor
 * @method getMotorSpeed
 * @return {Number} The current speed, or false if the motor is not enabled.
 */
RevoluteConstraint.prototype.getMotorSpeed = function(){
    if(!this.motorEnabled){
        return false;
    }
    return this.motorEquation.relativeVelocity;
};

},{"../equations/Equation":23,"../equations/RotationalLockEquation":25,"../equations/RotationalVelocityEquation":26,"../math/vec2":31,"./Constraint":15}],21:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = AngleLockEquation;

/**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class AngleLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in body A.
 * @param {Number} [options.ratio] Gear ratio
 */
function AngleLockEquation(bodyA, bodyB, options){
    options = options || {};
    Equation.call(this,bodyA,bodyB,-Number.MAX_VALUE,Number.MAX_VALUE);
    this.angle = options.angle || 0;

    /**
     * The gear ratio.
     * @property {Number} ratio
     * @private
     * @see setRatio
     */
    this.ratio = typeof(options.ratio)==="number" ? options.ratio : 1;

    this.setRatio(this.ratio);
}
AngleLockEquation.prototype = new Equation();
AngleLockEquation.prototype.constructor = AngleLockEquation;

AngleLockEquation.prototype.computeGq = function(){
    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
};

/**
 * Set the gear ratio for this equation
 * @method setRatio
 * @param {Number} ratio
 */
AngleLockEquation.prototype.setRatio = function(ratio){
    var G = this.G;
    G[2] =  ratio;
    G[5] = -1;
    this.ratio = ratio;
};

/**
 * Set the max force for the equation.
 * @method setMaxTorque
 * @param {Number} torque
 */
AngleLockEquation.prototype.setMaxTorque = function(torque){
    this.maxForce =  torque;
    this.minForce = -torque;
};

},{"../math/vec2":31,"./Equation":23}],22:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = ContactEquation;

/**
 * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.
 *
 * @class ContactEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function ContactEquation(bodyA, bodyB){
    Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);

    /**
     * Vector from body i center of mass to the contact point.
     * @property contactPointA
     * @type {Array}
     */
    this.contactPointA = vec2.create();
    this.penetrationVec = vec2.create();

    /**
     * World-oriented vector from body A center of mass to the contact point.
     * @property contactPointB
     * @type {Array}
     */
    this.contactPointB = vec2.create();

    /**
     * The normal vector, pointing out of body i
     * @property normalA
     * @type {Array}
     */
    this.normalA = vec2.create();

    /**
     * The restitution to use (0=no bounciness, 1=max bounciness).
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0;

    /**
     * This property is set to true if this is the first impact between the bodies (not persistant contact).
     * @property firstImpact
     * @type {Boolean}
     * @readOnly
     */
    this.firstImpact = false;

    /**
     * The shape in body i that triggered this contact.
     * @property shapeA
     * @type {Shape}
     */
    this.shapeA = null;

    /**
     * The shape in body j that triggered this contact.
     * @property shapeB
     * @type {Shape}
     */
    this.shapeB = null;
}
ContactEquation.prototype = new Equation();
ContactEquation.prototype.constructor = ContactEquation;
ContactEquation.prototype.computeB = function(a,b,h){
    var bi = this.bodyA,
        bj = this.bodyB,
        ri = this.contactPointA,
        rj = this.contactPointB,
        xi = bi.position,
        xj = bj.position;

    var penetrationVec = this.penetrationVec,
        n = this.normalA,
        G = this.G;

    // Caluclate cross products
    var rixn = vec2.crossLength(ri,n),
        rjxn = vec2.crossLength(rj,n);

    // G = [-n -rixn n rjxn]
    G[0] = -n[0];
    G[1] = -n[1];
    G[2] = -rixn;
    G[3] = n[0];
    G[4] = n[1];
    G[5] = rjxn;

    // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector
    vec2.add(penetrationVec,xj,rj);
    vec2.sub(penetrationVec,penetrationVec,xi);
    vec2.sub(penetrationVec,penetrationVec,ri);

    // Compute iteration
    var GW, Gq;
    if(this.firstImpact && this.restitution !== 0){
        Gq = 0;
        GW = (1/b)*(1+this.restitution) * this.computeGW();
    } else {
        Gq = vec2.dot(n,penetrationVec) + this.offset;
        GW = this.computeGW();
    }

    var GiMf = this.computeGiMf();
    var B = - Gq * a - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":31,"./Equation":23}],23:[function(_dereq_,module,exports){
module.exports = Equation;

var vec2 = _dereq_('../math/vec2'),
    Utils = _dereq_('../utils/Utils'),
    Body = _dereq_('../objects/Body');

/**
 * Base class for constraint equations.
 * @class Equation
 * @constructor
 * @param {Body} bodyA First body participating in the equation
 * @param {Body} bodyB Second body participating in the equation
 * @param {number} minForce Minimum force to apply. Default: -Number.MAX_VALUE
 * @param {number} maxForce Maximum force to apply. Default: Number.MAX_VALUE
 */
function Equation(bodyA, bodyB, minForce, maxForce){

    /**
     * Minimum force to apply when solving.
     * @property minForce
     * @type {Number}
     */
    this.minForce = typeof(minForce)==="undefined" ? -Number.MAX_VALUE : minForce;

    /**
     * Max force to apply when solving.
     * @property maxForce
     * @type {Number}
     */
    this.maxForce = typeof(maxForce)==="undefined" ? Number.MAX_VALUE : maxForce;

    /**
     * First body participating in the constraint
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second body participating in the constraint
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.
     * @property stiffness
     * @type {Number}
     */
    this.stiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.
     * @property relaxation
     * @type {Number}
     */
    this.relaxation = Equation.DEFAULT_RELAXATION;

    /**
     * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).
     * @property G
     * @type {Array}
     */
    this.G = new Utils.ARRAY_TYPE(6);
    for(var i=0; i<6; i++){
        this.G[i]=0;
    }

    this.offset = 0;

    this.a = 0;
    this.b = 0;
    this.epsilon = 0;
    this.timeStep = 1/60;

    /**
     * Indicates if stiffness or relaxation was changed.
     * @property {Boolean} needsUpdate
     */
    this.needsUpdate = true;

    /**
     * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.
     * @property multiplier
     * @type {Number}
     */
    this.multiplier = 0;

    /**
     * Relative velocity.
     * @property {Number} relativeVelocity
     */
    this.relativeVelocity = 0;

    /**
     * Whether this equation is enabled or not. If true, it will be added to the solver.
     * @property {Boolean} enabled
     */
    this.enabled = true;
}
Equation.prototype.constructor = Equation;

/**
 * The default stiffness when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_STIFFNESS
 * @default 1e6
 */
Equation.DEFAULT_STIFFNESS = 1e6;

/**
 * The default relaxation when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_RELAXATION
 * @default 4
 */
Equation.DEFAULT_RELAXATION = 4;

/**
 * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href="http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf">SPOOK notes</a>.
 * @method update
 */
Equation.prototype.update = function(){
    var k = this.stiffness,
        d = this.relaxation,
        h = this.timeStep;

    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = (4.0 * d) / (1 + 4 * d);
    this.epsilon = 4.0 / (h * h * k * (1 + 4 * d));

    this.needsUpdate = false;
};

/**
 * Multiply a jacobian entry with corresponding positions or velocities
 * @method gmult
 * @return {Number}
 */
Equation.prototype.gmult = function(G,vi,wi,vj,wj){
    return  G[0] * vi[0] +
            G[1] * vi[1] +
            G[2] * wi +
            G[3] * vj[0] +
            G[4] * vj[1] +
            G[5] * wj;
};

/**
 * Computes the RHS of the SPOOK equation
 * @method computeB
 * @return {Number}
 */
Equation.prototype.computeB = function(a,b,h){
    var GW = this.computeGW();
    var Gq = this.computeGq();
    var GiMf = this.computeGiMf();
    return - Gq * a - GW * b - GiMf*h;
};

/**
 * Computes G\*q, where q are the generalized body coordinates
 * @method computeGq
 * @return {Number}
 */
var qi = vec2.create(),
    qj = vec2.create();
Equation.prototype.computeGq = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        xi = bi.position,
        xj = bj.position,
        ai = bi.angle,
        aj = bj.angle;

    return this.gmult(G, qi, ai, qj, aj) + this.offset;
};

/**
 * Computes G\*W, where W are the body velocities
 * @method computeGW
 * @return {Number}
 */
Equation.prototype.computeGW = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        vi = bi.velocity,
        vj = bj.velocity,
        wi = bi.angularVelocity,
        wj = bj.angularVelocity;
    return this.gmult(G,vi,wi,vj,wj) + this.relativeVelocity;
};

/**
 * Computes G\*Wlambda, where W are the body velocities
 * @method computeGWlambda
 * @return {Number}
 */
Equation.prototype.computeGWlambda = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        vi = bi.vlambda,
        vj = bj.vlambda,
        wi = bi.wlambda,
        wj = bj.wlambda;
    return this.gmult(G,vi,wi,vj,wj);
};

/**
 * Computes G\*inv(M)\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
 * @method computeGiMf
 * @return {Number}
 */
var iMfi = vec2.create(),
    iMfj = vec2.create();
Equation.prototype.computeGiMf = function(){
    var bi = this.bodyA,
        bj = this.bodyB,
        fi = bi.force,
        ti = bi.angularForce,
        fj = bj.force,
        tj = bj.angularForce,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        G = this.G;

    vec2.scale(iMfi, fi,invMassi);
    vec2.scale(iMfj, fj,invMassj);

    return this.gmult(G,iMfi,ti*invIi,iMfj,tj*invIj);
};

/**
 * Computes G\*inv(M)\*G'
 * @method computeGiMGt
 * @return {Number}
 */
Equation.prototype.computeGiMGt = function(){
    var bi = this.bodyA,
        bj = this.bodyB,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        G = this.G;

    return  G[0] * G[0] * invMassi +
            G[1] * G[1] * invMassi +
            G[2] * G[2] *    invIi +
            G[3] * G[3] * invMassj +
            G[4] * G[4] * invMassj +
            G[5] * G[5] *    invIj;
};

var addToWlambda_temp = vec2.create(),
    addToWlambda_Gi = vec2.create(),
    addToWlambda_Gj = vec2.create(),
    addToWlambda_ri = vec2.create(),
    addToWlambda_rj = vec2.create(),
    addToWlambda_Mdiag = vec2.create();

/**
 * Add constraint velocity to the bodies.
 * @method addToWlambda
 * @param {Number} deltalambda
 */
Equation.prototype.addToWlambda = function(deltalambda){
    var bi = this.bodyA,
        bj = this.bodyB,
        temp = addToWlambda_temp,
        Gi = addToWlambda_Gi,
        Gj = addToWlambda_Gj,
        ri = addToWlambda_ri,
        rj = addToWlambda_rj,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        Mdiag = addToWlambda_Mdiag,
        G = this.G;

    Gi[0] = G[0];
    Gi[1] = G[1];
    Gj[0] = G[3];
    Gj[1] = G[4];

    // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G
    vec2.scale(temp, Gi, invMassi*deltalambda);
    vec2.add( bi.vlambda, bi.vlambda, temp);
    // This impulse is in the offset frame
    // Also add contribution to angular
    //bi.wlambda -= vec2.crossLength(temp,ri);
    bi.wlambda += invIi * G[2] * deltalambda;


    vec2.scale(temp, Gj, invMassj*deltalambda);
    vec2.add( bj.vlambda, bj.vlambda, temp);
    //bj.wlambda -= vec2.crossLength(temp,rj);
    bj.wlambda += invIj * G[5] * deltalambda;
};

/**
 * Compute the denominator part of the SPOOK equation: C = G\*inv(M)\*G' + eps
 * @method computeInvC
 * @param  {Number} eps
 * @return {Number}
 */
Equation.prototype.computeInvC = function(eps){
    return 1.0 / (this.computeGiMGt() + eps);
};

},{"../math/vec2":31,"../objects/Body":32,"../utils/Utils":50}],24:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Equation = _dereq_('./Equation')
,   Utils = _dereq_('../utils/Utils');

module.exports = FrictionEquation;

/**
 * Constrains the slipping in a contact along a tangent
 *
 * @class FrictionEquation
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} slipForce
 * @extends Equation
 */
function FrictionEquation(bodyA, bodyB, slipForce){
    Equation.call(this, bodyA, bodyB, -slipForce, slipForce);

    /**
     * Relative vector from center of body A to the contact point, world oriented.
     * @property contactPointA
     * @type {Array}
     */
    this.contactPointA = vec2.create();

    /**
     * Relative vector from center of body B to the contact point, world oriented.
     * @property contactPointB
     * @type {Array}
     */
    this.contactPointB = vec2.create();

    /**
     * Tangent vector that the friction force will act along. World oriented.
     * @property t
     * @type {Array}
     */
    this.t = vec2.create();

    /**
     * A ContactEquation connected to this friction. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.
     * @property contactEquations
     * @type {ContactEquation}
     */
    this.contactEquations = [];

    /**
     * The shape in body i that triggered this friction.
     * @property shapeA
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeA...
     */
    this.shapeA = null;

    /**
     * The shape in body j that triggered this friction.
     * @property shapeB
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeB...
     */
    this.shapeB = null;

    /**
     * The friction coefficient to use.
     * @property frictionCoefficient
     * @type {Number}
     */
    this.frictionCoefficient = 0.3;
}
FrictionEquation.prototype = new Equation();
FrictionEquation.prototype.constructor = FrictionEquation;

/**
 * Set the slipping condition for the constraint. The friction force cannot be
 * larger than this value.
 * @method setSlipForce
 * @param  {Number} slipForce
 */
FrictionEquation.prototype.setSlipForce = function(slipForce){
    this.maxForce = slipForce;
    this.minForce = -slipForce;
};

/**
 * Get the max force for the constraint.
 * @method getSlipForce
 * @return {Number}
 */
FrictionEquation.prototype.getSlipForce = function(){
    return this.maxForce;
};

FrictionEquation.prototype.computeB = function(a,b,h){
    var bi = this.bodyA,
        bj = this.bodyB,
        ri = this.contactPointA,
        rj = this.contactPointB,
        t = this.t,
        G = this.G;

    // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!
    G[0] = -t[0];
    G[1] = -t[1];
    G[2] = -vec2.crossLength(ri,t);
    G[3] = t[0];
    G[4] = t[1];
    G[5] = vec2.crossLength(rj,t);

    var GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = /* - g * a  */ - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":31,"../utils/Utils":50,"./Equation":23}],25:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = RotationalLockEquation;

/**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class RotationalLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in bodyA.
 */
function RotationalLockEquation(bodyA, bodyB, options){
    options = options || {};
    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);

    /**
     * @property {number} angle
     */
    this.angle = options.angle || 0;

    var G = this.G;
    G[2] =  1;
    G[5] = -1;
}
RotationalLockEquation.prototype = new Equation();
RotationalLockEquation.prototype.constructor = RotationalLockEquation;

var worldVectorA = vec2.create(),
    worldVectorB = vec2.create(),
    xAxis = vec2.fromValues(1,0),
    yAxis = vec2.fromValues(0,1);
RotationalLockEquation.prototype.computeGq = function(){
    vec2.rotate(worldVectorA,xAxis,this.bodyA.angle+this.angle);
    vec2.rotate(worldVectorB,yAxis,this.bodyB.angle);
    return vec2.dot(worldVectorA,worldVectorB);
};

},{"../math/vec2":31,"./Equation":23}],26:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = RotationalVelocityEquation;

/**
 * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).
 *
 * @class RotationalVelocityEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function RotationalVelocityEquation(bodyA, bodyB){
    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
    this.relativeVelocity = 1;
    this.ratio = 1;
}
RotationalVelocityEquation.prototype = new Equation();
RotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;
RotationalVelocityEquation.prototype.computeB = function(a,b,h){
    var G = this.G;
    G[2] = -1;
    G[5] = this.ratio;

    var GiMf = this.computeGiMf();
    var GW = this.computeGW();
    var B = - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":31,"./Equation":23}],27:[function(_dereq_,module,exports){
/**
 * Base class for objects that dispatches events.
 * @class EventEmitter
 * @constructor
 */
var EventEmitter = function () {};

module.exports = EventEmitter;

EventEmitter.prototype = {
    constructor: EventEmitter,

    /**
     * Add an event listener
     * @method on
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */
    on: function ( type, listener, context ) {
        listener.context = context || this;
        if ( this._listeners === undefined ){
            this._listeners = {};
        }
        var listeners = this._listeners;
        if ( listeners[ type ] === undefined ) {
            listeners[ type ] = [];
        }
        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
            listeners[ type ].push( listener );
        }
        return this;
    },

    /**
     * Check if an event listener is added
     * @method has
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    has: function ( type, listener ) {
        if ( this._listeners === undefined ){
            return false;
        }
        var listeners = this._listeners;
        if(listener){
            if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
                return true;
            }
        } else {
            if ( listeners[ type ] !== undefined ) {
                return true;
            }
        }

        return false;
    },

    /**
     * Remove an event listener
     * @method off
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */
    off: function ( type, listener ) {
        if ( this._listeners === undefined ){
            return this;
        }
        var listeners = this._listeners;
        var index = listeners[ type ].indexOf( listener );
        if ( index !== - 1 ) {
            listeners[ type ].splice( index, 1 );
        }
        return this;
    },

    /**
     * Emit an event.
     * @method emit
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventEmitter} The self object, for chainability.
     */
    emit: function ( event ) {
        if ( this._listeners === undefined ){
            return this;
        }
        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];
        if ( listenerArray !== undefined ) {
            event.target = this;
            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
                var listener = listenerArray[ i ];
                listener.call( listener.context, event );
            }
        }
        return this;
    }
};

},{}],28:[function(_dereq_,module,exports){
var Material = _dereq_('./Material');
var Equation = _dereq_('../equations/Equation');

module.exports = ContactMaterial;

/**
 * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters.
 * @class ContactMaterial
 * @constructor
 * @param {Material} materialA
 * @param {Material} materialB
 * @param {Object}   [options]
 * @param {Number}   [options.friction=0.3]       Friction coefficient.
 * @param {Number}   [options.restitution=0]      Restitution coefficient aka "bounciness".
 * @param {Number}   [options.stiffness]          ContactEquation stiffness.
 * @param {Number}   [options.relaxation]         ContactEquation relaxation.
 * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.
 * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.
 * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.
 * @author schteppe
 */
function ContactMaterial(materialA, materialB, options){
    options = options || {};

    if(!(materialA instanceof Material) || !(materialB instanceof Material)){
        throw new Error("First two arguments must be Material instances.");
    }

    /**
     * The contact material identifier
     * @property id
     * @type {Number}
     */
    this.id = ContactMaterial.idCounter++;

    /**
     * First material participating in the contact material
     * @property materialA
     * @type {Material}
     */
    this.materialA = materialA;

    /**
     * Second material participating in the contact material
     * @property materialB
     * @type {Material}
     */
    this.materialB = materialB;

    /**
     * Friction to use in the contact of these two materials
     * @property friction
     * @type {Number}
     */
    this.friction    =  typeof(options.friction)    !== "undefined" ?   Number(options.friction)    : 0.3;

    /**
     * Restitution to use in the contact of these two materials
     * @property restitution
     * @type {Number}
     */
    this.restitution =  typeof(options.restitution) !== "undefined" ?   Number(options.restitution) : 0.0;

    /**
     * Stiffness of the resulting ContactEquation that this ContactMaterial generate
     * @property stiffness
     * @type {Number}
     */
    this.stiffness =            typeof(options.stiffness)           !== "undefined" ?   Number(options.stiffness)   : Equation.DEFAULT_STIFFNESS;

    /**
     * Relaxation of the resulting ContactEquation that this ContactMaterial generate
     * @property relaxation
     * @type {Number}
     */
    this.relaxation =           typeof(options.relaxation)          !== "undefined" ?   Number(options.relaxation)  : Equation.DEFAULT_RELAXATION;

    /**
     * Stiffness of the resulting FrictionEquation that this ContactMaterial generate
     * @property frictionStiffness
     * @type {Number}
     */
    this.frictionStiffness =    typeof(options.frictionStiffness)   !== "undefined" ?   Number(options.frictionStiffness)   : Equation.DEFAULT_STIFFNESS;

    /**
     * Relaxation of the resulting FrictionEquation that this ContactMaterial generate
     * @property frictionRelaxation
     * @type {Number}
     */
    this.frictionRelaxation =   typeof(options.frictionRelaxation)  !== "undefined" ?   Number(options.frictionRelaxation)  : Equation.DEFAULT_RELAXATION;

    /**
     * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.
     * @property {Number} surfaceVelocity
     */
    this.surfaceVelocity = typeof(options.surfaceVelocity)    !== "undefined" ?   Number(options.surfaceVelocity)    : 0;

    /**
     * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka "cure for nervous contacts".
     * @property contactSkinSize
     * @type {Number}
     */
    this.contactSkinSize = 0.005;
}

ContactMaterial.idCounter = 0;

},{"../equations/Equation":23,"./Material":29}],29:[function(_dereq_,module,exports){
module.exports = Material;

/**
 * Defines a physics material.
 * @class Material
 * @constructor
 * @param {number} id Material identifier
 * @author schteppe
 */
function Material(id){
    /**
     * The material identifier
     * @property id
     * @type {Number}
     */
    this.id = id || Material.idCounter++;
}

Material.idCounter = 0;

},{}],30:[function(_dereq_,module,exports){

    /*
        PolyK library
        url: http://polyk.ivank.net
        Released under MIT licence.

        Copyright (c) 2012 Ivan Kuckir

        Permission is hereby granted, free of charge, to any person
        obtaining a copy of this software and associated documentation
        files (the "Software"), to deal in the Software without
        restriction, including without limitation the rights to use,
        copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the
        Software is furnished to do so, subject to the following
        conditions:

        The above copyright notice and this permission notice shall be
        included in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
        OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
        OTHER DEALINGS IN THE SOFTWARE.
    */

    var PolyK = {};

    /*
        Is Polygon self-intersecting?

        O(n^2)
    */
    /*
    PolyK.IsSimple = function(p)
    {
        var n = p.length>>1;
        if(n<4) return true;
        var a1 = new PolyK._P(), a2 = new PolyK._P();
        var b1 = new PolyK._P(), b2 = new PolyK._P();
        var c = new PolyK._P();

        for(var i=0; i<n; i++)
        {
            a1.x = p[2*i  ];
            a1.y = p[2*i+1];
            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }
            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }

            for(var j=0; j<n; j++)
            {
                if(Math.abs(i-j) < 2) continue;
                if(j==n-1 && i==0) continue;
                if(i==n-1 && j==0) continue;

                b1.x = p[2*j  ];
                b1.y = p[2*j+1];
                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }
                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }

                if(PolyK._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;
            }
        }
        return true;
    }

    PolyK.IsConvex = function(p)
    {
        if(p.length<6) return true;
        var l = p.length - 4;
        for(var i=0; i<l; i+=2)
            if(!PolyK._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;
        if(!PolyK._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;
        if(!PolyK._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;
        return true;
    }
    */
    PolyK.GetArea = function(p)
    {
        if(p.length <6) return 0;
        var l = p.length - 2;
        var sum = 0;
        for(var i=0; i<l; i+=2)
            sum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);
        sum += (p[0]-p[l]) * (p[l+1]+p[1]);
        return - sum * 0.5;
    }
    /*
    PolyK.GetAABB = function(p)
    {
        var minx = Infinity;
        var miny = Infinity;
        var maxx = -minx;
        var maxy = -miny;
        for(var i=0; i<p.length; i+=2)
        {
            minx = Math.min(minx, p[i  ]);
            maxx = Math.max(maxx, p[i  ]);
            miny = Math.min(miny, p[i+1]);
            maxy = Math.max(maxy, p[i+1]);
        }
        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};
    }
    */

    PolyK.Triangulate = function(p)
    {
        var n = p.length>>1;
        if(n<3) return [];
        var tgs = [];
        var avl = [];
        for(var i=0; i<n; i++) avl.push(i);

        var i = 0;
        var al = n;
        while(al > 3)
        {
            var i0 = avl[(i+0)%al];
            var i1 = avl[(i+1)%al];
            var i2 = avl[(i+2)%al];

            var ax = p[2*i0],  ay = p[2*i0+1];
            var bx = p[2*i1],  by = p[2*i1+1];
            var cx = p[2*i2],  cy = p[2*i2+1];

            var earFound = false;
            if(PolyK._convex(ax, ay, bx, by, cx, cy))
            {
                earFound = true;
                for(var j=0; j<al; j++)
                {
                    var vi = avl[j];
                    if(vi==i0 || vi==i1 || vi==i2) continue;
                    if(PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}
                }
            }
            if(earFound)
            {
                tgs.push(i0, i1, i2);
                avl.splice((i+1)%al, 1);
                al--;
                i= 0;
            }
            else if(i++ > 3*al) break;      // no convex angles :(
        }
        tgs.push(avl[0], avl[1], avl[2]);
        return tgs;
    }
    /*
    PolyK.ContainsPoint = function(p, px, py)
    {
        var n = p.length>>1;
        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;
        var depth = 0;
        for(var i=0; i<n; i++)
        {
            ax = bx;  ay = by;
            bx = p[2*i  ] - px;
            by = p[2*i+1] - py;
            if(ay< 0 && by< 0) continue;    // both "up" or both "donw"
            if(ay>=0 && by>=0) continue;    // both "up" or both "donw"
            if(ax< 0 && bx< 0) continue;

            var lx = ax + (bx-ax)*(-ay)/(by-ay);
            if(lx>0) depth++;
        }
        return (depth & 1) == 1;
    }

    PolyK.Slice = function(p, ax, ay, bx, by)
    {
        if(PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by)) return [p.slice(0)];

        var a = new PolyK._P(ax, ay);
        var b = new PolyK._P(bx, by);
        var iscs = [];  // intersections
        var ps = [];    // points
        for(var i=0; i<p.length; i+=2) ps.push(new PolyK._P(p[i], p[i+1]));

        for(var i=0; i<ps.length; i++)
        {
            var isc = new PolyK._P(0,0);
            isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);

            if(isc)
            {
                isc.flag = true;
                iscs.push(isc);
                ps.splice(i+1,0,isc);
                i++;
            }
        }
        if(iscs.length == 0) return [p.slice(0)];
        var comp = function(u,v) {return PolyK._P.dist(a,u) - PolyK._P.dist(a,v); }
        iscs.sort(comp);

        var pgs = [];
        var dir = 0;
        while(iscs.length > 0)
        {
            var n = ps.length;
            var i0 = iscs[0];
            var i1 = iscs[1];
            var ind0 = ps.indexOf(i0);
            var ind1 = ps.indexOf(i1);
            var solved = false;

            if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            else
            {
                i0 = iscs[1];
                i1 = iscs[0];
                ind0 = ps.indexOf(i0);
                ind1 = ps.indexOf(i1);
                if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            }
            if(solved)
            {
                dir--;
                var pgn = PolyK._getPoints(ps, ind0, ind1);
                pgs.push(pgn);
                ps = PolyK._getPoints(ps, ind1, ind0);
                i0.flag = i1.flag = false;
                iscs.splice(0,2);
                if(iscs.length == 0) pgs.push(ps);
            }
            else { dir++; iscs.reverse(); }
            if(dir>1) break;
        }
        var result = [];
        for(var i=0; i<pgs.length; i++)
        {
            var pg = pgs[i];
            var npg = [];
            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);
            result.push(npg);
        }
        return result;
    }

    PolyK.Raycast = function(p, x, y, dx, dy, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0], a2 = tp[1],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;
        a2.x = x+dx; a2.y = y+dy;

        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
            if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
        if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);

        return (isc.dist != Infinity) ? isc : null;
    }

    PolyK.ClosestEdge = function(p, x, y, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;

        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            PolyK._pointLineDist(a1, b1, b2, i>>1, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        PolyK._pointLineDist(a1, b1, b2, l>>1, isc);

        var idst = 1/isc.dist;
        isc.norm.x = (x-isc.point.x)*idst;
        isc.norm.y = (y-isc.point.y)*idst;
        return isc;
    }

    PolyK._pointLineDist = function(p, a, b, edge, isc)
    {
        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;

        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;

        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var param = dot / len_sq;

        var xx, yy;

        if (param < 0 || (x1 == x2 && y1 == y2)) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        var dx = x - xx;
        var dy = y - yy;
        var dst = Math.sqrt(dx * dx + dy * dy);
        if(dst<isc.dist)
        {
            isc.dist = dst;
            isc.edge = edge;
            isc.point.x = xx;
            isc.point.y = yy;
        }
    }

    PolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)
    {
        var nrl = PolyK._P.dist(a1, c);
        if(nrl<isc.dist)
        {
            var ibl = 1/PolyK._P.dist(b1, b2);
            var nx = -(b2.y-b1.y)*ibl;
            var ny =  (b2.x-b1.x)*ibl;
            var ddot = 2*(dx*nx+dy*ny);
            isc.dist = nrl;
            isc.norm.x = nx;
            isc.norm.y = ny;
            isc.refl.x = -ddot*nx+dx;
            isc.refl.y = -ddot*ny+dy;
            isc.edge = edge;
        }
    }

    PolyK._getPoints = function(ps, ind0, ind1)
    {
        var n = ps.length;
        var nps = [];
        if(ind1<ind0) ind1 += n;
        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);
        return nps;
    }

    PolyK._firstWithFlag = function(ps, ind)
    {
        var n = ps.length;
        while(true)
        {
            ind = (ind+1)%n;
            if(ps[ind].flag) return ind;
        }
    }
    */
    PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)
    {
        var v0x = cx-ax;
        var v0y = cy-ay;
        var v1x = bx-ax;
        var v1y = by-ay;
        var v2x = px-ax;
        var v2y = py-ay;

        var dot00 = v0x*v0x+v0y*v0y;
        var dot01 = v0x*v1x+v0y*v1y;
        var dot02 = v0x*v2x+v0y*v2y;
        var dot11 = v1x*v1x+v1y*v1y;
        var dot12 = v1x*v2x+v1y*v2y;

        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

        // Check if point is in triangle
        return (u >= 0) && (v >= 0) && (u + v < 1);
    }
    /*
    PolyK._RayLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        var iDen = 1/Den;
        I.x = ( A*dbx - dax*B ) * iDen;
        I.y = ( A*dby - day*B ) * iDen;

        if(!PolyK._InRect(I, b1, b2)) return null;
        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;
        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;
        return I;
    }

    PolyK._GetLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        I.x = ( A*dbx - dax*B ) / Den;
        I.y = ( A*dby - day*B ) / Den;

        if(PolyK._InRect(I, a1, a2) && PolyK._InRect(I, b1, b2)) return I;
        return null;
    }

    PolyK._InRect = function(a, b, c)
    {
        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));
        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));

        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)
        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))
        return true;
        return false;
    }
    */
    PolyK._convex = function(ax, ay, bx, by, cx, cy)
    {
        return (ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0;
    }
    /*
    PolyK._P = function(x,y)
    {
        this.x = x;
        this.y = y;
        this.flag = false;
    }
    PolyK._P.prototype.toString = function()
    {
        return "Point ["+this.x+", "+this.y+"]";
    }
    PolyK._P.dist = function(a,b)
    {
        var dx = b.x-a.x;
        var dy = b.y-a.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    PolyK._tp = [];
    for(var i=0; i<10; i++) PolyK._tp.push(new PolyK._P(0,0));
        */

module.exports = PolyK;

},{}],31:[function(_dereq_,module,exports){
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.
 * @class vec2
 */

var vec2 = module.exports = {};

var Utils = _dereq_('../utils/Utils');

/**
 * Make a cross product and only return the z component
 * @method crossLength
 * @static
 * @param  {Array} a
 * @param  {Array} b
 * @return {Number}
 */
vec2.crossLength = function(a,b){
    return a[0] * b[1] - a[1] * b[0];
};

/**
 * Cross product between a vector and the Z component of a vector
 * @method crossVZ
 * @static
 * @param  {Array} out
 * @param  {Array} vec
 * @param  {Number} zcomp
 * @return {Number}
 */
vec2.crossVZ = function(out, vec, zcomp){
    vec2.rotate(out,vec,-Math.PI/2);// Rotate according to the right hand rule
    vec2.scale(out,out,zcomp);      // Scale with z
    return out;
};

/**
 * Cross product between a vector and the Z component of a vector
 * @method crossZV
 * @static
 * @param  {Array} out
 * @param  {Number} zcomp
 * @param  {Array} vec
 * @return {Number}
 */
vec2.crossZV = function(out, zcomp, vec){
    vec2.rotate(out,vec,Math.PI/2); // Rotate according to the right hand rule
    vec2.scale(out,out,zcomp);      // Scale with z
    return out;
};

/**
 * Rotate a vector by an angle
 * @method rotate
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */
vec2.rotate = function(out,a,angle){
    if(angle !== 0){
        var c = Math.cos(angle),
            s = Math.sin(angle),
            x = a[0],
            y = a[1];
        out[0] = c*x -s*y;
        out[1] = s*x +c*y;
    } else {
        out[0] = a[0];
        out[1] = a[1];
    }
};

/**
 * Rotate a vector 90 degrees clockwise
 * @method rotate90cw
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */
vec2.rotate90cw = function(out, a) {
    var x = a[0];
    var y = a[1];
    out[0] = y;
    out[1] = -x;
};

/**
 * Transform a point position to local frame.
 * @method toLocalFrame
 * @param  {Array} out
 * @param  {Array} worldPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */
vec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle){
    vec2.copy(out, worldPoint);
    vec2.sub(out, out, framePosition);
    vec2.rotate(out, out, -frameAngle);
};

/**
 * Transform a point position to global frame.
 * @method toGlobalFrame
 * @param  {Array} out
 * @param  {Array} localPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */
vec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle){
    vec2.copy(out, localPoint);
    vec2.rotate(out, out, frameAngle);
    vec2.add(out, out, framePosition);
};

/**
 * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php
 * @method centroid
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return  {Array} The out object
 */
vec2.centroid = function(out, a, b, c){
    vec2.add(out, a, b);
    vec2.add(out, out, c);
    vec2.scale(out, out, 1/3);
    return out;
};

/**
 * Creates a new, empty vec2
 * @static
 * @method create
 * @return {Array} a new 2D vector
 */
vec2.create = function() {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 * @static
 * @method clone
 * @param {Array} a vector to clone
 * @return {Array} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 * @static
 * @method fromValues
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 * @static
 * @method copy
 * @param {Array} out the receiving vector
 * @param {Array} a the source vector
 * @return {Array} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 * @static
 * @method set
 * @param {Array} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 * @static
 * @method add
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts two vec2's
 * @static
 * @method subtract
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for vec2.subtract
 * @static
 * @method sub
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 * @static
 * @method multiply
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for vec2.multiply
 * @static
 * @method mul
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 * @static
 * @method divide
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for vec2.divide
 * @static
 * @method div
 */
vec2.div = vec2.divide;

/**
 * Scales a vec2 by a scalar number
 * @static
 * @method scale
 * @param {Array} out the receiving vector
 * @param {Array} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @return {Array} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 * @static
 * @method distance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for vec2.distance
 * @static
 * @method dist
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 * @static
 * @method squaredDistance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for vec2.squaredDistance
 * @static
 * @method sqrDist
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 * @static
 * @method length
 * @param {Array} a vector to calculate length of
 * @return {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for vec2.length
 * @method len
 * @static
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 * @static
 * @method squaredLength
 * @param {Array} a vector to calculate squared length of
 * @return {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for vec2.squaredLength
 * @static
 * @method sqrLen
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 * @static
 * @method negate
 * @param {Array} out the receiving vector
 * @param {Array} a vector to negate
 * @return {Array} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 * @static
 * @method normalize
 * @param {Array} out the receiving vector
 * @param {Array} a vector to normalize
 * @return {Array} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 * @static
 * @method dot
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Returns a string representation of a vector
 * @static
 * @method str
 * @param {Array} vec vector to represent as a string
 * @return {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

},{"../utils/Utils":50}],32:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   decomp = _dereq_('poly-decomp')
,   Convex = _dereq_('../shapes/Convex')
,   AABB = _dereq_('../collision/AABB')
,   EventEmitter = _dereq_('../events/EventEmitter');

module.exports = Body;

/**
 * A rigid body. Has got a center of mass, position, velocity and a number of
 * shapes that are used for collisions.
 *
 * @class Body
 * @constructor
 * @extends EventEmitter
 * @param {Object}              [options]
 * @param {Number}              [options.mass=0]    A number >= 0. If zero, the .type will be set to Body.STATIC.
 * @param {Array}               [options.position]
 * @param {Array}               [options.velocity]
 * @param {Number}              [options.angle=0]
 * @param {Number}              [options.angularVelocity=0]
 * @param {Array}               [options.force]
 * @param {Number}              [options.angularForce=0]
 * @param {Number}              [options.fixedRotation=false]
 * @param {Number}              [options.ccdSpeedThreshold=-1]
 * @param {Number}              [options.ccdIterations=10]
 *
 * @example
 *
 *     // Create a typical dynamic body
 *     var body = new Body({
 *         mass: 1,
 *         position: [0, 0],
 *         angle: 0,
 *         velocity: [0, 0],
 *         angularVelocity: 0
 *     });
 *
 *     // Add a circular shape to the body
 *     body.addShape(new Circle(1));
 *
 *     // Add the body to the world
 *     world.addBody(body);
 */
function Body(options){
    options = options || {};

    EventEmitter.call(this);

    /**
     * The body identifyer
     * @property id
     * @type {Number}
     */
    this.id = ++Body._idCounter;

    /**
     * The world that this body is added to. This property is set to NULL if the body is not added to any world.
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * The shapes of the body. The local transform of the shape in .shapes[i] is
     * defined by .shapeOffsets[i] and .shapeAngles[i].
     *
     * @property shapes
     * @type {Array}
     */
    this.shapes = [];

    /**
     * The local shape offsets, relative to the body center of mass. This is an
     * array of Array.
     * @property shapeOffsets
     * @type {Array}
     */
    this.shapeOffsets = [];

    /**
     * The body-local shape angle transforms. This is an array of numbers (angles).
     * @property shapeAngles
     * @type {Array}
     */
    this.shapeAngles = [];

    /**
     * The mass of the body.
     * @property mass
     * @type {number}
     */
    this.mass = options.mass || 0;

    /**
     * The inverse mass of the body.
     * @property invMass
     * @type {number}
     */
    this.invMass = 0;

    /**
     * The inertia of the body around the Z axis.
     * @property inertia
     * @type {number}
     */
    this.inertia = 0;

    /**
     * The inverse inertia of the body.
     * @property invInertia
     * @type {number}
     */
    this.invInertia = 0;

    this.invMassSolve = 0;
    this.invInertiaSolve = 0;

    /**
     * Set to true if you want to fix the rotation of the body.
     * @property fixedRotation
     * @type {Boolean}
     */
    this.fixedRotation = !!options.fixedRotation;

    /**
     * The position of the body
     * @property position
     * @type {Array}
     */
    this.position = vec2.fromValues(0,0);
    if(options.position){
        vec2.copy(this.position, options.position);
    }

    /**
     * The interpolated position of the body.
     * @property interpolatedPosition
     * @type {Array}
     */
    this.interpolatedPosition = vec2.fromValues(0,0);

    /**
     * The interpolated angle of the body.
     * @property interpolatedAngle
     * @type {Number}
     */
    this.interpolatedAngle = 0;

    /**
     * The previous position of the body.
     * @property previousPosition
     * @type {Array}
     */
    this.previousPosition = vec2.fromValues(0,0);

    /**
     * The previous angle of the body.
     * @property previousAngle
     * @type {Number}
     */
    this.previousAngle = 0;

    /**
     * The velocity of the body
     * @property velocity
     * @type {Array}
     */
    this.velocity = vec2.fromValues(0,0);
    if(options.velocity){
        vec2.copy(this.velocity, options.velocity);
    }

    /**
     * Constraint velocity that was added to the body during the last step.
     * @property vlambda
     * @type {Array}
     */
    this.vlambda = vec2.fromValues(0,0);

    /**
     * Angular constraint velocity that was added to the body during last step.
     * @property wlambda
     * @type {Array}
     */
    this.wlambda = 0;

    /**
     * The angle of the body, in radians.
     * @property angle
     * @type {number}
     * @example
     *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.
     *     // If you need a value between 0 and 2*pi, use the following function to normalize it.
     *     function normalizeAngle(angle){
     *         angle = angle % (2*Math.PI);
     *         if(angle < 0){
     *             angle += (2*Math.PI);
     *         }
     *         return angle;
     *     }
     */
    this.angle = options.angle || 0;

    /**
     * The angular velocity of the body, in radians per second.
     * @property angularVelocity
     * @type {number}
     */
    this.angularVelocity = options.angularVelocity || 0;

    /**
     * The force acting on the body. Since the body force (and {{#crossLink "Body/angularForce:property"}}{{/crossLink}}) will be zeroed after each step, so you need to set the force before each step.
     * @property force
     * @type {Array}
     *
     * @example
     *     // This produces a forcefield of 1 Newton in the positive x direction.
     *     for(var i=0; i<numSteps; i++){
     *         body.force[0] = 1;
     *         world.step(1/60);
     *     }
     *
     * @example
     *     // This will apply a rotational force on the body
     *     for(var i=0; i<numSteps; i++){
     *         body.angularForce = -3;
     *         world.step(1/60);
     *     }
     */
    this.force = vec2.create();
    if(options.force){
        vec2.copy(this.force, options.force);
    }

    /**
     * The angular force acting on the body. See {{#crossLink "Body/force:property"}}{{/crossLink}}.
     * @property angularForce
     * @type {number}
     */
    this.angularForce = options.angularForce || 0;

    /**
     * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.
     * @property damping
     * @type {Number}
     * @default 0.1
     */
    this.damping = typeof(options.damping) === "number" ? options.damping : 0.1;

    /**
     * The angular force acting on the body. Should be a value between 0 and 1.
     * @property angularDamping
     * @type {Number}
     * @default 0.1
     */
    this.angularDamping = typeof(options.angularDamping) === "number" ? options.angularDamping : 0.1;

    /**
     * The type of motion this body has. Should be one of: {{#crossLink "Body/STATIC:property"}}Body.STATIC{{/crossLink}}, {{#crossLink "Body/DYNAMIC:property"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink "Body/KINEMATIC:property"}}Body.KINEMATIC{{/crossLink}}.
     *
     * * Static bodies do not move, and they do not respond to forces or collision.
     * * Dynamic bodies body can move and respond to collisions and forces.
     * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.
     *
     * @property type
     * @type {number}
     *
     * @example
     *     // Bodies are static by default. Static bodies will never move.
     *     var body = new Body();
     *     console.log(body.type == Body.STATIC); // true
     *
     * @example
     *     // By setting the mass of a body to a nonzero number, the body
     *     // will become dynamic and will move and interact with other bodies.
     *     var dynamicBody = new Body({
     *         mass : 1
     *     });
     *     console.log(dynamicBody.type == Body.DYNAMIC); // true
     *
     * @example
     *     // Kinematic bodies will only move if you change their velocity.
     *     var kinematicBody = new Body({
     *         type: Body.KINEMATIC // Type can be set via the options object.
     *     });
     */
    this.type = Body.STATIC;

    if(typeof(options.type) !== 'undefined'){
        this.type = options.type;
    } else if(!options.mass){
        this.type = Body.STATIC;
    } else {
        this.type = Body.DYNAMIC;
    }

    /**
     * Bounding circle radius.
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    /**
     * Bounding box of this body.
     * @property aabb
     * @type {AABB}
     */
    this.aabb = new AABB();

    /**
     * Indicates if the AABB needs update. Update it with {{#crossLink "Body/updateAABB:method"}}.updateAABB(){{/crossLink}}.
     * @property aabbNeedsUpdate
     * @type {Boolean}
     * @see updateAABB
     *
     * @example
     *     // Force update the AABB
     *     body.aabbNeedsUpdate = true;
     *     body.updateAABB();
     *     console.log(body.aabbNeedsUpdate); // false
     */
    this.aabbNeedsUpdate = true;

    /**
     * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink "World"}}{{/crossLink}} before anything will happen.
     * @property allowSleep
     * @type {Boolean}
     * @default true
     */
    this.allowSleep = true;

    this.wantsToSleep = false;

    /**
     * One of {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}}, {{#crossLink "Body/SLEEPY:property"}}Body.SLEEPY{{/crossLink}} and {{#crossLink "Body/SLEEPING:property"}}Body.SLEEPING{{/crossLink}}.
     *
     * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).
     *
     * @property sleepState
     * @type {Number}
     * @default Body.AWAKE
     */
    this.sleepState = Body.AWAKE;

    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @property sleepSpeedLimit
     * @type {Number}
     * @default 0.2
     */
    this.sleepSpeedLimit = 0.2;

    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @property sleepTimeLimit
     * @type {Number}
     * @default 1
     */
    this.sleepTimeLimit = 1;

    /**
     * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.
     * @property {Number} gravityScale
     * @default 1
     */
    this.gravityScale = 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * How long the body has been sleeping.
     * @property {Number} idleTime
     */
    this.idleTime = 0;

    /**
     * The last time when the body went to SLEEPY state.
     * @property {Number} timeLastSleepy
     * @private
     */
    this.timeLastSleepy = 0;

    /**
     * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.
     * @property {number} ccdSpeedThreshold
     * @default -1
     */
    this.ccdSpeedThreshold = options.ccdSpeedThreshold !== undefined ? options.ccdSpeedThreshold : -1;

    /**
     * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.
     * @property {number} ccdIterations
     * @default 10
     */
    this.ccdIterations = options.ccdIterations !== undefined ? options.ccdIterations : 10;

    this.concavePath = null;

    this._wakeUpAfterNarrowphase = false;

    this.updateMassProperties();
}
Body.prototype = new EventEmitter();
Body.prototype.constructor = Body;

Body._idCounter = 0;

Body.prototype.updateSolveMassProperties = function(){
    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
        this.invMassSolve = 0;
        this.invInertiaSolve = 0;
    } else {
        this.invMassSolve = this.invMass;
        this.invInertiaSolve = this.invInertia;
    }
};

/**
 * Set the total density of the body
 * @method setDensity
 */
Body.prototype.setDensity = function(density) {
    var totalArea = this.getArea();
    this.mass = totalArea * density;
    this.updateMassProperties();
};

/**
 * Get the total area of all shapes in the body
 * @method getArea
 * @return {Number}
 */
Body.prototype.getArea = function() {
    var totalArea = 0;
    for(var i=0; i<this.shapes.length; i++){
        totalArea += this.shapes[i].area;
    }
    return totalArea;
};

/**
 * Get the AABB from the body. The AABB is updated if necessary.
 * @method getAABB
 */
Body.prototype.getAABB = function(){
    if(this.aabbNeedsUpdate){
        this.updateAABB();
    }
    return this.aabb;
};

var shapeAABB = new AABB(),
    tmp = vec2.create();

/**
 * Updates the AABB of the Body
 * @method updateAABB
 */
Body.prototype.updateAABB = function() {
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        shapeAngles = this.shapeAngles,
        N = shapes.length,
        offset = tmp,
        bodyAngle = this.angle;

    for(var i=0; i!==N; i++){
        var shape = shapes[i],
            angle = shapeAngles[i] + bodyAngle;

        // Get shape world offset
        vec2.rotate(offset, shapeOffsets[i], bodyAngle);
        vec2.add(offset, offset, this.position);

        // Get shape AABB
        shape.computeAABB(shapeAABB, offset, angle);

        if(i===0){
            this.aabb.copy(shapeAABB);
        } else {
            this.aabb.extend(shapeAABB);
        }
    }

    this.aabbNeedsUpdate = false;
};

/**
 * Update the bounding radius of the body. Should be done if any of the shapes
 * are changed.
 * @method updateBoundingRadius
 */
Body.prototype.updateBoundingRadius = function(){
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        N = shapes.length,
        radius = 0;

    for(var i=0; i!==N; i++){
        var shape = shapes[i],
            offset = vec2.length(shapeOffsets[i]),
            r = shape.boundingRadius;
        if(offset + r > radius){
            radius = offset + r;
        }
    }

    this.boundingRadius = radius;
};

/**
 * Add a shape to the body. You can pass a local transform when adding a shape,
 * so that the shape gets an offset and angle relative to the body center of mass.
 * Will automatically update the mass properties and bounding radius.
 *
 * @method addShape
 * @param  {Shape}              shape
 * @param  {Array} [offset] Local body offset of the shape.
 * @param  {Number}             [angle]  Local body angle.
 *
 * @example
 *     var body = new Body(),
 *         shape = new Circle();
 *
 *     // Add the shape to the body, positioned in the center
 *     body.addShape(shape);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.
 *     body.addShape(shape,[1,0]);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.
 *     body.addShape(shape,[0,1],Math.PI/2);
 */
Body.prototype.addShape = function(shape,offset,angle){
    angle = angle || 0.0;

    // Copy the offset vector
    if(offset){
        offset = vec2.fromValues(offset[0],offset[1]);
    } else {
        offset = vec2.fromValues(0,0);
    }

    this.shapes      .push(shape);
    this.shapeOffsets.push(offset);
    this.shapeAngles .push(angle);
    this.updateMassProperties();
    this.updateBoundingRadius();

    this.aabbNeedsUpdate = true;
};

/**
 * Remove a shape
 * @method removeShape
 * @param  {Shape}  shape
 * @return {Boolean}       True if the shape was found and removed, else false.
 */
Body.prototype.removeShape = function(shape){
    var idx = this.shapes.indexOf(shape);

    if(idx !== -1){
        this.shapes.splice(idx,1);
        this.shapeOffsets.splice(idx,1);
        this.shapeAngles.splice(idx,1);
        this.aabbNeedsUpdate = true;
        return true;
    } else {
        return false;
    }
};

/**
 * Updates .inertia, .invMass, .invInertia for this Body. Should be called when
 * changing the structure or mass of the Body.
 *
 * @method updateMassProperties
 *
 * @example
 *     body.mass += 1;
 *     body.updateMassProperties();
 */
Body.prototype.updateMassProperties = function(){
    if(this.type === Body.STATIC || this.type === Body.KINEMATIC){

        this.mass = Number.MAX_VALUE;
        this.invMass = 0;
        this.inertia = Number.MAX_VALUE;
        this.invInertia = 0;

    } else {

        var shapes = this.shapes,
            N = shapes.length,
            m = this.mass / N,
            I = 0;

        if(!this.fixedRotation){
            for(var i=0; i<N; i++){
                var shape = shapes[i],
                    r2 = vec2.squaredLength(this.shapeOffsets[i]),
                    Icm = shape.computeMomentOfInertia(m);
                I += Icm + m*r2;
            }
            this.inertia = I;
            this.invInertia = I>0 ? 1/I : 0;

        } else {
            this.inertia = Number.MAX_VALUE;
            this.invInertia = 0;
        }

        // Inverse mass properties are easy
        this.invMass = 1/this.mass;// > 0 ? 1/this.mass : 0;
    }
};

var Body_applyForce_r = vec2.create();

/**
 * Apply force to a world point. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce.
 * @method applyForce
 * @param {Array} force The force to add.
 * @param {Array} worldPoint A world point to apply the force on.
 */
Body.prototype.applyForce = function(force,worldPoint){
    // Compute point position relative to the body center
    var r = Body_applyForce_r;
    vec2.sub(r,worldPoint,this.position);

    // Add linear force
    vec2.add(this.force,this.force,force);

    // Compute produced rotational force
    var rotForce = vec2.crossLength(r,force);

    // Add rotational force
    this.angularForce += rotForce;
};

/**
 * Transform a world point to local body frame.
 * @method toLocalFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} worldPoint   The input world vector
 */
Body.prototype.toLocalFrame = function(out, worldPoint){
    vec2.toLocalFrame(out, worldPoint, this.position, this.angle);
};

/**
 * Transform a local point to world frame.
 * @method toWorldFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} localPoint   The input local vector
 */
Body.prototype.toWorldFrame = function(out, localPoint){
    vec2.toGlobalFrame(out, localPoint, this.position, this.angle);
};

/**
 * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.
 * @method fromPolygon
 * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.
 * @param {Object} [options]
 * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
 * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.
 * @param {Boolean|Number} [options.removeCollinearPoints=false] Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
 * @return {Boolean} True on success, else false.
 */
Body.prototype.fromPolygon = function(path,options){
    options = options || {};

    // Remove all shapes
    for(var i=this.shapes.length; i>=0; --i){
        this.removeShape(this.shapes[i]);
    }

    var p = new decomp.Polygon();
    p.vertices = path;

    // Make it counter-clockwise
    p.makeCCW();

    if(typeof(options.removeCollinearPoints) === "number"){
        p.removeCollinearPoints(options.removeCollinearPoints);
    }

    // Check if any line segment intersects the path itself
    if(typeof(options.skipSimpleCheck) === "undefined"){
        if(!p.isSimple()){
            return false;
        }
    }

    // Save this path for later
    this.concavePath = p.vertices.slice(0);
    for(var i=0; i<this.concavePath.length; i++){
        var v = [0,0];
        vec2.copy(v,this.concavePath[i]);
        this.concavePath[i] = v;
    }

    // Slow or fast decomp?
    var convexes;
    if(options.optimalDecomp){
        convexes = p.decomp();
    } else {
        convexes = p.quickDecomp();
    }

    var cm = vec2.create();

    // Add convexes
    for(var i=0; i!==convexes.length; i++){
        // Create convex
        var c = new Convex(convexes[i].vertices);

        // Move all vertices so its center of mass is in the local center of the convex
        for(var j=0; j!==c.vertices.length; j++){
            var v = c.vertices[j];
            vec2.sub(v,v,c.centerOfMass);
        }

        vec2.scale(cm,c.centerOfMass,1);
        c.updateTriangles();
        c.updateCenterOfMass();
        c.updateBoundingRadius();

        // Add the shape
        this.addShape(c,cm);
    }

    this.adjustCenterOfMass();

    this.aabbNeedsUpdate = true;

    return true;
};

var adjustCenterOfMass_tmp1 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp2 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp3 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp4 = vec2.fromValues(0,0);

/**
 * Moves the shape offsets so their center of mass becomes the body center of mass.
 * @method adjustCenterOfMass
 */
Body.prototype.adjustCenterOfMass = function(){
    var offset_times_area = adjustCenterOfMass_tmp2,
        sum =               adjustCenterOfMass_tmp3,
        cm =                adjustCenterOfMass_tmp4,
        totalArea =         0;
    vec2.set(sum,0,0);

    for(var i=0; i!==this.shapes.length; i++){
        var s = this.shapes[i],
            offset = this.shapeOffsets[i];
        vec2.scale(offset_times_area,offset,s.area);
        vec2.add(sum,sum,offset_times_area);
        totalArea += s.area;
    }

    vec2.scale(cm,sum,1/totalArea);

    // Now move all shapes
    for(var i=0; i!==this.shapes.length; i++){
        var s = this.shapes[i],
            offset = this.shapeOffsets[i];

        // Offset may be undefined. Fix that.
        if(!offset){
            offset = this.shapeOffsets[i] = vec2.create();
        }

        vec2.sub(offset,offset,cm);
    }

    // Move the body position too
    vec2.add(this.position,this.position,cm);

    // And concave path
    for(var i=0; this.concavePath && i<this.concavePath.length; i++){
        vec2.sub(this.concavePath[i], this.concavePath[i], cm);
    }

    this.updateMassProperties();
    this.updateBoundingRadius();
};

/**
 * Sets the force on the body to zero.
 * @method setZeroForce
 */
Body.prototype.setZeroForce = function(){
    vec2.set(this.force,0.0,0.0);
    this.angularForce = 0.0;
};

Body.prototype.resetConstraintVelocity = function(){
    var b = this,
        vlambda = b.vlambda;
    vec2.set(vlambda,0,0);
    b.wlambda = 0;
};

Body.prototype.addConstraintVelocity = function(){
    var b = this,
        v = b.velocity;
    vec2.add( v, v, b.vlambda);
    b.angularVelocity += b.wlambda;
};

/**
 * Apply damping, see <a href="http://code.google.com/p/bullet/issues/detail?id=74">this</a> for details.
 * @method applyDamping
 * @param  {number} dt Current time step
 */
Body.prototype.applyDamping = function(dt){
    if(this.type === Body.DYNAMIC){ // Only for dynamic bodies
        var v = this.velocity;
        vec2.scale(v, v, Math.pow(1.0 - this.damping,dt));
        this.angularVelocity *= Math.pow(1.0 - this.angularDamping,dt);
    }
};

/**
 * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.
 * Sets the sleepState to {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.
 * @method wakeUp
 */
Body.prototype.wakeUp = function(){
    var s = this.sleepState;
    this.sleepState = Body.AWAKE;
    this.idleTime = 0;
    if(s !== Body.AWAKE){
        this.emit(Body.wakeUpEvent);
    }
};

/**
 * Force body sleep
 * @method sleep
 */
Body.prototype.sleep = function(){
    this.sleepState = Body.SLEEPING;
    this.angularVelocity = 0;
    this.angularForce = 0;
    vec2.set(this.velocity,0,0);
    vec2.set(this.force,0,0);
    this.emit(Body.sleepEvent);
};

/**
 * Called every timestep to update internal sleep timer and change sleep state if needed.
 * @method sleepTick
 * @param {number} time The world time in seconds
 * @param {boolean} dontSleep
 * @param {number} dt
 */
Body.prototype.sleepTick = function(time, dontSleep, dt){
    if(!this.allowSleep || this.type === Body.SLEEPING){
        return;
    }

    this.wantsToSleep = false;

    var sleepState = this.sleepState,
        speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity,2),
        speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);

    // Add to idle time
    if(speedSquared >= speedLimitSquared){
        this.idleTime = 0;
        this.sleepState = Body.AWAKE;
    } else {
        this.idleTime += dt;
        this.sleepState = Body.SLEEPY;
    }
    if(this.idleTime > this.sleepTimeLimit){
        if(!dontSleep){
            this.sleep();
        } else {
            this.wantsToSleep = true;
        }
    }

    /*
    if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){
        this.sleepState = Body.SLEEPY; // Sleepy
        this.timeLastSleepy = time;
        this.emit(Body.sleepyEvent);
    } else if(sleepState===Body.SLEEPY && speedSquared >= speedLimitSquared){
        this.wakeUp(); // Wake up
    } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){
        this.wantsToSleep = true;
        if(!dontSleep){
            this.sleep();
        }
    }
    */
};

Body.prototype.getVelocityFromPosition = function(store, timeStep){
    store = store || vec2.create();
    vec2.sub(store, this.position, this.previousPosition);
    vec2.scale(store, store, 1/timeStep);
    return store;
};

Body.prototype.getAngularVelocityFromPosition = function(timeStep){
    return (this.angle - this.previousAngle) / timeStep;
};

/**
 * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.
 * @method overlaps
 * @param  {Body} body
 * @return {boolean}
 */
Body.prototype.overlaps = function(body){
    return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
};

var integrate_fhMinv = vec2.create();
var integrate_velodt = vec2.create();

/**
 * Move the body forward in time given its current velocity.
 * @method integrate
 * @param  {Number} dt
 */
Body.prototype.integrate = function(dt){
    var minv = this.invMass,
        f = this.force,
        pos = this.position,
        velo = this.velocity;

    // Save old position
    vec2.copy(this.previousPosition, this.position);
    this.previousAngle = this.angle;

    // Velocity update
    if(!this.fixedRotation){
        this.angularVelocity += this.angularForce * this.invInertia * dt;
    }
    vec2.scale(integrate_fhMinv, f, dt * minv);
    vec2.add(velo, integrate_fhMinv, velo);

    // CCD
    if(!this.integrateToTimeOfImpact(dt)){

        // Regular position update
        vec2.scale(integrate_velodt, velo, dt);
        vec2.add(pos, pos, integrate_velodt);
        if(!this.fixedRotation){
            this.angle += this.angularVelocity * dt;
        }
    }

    this.aabbNeedsUpdate = true;
};

var direction = vec2.create();
var end = vec2.create();
var startToEnd = vec2.create();
var rememberPosition = vec2.create();
Body.prototype.integrateToTimeOfImpact = function(dt){

    if(this.ccdSpeedThreshold < 0 || vec2.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)){
        return false;
    }

    vec2.normalize(direction, this.velocity);

    vec2.scale(end, this.velocity, dt);
    vec2.add(end, end, this.position);

    vec2.sub(startToEnd, end, this.position);
    var startToEndAngle = this.angularVelocity * dt;
    var len = vec2.length(startToEnd);

    var timeOfImpact = 1;

    var hit;
    var that = this;
    this.world.raycastAll(this.position, end, {}, function (result) {
        if(result.body === that){
            return;
        }
        hit = result.body;
        vec2.copy(end, result.hitPointWorld);
        vec2.sub(startToEnd, result.hitPointWorld, that.position);
        timeOfImpact = vec2.length(startToEnd) / len;
        result.abort();
    });

    if(!hit){
        return false;
    }

    var rememberAngle = this.angle;
    vec2.copy(rememberPosition, this.position);

    // Got a start and end point. Approximate time of impact using binary search
    var iter = 0;
    var tmin = 0;
    var tmid = 0;
    var tmax = timeOfImpact;
    while (tmax >= tmin && iter < this.ccdIterations) {
        iter++;

        // calculate the midpoint
        tmid = (tmax - tmin) / 2;

        // Move the body to that point
        vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
        vec2.add(this.position, rememberPosition, integrate_velodt);
        this.angle = rememberAngle + startToEndAngle * timeOfImpact;
        this.updateAABB();

        // check overlap
        var overlaps = this.aabb.overlaps(hit.aabb) && this.world.narrowphase.bodiesOverlap(this, hit);

        if (overlaps) {
            // change min to search upper interval
            tmin = tmid;
        } else {
            // change max to search lower interval
            tmax = tmid;
        }
    }

    timeOfImpact = tmid;

    vec2.copy(this.position, rememberPosition);
    this.angle = rememberAngle;

    // move to TOI
    vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
    vec2.add(this.position, this.position, integrate_velodt);
    if(!this.fixedRotation){
        this.angle += startToEndAngle * timeOfImpact;
    }

    return true;
};

/**
 * @event sleepy
 */
Body.sleepyEvent = {
    type: "sleepy"
};

/**
 * @event sleep
 */
Body.sleepEvent = {
    type: "sleep"
};

/**
 * @event wakeup
 */
Body.wakeUpEvent = {
    type: "wakeup"
};

/**
 * Dynamic body.
 * @property DYNAMIC
 * @type {Number}
 * @static
 */
Body.DYNAMIC = 1;

/**
 * Static body.
 * @property STATIC
 * @type {Number}
 * @static
 */
Body.STATIC = 2;

/**
 * Kinematic body.
 * @property KINEMATIC
 * @type {Number}
 * @static
 */
Body.KINEMATIC = 4;

/**
 * @property AWAKE
 * @type {Number}
 * @static
 */
Body.AWAKE = 0;

/**
 * @property SLEEPY
 * @type {Number}
 * @static
 */
Body.SLEEPY = 1;

/**
 * @property SLEEPING
 * @type {Number}
 * @static
 */
Body.SLEEPING = 2;


},{"../collision/AABB":7,"../events/EventEmitter":27,"../math/vec2":31,"../shapes/Convex":39,"poly-decomp":5}],33:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Spring = _dereq_('./Spring');
var Utils = _dereq_('../utils/Utils');

module.exports = LinearSpring;

/**
 * A spring, connecting two bodies.
 *
 * The Spring explicitly adds force and angularForce to the bodies.
 *
 * @class LinearSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 */
function LinearSpring(bodyA,bodyB,options){
    options = options || {};

    Spring.call(this, bodyA, bodyB, options);

    /**
     * Anchor for bodyA in local bodyA coordinates.
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = vec2.fromValues(0,0);

    /**
     * Anchor for bodyB in local bodyB coordinates.
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = vec2.fromValues(0,0);

    if(options.localAnchorA){ vec2.copy(this.localAnchorA, options.localAnchorA); }
    if(options.localAnchorB){ vec2.copy(this.localAnchorB, options.localAnchorB); }
    if(options.worldAnchorA){ this.setWorldAnchorA(options.worldAnchorA); }
    if(options.worldAnchorB){ this.setWorldAnchorB(options.worldAnchorB); }

    var worldAnchorA = vec2.create();
    var worldAnchorB = vec2.create();
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);
    var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);

    /**
     * Rest length of the spring.
     * @property restLength
     * @type {number}
     */
    this.restLength = typeof(options.restLength) === "number" ? options.restLength : worldDistance;
}
LinearSpring.prototype = new Spring();
LinearSpring.prototype.constructor = LinearSpring;

/**
 * Set the anchor point on body A, using world coordinates.
 * @method setWorldAnchorA
 * @param {Array} worldAnchorA
 */
LinearSpring.prototype.setWorldAnchorA = function(worldAnchorA){
    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
};

/**
 * Set the anchor point on body B, using world coordinates.
 * @method setWorldAnchorB
 * @param {Array} worldAnchorB
 */
LinearSpring.prototype.setWorldAnchorB = function(worldAnchorB){
    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
};

/**
 * Get the anchor point on body A, in world coordinates.
 * @method getWorldAnchorA
 * @param {Array} result The vector to store the result in.
 */
LinearSpring.prototype.getWorldAnchorA = function(result){
    this.bodyA.toWorldFrame(result, this.localAnchorA);
};

/**
 * Get the anchor point on body B, in world coordinates.
 * @method getWorldAnchorB
 * @param {Array} result The vector to store the result in.
 */
LinearSpring.prototype.getWorldAnchorB = function(result){
    this.bodyB.toWorldFrame(result, this.localAnchorB);
};

var applyForce_r =              vec2.create(),
    applyForce_r_unit =         vec2.create(),
    applyForce_u =              vec2.create(),
    applyForce_f =              vec2.create(),
    applyForce_worldAnchorA =   vec2.create(),
    applyForce_worldAnchorB =   vec2.create(),
    applyForce_ri =             vec2.create(),
    applyForce_rj =             vec2.create(),
    applyForce_tmp =            vec2.create();

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
LinearSpring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restLength,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        r = applyForce_r,
        r_unit = applyForce_r_unit,
        u = applyForce_u,
        f = applyForce_f,
        tmp = applyForce_tmp;

    var worldAnchorA = applyForce_worldAnchorA,
        worldAnchorB = applyForce_worldAnchorB,
        ri = applyForce_ri,
        rj = applyForce_rj;

    // Get world anchors
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);

    // Get offset points
    vec2.sub(ri, worldAnchorA, bodyA.position);
    vec2.sub(rj, worldAnchorB, bodyB.position);

    // Compute distance vector between world anchor points
    vec2.sub(r, worldAnchorB, worldAnchorA);
    var rlen = vec2.len(r);
    vec2.normalize(r_unit,r);

    //console.log(rlen)
    //console.log("A",vec2.str(worldAnchorA),"B",vec2.str(worldAnchorB))

    // Compute relative velocity of the anchor points, u
    vec2.sub(u, bodyB.velocity, bodyA.velocity);
    vec2.crossZV(tmp, bodyB.angularVelocity, rj);
    vec2.add(u, u, tmp);
    vec2.crossZV(tmp, bodyA.angularVelocity, ri);
    vec2.sub(u, u, tmp);

    // F = - k * ( x - L ) - D * ( u )
    vec2.scale(f, r_unit, -k*(rlen-l) - d*vec2.dot(u,r_unit));

    // Add forces to bodies
    vec2.sub( bodyA.force, bodyA.force, f);
    vec2.add( bodyB.force, bodyB.force, f);

    // Angular force
    var ri_x_f = vec2.crossLength(ri, f);
    var rj_x_f = vec2.crossLength(rj, f);
    bodyA.angularForce -= ri_x_f;
    bodyB.angularForce += rj_x_f;
};

},{"../math/vec2":31,"../utils/Utils":50,"./Spring":35}],34:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Spring = _dereq_('./Spring');

module.exports = RotationalSpring;

/**
 * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.
 *
 * The spring can be combined with a {{#crossLink "RevoluteConstraint"}}{{/crossLink}} to make, for example, a mouse trap.
 *
 * @class RotationalSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.
 * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1] A number >= 0.
 */
function RotationalSpring(bodyA, bodyB, options){
    options = options || {};

    Spring.call(this, bodyA, bodyB, options);

    /**
     * Rest angle of the spring.
     * @property restAngle
     * @type {number}
     */
    this.restAngle = typeof(options.restAngle) === "number" ? options.restAngle : bodyB.angle - bodyA.angle;
}
RotationalSpring.prototype = new Spring();
RotationalSpring.prototype.constructor = RotationalSpring;

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
RotationalSpring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restAngle,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        x = bodyB.angle - bodyA.angle,
        u = bodyB.angularVelocity - bodyA.angularVelocity;

    var torque = - k * (x - l) - d * u * 0;

    bodyA.angularForce -= torque;
    bodyB.angularForce += torque;
};

},{"../math/vec2":31,"./Spring":35}],35:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Utils = _dereq_('../utils/Utils');

module.exports = Spring;

/**
 * A spring, connecting two bodies. The Spring explicitly adds force and angularForce to the bodies and does therefore not put load on the constraint solver.
 *
 * @class Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 */
function Spring(bodyA, bodyB, options){
    options = Utils.defaults(options,{
        stiffness: 100,
        damping: 1,
    });

    /**
     * Stiffness of the spring.
     * @property stiffness
     * @type {number}
     */
    this.stiffness = options.stiffness;

    /**
     * Damping of the spring.
     * @property damping
     * @type {number}
     */
    this.damping = options.damping;

    /**
     * First connected body.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second connected body.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;
}

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
Spring.prototype.applyForce = function(){
    // To be implemented by subclasses
};

},{"../math/vec2":31,"../utils/Utils":50}],36:[function(_dereq_,module,exports){
// Export p2 classes
module.exports = {
    AABB :                          _dereq_('./collision/AABB'),
    AngleLockEquation :             _dereq_('./equations/AngleLockEquation'),
    Body :                          _dereq_('./objects/Body'),
    Broadphase :                    _dereq_('./collision/Broadphase'),
    Capsule :                       _dereq_('./shapes/Capsule'),
    Circle :                        _dereq_('./shapes/Circle'),
    Constraint :                    _dereq_('./constraints/Constraint'),
    ContactEquation :               _dereq_('./equations/ContactEquation'),
    ContactMaterial :               _dereq_('./material/ContactMaterial'),
    Convex :                        _dereq_('./shapes/Convex'),
    DistanceConstraint :            _dereq_('./constraints/DistanceConstraint'),
    Equation :                      _dereq_('./equations/Equation'),
    EventEmitter :                  _dereq_('./events/EventEmitter'),
    FrictionEquation :              _dereq_('./equations/FrictionEquation'),
    GearConstraint :                _dereq_('./constraints/GearConstraint'),
    GridBroadphase :                _dereq_('./collision/GridBroadphase'),
    GSSolver :                      _dereq_('./solver/GSSolver'),
    Heightfield :                   _dereq_('./shapes/Heightfield'),
    Line :                          _dereq_('./shapes/Line'),
    LockConstraint :                _dereq_('./constraints/LockConstraint'),
    Material :                      _dereq_('./material/Material'),
    Narrowphase :                   _dereq_('./collision/Narrowphase'),
    NaiveBroadphase :               _dereq_('./collision/NaiveBroadphase'),
    Particle :                      _dereq_('./shapes/Particle'),
    Plane :                         _dereq_('./shapes/Plane'),
    RevoluteConstraint :            _dereq_('./constraints/RevoluteConstraint'),
    PrismaticConstraint :           _dereq_('./constraints/PrismaticConstraint'),
    Ray :                           _dereq_('./collision/Ray'),
    RaycastResult :                 _dereq_('./collision/RaycastResult'),
    Rectangle :                     _dereq_('./shapes/Rectangle'),
    RotationalVelocityEquation :    _dereq_('./equations/RotationalVelocityEquation'),
    SAPBroadphase :                 _dereq_('./collision/SAPBroadphase'),
    Shape :                         _dereq_('./shapes/Shape'),
    Solver :                        _dereq_('./solver/Solver'),
    Spring :                        _dereq_('./objects/Spring'),
    LinearSpring :                  _dereq_('./objects/LinearSpring'),
    RotationalSpring :              _dereq_('./objects/RotationalSpring'),
    Utils :                         _dereq_('./utils/Utils'),
    World :                         _dereq_('./world/World'),
    vec2 :                          _dereq_('./math/vec2'),
    version :                       _dereq_('../package.json').version,
};

},{"../package.json":6,"./collision/AABB":7,"./collision/Broadphase":8,"./collision/GridBroadphase":9,"./collision/NaiveBroadphase":10,"./collision/Narrowphase":11,"./collision/Ray":12,"./collision/RaycastResult":13,"./collision/SAPBroadphase":14,"./constraints/Constraint":15,"./constraints/DistanceConstraint":16,"./constraints/GearConstraint":17,"./constraints/LockConstraint":18,"./constraints/PrismaticConstraint":19,"./constraints/RevoluteConstraint":20,"./equations/AngleLockEquation":21,"./equations/ContactEquation":22,"./equations/Equation":23,"./equations/FrictionEquation":24,"./equations/RotationalVelocityEquation":26,"./events/EventEmitter":27,"./material/ContactMaterial":28,"./material/Material":29,"./math/vec2":31,"./objects/Body":32,"./objects/LinearSpring":33,"./objects/RotationalSpring":34,"./objects/Spring":35,"./shapes/Capsule":37,"./shapes/Circle":38,"./shapes/Convex":39,"./shapes/Heightfield":40,"./shapes/Line":41,"./shapes/Particle":42,"./shapes/Plane":43,"./shapes/Rectangle":44,"./shapes/Shape":45,"./solver/GSSolver":46,"./solver/Solver":47,"./utils/Utils":50,"./world/World":54}],37:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Capsule;

/**
 * Capsule shape class.
 * @class Capsule
 * @constructor
 * @extends Shape
 * @param {Number} [length=1] The distance between the end points
 * @param {Number} [radius=1] Radius of the capsule
 * @example
 *     var radius = 1;
 *     var length = 2;
 *     var capsuleShape = new Capsule(length, radius);
 *     body.addShape(capsuleShape);
 */
function Capsule(length, radius){

    /**
     * The distance between the end points.
     * @property {Number} length
     */
    this.length = length || 1;

    /**
     * The radius of the capsule.
     * @property {Number} radius
     */
    this.radius = radius || 1;

    Shape.call(this,Shape.CAPSULE);
}
Capsule.prototype = new Shape();
Capsule.prototype.constructor = Capsule;

/**
 * Compute the mass moment of inertia of the Capsule.
 * @method conputeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @todo
 */
Capsule.prototype.computeMomentOfInertia = function(mass){
    // Approximate with rectangle
    var r = this.radius,
        w = this.length + r, // 2*r is too much, 0 is too little
        h = r*2;
    return mass * (h*h + w*w) / 12;
};

/**
 * @method updateBoundingRadius
 */
Capsule.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.radius + this.length/2;
};

/**
 * @method updateArea
 */
Capsule.prototype.updateArea = function(){
    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
};

var r = vec2.create();

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Capsule.prototype.computeAABB = function(out, position, angle){
    var radius = this.radius;

    // Compute center position of one of the the circles, world oriented, but with local offset
    vec2.set(r,this.length / 2,0);
    if(angle !== 0){
        vec2.rotate(r,r,angle);
    }

    // Get bounds
    vec2.set(out.upperBound,  Math.max(r[0]+radius, -r[0]+radius),
                              Math.max(r[1]+radius, -r[1]+radius));
    vec2.set(out.lowerBound,  Math.min(r[0]-radius, -r[0]-radius),
                              Math.min(r[1]-radius, -r[1]-radius));

    // Add offset
    vec2.add(out.lowerBound, out.lowerBound, position);
    vec2.add(out.upperBound, out.upperBound, position);
};

},{"../math/vec2":31,"./Shape":45}],38:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,    vec2 = _dereq_('../math/vec2');

module.exports = Circle;

/**
 * Circle shape class.
 * @class Circle
 * @extends Shape
 * @constructor
 * @param {number} [radius=1] The radius of this circle
 *
 * @example
 *     var radius = 1;
 *     var circleShape = new Circle(radius);
 *     body.addShape(circleShape);
 */
function Circle(radius){

    /**
     * The radius of the circle.
     * @property radius
     * @type {number}
     */
    this.radius = radius || 1;

    Shape.call(this,Shape.CIRCLE);
}
Circle.prototype = new Shape();
Circle.prototype.constructor = Circle;

/**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Circle.prototype.computeMomentOfInertia = function(mass){
    var r = this.radius;
    return mass * r * r / 2;
};

/**
 * @method updateBoundingRadius
 * @return {Number}
 */
Circle.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.radius;
};

/**
 * @method updateArea
 * @return {Number}
 */
Circle.prototype.updateArea = function(){
    this.area = Math.PI * this.radius * this.radius;
};

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Circle.prototype.computeAABB = function(out, position, angle){
    var r = this.radius;
    vec2.set(out.upperBound,  r,  r);
    vec2.set(out.lowerBound, -r, -r);
    if(position){
        vec2.add(out.lowerBound, out.lowerBound, position);
        vec2.add(out.upperBound, out.upperBound, position);
    }
};

},{"../math/vec2":31,"./Shape":45}],39:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2')
,   polyk = _dereq_('../math/polyk')
,   decomp = _dereq_('poly-decomp');

module.exports = Convex;

/**
 * Convex shape class.
 * @class Convex
 * @constructor
 * @extends Shape
 * @param {Array} vertices An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.
 * @param {Array} [axes] An array of unit length vectors, representing the symmetry axes in the convex.
 * @example
 *     // Create a box
 *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];
 *     var convexShape = new Convex(vertices);
 *     body.addShape(convexShape);
 */
function Convex(vertices, axes){

    /**
     * Vertices defined in the local frame.
     * @property vertices
     * @type {Array}
     */
    this.vertices = [];

    /**
     * Axes defined in the local frame.
     * @property axes
     * @type {Array}
     */
    this.axes = [];

    // Copy the verts
    for(var i=0; i<vertices.length; i++){
        var v = vec2.create();
        vec2.copy(v,vertices[i]);
        this.vertices.push(v);
    }

    if(axes){
        // Copy the axes
        for(var i=0; i < axes.length; i++){
            var axis = vec2.create();
            vec2.copy(axis, axes[i]);
            this.axes.push(axis);
        }
    } else {
        // Construct axes from the vertex data
        for(var i = 0; i < vertices.length; i++){
            // Get the world edge
            var worldPoint0 = vertices[i];
            var worldPoint1 = vertices[(i+1) % vertices.length];

            var normal = vec2.create();
            vec2.sub(normal, worldPoint1, worldPoint0);

            // Get normal - just rotate 90 degrees since vertices are given in CCW
            vec2.rotate90cw(normal, normal);
            vec2.normalize(normal, normal);

            this.axes.push(normal);
        }
    }

    /**
     * The center of mass of the Convex
     * @property centerOfMass
     * @type {Array}
     */
    this.centerOfMass = vec2.fromValues(0,0);

    /**
     * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.
     * @property triangles
     * @type {Array}
     */
    this.triangles = [];

    if(this.vertices.length){
        this.updateTriangles();
        this.updateCenterOfMass();
    }

    /**
     * The bounding radius of the convex
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    Shape.call(this, Shape.CONVEX);

    this.updateBoundingRadius();
    this.updateArea();
    if(this.area < 0){
        throw new Error("Convex vertices must be given in conter-clockwise winding.");
    }
}
Convex.prototype = new Shape();
Convex.prototype.constructor = Convex;

var tmpVec1 = vec2.create();
var tmpVec2 = vec2.create();

/**
 * Project a Convex onto a world-oriented axis
 * @method projectOntoAxis
 * @static
 * @param  {Array} offset
 * @param  {Array} localAxis
 * @param  {Array} result
 */
Convex.prototype.projectOntoLocalAxis = function(localAxis, result){
    var max=null,
        min=null,
        v,
        value,
        localAxis = tmpVec1;

    // Get projected position of all vertices
    for(var i=0; i<this.vertices.length; i++){
        v = this.vertices[i];
        value = vec2.dot(v, localAxis);
        if(max === null || value > max){
            max = value;
        }
        if(min === null || value < min){
            min = value;
        }
    }

    if(min > max){
        var t = min;
        min = max;
        max = t;
    }

    vec2.set(result, min, max);
};

Convex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result){
    var worldAxis = tmpVec2;

    this.projectOntoLocalAxis(localAxis, result);

    // Project the position of the body onto the axis - need to add this to the result
    if(shapeAngle !== 0){
        vec2.rotate(worldAxis, localAxis, shapeAngle);
    } else {
        worldAxis = localAxis;
    }
    var offset = vec2.dot(shapeOffset, worldAxis);

    vec2.set(result, result[0] + offset, result[1] + offset);
};


/**
 * Update the .triangles property
 * @method updateTriangles
 */
Convex.prototype.updateTriangles = function(){

    this.triangles.length = 0;

    // Rewrite on polyk notation, array of numbers
    var polykVerts = [];
    for(var i=0; i<this.vertices.length; i++){
        var v = this.vertices[i];
        polykVerts.push(v[0],v[1]);
    }

    // Triangulate
    var triangles = polyk.Triangulate(polykVerts);

    // Loop over all triangles, add their inertia contributions to I
    for(var i=0; i<triangles.length; i+=3){
        var id1 = triangles[i],
            id2 = triangles[i+1],
            id3 = triangles[i+2];

        // Add to triangles
        this.triangles.push([id1,id2,id3]);
    }
};

var updateCenterOfMass_centroid = vec2.create(),
    updateCenterOfMass_centroid_times_mass = vec2.create(),
    updateCenterOfMass_a = vec2.create(),
    updateCenterOfMass_b = vec2.create(),
    updateCenterOfMass_c = vec2.create(),
    updateCenterOfMass_ac = vec2.create(),
    updateCenterOfMass_ca = vec2.create(),
    updateCenterOfMass_cb = vec2.create(),
    updateCenterOfMass_n = vec2.create();

/**
 * Update the .centerOfMass property.
 * @method updateCenterOfMass
 */
Convex.prototype.updateCenterOfMass = function(){
    var triangles = this.triangles,
        verts = this.vertices,
        cm = this.centerOfMass,
        centroid = updateCenterOfMass_centroid,
        n = updateCenterOfMass_n,
        a = updateCenterOfMass_a,
        b = updateCenterOfMass_b,
        c = updateCenterOfMass_c,
        ac = updateCenterOfMass_ac,
        ca = updateCenterOfMass_ca,
        cb = updateCenterOfMass_cb,
        centroid_times_mass = updateCenterOfMass_centroid_times_mass;

    vec2.set(cm,0,0);
    var totalArea = 0;

    for(var i=0; i!==triangles.length; i++){
        var t = triangles[i],
            a = verts[t[0]],
            b = verts[t[1]],
            c = verts[t[2]];

        vec2.centroid(centroid,a,b,c);

        // Get mass for the triangle (density=1 in this case)
        // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors
        var m = Convex.triangleArea(a,b,c);
        totalArea += m;

        // Add to center of mass
        vec2.scale(centroid_times_mass, centroid, m);
        vec2.add(cm, cm, centroid_times_mass);
    }

    vec2.scale(cm,cm,1/totalArea);
};

/**
 * Compute the mass moment of inertia of the Convex.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/
 */
Convex.prototype.computeMomentOfInertia = function(mass){
    var denom = 0.0,
        numer = 0.0,
        N = this.vertices.length;
    for(var j = N-1, i = 0; i < N; j = i, i ++){
        var p0 = this.vertices[j];
        var p1 = this.vertices[i];
        var a = Math.abs(vec2.crossLength(p0,p1));
        var b = vec2.dot(p1,p1) + vec2.dot(p1,p0) + vec2.dot(p0,p0);
        denom += a * b;
        numer += a;
    }
    return (mass / 6.0) * (denom / numer);
};

/**
 * Updates the .boundingRadius property
 * @method updateBoundingRadius
 */
Convex.prototype.updateBoundingRadius = function(){
    var verts = this.vertices,
        r2 = 0;

    for(var i=0; i!==verts.length; i++){
        var l2 = vec2.squaredLength(verts[i]);
        if(l2 > r2){
            r2 = l2;
        }
    }

    this.boundingRadius = Math.sqrt(r2);
};

/**
 * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.
 * @static
 * @method triangleArea
 * @param {Array} a
 * @param {Array} b
 * @param {Array} c
 * @return {Number}
 */
Convex.triangleArea = function(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1]))) * 0.5;
};

/**
 * Update the .area
 * @method updateArea
 */
Convex.prototype.updateArea = function(){
    this.updateTriangles();
    this.area = 0;

    var triangles = this.triangles,
        verts = this.vertices;
    for(var i=0; i!==triangles.length; i++){
        var t = triangles[i],
            a = verts[t[0]],
            b = verts[t[1]],
            c = verts[t[2]];

        // Get mass for the triangle (density=1 in this case)
        var m = Convex.triangleArea(a,b,c);
        this.area += m;
    }
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Convex.prototype.computeAABB = function(out, position, angle){
    out.setFromPoints(this.vertices, position, angle, 0);
};

},{"../math/polyk":30,"../math/vec2":31,"./Shape":45,"poly-decomp":5}],40:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,    vec2 = _dereq_('../math/vec2')
,    Utils = _dereq_('../utils/Utils');

module.exports = Heightfield;

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance "elementWidth".
 * @class Heightfield
 * @extends Shape
 * @constructor
 * @param {Array} data An array of Y values that will be used to construct the terrain.
 * @param {object} options
 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
 * @param {Number} [options.maxValue] Maximum value.
 * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.
 * @todo Should be possible to use along all axes, not just y
 *
 * @example
 *     // Generate some height data (y-values).
 *     var data = [];
 *     for(var i = 0; i < 1000; i++){
 *         var y = 0.5 * Math.cos(0.2 * i);
 *         data.push(y);
 *     }
 *
 *     // Create the heightfield shape
 *     var heightfieldShape = new Heightfield(data, {
 *         elementWidth: 1 // Distance between the data points in X direction
 *     });
 *     var heightfieldBody = new Body();
 *     heightfieldBody.addShape(heightfieldShape);
 *     world.addBody(heightfieldBody);
 */
function Heightfield(data, options){
    options = Utils.defaults(options, {
        maxValue : null,
        minValue : null,
        elementWidth : 0.1
    });

    if(options.minValue === null || options.maxValue === null){
        options.maxValue = data[0];
        options.minValue = data[0];
        for(var i=0; i !== data.length; i++){
            var v = data[i];
            if(v > options.maxValue){
                options.maxValue = v;
            }
            if(v < options.minValue){
                options.minValue = v;
            }
        }
    }

    /**
     * An array of numbers, or height values, that are spread out along the x axis.
     * @property {array} data
     */
    this.data = data;

    /**
     * Max value of the data
     * @property {number} maxValue
     */
    this.maxValue = options.maxValue;

    /**
     * Max value of the data
     * @property {number} minValue
     */
    this.minValue = options.minValue;

    /**
     * The width of each element
     * @property {number} elementWidth
     */
    this.elementWidth = options.elementWidth;

    Shape.call(this,Shape.HEIGHTFIELD);
}
Heightfield.prototype = new Shape();
Heightfield.prototype.constructor = Heightfield;

/**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Heightfield.prototype.computeMomentOfInertia = function(mass){
    return Number.MAX_VALUE;
};

Heightfield.prototype.updateBoundingRadius = function(){
    this.boundingRadius = Number.MAX_VALUE;
};

Heightfield.prototype.updateArea = function(){
    var data = this.data,
        area = 0;
    for(var i=0; i<data.length-1; i++){
        area += (data[i]+data[i+1]) / 2 * this.elementWidth;
    }
    this.area = area;
};

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Heightfield.prototype.computeAABB = function(out, position, angle){
    // Use the max data rectangle
    out.upperBound[0] = this.elementWidth * this.data.length + position[0];
    out.upperBound[1] = this.maxValue + position[1];
    out.lowerBound[0] = position[0];
    out.lowerBound[1] = -Number.MAX_VALUE; // Infinity
};

},{"../math/vec2":31,"../utils/Utils":50,"./Shape":45}],41:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Line;

/**
 * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
 * @class Line
 * @param {Number} [length=1] The total length of the line
 * @extends Shape
 * @constructor
 */
function Line(length){

    /**
     * Length of this line
     * @property length
     * @type {Number}
     */
    this.length = length || 1;

    Shape.call(this,Shape.LINE);
}
Line.prototype = new Shape();
Line.prototype.constructor = Line;

Line.prototype.computeMomentOfInertia = function(mass){
    return mass * Math.pow(this.length,2) / 12;
};

Line.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.length/2;
};

var points = [vec2.create(),vec2.create()];

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Line.prototype.computeAABB = function(out, position, angle){
    var l2 = this.length / 2;
    vec2.set(points[0], -l2,  0);
    vec2.set(points[1],  l2,  0);
    out.setFromPoints(points,position,angle,0);
};


},{"../math/vec2":31,"./Shape":45}],42:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Particle;

/**
 * Particle shape class.
 * @class Particle
 * @constructor
 * @extends Shape
 */
function Particle(){
    Shape.call(this,Shape.PARTICLE);
}
Particle.prototype = new Shape();
Particle.prototype.constructor = Particle;

Particle.prototype.computeMomentOfInertia = function(mass){
    return 0; // Can't rotate a particle
};

Particle.prototype.updateBoundingRadius = function(){
    this.boundingRadius = 0;
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Particle.prototype.computeAABB = function(out, position, angle){
    vec2.copy(out.lowerBound, position);
    vec2.copy(out.upperBound, position);
};

},{"../math/vec2":31,"./Shape":45}],43:[function(_dereq_,module,exports){
var Shape =  _dereq_('./Shape')
,    vec2 =  _dereq_('../math/vec2')
,    Utils = _dereq_('../utils/Utils');

module.exports = Plane;

/**
 * Plane shape class. The plane is facing in the Y direction.
 * @class Plane
 * @extends Shape
 * @constructor
 */
function Plane(){
    Shape.call(this,Shape.PLANE);
}
Plane.prototype = new Shape();
Plane.prototype.constructor = Plane;

/**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 */
Plane.prototype.computeMomentOfInertia = function(mass){
    return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here
};

/**
 * Update the bounding radius
 * @method updateBoundingRadius
 */
Plane.prototype.updateBoundingRadius = function(){
    this.boundingRadius = Number.MAX_VALUE;
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Plane.prototype.computeAABB = function(out, position, angle){
    var a = 0,
        set = vec2.set;
    if(typeof(angle) === "number"){
        a = angle % (2*Math.PI);
    }

    if(a === 0){
        // y goes from -inf to 0
        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
        set(out.upperBound,  Number.MAX_VALUE,  0);
    } else if(a === Math.PI / 2){
        // x goes from 0 to inf
        set(out.lowerBound, 0, -Number.MAX_VALUE);
        set(out.upperBound,      Number.MAX_VALUE,  Number.MAX_VALUE);
    } else if(a === Math.PI){
        // y goes from 0 to inf
        set(out.lowerBound, -Number.MAX_VALUE, 0);
        set(out.upperBound,  Number.MAX_VALUE, Number.MAX_VALUE);
    } else if(a === 3*Math.PI/2){
        // x goes from -inf to 0
        set(out.lowerBound, -Number.MAX_VALUE,     -Number.MAX_VALUE);
        set(out.upperBound,  0,  Number.MAX_VALUE);
    } else {
        // Set max bounds
        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
        set(out.upperBound,  Number.MAX_VALUE,  Number.MAX_VALUE);
    }

    vec2.add(out.lowerBound, out.lowerBound, position);
    vec2.add(out.upperBound, out.upperBound, position);
};

Plane.prototype.updateArea = function(){
    this.area = Number.MAX_VALUE;
};


},{"../math/vec2":31,"../utils/Utils":50,"./Shape":45}],44:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Shape = _dereq_('./Shape')
,   Convex = _dereq_('./Convex');

module.exports = Rectangle;

/**
 * Rectangle shape class.
 * @class Rectangle
 * @constructor
 * @param {Number} [width=1] Width
 * @param {Number} [height=1] Height
 * @extends Convex
 */
function Rectangle(width, height){

    /**
     * Total width of the rectangle
     * @property width
     * @type {Number}
     */
    this.width = width || 1;

    /**
     * Total height of the rectangle
     * @property height
     * @type {Number}
     */
    this.height = height || 1;

    var verts = [   vec2.fromValues(-width/2, -height/2),
                    vec2.fromValues( width/2, -height/2),
                    vec2.fromValues( width/2,  height/2),
                    vec2.fromValues(-width/2,  height/2)];
    var axes = [vec2.fromValues(1, 0), vec2.fromValues(0, 1)];

    Convex.call(this, verts, axes);

    this.type = Shape.RECTANGLE;
}
Rectangle.prototype = new Convex([]);
Rectangle.prototype.constructor = Rectangle;

/**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Rectangle.prototype.computeMomentOfInertia = function(mass){
    var w = this.width,
        h = this.height;
    return mass * (h*h + w*w) / 12;
};

/**
 * Update the bounding radius
 * @method updateBoundingRadius
 */
Rectangle.prototype.updateBoundingRadius = function(){
    var w = this.width,
        h = this.height;
    this.boundingRadius = Math.sqrt(w*w + h*h) / 2;
};

var corner1 = vec2.create(),
    corner2 = vec2.create(),
    corner3 = vec2.create(),
    corner4 = vec2.create();

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Rectangle.prototype.computeAABB = function(out, position, angle){
    out.setFromPoints(this.vertices,position,angle,0);
};

Rectangle.prototype.updateArea = function(){
    this.area = this.width * this.height;
};


},{"../math/vec2":31,"./Convex":39,"./Shape":45}],45:[function(_dereq_,module,exports){
module.exports = Shape;

/**
 * Base class for shapes.
 * @class Shape
 * @constructor
 * @param {Number} type
 */
function Shape(type){

    /**
     * The type of the shape. One of:
     *
     * * {{#crossLink "Shape/CIRCLE:property"}}Shape.CIRCLE{{/crossLink}}
     * * {{#crossLink "Shape/PARTICLE:property"}}Shape.PARTICLE{{/crossLink}}
     * * {{#crossLink "Shape/PLANE:property"}}Shape.PLANE{{/crossLink}}
     * * {{#crossLink "Shape/CONVEX:property"}}Shape.CONVEX{{/crossLink}}
     * * {{#crossLink "Shape/LINE:property"}}Shape.LINE{{/crossLink}}
     * * {{#crossLink "Shape/RECTANGLE:property"}}Shape.RECTANGLE{{/crossLink}}
     * * {{#crossLink "Shape/CAPSULE:property"}}Shape.CAPSULE{{/crossLink}}
     * * {{#crossLink "Shape/HEIGHTFIELD:property"}}Shape.HEIGHTFIELD{{/crossLink}}
     *
     * @property {number} type
     */
    this.type = type;

    /**
     * Shape object identifier.
     * @type {Number}
     * @property id
     */
    this.id = Shape.idCounter++;

    /**
     * Bounding circle radius of this shape
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    /**
     * Collision group that this shape belongs to (bit mask). See <a href="http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/">this tutorial</a>.
     * @property collisionGroup
     * @type {Number}
     * @example
     *     // Setup bits for each available group
     *     var PLAYER = Math.pow(2,0),
     *         ENEMY =  Math.pow(2,1),
     *         GROUND = Math.pow(2,2)
     *
     *     // Put shapes into their groups
     *     player1Shape.collisionGroup = PLAYER;
     *     player2Shape.collisionGroup = PLAYER;
     *     enemyShape  .collisionGroup = ENEMY;
     *     groundShape .collisionGroup = GROUND;
     *
     *     // Assign groups that each shape collide with.
     *     // Note that the players can collide with ground and enemies, but not with other players.
     *     player1Shape.collisionMask = ENEMY | GROUND;
     *     player2Shape.collisionMask = ENEMY | GROUND;
     *     enemyShape  .collisionMask = PLAYER | GROUND;
     *     groundShape .collisionMask = PLAYER | ENEMY;
     *
     * @example
     *     // How collision check is done
     *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){
     *         // The shapes will collide
     *     }
     */
    this.collisionGroup = 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this shape will move through other body shapes, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * Collision mask of this shape. See .collisionGroup.
     * @property collisionMask
     * @type {Number}
     */
    this.collisionMask =  1;
    if(type){
        this.updateBoundingRadius();
    }

    /**
     * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.
     * @property material
     * @type {Material}
     */
    this.material = null;

    /**
     * Area of this shape.
     * @property area
     * @type {Number}
     */
    this.area = 0;

    /**
     * Set to true if you want this shape to be a sensor. A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.
     * @property {Boolean} sensor
     */
    this.sensor = false;

    this.updateArea();
}

Shape.idCounter = 0;

/**
 * @static
 * @property {Number} CIRCLE
 */
Shape.CIRCLE =      1;

/**
 * @static
 * @property {Number} PARTICLE
 */
Shape.PARTICLE =    2;

/**
 * @static
 * @property {Number} PLANE
 */
Shape.PLANE =       4;

/**
 * @static
 * @property {Number} CONVEX
 */
Shape.CONVEX =      8;

/**
 * @static
 * @property {Number} LINE
 */
Shape.LINE =        16;

/**
 * @static
 * @property {Number} RECTANGLE
 */
Shape.RECTANGLE =   32;

/**
 * @static
 * @property {Number} CAPSULE
 */
Shape.CAPSULE =     64;

/**
 * @static
 * @property {Number} HEIGHTFIELD
 */
Shape.HEIGHTFIELD = 128;

/**
 * Should return the moment of inertia around the Z axis of the body given the total mass. See <a href="http://en.wikipedia.org/wiki/List_of_moments_of_inertia">Wikipedia's list of moments of inertia</a>.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number} If the inertia is infinity or if the object simply isn't possible to rotate, return 0.
 */
Shape.prototype.computeMomentOfInertia = function(mass){
    throw new Error("Shape.computeMomentOfInertia is not implemented in this Shape...");
};

/**
 * Returns the bounding circle radius of this shape.
 * @method updateBoundingRadius
 * @return {Number}
 */
Shape.prototype.updateBoundingRadius = function(){
    throw new Error("Shape.updateBoundingRadius is not implemented in this Shape...");
};

/**
 * Update the .area property of the shape.
 * @method updateArea
 */
Shape.prototype.updateArea = function(){
    // To be implemented in all subclasses
};

/**
 * Compute the world axis-aligned bounding box (AABB) of this shape.
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Shape.prototype.computeAABB = function(out, position, angle){
    // To be implemented in each subclass
};

},{}],46:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Solver = _dereq_('./Solver')
,   Utils = _dereq_('../utils/Utils')
,   FrictionEquation = _dereq_('../equations/FrictionEquation');

module.exports = GSSolver;

/**
 * Iterative Gauss-Seidel constraint equation solver.
 *
 * @class GSSolver
 * @constructor
 * @extends Solver
 * @param {Object} [options]
 * @param {Number} [options.iterations=10]
 * @param {Number} [options.tolerance=0]
 */
function GSSolver(options){
    Solver.call(this,options,Solver.GS);
    options = options || {};

    /**
     * The number of iterations to do when solving. More gives better results, but is more expensive.
     * @property iterations
     * @type {Number}
     */
    this.iterations = options.iterations || 10;

    /**
     * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.
     * @property tolerance
     * @type {Number}
     */
    this.tolerance = options.tolerance || 1e-10;

    this.arrayStep = 30;
    this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);
    this.Bs =     new Utils.ARRAY_TYPE(this.arrayStep);
    this.invCs =  new Utils.ARRAY_TYPE(this.arrayStep);

    /**
     * Set to true to set all right hand side terms to zero when solving. Can be handy for a few applications.
     * @property useZeroRHS
     * @type {Boolean}
     */
    this.useZeroRHS = false;

    /**
     * Number of solver iterations that are done to approximate normal forces. When these iterations are done, friction force will be computed from the contact normal forces. These friction forces will override any other friction forces set from the World for example.
     * The solver will use less iterations if the solution is below the .tolerance.
     * @property frictionIterations
     * @type {Number}
     */
    this.frictionIterations = 0;

    /**
     * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.
     * @property {Number} usedIterations
     */
    this.usedIterations = 0;
}
GSSolver.prototype = new Solver();
GSSolver.prototype.constructor = GSSolver;

function setArrayZero(array){
    var l = array.length;
    while(l--){
        array[l] = +0.0;
    }
}

/**
 * Solve the system of equations
 * @method solve
 * @param  {Number}  h       Time step
 * @param  {World}   world    World to solve
 */
GSSolver.prototype.solve = function(h, world){

    this.sortEquations();

    var iter = 0,
        maxIter = this.iterations,
        maxFrictionIter = this.frictionIterations,
        equations = this.equations,
        Neq = equations.length,
        tolSquared = Math.pow(this.tolerance*Neq, 2),
        bodies = world.bodies,
        Nbodies = world.bodies.length,
        add = vec2.add,
        set = vec2.set,
        useZeroRHS = this.useZeroRHS,
        lambda = this.lambda;

    this.usedIterations = 0;

    if(Neq){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i];

            // Update solve mass
            b.updateSolveMassProperties();
        }
    }

    // Things that does not change during iteration can be computed once
    if(lambda.length < Neq){
        lambda = this.lambda =  new Utils.ARRAY_TYPE(Neq + this.arrayStep);
        this.Bs =               new Utils.ARRAY_TYPE(Neq + this.arrayStep);
        this.invCs =            new Utils.ARRAY_TYPE(Neq + this.arrayStep);
    }
    setArrayZero(lambda);
    var invCs = this.invCs,
        Bs = this.Bs,
        lambda = this.lambda;

    for(var i=0; i!==equations.length; i++){
        var c = equations[i];
        if(c.timeStep !== h || c.needsUpdate){
            c.timeStep = h;
            c.update();
        }
        Bs[i] =     c.computeB(c.a,c.b,h);
        invCs[i] =  c.computeInvC(c.epsilon);
    }

    var q, B, c, deltalambdaTot,i,j;

    if(Neq !== 0){

        for(i=0; i!==Nbodies; i++){
            var b = bodies[i];

            // Reset vlambda
            b.resetConstraintVelocity();
        }

        if(maxFrictionIter){
            // Iterate over contact equations to get normal forces
            for(iter=0; iter!==maxFrictionIter; iter++){

                // Accumulate the total error for each iteration.
                deltalambdaTot = 0.0;

                for(j=0; j!==Neq; j++){
                    c = equations[j];

                    var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
                    deltalambdaTot += Math.abs(deltalambda);
                }

                this.usedIterations++;

                // If the total error is small enough - stop iterate
                if(deltalambdaTot*deltalambdaTot <= tolSquared){
                    break;
                }
            }

            GSSolver.updateMultipliers(equations, lambda, 1/h);

            // Set computed friction force
            for(j=0; j!==Neq; j++){
                var eq = equations[j];
                if(eq instanceof FrictionEquation){
                    var f = 0.0;
                    for(var k=0; k!==eq.contactEquations.length; k++){
                        f += eq.contactEquations[k].multiplier;
                    }
                    f *= eq.frictionCoefficient / eq.contactEquations.length;
                    eq.maxForce =  f;
                    eq.minForce = -f;
                }
            }
        }

        // Iterate over all equations
        for(iter=0; iter!==maxIter; iter++){

            // Accumulate the total error for each iteration.
            deltalambdaTot = 0.0;

            for(j=0; j!==Neq; j++){
                c = equations[j];

                var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
                deltalambdaTot += Math.abs(deltalambda);
            }

            this.usedIterations++;

            // If the total error is small enough - stop iterate
            if(deltalambdaTot*deltalambdaTot <= tolSquared){
                break;
            }
        }

        // Add result to velocity
        for(i=0; i!==Nbodies; i++){
            bodies[i].addConstraintVelocity();
        }

        GSSolver.updateMultipliers(equations, lambda, 1/h);
    }
};

// Sets the .multiplier property of each equation
GSSolver.updateMultipliers = function(equations, lambda, invDt){
    // Set the .multiplier property of each equation
    var l = equations.length;
    while(l--){
        equations[l].multiplier = lambda[l] * invDt;
    }
};

GSSolver.iterateEquation = function(j,eq,eps,Bs,invCs,lambda,useZeroRHS,dt,iter){
    // Compute iteration
    var B = Bs[j],
        invC = invCs[j],
        lambdaj = lambda[j],
        GWlambda = eq.computeGWlambda();

    var maxForce = eq.maxForce,
        minForce = eq.minForce;

    if(useZeroRHS){
        B = 0;
    }

    var deltalambda = invC * ( B - GWlambda - eps * lambdaj );

    // Clamp if we are not within the min/max interval
    var lambdaj_plus_deltalambda = lambdaj + deltalambda;
    if(lambdaj_plus_deltalambda < minForce*dt){
        deltalambda = minForce*dt - lambdaj;
    } else if(lambdaj_plus_deltalambda > maxForce*dt){
        deltalambda = maxForce*dt - lambdaj;
    }
    lambda[j] += deltalambda;
    eq.addToWlambda(deltalambda);

    return deltalambda;
};

},{"../equations/FrictionEquation":24,"../math/vec2":31,"../utils/Utils":50,"./Solver":47}],47:[function(_dereq_,module,exports){
var Utils = _dereq_('../utils/Utils')
,   EventEmitter = _dereq_('../events/EventEmitter');

module.exports = Solver;

/**
 * Base class for constraint solvers.
 * @class Solver
 * @constructor
 * @extends EventEmitter
 */
function Solver(options,type){
    options = options || {};

    EventEmitter.call(this);

    this.type = type;

    /**
     * Current equations in the solver.
     *
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * Function that is used to sort all equations before each solve.
     * @property equationSortFunction
     * @type {function|boolean}
     */
    this.equationSortFunction = options.equationSortFunction || false;
}
Solver.prototype = new EventEmitter();
Solver.prototype.constructor = Solver;

/**
 * Method to be implemented in each subclass
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
Solver.prototype.solve = function(dt,world){
    throw new Error("Solver.solve should be implemented by subclasses!");
};

var mockWorld = {bodies:[]};

/**
 * Solves all constraints in an island.
 * @method solveIsland
 * @param  {Number} dt
 * @param  {Island} island
 */
Solver.prototype.solveIsland = function(dt,island){

    this.removeAllEquations();

    if(island.equations.length){
        // Add equations to solver
        this.addEquations(island.equations);
        mockWorld.bodies.length = 0;
        island.getBodies(mockWorld.bodies);

        // Solve
        if(mockWorld.bodies.length){
            this.solve(dt,mockWorld);
        }
    }
};

/**
 * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.
 * @method sortEquations
 */
Solver.prototype.sortEquations = function(){
    if(this.equationSortFunction){
        this.equations.sort(this.equationSortFunction);
    }
};

/**
 * Add an equation to be solved.
 *
 * @method addEquation
 * @param {Equation} eq
 */
Solver.prototype.addEquation = function(eq){
    if(eq.enabled){
        this.equations.push(eq);
    }
};

/**
 * Add equations. Same as .addEquation, but this time the argument is an array of Equations
 *
 * @method addEquations
 * @param {Array} eqs
 */
Solver.prototype.addEquations = function(eqs){
    //Utils.appendArray(this.equations,eqs);
    for(var i=0, N=eqs.length; i!==N; i++){
        var eq = eqs[i];
        if(eq.enabled){
            this.equations.push(eq);
        }
    }
};

/**
 * Remove an equation.
 *
 * @method removeEquation
 * @param {Equation} eq
 */
Solver.prototype.removeEquation = function(eq){
    var i = this.equations.indexOf(eq);
    if(i !== -1){
        this.equations.splice(i,1);
    }
};

/**
 * Remove all currently added equations.
 *
 * @method removeAllEquations
 */
Solver.prototype.removeAllEquations = function(){
    this.equations.length=0;
};

Solver.GS = 1;
Solver.ISLAND = 2;

},{"../events/EventEmitter":27,"../utils/Utils":50}],48:[function(_dereq_,module,exports){
var TupleDictionary = _dereq_('./TupleDictionary');
var Utils = _dereq_('./Utils');

module.exports = OverlapKeeper;

/**
 * Keeps track of overlaps in the current state and the last step state.
 * @class OverlapKeeper
 * @constructor
 */
function OverlapKeeper() {
    this.overlappingShapesLastState = new TupleDictionary();
    this.overlappingShapesCurrentState = new TupleDictionary();
    this.recordPool = [];
    this.tmpDict = new TupleDictionary();
    this.tmpArray1 = [];
}

/**
 * Ticks one step forward in time. This will move the current overlap state to the "old" overlap state, and create a new one as current.
 * @method tick
 */
OverlapKeeper.prototype.tick = function() {
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;

    // Save old objects into pool
    var l = last.keys.length;
    while(l--){
        var key = last.keys[l];
        var lastObject = last.getByKey(key);
        var currentObject = current.getByKey(key);
        if(lastObject && !currentObject){
            // The record is only used in the "last" dict, and will be removed. We might as well pool it.
            this.recordPool.push(lastObject);
        }
    }

    // Clear last object
    last.reset();

    // Transfer from new object to old
    last.copy(current);

    // Clear current object
    current.reset();
};

/**
 * @method setOverlapping
 * @param {Body} bodyA
 * @param {Body} shapeA
 * @param {Body} bodyB
 * @param {Body} shapeB
 */
OverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;

    // Store current contact state
    if(!current.get(shapeA.id, shapeB.id)){

        var data;
        if(this.recordPool.length){
            data = this.recordPool.pop();
            data.set(bodyA, shapeA, bodyB, shapeB);
        } else {
            data = new OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB);
        }

        current.set(shapeA.id, shapeB.id, data);
    }
};

OverlapKeeper.prototype.getNewOverlaps = function(result){
    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
};

OverlapKeeper.prototype.getEndOverlaps = function(result){
    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
};

/**
 * Checks if two bodies are currently overlapping.
 * @method bodiesAreOverlapping
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {boolean}
 */
OverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB){
    var current = this.overlappingShapesCurrentState;
    var l = current.keys.length;
    while(l--){
        var key = current.keys[l];
        var data = current.data[key];
        if((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA){
            return true;
        }
    }
    return false;
};

OverlapKeeper.prototype.getDiff = function(dictA, dictB, result){
    var result = result || [];
    var last = dictA;
    var current = dictB;

    result.length = 0;

    var l = current.keys.length;
    while(l--){
        var key = current.keys[l];
        var data = current.data[key];

        if(!data){
            throw new Error('Key '+key+' had no data!');
        }

        var lastData = last.data[key];
        if(!lastData){
            // Not overlapping in last state, but in current.
            result.push(data);
        }
    }

    return result;
};

OverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB){
    var idA = shapeA.id|0,
        idB = shapeB.id|0;
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;
    // Not in last but in new
    return !!!last.get(idA, idB) && !!current.get(idA, idB);
};

OverlapKeeper.prototype.getNewBodyOverlaps = function(result){
    this.tmpArray1.length = 0;
    var overlaps = this.getNewOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
};

OverlapKeeper.prototype.getEndBodyOverlaps = function(result){
    this.tmpArray1.length = 0;
    var overlaps = this.getEndOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
};

OverlapKeeper.prototype.getBodyDiff = function(overlaps, result){
    result = result || [];
    var accumulator = this.tmpDict;

    var l = overlaps.length;

    while(l--){
        var data = overlaps[l];

        // Since we use body id's for the accumulator, these will be a subset of the original one
        accumulator.set(data.bodyA.id|0, data.bodyB.id|0, data);
    }

    l = accumulator.keys.length;
    while(l--){
        var data = accumulator.getByKey(accumulator.keys[l]);
        if(data){
            result.push(data.bodyA, data.bodyB);
        }
    }

    accumulator.reset();

    return result;
};

/**
 * Overlap data container for the OverlapKeeper
 * @class OverlapKeeperRecord
 * @constructor
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */
function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB){
    /**
     * @property {Shape} shapeA
     */
    this.shapeA = shapeA;
    /**
     * @property {Shape} shapeB
     */
    this.shapeB = shapeB;
    /**
     * @property {Body} bodyA
     */
    this.bodyA = bodyA;
    /**
     * @property {Body} bodyB
     */
    this.bodyB = bodyB;
}

/**
 * Set the data for the record
 * @method set
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */
OverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB){
    OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);
};

},{"./TupleDictionary":49,"./Utils":50}],49:[function(_dereq_,module,exports){
var Utils = _dereq_('./Utils');

module.exports = TupleDictionary;

/**
 * @class TupleDictionary
 * @constructor
 */
function TupleDictionary() {

    /**
     * The data storage
     * @property data
     * @type {Object}
     */
    this.data = {};

    /**
     * Keys that are currently used.
     * @property {Array} keys
     */
    this.keys = [];
}

/**
 * Generate a key given two integers
 * @method getKey
 * @param  {number} i
 * @param  {number} j
 * @return {string}
 */
TupleDictionary.prototype.getKey = function(id1, id2) {
    id1 = id1|0;
    id2 = id2|0;

    if ( (id1|0) === (id2|0) ){
        return -1;
    }

    // valid for values < 2^16
    return ((id1|0) > (id2|0) ?
        (id1 << 16) | (id2 & 0xFFFF) :
        (id2 << 16) | (id1 & 0xFFFF))|0
        ;
};

/**
 * @method getByKey
 * @param  {Number} key
 * @return {Object}
 */
TupleDictionary.prototype.getByKey = function(key) {
    key = key|0;
    return this.data[key];
};

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
TupleDictionary.prototype.get = function(i, j) {
    return this.data[this.getKey(i, j)];
};

/**
 * Set a value.
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
TupleDictionary.prototype.set = function(i, j, value) {
    if(!value){
        throw new Error("No data!");
    }

    var key = this.getKey(i, j);

    // Check if key already exists
    if(!this.data[key]){
        this.keys.push(key);
    }

    this.data[key] = value;

    return key;
};

/**
 * Remove all data.
 * @method reset
 */
TupleDictionary.prototype.reset = function() {
    var data = this.data,
        keys = this.keys;

    var l = keys.length;
    while(l--) {
        delete data[keys[l]];
    }

    keys.length = 0;
};

/**
 * Copy another TupleDictionary. Note that all data in this dictionary will be removed.
 * @method copy
 * @param {TupleDictionary} dict The TupleDictionary to copy into this one.
 */
TupleDictionary.prototype.copy = function(dict) {
    this.reset();
    Utils.appendArray(this.keys, dict.keys);
    var l = dict.keys.length;
    while(l--){
        var key = dict.keys[l];
        this.data[key] = dict.data[key];
    }
};

},{"./Utils":50}],50:[function(_dereq_,module,exports){
/* global P2_ARRAY_TYPE */

module.exports = Utils;

/**
 * Misc utility functions
 * @class Utils
 * @constructor
 */
function Utils(){}

/**
 * Append the values in array b to the array a. See <a href="http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131">this</a> for an explanation.
 * @method appendArray
 * @static
 * @param  {Array} a
 * @param  {Array} b
 */
Utils.appendArray = function(a,b){
    if (b.length < 150000) {
        a.push.apply(a, b);
    } else {
        for (var i = 0, len = b.length; i !== len; ++i) {
            a.push(b[i]);
        }
    }
};

/**
 * Garbage free Array.splice(). Does not allocate a new array.
 * @method splice
 * @static
 * @param  {Array} array
 * @param  {Number} index
 * @param  {Number} howmany
 */
Utils.splice = function(array,index,howmany){
    howmany = howmany || 1;
    for (var i=index, len=array.length-howmany; i < len; i++){
        array[i] = array[i + howmany];
    }
    array.length = len;
};

/**
 * The array type to use for internal numeric computations throughout the library. Float32Array is used if it is available, but falls back on Array. If you want to set array type manually, inject it via the global variable P2_ARRAY_TYPE. See example below.
 * @static
 * @property {function} ARRAY_TYPE
 * @example
 *     <script>
 *         <!-- Inject your preferred array type before loading p2.js -->
 *         P2_ARRAY_TYPE = Array;
 *     </script>
 *     <script src="p2.js"></script>
 */
if(typeof P2_ARRAY_TYPE !== 'undefined') {
    Utils.ARRAY_TYPE = P2_ARRAY_TYPE;
} else if (typeof Float32Array !== 'undefined'){
    Utils.ARRAY_TYPE = Float32Array;
} else {
    Utils.ARRAY_TYPE = Array;
}

/**
 * Extend an object with the properties of another
 * @static
 * @method extend
 * @param  {object} a
 * @param  {object} b
 */
Utils.extend = function(a,b){
    for(var key in b){
        a[key] = b[key];
    }
};

/**
 * Extend an options object with default values.
 * @static
 * @method defaults
 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
 * @param  {object} defaults An object containing default values.
 * @return {object} The modified options object.
 */
Utils.defaults = function(options, defaults){
    options = options || {};
    for(var key in defaults){
        if(!(key in options)){
            options[key] = defaults[key];
        }
    }
    return options;
};

},{}],51:[function(_dereq_,module,exports){
var Body = _dereq_('../objects/Body');

module.exports = Island;

/**
 * An island of bodies connected with equations.
 * @class Island
 * @constructor
 */
function Island(){

    /**
     * Current equations in this island.
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * Current bodies in this island.
     * @property bodies
     * @type {Array}
     */
    this.bodies = [];
}

/**
 * Clean this island from bodies and equations.
 * @method reset
 */
Island.prototype.reset = function(){
    this.equations.length = this.bodies.length = 0;
};

var bodyIds = [];

/**
 * Get all unique bodies in this island.
 * @method getBodies
 * @return {Array} An array of Body
 */
Island.prototype.getBodies = function(result){
    var bodies = result || [],
        eqs = this.equations;
    bodyIds.length = 0;
    for(var i=0; i!==eqs.length; i++){
        var eq = eqs[i];
        if(bodyIds.indexOf(eq.bodyA.id)===-1){
            bodies.push(eq.bodyA);
            bodyIds.push(eq.bodyA.id);
        }
        if(bodyIds.indexOf(eq.bodyB.id)===-1){
            bodies.push(eq.bodyB);
            bodyIds.push(eq.bodyB.id);
        }
    }
    return bodies;
};

/**
 * Check if the entire island wants to sleep.
 * @method wantsToSleep
 * @return {Boolean}
 */
Island.prototype.wantsToSleep = function(){
    for(var i=0; i<this.bodies.length; i++){
        var b = this.bodies[i];
        if(b.type === Body.DYNAMIC && !b.wantsToSleep){
            return false;
        }
    }
    return true;
};

/**
 * Make all bodies in the island sleep.
 * @method sleep
 */
Island.prototype.sleep = function(){
    for(var i=0; i<this.bodies.length; i++){
        var b = this.bodies[i];
        b.sleep();
    }
    return true;
};

},{"../objects/Body":32}],52:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Island = _dereq_('./Island')
,   IslandNode = _dereq_('./IslandNode')
,   Body = _dereq_('../objects/Body');

module.exports = IslandManager;

/**
 * Splits the system of bodies and equations into independent islands
 *
 * @class IslandManager
 * @constructor
 * @param {Object} [options]
 * @extends Solver
 */
function IslandManager(options){

    // Pooling of node objects saves some GC load
    this._nodePool = [];
    this._islandPool = [];

    /**
     * The equations to split. Manually fill this array before running .split().
     * @property {Array} equations
     */
    this.equations = [];

    /**
     * The resulting {{#crossLink "Island"}}{{/crossLink}}s.
     * @property {Array} islands
     */
    this.islands = [];

    /**
     * The resulting graph nodes.
     * @property {Array} nodes
     */
    this.nodes = [];

    /**
     * The node queue, used when traversing the graph of nodes.
     * @private
     * @property {Array} queue
     */
    this.queue = [];
}

/**
 * Get an unvisited node from a list of nodes.
 * @static
 * @method getUnvisitedNode
 * @param  {Array} nodes
 * @return {IslandNode|boolean} The node if found, else false.
 */
IslandManager.getUnvisitedNode = function(nodes){
    var Nnodes = nodes.length;
    for(var i=0; i!==Nnodes; i++){
        var node = nodes[i];
        if(!node.visited && node.body.type === Body.DYNAMIC){
            return node;
        }
    }
    return false;
};

/**
 * Visit a node.
 * @method visit
 * @param  {IslandNode} node
 * @param  {Array} bds
 * @param  {Array} eqs
 */
IslandManager.prototype.visit = function (node,bds,eqs){
    bds.push(node.body);
    var Neqs = node.equations.length;
    for(var i=0; i!==Neqs; i++){
        var eq = node.equations[i];
        if(eqs.indexOf(eq) === -1){ // Already added?
            eqs.push(eq);
        }
    }
};

/**
 * Runs the search algorithm, starting at a root node. The resulting bodies and equations will be stored in the provided arrays.
 * @method bfs
 * @param  {IslandNode} root The node to start from
 * @param  {Array} bds  An array to append resulting Bodies to.
 * @param  {Array} eqs  An array to append resulting Equations to.
 */
IslandManager.prototype.bfs = function(root,bds,eqs){

    // Reset the visit queue
    var queue = this.queue;
    queue.length = 0;

    // Add root node to queue
    queue.push(root);
    root.visited = true;
    this.visit(root,bds,eqs);

    // Process all queued nodes
    while(queue.length) {

        // Get next node in the queue
        var node = queue.pop();

        // Visit unvisited neighboring nodes
        var child;
        while((child = IslandManager.getUnvisitedNode(node.neighbors))) {
            child.visited = true;
            this.visit(child,bds,eqs);

            // Only visit the children of this node if it's dynamic
            if(child.body.type === Body.DYNAMIC){
                queue.push(child);
            }
        }
    }
};

/**
 * Split the world into independent islands. The result is stored in .islands.
 * @method split
 * @param  {World} world
 * @return {Array} The generated islands
 */
IslandManager.prototype.split = function(world){
    var bodies = world.bodies,
        nodes = this.nodes,
        equations = this.equations;

    // Move old nodes to the node pool
    while(nodes.length){
        this._nodePool.push(nodes.pop());
    }

    // Create needed nodes, reuse if possible
    for(var i=0; i!==bodies.length; i++){
        if(this._nodePool.length){
            var node = this._nodePool.pop();
            node.reset();
            node.body = bodies[i];
            nodes.push(node);
        } else {
            nodes.push(new IslandNode(bodies[i]));
        }
    }

    // Add connectivity data. Each equation connects 2 bodies.
    for(var k=0; k!==equations.length; k++){
        var eq=equations[k],
            i=bodies.indexOf(eq.bodyA),
            j=bodies.indexOf(eq.bodyB),
            ni=nodes[i],
            nj=nodes[j];
        ni.neighbors.push(nj);
        nj.neighbors.push(ni);
        ni.equations.push(eq);
        nj.equations.push(eq);
    }

    // Move old islands to the island pool
    var islands = this.islands;
    while(islands.length){
        var island = islands.pop();
        island.reset();
        this._islandPool.push(island);
    }

    // Get islands
    var child;
    while((child = IslandManager.getUnvisitedNode(nodes))){

        // Create new island
        var island = this._islandPool.length ? this._islandPool.pop() : new Island();

        // Get all equations and bodies in this island
        this.bfs(child, island.bodies, island.equations);

        islands.push(island);
    }

    return islands;
};

},{"../math/vec2":31,"../objects/Body":32,"./Island":51,"./IslandNode":53}],53:[function(_dereq_,module,exports){
module.exports = IslandNode;

/**
 * Holds a body and keeps track of some additional properties needed for graph traversal.
 * @class IslandNode
 * @constructor
 * @param {Body} body
 */
function IslandNode(body){

	/**
	 * The body that is contained in this node.
	 * @property {Body} body
	 */
    this.body = body;

    /**
     * Neighboring IslandNodes
     * @property {Array} neighbors
     */
    this.neighbors = [];

    /**
     * Equations connected to this node.
     * @property {Array} equations
     */
    this.equations = [];

    /**
     * If this node was visiting during the graph traversal.
     * @property visited
     * @type {Boolean}
     */
    this.visited = false;
}

/**
 * Clean this node from bodies and equations.
 * @method reset
 */
IslandNode.prototype.reset = function(){
    this.equations.length = 0;
    this.neighbors.length = 0;
    this.visited = false;
    this.body = null;
};

},{}],54:[function(_dereq_,module,exports){
/* global performance */
/*jshint -W020 */

var  GSSolver = _dereq_('../solver/GSSolver')
,    Solver = _dereq_('../solver/Solver')
,    NaiveBroadphase = _dereq_('../collision/NaiveBroadphase')
,    Ray = _dereq_('../collision/Ray')
,    vec2 = _dereq_('../math/vec2')
,    Circle = _dereq_('../shapes/Circle')
,    Rectangle = _dereq_('../shapes/Rectangle')
,    Convex = _dereq_('../shapes/Convex')
,    Line = _dereq_('../shapes/Line')
,    Plane = _dereq_('../shapes/Plane')
,    Capsule = _dereq_('../shapes/Capsule')
,    Particle = _dereq_('../shapes/Particle')
,    EventEmitter = _dereq_('../events/EventEmitter')
,    Body = _dereq_('../objects/Body')
,    Shape = _dereq_('../shapes/Shape')
,    LinearSpring = _dereq_('../objects/LinearSpring')
,    Material = _dereq_('../material/Material')
,    ContactMaterial = _dereq_('../material/ContactMaterial')
,    DistanceConstraint = _dereq_('../constraints/DistanceConstraint')
,    Constraint = _dereq_('../constraints/Constraint')
,    LockConstraint = _dereq_('../constraints/LockConstraint')
,    RevoluteConstraint = _dereq_('../constraints/RevoluteConstraint')
,    PrismaticConstraint = _dereq_('../constraints/PrismaticConstraint')
,    GearConstraint = _dereq_('../constraints/GearConstraint')
,    pkg = _dereq_('../../package.json')
,    Broadphase = _dereq_('../collision/Broadphase')
,    SAPBroadphase = _dereq_('../collision/SAPBroadphase')
,    Narrowphase = _dereq_('../collision/Narrowphase')
,    Utils = _dereq_('../utils/Utils')
,    OverlapKeeper = _dereq_('../utils/OverlapKeeper')
,    IslandManager = _dereq_('./IslandManager')
,    RotationalSpring = _dereq_('../objects/RotationalSpring');

module.exports = World;

if(typeof performance === 'undefined'){
    performance = {};
}
if(!performance.now){
    var nowOffset = Date.now();
    if (performance.timing && performance.timing.navigationStart){
        nowOffset = performance.timing.navigationStart;
    }
    performance.now = function(){
        return Date.now() - nowOffset;
    };
}

/**
 * The dynamics world, where all bodies and constraints lives.
 *
 * @class World
 * @constructor
 * @param {Object}          [options]
 * @param {Solver}          [options.solver]            Defaults to GSSolver.
 * @param {Array}           [options.gravity]           Defaults to [0,-9.78]
 * @param {Broadphase}      [options.broadphase]        Defaults to NaiveBroadphase
 * @param {Boolean}         [options.islandSplit=false]
 * @param {Boolean}         [options.doProfiling=false]
 * @extends EventEmitter
 *
 * @example
 *     var world = new World({
 *         gravity: [0, -9.81],
 *         broadphase: new SAPBroadphase()
 *     });
 */
function World(options){
    EventEmitter.apply(this);

    options = options || {};

    /**
     * All springs in the world. To add a spring to the world, use {{#crossLink "World/addSpring:method"}}{{/crossLink}}.
     *
     * @property springs
     * @type {Array}
     */
    this.springs = [];

    /**
     * All bodies in the world. To add a body to the world, use {{#crossLink "World/addBody:method"}}{{/crossLink}}.
     * @property {Array} bodies
     */
    this.bodies = [];

    /**
     * Disabled body collision pairs. See {{#crossLink "World/disableBodyCollision:method"}}.
     * @private
     * @property {Array} disabledBodyCollisionPairs
     */
    this.disabledBodyCollisionPairs = [];

    /**
     * The solver used to satisfy constraints and contacts. Default is {{#crossLink "GSSolver"}}{{/crossLink}}.
     * @property {Solver} solver
     */
    this.solver = options.solver || new GSSolver();

    /**
     * The narrowphase to use to generate contacts.
     *
     * @property narrowphase
     * @type {Narrowphase}
     */
    this.narrowphase = new Narrowphase(this);

    /**
     * The island manager of this world.
     * @property {IslandManager} islandManager
     */
    this.islandManager = new IslandManager();

    /**
     * Gravity in the world. This is applied on all bodies in the beginning of each step().
     *
     * @property gravity
     * @type {Array}
     */
    this.gravity = vec2.fromValues(0, -9.78);
    if(options.gravity){
        vec2.copy(this.gravity, options.gravity);
    }

    /**
     * Gravity to use when approximating the friction max force (mu*mass*gravity).
     * @property {Number} frictionGravity
     */
    this.frictionGravity = vec2.length(this.gravity) || 10;

    /**
     * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.
     * @property {Boolean} useWorldGravityAsFrictionGravity
     */
    this.useWorldGravityAsFrictionGravity = true;

    /**
     * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.
     * @property {Boolean} useFrictionGravityOnZeroGravity
     */
    this.useFrictionGravityOnZeroGravity = true;

    /**
     * Whether to do timing measurements during the step() or not.
     *
     * @property doPofiling
     * @type {Boolean}
     */
    this.doProfiling = options.doProfiling || false;

    /**
     * How many millisecconds the last step() took. This is updated each step if .doProfiling is set to true.
     *
     * @property lastStepTime
     * @type {Number}
     */
    this.lastStepTime = 0.0;

    /**
     * The broadphase algorithm to use.
     *
     * @property broadphase
     * @type {Broadphase}
     */
    this.broadphase = options.broadphase || new SAPBroadphase();
    this.broadphase.setWorld(this);

    /**
     * User-added constraints.
     *
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    /**
     * Dummy default material in the world, used in .defaultContactMaterial
     * @property {Material} defaultMaterial
     */
    this.defaultMaterial = new Material();

    /**
     * The default contact material to use, if no contact material was set for the colliding materials.
     * @property {ContactMaterial} defaultContactMaterial
     */
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial,this.defaultMaterial);

    /**
     * For keeping track of what time step size we used last step
     * @property lastTimeStep
     * @type {Number}
     */
    this.lastTimeStep = 1/60;

    /**
     * Enable to automatically apply spring forces each step.
     * @property applySpringForces
     * @type {Boolean}
     */
    this.applySpringForces = true;

    /**
     * Enable to automatically apply body damping each step.
     * @property applyDamping
     * @type {Boolean}
     */
    this.applyDamping = true;

    /**
     * Enable to automatically apply gravity each step.
     * @property applyGravity
     * @type {Boolean}
     */
    this.applyGravity = true;

    /**
     * Enable/disable constraint solving in each step.
     * @property solveConstraints
     * @type {Boolean}
     */
    this.solveConstraints = true;

    /**
     * The ContactMaterials added to the World.
     * @property contactMaterials
     * @type {Array}
     */
    this.contactMaterials = [];

    /**
     * World time.
     * @property time
     * @type {Number}
     */
    this.time = 0.0;

    /**
     * Is true during the step().
     * @property {Boolean} stepping
     */
    this.stepping = false;

    /**
     * Bodies that are scheduled to be removed at the end of the step.
     * @property {Array} bodiesToBeRemoved
     * @private
     */
    this.bodiesToBeRemoved = [];

    this.fixedStepTime = 0.0;

    /**
     * Whether to enable island splitting. Island splitting can be an advantage for many things, including solver performance. See {{#crossLink "IslandManager"}}{{/crossLink}}.
     * @property {Boolean} islandSplit
     */
    this.islandSplit = typeof(options.islandSplit)!=="undefined" ? !!options.islandSplit : false;

    /**
     * Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
     * @property emitImpactEvent
     * @type {Boolean}
     */
    this.emitImpactEvent = true;

    // Id counters
    this._constraintIdCounter = 0;
    this._bodyIdCounter = 0;

    /**
     * Fired after the step().
     * @event postStep
     */
    this.postStepEvent = {
        type : "postStep",
    };

    /**
     * Fired when a body is added to the world.
     * @event addBody
     * @param {Body} body
     */
    this.addBodyEvent = {
        type : "addBody",
        body : null
    };

    /**
     * Fired when a body is removed from the world.
     * @event removeBody
     * @param {Body} body
     */
    this.removeBodyEvent = {
        type : "removeBody",
        body : null
    };

    /**
     * Fired when a spring is added to the world.
     * @event addSpring
     * @param {Spring} spring
     */
    this.addSpringEvent = {
        type : "addSpring",
        spring : null,
    };

    /**
     * Fired when a first contact is created between two bodies. This event is fired after the step has been done.
     * @event impact
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    this.impactEvent = {
        type: "impact",
        bodyA : null,
        bodyB : null,
        shapeA : null,
        shapeB : null,
        contactEquation : null,
    };

    /**
     * Fired after the Broadphase has collected collision pairs in the world.
     * Inside the event handler, you can modify the pairs array as you like, to
     * prevent collisions between objects that you don't want.
     * @event postBroadphase
     * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.
     */
    this.postBroadphaseEvent = {
        type:"postBroadphase",
        pairs:null,
    };

    /**
     * How to deactivate bodies during simulation. Possible modes are: {{#crossLink "World/NO_SLEEPING:property"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink "World/BODY_SLEEPING:property"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink "World/ISLAND_SLEEPING:property"}}World.ISLAND_SLEEPING{{/crossLink}}.
     * If sleeping is enabled, you might need to {{#crossLink "Body/wakeUp:method"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink "Body/allowSleep:property"}}Body.allowSleep{{/crossLink}}.
     * @property sleepMode
     * @type {number}
     * @default World.NO_SLEEPING
     */
    this.sleepMode = World.NO_SLEEPING;

    /**
     * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.
     * @event beginContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     * @param {Array} contactEquations
     */
    this.beginContactEvent = {
        type:"beginContact",
        shapeA : null,
        shapeB : null,
        bodyA : null,
        bodyB : null,
        contactEquations : [],
    };

    /**
     * Fired when two shapes stop overlapping, after the narrowphase (during step).
     * @event endContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     * @param {Array} contactEquations
     */
    this.endContactEvent = {
        type:"endContact",
        shapeA : null,
        shapeB : null,
        bodyA : null,
        bodyB : null,
    };

    /**
     * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.
     * @event preSolve
     * @param {Array} contactEquations  An array of contacts to be solved.
     * @param {Array} frictionEquations An array of friction equations to be solved.
     */
    this.preSolveEvent = {
        type:"preSolve",
        contactEquations:null,
        frictionEquations:null,
    };

    // For keeping track of overlapping shapes
    this.overlappingShapesLastState = { keys:[] };
    this.overlappingShapesCurrentState = { keys:[] };

    this.overlapKeeper = new OverlapKeeper();
}
World.prototype = new Object(EventEmitter.prototype);
World.prototype.constructor = World;

/**
 * Never deactivate bodies.
 * @static
 * @property {number} NO_SLEEPING
 */
World.NO_SLEEPING = 1;

/**
 * Deactivate individual bodies if they are sleepy.
 * @static
 * @property {number} BODY_SLEEPING
 */
World.BODY_SLEEPING = 2;

/**
 * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink "World/islandSplit:property"}}.islandSplit{{/crossLink}} for this to work.
 * @static
 * @property {number} ISLAND_SLEEPING
 */
World.ISLAND_SLEEPING = 4;

/**
 * Add a constraint to the simulation.
 *
 * @method addConstraint
 * @param {Constraint} c
 */
World.prototype.addConstraint = function(c){
    this.constraints.push(c);
};

/**
 * Add a ContactMaterial to the simulation.
 * @method addContactMaterial
 * @param {ContactMaterial} contactMaterial
 */
World.prototype.addContactMaterial = function(contactMaterial){
    this.contactMaterials.push(contactMaterial);
};

/**
 * Removes a contact material
 *
 * @method removeContactMaterial
 * @param {ContactMaterial} cm
 */
World.prototype.removeContactMaterial = function(cm){
    var idx = this.contactMaterials.indexOf(cm);
    if(idx!==-1){
        Utils.splice(this.contactMaterials,idx,1);
    }
};

/**
 * Get a contact material given two materials
 * @method getContactMaterial
 * @param {Material} materialA
 * @param {Material} materialB
 * @return {ContactMaterial} The matching ContactMaterial, or false on fail.
 * @todo Use faster hash map to lookup from material id's
 */
World.prototype.getContactMaterial = function(materialA,materialB){
    var cmats = this.contactMaterials;
    for(var i=0, N=cmats.length; i!==N; i++){
        var cm = cmats[i];
        if( (cm.materialA.id === materialA.id) && (cm.materialB.id === materialB.id) ||
            (cm.materialA.id === materialB.id) && (cm.materialB.id === materialA.id) ){
            return cm;
        }
    }
    return false;
};

/**
 * Removes a constraint
 *
 * @method removeConstraint
 * @param {Constraint} c
 */
World.prototype.removeConstraint = function(c){
    var idx = this.constraints.indexOf(c);
    if(idx!==-1){
        Utils.splice(this.constraints,idx,1);
    }
};

var step_r = vec2.create(),
    step_runit = vec2.create(),
    step_u = vec2.create(),
    step_f = vec2.create(),
    step_fhMinv = vec2.create(),
    step_velodt = vec2.create(),
    step_mg = vec2.create(),
    xiw = vec2.fromValues(0,0),
    xjw = vec2.fromValues(0,0),
    zero = vec2.fromValues(0,0),
    interpvelo = vec2.fromValues(0,0);

/**
 * Step the physics world forward in time.
 *
 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
 *
 * @method step
 * @param {Number} dt                       The fixed time step size to use.
 * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.
 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
 *
 * @example
 *     // fixed timestepping without interpolation
 *     var world = new World();
 *     world.step(0.01);
 *
 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
 */
World.prototype.step = function(dt,timeSinceLastCalled,maxSubSteps){
    maxSubSteps = maxSubSteps || 10;
    timeSinceLastCalled = timeSinceLastCalled || 0;

    if(timeSinceLastCalled === 0){ // Fixed, simple stepping

        this.internalStep(dt);

        // Increment time
        this.time += dt;

    } else {

        // Compute the number of fixed steps we should have taken since the last step
        var internalSteps = Math.floor( (this.time+timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
        internalSteps = Math.min(internalSteps,maxSubSteps);

        // Do some fixed steps to catch up
        var t0 = performance.now();
        for(var i=0; i!==internalSteps; i++){
            this.internalStep(dt);
            if(performance.now() - t0 > dt*1000){
                // We are slower than real-time. Better bail out.
                break;
            }
        }

        // Increment internal clock
        this.time += timeSinceLastCalled;

        // Compute "Left over" time step
        var h = this.time % dt;
        var h_div_dt = h/dt;

        for(var j=0; j!==this.bodies.length; j++){
            var b = this.bodies[j];
            if(b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING){
                // Interpolate
                vec2.sub(interpvelo, b.position, b.previousPosition);
                vec2.scale(interpvelo, interpvelo, h_div_dt);
                vec2.add(b.interpolatedPosition, b.position, interpvelo);

                b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;
            } else {
                // For static bodies, just copy. Who else will do it?
                vec2.copy(b.interpolatedPosition, b.position);
                b.interpolatedAngle = b.angle;
            }
        }
    }
};

var endOverlaps = [];

/**
 * Make a fixed step.
 * @method internalStep
 * @param  {number} dt
 * @private
 */
World.prototype.internalStep = function(dt){
    this.stepping = true;

    var that = this,
        doProfiling = this.doProfiling,
        Nsprings = this.springs.length,
        springs = this.springs,
        bodies = this.bodies,
        g = this.gravity,
        solver = this.solver,
        Nbodies = this.bodies.length,
        broadphase = this.broadphase,
        np = this.narrowphase,
        constraints = this.constraints,
        t0, t1,
        fhMinv = step_fhMinv,
        velodt = step_velodt,
        mg = step_mg,
        scale = vec2.scale,
        add = vec2.add,
        rotate = vec2.rotate,
        islandManager = this.islandManager;

    this.overlapKeeper.tick();

    this.lastTimeStep = dt;

    if(doProfiling){
        t0 = performance.now();
    }

    // Update approximate friction gravity.
    if(this.useWorldGravityAsFrictionGravity){
        var gravityLen = vec2.length(this.gravity);
        if(!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)){
            // Nonzero gravity. Use it.
            this.frictionGravity = gravityLen;
        }
    }

    // Add gravity to bodies
    if(this.applyGravity){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i],
                fi = b.force;
            if(b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING){
                continue;
            }
            vec2.scale(mg,g,b.mass*b.gravityScale); // F=m*g
            add(fi,fi,mg);
        }
    }

    // Add spring forces
    if(this.applySpringForces){
        for(var i=0; i!==Nsprings; i++){
            var s = springs[i];
            s.applyForce();
        }
    }

    if(this.applyDamping){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i];
            if(b.type === Body.DYNAMIC){
                b.applyDamping(dt);
            }
        }
    }

    // Broadphase
    var result = broadphase.getCollisionPairs(this);

    // Remove ignored collision pairs
    var ignoredPairs = this.disabledBodyCollisionPairs;
    for(var i=ignoredPairs.length-2; i>=0; i-=2){
        for(var j=result.length-2; j>=0; j-=2){
            if( (ignoredPairs[i]   === result[j] && ignoredPairs[i+1] === result[j+1]) ||
                (ignoredPairs[i+1] === result[j] && ignoredPairs[i]   === result[j+1])){
                result.splice(j,2);
            }
        }
    }

    // Remove constrained pairs with collideConnected == false
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        if(!c.collideConnected){
            for(var j=result.length-2; j>=0; j-=2){
                if( (c.bodyA === result[j] && c.bodyB === result[j+1]) ||
                    (c.bodyB === result[j] && c.bodyA === result[j+1])){
                    result.splice(j,2);
                }
            }
        }
    }

    // postBroadphase event
    this.postBroadphaseEvent.pairs = result;
    this.emit(this.postBroadphaseEvent);

    // Narrowphase
    np.reset(this);
    for(var i=0, Nresults=result.length; i!==Nresults; i+=2){
        var bi = result[i],
            bj = result[i+1];

        // Loop over all shapes of body i
        for(var k=0, Nshapesi=bi.shapes.length; k!==Nshapesi; k++){
            var si = bi.shapes[k],
                xi = bi.shapeOffsets[k],
                ai = bi.shapeAngles[k];

            // All shapes of body j
            for(var l=0, Nshapesj=bj.shapes.length; l!==Nshapesj; l++){
                var sj = bj.shapes[l],
                    xj = bj.shapeOffsets[l],
                    aj = bj.shapeAngles[l];

                var cm = this.defaultContactMaterial;
                if(si.material && sj.material){
                    var tmp = this.getContactMaterial(si.material,sj.material);
                    if(tmp){
                        cm = tmp;
                    }
                }

                this.runNarrowphase(np,bi,si,xi,ai,bj,sj,xj,aj,cm,this.frictionGravity);
            }
        }
    }

    // Wake up bodies
    for(var i=0; i!==Nbodies; i++){
        var body = bodies[i];
        if(body._wakeUpAfterNarrowphase){
            body.wakeUp();
            body._wakeUpAfterNarrowphase = false;
        }
    }

    // Emit end overlap events
    if(this.has('endContact')){
        this.overlapKeeper.getEndOverlaps(endOverlaps);
        var e = this.endContactEvent;
        var l = endOverlaps.length;
        while(l--){
            var data = endOverlaps[l];
            e.shapeA = data.shapeA;
            e.shapeB = data.shapeB;
            e.bodyA = data.bodyA;
            e.bodyB = data.bodyB;
            this.emit(e);
        }
    }

    var preSolveEvent = this.preSolveEvent;
    preSolveEvent.contactEquations = np.contactEquations;
    preSolveEvent.frictionEquations = np.frictionEquations;
    this.emit(preSolveEvent);

    // update constraint equations
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        constraints[i].update();
    }

    if(np.contactEquations.length || np.frictionEquations.length || constraints.length){
        if(this.islandSplit){
            // Split into islands
            islandManager.equations.length = 0;
            Utils.appendArray(islandManager.equations, np.contactEquations);
            Utils.appendArray(islandManager.equations, np.frictionEquations);
            for(i=0; i!==Nconstraints; i++){
                Utils.appendArray(islandManager.equations, constraints[i].equations);
            }
            islandManager.split(this);

            for(var i=0; i!==islandManager.islands.length; i++){
                var island = islandManager.islands[i];
                if(island.equations.length){
                    solver.solveIsland(dt,island);
                }
            }

        } else {

            // Add contact equations to solver
            solver.addEquations(np.contactEquations);
            solver.addEquations(np.frictionEquations);

            // Add user-defined constraint equations
            for(i=0; i!==Nconstraints; i++){
                solver.addEquations(constraints[i].equations);
            }

            if(this.solveConstraints){
                solver.solve(dt,this);
            }

            solver.removeAllEquations();
        }
    }

    // Step forward
    for(var i=0; i!==Nbodies; i++){
        var body = bodies[i];

        if(body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC){
            body.integrate(dt);
        }
    }

    // Reset force
    for(var i=0; i!==Nbodies; i++){
        bodies[i].setZeroForce();
    }

    if(doProfiling){
        t1 = performance.now();
        that.lastStepTime = t1-t0;
    }

    // Emit impact event
    if(this.emitImpactEvent && this.has('impact')){
        var ev = this.impactEvent;
        for(var i=0; i!==np.contactEquations.length; i++){
            var eq = np.contactEquations[i];
            if(eq.firstImpact){
                ev.bodyA = eq.bodyA;
                ev.bodyB = eq.bodyB;
                ev.shapeA = eq.shapeA;
                ev.shapeB = eq.shapeB;
                ev.contactEquation = eq;
                this.emit(ev);
            }
        }
    }

    // Sleeping update
    if(this.sleepMode === World.BODY_SLEEPING){
        for(i=0; i!==Nbodies; i++){
            bodies[i].sleepTick(this.time, false, dt);
        }
    } else if(this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit){

        // Tell all bodies to sleep tick but dont sleep yet
        for(i=0; i!==Nbodies; i++){
            bodies[i].sleepTick(this.time, true, dt);
        }

        // Sleep islands
        for(var i=0; i<this.islandManager.islands.length; i++){
            var island = this.islandManager.islands[i];
            if(island.wantsToSleep()){
                island.sleep();
            }
        }
    }

    this.stepping = false;

    // Remove bodies that are scheduled for removal
    if(this.bodiesToBeRemoved.length){
        for(var i=0; i!==this.bodiesToBeRemoved.length; i++){
            this.removeBody(this.bodiesToBeRemoved[i]);
        }
        this.bodiesToBeRemoved.length = 0;
    }

    this.emit(this.postStepEvent);
};

/**
 * Runs narrowphase for the shape pair i and j.
 * @method runNarrowphase
 * @param  {Narrowphase} np
 * @param  {Body} bi
 * @param  {Shape} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Shape} sj
 * @param  {Array} xj
 * @param  {Number} aj
 * @param  {Number} mu
 */
World.prototype.runNarrowphase = function(np,bi,si,xi,ai,bj,sj,xj,aj,cm,glen){

    // Check collision groups and masks
    if(!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)){
        return;
    }

    // Get world position and angle of each shape
    vec2.rotate(xiw, xi, bi.angle);
    vec2.rotate(xjw, xj, bj.angle);
    vec2.add(xiw, xiw, bi.position);
    vec2.add(xjw, xjw, bj.position);
    var aiw = ai + bi.angle;
    var ajw = aj + bj.angle;

    np.enableFriction = cm.friction > 0;
    np.frictionCoefficient = cm.friction;
    var reducedMass;
    if(bi.type === Body.STATIC || bi.type === Body.KINEMATIC){
        reducedMass = bj.mass;
    } else if(bj.type === Body.STATIC || bj.type === Body.KINEMATIC){
        reducedMass = bi.mass;
    } else {
        reducedMass = (bi.mass*bj.mass)/(bi.mass+bj.mass);
    }
    np.slipForce = cm.friction*glen*reducedMass;
    np.restitution = cm.restitution;
    np.surfaceVelocity = cm.surfaceVelocity;
    np.frictionStiffness = cm.frictionStiffness;
    np.frictionRelaxation = cm.frictionRelaxation;
    np.stiffness = cm.stiffness;
    np.relaxation = cm.relaxation;
    np.contactSkinSize = cm.contactSkinSize;
    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

    var resolver = np[si.type | sj.type],
        numContacts = 0;
    if (resolver) {
        var sensor = si.sensor || sj.sensor;
        var numFrictionBefore = np.frictionEquations.length;
        if (si.type < sj.type) {
            numContacts = resolver.call(np, bi,si,xiw,aiw, bj,sj,xjw,ajw, sensor);
        } else {
            numContacts = resolver.call(np, bj,sj,xjw,ajw, bi,si,xiw,aiw, sensor);
        }
        var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;

        if(numContacts){

            if( bi.allowSleep &&
                bi.type === Body.DYNAMIC &&
                bi.sleepState  === Body.SLEEPING &&
                bj.sleepState  === Body.AWAKE &&
                bj.type !== Body.STATIC
            ){
                var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity,2);
                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
                if(speedSquaredB >= speedLimitSquaredB*2){
                    bi._wakeUpAfterNarrowphase = true;
                }
            }

            if( bj.allowSleep &&
                bj.type === Body.DYNAMIC &&
                bj.sleepState  === Body.SLEEPING &&
                bi.sleepState  === Body.AWAKE &&
                bi.type !== Body.STATIC
            ){
                var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity,2);
                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
                if(speedSquaredA >= speedLimitSquaredA*2){
                    bj._wakeUpAfterNarrowphase = true;
                }
            }

            this.overlapKeeper.setOverlapping(bi, si, bj, sj);
            if(this.has('beginContact') && this.overlapKeeper.isNewOverlap(si, sj)){

                // Report new shape overlap
                var e = this.beginContactEvent;
                e.shapeA = si;
                e.shapeB = sj;
                e.bodyA = bi;
                e.bodyB = bj;

                // Reset contact equations
                e.contactEquations.length = 0;

                if(typeof(numContacts)==="number"){
                    for(var i=np.contactEquations.length-numContacts; i<np.contactEquations.length; i++){
                        e.contactEquations.push(np.contactEquations[i]);
                    }
                }

                this.emit(e);
            }

            // divide the max friction force by the number of contacts
            if(typeof(numContacts)==="number" && numFrictionEquations > 1){ // Why divide by 1?
                for(var i=np.frictionEquations.length-numFrictionEquations; i<np.frictionEquations.length; i++){
                    var f = np.frictionEquations[i];
                    f.setSlipForce(f.getSlipForce() / numFrictionEquations);
                }
            }
        }
    }

};

/**
 * Add a spring to the simulation
 *
 * @method addSpring
 * @param {Spring} s
 */
World.prototype.addSpring = function(s){
    this.springs.push(s);
    this.addSpringEvent.spring = s;
    this.emit(this.addSpringEvent);
};

/**
 * Remove a spring
 *
 * @method removeSpring
 * @param {Spring} s
 */
World.prototype.removeSpring = function(s){
    var idx = this.springs.indexOf(s);
    if(idx!==-1){
        Utils.splice(this.springs,idx,1);
    }
};

/**
 * Add a body to the simulation
 *
 * @method addBody
 * @param {Body} body
 *
 * @example
 *     var world = new World(),
 *         body = new Body();
 *     world.addBody(body);
 * @todo What if this is done during step?
 */
World.prototype.addBody = function(body){
    if(this.bodies.indexOf(body) === -1){
        this.bodies.push(body);
        body.world = this;
        this.addBodyEvent.body = body;
        this.emit(this.addBodyEvent);
    }
};

/**
 * Remove a body from the simulation. If this method is called during step(), the body removal is scheduled to after the step.
 *
 * @method removeBody
 * @param {Body} body
 */
World.prototype.removeBody = function(body){
    if(this.stepping){
        this.bodiesToBeRemoved.push(body);
    } else {
        body.world = null;
        var idx = this.bodies.indexOf(body);
        if(idx!==-1){
            Utils.splice(this.bodies,idx,1);
            this.removeBodyEvent.body = body;
            body.resetConstraintVelocity();
            this.emit(this.removeBodyEvent);
        }
    }
};

/**
 * Get a body by its id.
 * @method getBodyById
 * @return {Body|Boolean} The body, or false if it was not found.
 */
World.prototype.getBodyById = function(id){
    var bodies = this.bodies;
    for(var i=0; i<bodies.length; i++){
        var b = bodies[i];
        if(b.id === id){
            return b;
        }
    }
    return false;
};

/**
 * Disable collision between two bodies
 * @method disableCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
World.prototype.disableBodyCollision = function(bodyA,bodyB){
    this.disabledBodyCollisionPairs.push(bodyA,bodyB);
};

/**
 * Enable collisions between the given two bodies
 * @method enableCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
World.prototype.enableBodyCollision = function(bodyA,bodyB){
    var pairs = this.disabledBodyCollisionPairs;
    for(var i=0; i<pairs.length; i+=2){
        if((pairs[i] === bodyA && pairs[i+1] === bodyB) || (pairs[i+1] === bodyA && pairs[i] === bodyB)){
            pairs.splice(i,2);
            return;
        }
    }
};


function v2a(v){
    if(!v){
        return v;
    }
    return [v[0],v[1]];
}

function extend(a,b){
    for(var key in b){
        a[key] = b[key];
    }
}

function contactMaterialToJSON(cm){
    return {
        id : cm.id,
        materialA :             cm.materialA.id,
        materialB :             cm.materialB.id,
        friction :              cm.friction,
        restitution :           cm.restitution,
        stiffness :             cm.stiffness,
        relaxation :            cm.relaxation,
        frictionStiffness :     cm.frictionStiffness,
        frictionRelaxation :    cm.frictionRelaxation,
    };
}

/**
 * Resets the World, removes all bodies, constraints and springs.
 *
 * @method clear
 */
World.prototype.clear = function(){

    this.time = 0;
    this.fixedStepTime = 0;

    // Remove all solver equations
    if(this.solver && this.solver.equations.length){
        this.solver.removeAllEquations();
    }

    // Remove all constraints
    var cs = this.constraints;
    for(var i=cs.length-1; i>=0; i--){
        this.removeConstraint(cs[i]);
    }

    // Remove all bodies
    var bodies = this.bodies;
    for(var i=bodies.length-1; i>=0; i--){
        this.removeBody(bodies[i]);
    }

    // Remove all springs
    var springs = this.springs;
    for(var i=springs.length-1; i>=0; i--){
        this.removeSpring(springs[i]);
    }

    // Remove all contact materials
    var cms = this.contactMaterials;
    for(var i=cms.length-1; i>=0; i--){
        this.removeContactMaterial(cms[i]);
    }

    World.apply(this);
};

/**
 * Get a copy of this World instance
 * @method clone
 * @return {World}
 */
World.prototype.clone = function(){
    var world = new World();
    world.fromJSON(this.toJSON());
    return world;
};

var hitTest_tmp1 = vec2.create(),
    hitTest_zero = vec2.fromValues(0,0),
    hitTest_tmp2 = vec2.fromValues(0,0);

/**
 * Test if a world point overlaps bodies
 * @method hitTest
 * @param  {Array}  worldPoint  Point to use for intersection tests
 * @param  {Array}  bodies      A list of objects to check for intersection
 * @param  {Number} precision   Used for matching against particles and lines. Adds some margin to these infinitesimal objects.
 * @return {Array}              Array of bodies that overlap the point
 */
World.prototype.hitTest = function(worldPoint,bodies,precision){
    precision = precision || 0;

    // Create a dummy particle body with a particle shape to test against the bodies
    var pb = new Body({ position:worldPoint }),
        ps = new Particle(),
        px = worldPoint,
        pa = 0,
        x = hitTest_tmp1,
        zero = hitTest_zero,
        tmp = hitTest_tmp2;
    pb.addShape(ps);

    var n = this.narrowphase,
        result = [];

    // Check bodies
    for(var i=0, N=bodies.length; i!==N; i++){
        var b = bodies[i];
        for(var j=0, NS=b.shapes.length; j!==NS; j++){
            var s = b.shapes[j],
                offset = b.shapeOffsets[j] || zero,
                angle = b.shapeAngles[j] || 0.0;

            // Get shape world position + angle
            vec2.rotate(x, offset, b.angle);
            vec2.add(x, x, b.position);
            var a = angle + b.angle;

            if( (s instanceof Circle    && n.circleParticle  (b,s,x,a,     pb,ps,px,pa, true)) ||
                (s instanceof Convex    && n.particleConvex  (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Plane     && n.particlePlane   (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Capsule   && n.particleCapsule (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Particle  && vec2.squaredLength(vec2.sub(tmp,x,worldPoint)) < precision*precision)
                ){
                result.push(b);
            }
        }
    }

    return result;
};

/**
 * Sets the Equation parameters for all constraints and contact materials.
 * @method setGlobalEquationParameters
 * @param {object} [parameters]
 * @param {Number} [parameters.relaxation]
 * @param {Number} [parameters.stiffness]
 */
World.prototype.setGlobalEquationParameters = function(parameters){
    parameters = parameters || {};

    // Set for all constraints
    for(var i=0; i !== this.constraints.length; i++){
        var c = this.constraints[i];
        for(var j=0; j !== c.equations.length; j++){
            var eq = c.equations[j];
            if(typeof(parameters.stiffness) !== "undefined"){
                eq.stiffness = parameters.stiffness;
            }
            if(typeof(parameters.relaxation) !== "undefined"){
                eq.relaxation = parameters.relaxation;
            }
            eq.needsUpdate = true;
        }
    }

    // Set for all contact materials
    for(var i=0; i !== this.contactMaterials.length; i++){
        var c = this.contactMaterials[i];
        if(typeof(parameters.stiffness) !== "undefined"){
            c.stiffness = parameters.stiffness;
            c.frictionStiffness = parameters.stiffness;
        }
        if(typeof(parameters.relaxation) !== "undefined"){
            c.relaxation = parameters.relaxation;
            c.frictionRelaxation = parameters.relaxation;
        }
    }

    // Set for default contact material
    var c = this.defaultContactMaterial;
    if(typeof(parameters.stiffness) !== "undefined"){
        c.stiffness = parameters.stiffness;
        c.frictionStiffness = parameters.stiffness;
    }
    if(typeof(parameters.relaxation) !== "undefined"){
        c.relaxation = parameters.relaxation;
        c.frictionRelaxation = parameters.relaxation;
    }
};

/**
 * Set the stiffness for all equations and contact materials.
 * @method setGlobalStiffness
 * @param {Number} stiffness
 */
World.prototype.setGlobalStiffness = function(stiffness){
    this.setGlobalEquationParameters({
        stiffness: stiffness
    });
};

/**
 * Set the relaxation for all equations and contact materials.
 * @method setGlobalRelaxation
 * @param {Number} relaxation
 */
World.prototype.setGlobalRelaxation = function(relaxation){
    this.setGlobalEquationParameters({
        relaxation: relaxation
    });
};

var tmpRay = new Ray();

/**
 * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
 * @method raycastAll
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {Function} callback
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAll = function(from, to, options, callback){
    options.mode = Ray.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
 * @method raycastAny
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAny = function(from, to, options, result){
    options.mode = Ray.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and return information of the closest hit.
 * @method raycastClosest
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastClosest = function(from, to, options, result){
    options.mode = Ray.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};
},{"../../package.json":6,"../collision/Broadphase":8,"../collision/NaiveBroadphase":10,"../collision/Narrowphase":11,"../collision/Ray":12,"../collision/SAPBroadphase":14,"../constraints/Constraint":15,"../constraints/DistanceConstraint":16,"../constraints/GearConstraint":17,"../constraints/LockConstraint":18,"../constraints/PrismaticConstraint":19,"../constraints/RevoluteConstraint":20,"../events/EventEmitter":27,"../material/ContactMaterial":28,"../material/Material":29,"../math/vec2":31,"../objects/Body":32,"../objects/LinearSpring":33,"../objects/RotationalSpring":34,"../shapes/Capsule":37,"../shapes/Circle":38,"../shapes/Convex":39,"../shapes/Line":41,"../shapes/Particle":42,"../shapes/Plane":43,"../shapes/Rectangle":44,"../shapes/Shape":45,"../solver/GSSolver":46,"../solver/Solver":47,"../utils/OverlapKeeper":48,"../utils/Utils":50,"./IslandManager":52}]},{},[36])
(36)
});;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/Lau/www/svjelly/libs/poly2tri/dist/poly2tri.js":[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.poly2tri=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports={"version": "1.3.5"}
},{}],2:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:11 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */


// -------------------------------------------------------------------------Node

/**
 * Advancing front node
 * @constructor
 * @private
 * @struct
 * @param {!XY} p - Point
 * @param {Triangle=} t triangle (optional)
 */
var Node = function(p, t) {
    /** @type {XY} */
    this.point = p;

    /** @type {Triangle|null} */
    this.triangle = t || null;

    /** @type {Node|null} */
    this.next = null;
    /** @type {Node|null} */
    this.prev = null;

    /** @type {number} */
    this.value = p.x;
};

// ---------------------------------------------------------------AdvancingFront
/**
 * @constructor
 * @private
 * @struct
 * @param {Node} head
 * @param {Node} tail
 */
var AdvancingFront = function(head, tail) {
    /** @type {Node} */
    this.head_ = head;
    /** @type {Node} */
    this.tail_ = tail;
    /** @type {Node} */
    this.search_node_ = head;
};

/** @return {Node} */
AdvancingFront.prototype.head = function() {
    return this.head_;
};

/** @param {Node} node */
AdvancingFront.prototype.setHead = function(node) {
    this.head_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.tail = function() {
    return this.tail_;
};

/** @param {Node} node */
AdvancingFront.prototype.setTail = function(node) {
    this.tail_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.search = function() {
    return this.search_node_;
};

/** @param {Node} node */
AdvancingFront.prototype.setSearch = function(node) {
    this.search_node_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.findSearchNode = function(/*x*/) {
    // TODO: implement BST index
    return this.search_node_;
};

/**
 * @param {number} x value
 * @return {Node}
 */
AdvancingFront.prototype.locateNode = function(x) {
    var node = this.search_node_;

    /* jshint boss:true */
    if (x < node.value) {
        while (node = node.prev) {
            if (x >= node.value) {
                this.search_node_ = node;
                return node;
            }
        }
    } else {
        while (node = node.next) {
            if (x < node.value) {
                this.search_node_ = node.prev;
                return node.prev;
            }
        }
    }
    return null;
};

/**
 * @param {!XY} point - Point
 * @return {Node}
 */
AdvancingFront.prototype.locatePoint = function(point) {
    var px = point.x;
    var node = this.findSearchNode(px);
    var nx = node.point.x;

    if (px === nx) {
        // Here we are comparing point references, not values
        if (point !== node.point) {
            // We might have two nodes with same x value for a short time
            if (point === node.prev.point) {
                node = node.prev;
            } else if (point === node.next.point) {
                node = node.next;
            } else {
                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
            }
        }
    } else if (px < nx) {
        /* jshint boss:true */
        while (node = node.prev) {
            if (point === node.point) {
                break;
            }
        }
    } else {
        while (node = node.next) {
            if (point === node.point) {
                break;
            }
        }
    }

    if (node) {
        this.search_node_ = node;
    }
    return node;
};


// ----------------------------------------------------------------------Exports

module.exports = AdvancingFront;
module.exports.Node = Node;


},{}],3:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 *
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Function added in the JavaScript version (was not present in the c++ version)
 */

/**
 * assert and throw an exception.
 *
 * @private
 * @param {boolean} condition   the condition which is asserted
 * @param {string} message      the message which is display is condition is falsy
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || "Assert Failed");
    }
}
module.exports = assert;



},{}],4:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = _dereq_('./xy');

// ------------------------------------------------------------------------Point
/**
 * Construct a point
 * @example
 *      var point = new poly2tri.Point(150, 150);
 * @public
 * @constructor
 * @struct
 * @param {number=} x    coordinate (0 if undefined)
 * @param {number=} y    coordinate (0 if undefined)
 */
var Point = function(x, y) {
    /**
     * @type {number}
     * @expose
     */
    this.x = +x || 0;
    /**
     * @type {number}
     * @expose
     */
    this.y = +y || 0;

    // All extra fields added to Point are prefixed with _p2t_
    // to avoid collisions if custom Point class is used.

    /**
     * The edges this point constitutes an upper ending point
     * @private
     * @type {Array.<Edge>}
     */
    this._p2t_edge_list = null;
};

/**
 * For pretty printing
 * @example
 *      "p=" + new poly2tri.Point(5,42)
 *      //  "p=(5;42)"
 * @returns {string} <code>"(x;y)"</code>
 */
Point.prototype.toString = function() {
    return xy.toStringBase(this);
};

/**
 * JSON output, only coordinates
 * @example
 *      JSON.stringify(new poly2tri.Point(1,2))
 *      //  '{"x":1,"y":2}'
 */
Point.prototype.toJSON = function() {
    return { x: this.x, y: this.y };
};

/**
 * Creates a copy of this Point object.
 * @return {Point} new cloned point
 */
Point.prototype.clone = function() {
    return new Point(this.x, this.y);
};

/**
 * Set this Point instance to the origo. <code>(0; 0)</code>
 * @return {Point} this (for chaining)
 */
Point.prototype.set_zero = function() {
    this.x = 0.0;
    this.y = 0.0;
    return this; // for chaining
};

/**
 * Set the coordinates of this instance.
 * @param {number} x   coordinate
 * @param {number} y   coordinate
 * @return {Point} this (for chaining)
 */
Point.prototype.set = function(x, y) {
    this.x = +x || 0;
    this.y = +y || 0;
    return this; // for chaining
};

/**
 * Negate this Point instance. (component-wise)
 * @return {Point} this (for chaining)
 */
Point.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this; // for chaining
};

/**
 * Add another Point object to this instance. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.add = function(n) {
    this.x += n.x;
    this.y += n.y;
    return this; // for chaining
};

/**
 * Subtract this Point instance with another point given. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.sub = function(n) {
    this.x -= n.x;
    this.y -= n.y;
    return this; // for chaining
};

/**
 * Multiply this Point instance by a scalar. (component-wise)
 * @param {number} s   scalar.
 * @return {Point} this (for chaining)
 */
Point.prototype.mul = function(s) {
    this.x *= s;
    this.y *= s;
    return this; // for chaining
};

/**
 * Return the distance of this Point instance from the origo.
 * @return {number} distance
 */
Point.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};

/**
 * Normalize this Point instance (as a vector).
 * @return {number} The original distance of this instance from the origo.
 */
Point.prototype.normalize = function() {
    var len = this.length();
    this.x /= len;
    this.y /= len;
    return len;
};

/**
 * Test this Point object with another for equality.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.
 */
Point.prototype.equals = function(p) {
    return this.x === p.x && this.y === p.y;
};


// -----------------------------------------------------Point ("static" methods)

/**
 * Negate a point component-wise and return the result as a new Point object.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.negate = function(p) {
    return new Point(-p.x, -p.y);
};

/**
 * Add two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.add = function(a, b) {
    return new Point(a.x + b.x, a.y + b.y);
};

/**
 * Subtract two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.sub = function(a, b) {
    return new Point(a.x - b.x, a.y - b.y);
};

/**
 * Multiply a point by a scalar and return the result as a new Point object.
 * @param {number} s - the scalar
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.mul = function(s, p) {
    return new Point(s * p.x, s * p.y);
};

/**
 * Perform the cross product on either two points (this produces a scalar)
 * or a point and a scalar (this produces a point).
 * This function requires two parameters, either may be a Point object or a
 * number.
 * @param  {XY|number} a - Point object or scalar.
 * @param  {XY|number} b - Point object or scalar.
 * @return {Point|number} a Point object or a number, depending on the parameters.
 */
Point.cross = function(a, b) {
    if (typeof(a) === 'number') {
        if (typeof(b) === 'number') {
            return a * b;
        } else {
            return new Point(-a * b.y, a * b.x);
        }
    } else {
        if (typeof(b) === 'number') {
            return new Point(b * a.y, -b * a.x);
        } else {
            return a.x * b.y - a.y * b.x;
        }
    }
};


// -----------------------------------------------------------------"Point-Like"
/*
 * The following functions operate on "Point" or any "Point like" object 
 * with {x,y} (duck typing).
 */

Point.toString = xy.toString;
Point.compare = xy.compare;
Point.cmp = xy.compare; // backward compatibility
Point.equals = xy.equals;

/**
 * Peform the dot product on two vectors.
 * @public
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {number} The dot product
 */
Point.dot = function(a, b) {
    return a.x * b.x + a.y * b.y;
};


// ---------------------------------------------------------Exports (public API)

module.exports = Point;

},{"./xy":11}],5:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Class added in the JavaScript version (was not present in the c++ version)
 */

var xy = _dereq_('./xy');

/**
 * Custom exception class to indicate invalid Point values
 * @constructor
 * @public
 * @extends Error
 * @struct
 * @param {string=} message - error message
 * @param {Array.<XY>=} points - invalid points
 */
var PointError = function(message, points) {
    this.name = "PointError";
    /**
     * Invalid points
     * @public
     * @type {Array.<XY>}
     */
    this.points = points = points || [];
    /**
     * Error message
     * @public
     * @type {string}
     */
    this.message = message || "Invalid Points!";
    for (var i = 0; i < points.length; i++) {
        this.message += " " + xy.toString(points[i]);
    }
};
PointError.prototype = new Error();
PointError.prototype.constructor = PointError;


module.exports = PointError;

},{"./xy":11}],6:[function(_dereq_,module,exports){
(function (global){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of Poly2Tri nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

"use strict";

/**
 * Public API for poly2tri.js
 * @module poly2tri
 */


/**
 * If you are not using a module system (e.g. CommonJS, RequireJS), you can access this library
 * as a global variable <code>poly2tri</code> i.e. <code>window.poly2tri</code> in a browser.
 * @name poly2tri
 * @global
 * @public
 * @type {module:poly2tri}
 */
var previousPoly2tri = global.poly2tri;
/**
 * For Browser + &lt;script&gt; :
 * reverts the {@linkcode poly2tri} global object to its previous value,
 * and returns a reference to the instance called.
 *
 * @example
 *              var p = poly2tri.noConflict();
 * @public
 * @return {module:poly2tri} instance called
 */
// (this feature is not automatically provided by browserify).
exports.noConflict = function() {
    global.poly2tri = previousPoly2tri;
    return exports;
};

/**
 * poly2tri library version
 * @public
 * @const {string}
 */
exports.VERSION = _dereq_('../dist/version.json').version;

/**
 * Exports the {@linkcode PointError} class.
 * @public
 * @typedef {PointError} module:poly2tri.PointError
 * @function
 */
exports.PointError = _dereq_('./pointerror');
/**
 * Exports the {@linkcode Point} class.
 * @public
 * @typedef {Point} module:poly2tri.Point
 * @function
 */
exports.Point = _dereq_('./point');
/**
 * Exports the {@linkcode Triangle} class.
 * @public
 * @typedef {Triangle} module:poly2tri.Triangle
 * @function
 */
exports.Triangle = _dereq_('./triangle');
/**
 * Exports the {@linkcode SweepContext} class.
 * @public
 * @typedef {SweepContext} module:poly2tri.SweepContext
 * @function
 */
exports.SweepContext = _dereq_('./sweepcontext');


// Backward compatibility
var sweep = _dereq_('./sweep');
/**
 * @function
 * @deprecated use {@linkcode SweepContext#triangulate} instead
 */
exports.triangulate = sweep.triangulate;
/**
 * @deprecated use {@linkcode SweepContext#triangulate} instead
 * @property {function} Triangulate - use {@linkcode SweepContext#triangulate} instead
 */
exports.sweep = {Triangulate: sweep.triangulate};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../dist/version.json":1,"./point":4,"./pointerror":5,"./sweep":7,"./sweepcontext":8,"./triangle":9}],7:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint latedef:nofunc, maxcomplexity:9 */

"use strict";

/**
 * This 'Sweep' module is present in order to keep this JavaScript version
 * as close as possible to the reference C++ version, even though almost all
 * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.
 * @module
 * @private
 */

/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var assert = _dereq_('./assert');
var PointError = _dereq_('./pointerror');
var Triangle = _dereq_('./triangle');
var Node = _dereq_('./advancingfront').Node;


// ------------------------------------------------------------------------utils

var utils = _dereq_('./utils');

/** @const */
var EPSILON = utils.EPSILON;

/** @const */
var Orientation = utils.Orientation;
/** @const */
var orient2d = utils.orient2d;
/** @const */
var inScanArea = utils.inScanArea;
/** @const */
var isAngleObtuse = utils.isAngleObtuse;


// ------------------------------------------------------------------------Sweep

/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @private
 * @param {!SweepContext} tcx - SweepContext object
 */
function triangulate(tcx) {
    tcx.initTriangulation();
    tcx.createAdvancingFront();
    // Sweep points; build mesh
    sweepPoints(tcx);
    // Clean up
    finalizationPolygon(tcx);
}

/**
 * Start sweeping the Y-sorted point set from bottom to top
 * @param {!SweepContext} tcx - SweepContext object
 */
function sweepPoints(tcx) {
    var i, len = tcx.pointCount();
    for (i = 1; i < len; ++i) {
        var point = tcx.getPoint(i);
        var node = pointEvent(tcx, point);
        var edges = point._p2t_edge_list;
        for (var j = 0; edges && j < edges.length; ++j) {
            edgeEventByEdge(tcx, edges[j], node);
        }
    }
}

/**
 * @param {!SweepContext} tcx - SweepContext object
 */
function finalizationPolygon(tcx) {
    // Get an Internal triangle to start with
    var t = tcx.front().head().next.triangle;
    var p = tcx.front().head().next.point;
    while (!t.getConstrainedEdgeCW(p)) {
        t = t.neighborCCW(p);
    }

    // Collect interior triangles constrained by edges
    tcx.meshClean(t);
}

/**
 * Find closes node to the left of the new point and
 * create a new triangle. If needed new holes and basins
 * will be filled to.
 * @param {!SweepContext} tcx - SweepContext object
 * @param {!XY} point   Point
 */
function pointEvent(tcx, point) {
    var node = tcx.locateNode(point);
    var new_node = newFrontTriangle(tcx, point, node);

    // Only need to check +epsilon since point never have smaller
    // x value than node due to how we fetch nodes from the front
    if (point.x <= node.point.x + (EPSILON)) {
        fill(tcx, node);
    }

    //tcx.AddNode(new_node);

    fillAdvancingFront(tcx, new_node);
    return new_node;
}

function edgeEventByEdge(tcx, edge, node) {
    tcx.edge_event.constrained_edge = edge;
    tcx.edge_event.right = (edge.p.x > edge.q.x);

    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
        return;
    }

    // For now we will do all needed filling
    // TODO: integrate with flip process might give some better performance
    //       but for now this avoid the issue with cases that needs both flips and fills
    fillEdgeEvent(tcx, edge, node);
    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
}

function edgeEventByPoints(tcx, ep, eq, triangle, point) {
    if (isEdgeSideOfTriangle(triangle, ep, eq)) {
        return;
    }

    var p1 = triangle.pointCCW(point);
    var o1 = orient2d(eq, p1, ep);
    if (o1 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
    }

    var p2 = triangle.pointCW(point);
    var o2 = orient2d(eq, p2, ep);
    if (o2 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
    }

    if (o1 === o2) {
        // Need to decide if we are rotating CW or CCW to get to a triangle
        // that will cross edge
        if (o1 === Orientation.CW) {
            triangle = triangle.neighborCCW(point);
        } else {
            triangle = triangle.neighborCW(point);
        }
        edgeEventByPoints(tcx, ep, eq, triangle, point);
    } else {
        // This triangle crosses constraint so lets flippin start!
        flipEdgeEvent(tcx, ep, eq, triangle, point);
    }
}

function isEdgeSideOfTriangle(triangle, ep, eq) {
    var index = triangle.edgeIndex(ep, eq);
    if (index !== -1) {
        triangle.markConstrainedEdgeByIndex(index);
        var t = triangle.getNeighbor(index);
        if (t) {
            t.markConstrainedEdgeByPoints(ep, eq);
        }
        return true;
    }
    return false;
}

/**
 * Creates a new front triangle and legalize it
 * @param {!SweepContext} tcx - SweepContext object
 */
function newFrontTriangle(tcx, point, node) {
    var triangle = new Triangle(point, node.point, node.next.point);

    triangle.markNeighbor(node.triangle);
    tcx.addToMap(triangle);

    var new_node = new Node(point);
    new_node.next = node.next;
    new_node.prev = node;
    node.next.prev = new_node;
    node.next = new_node;

    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    return new_node;
}

/**
 * Adds a triangle to the advancing front to fill a hole.
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - middle node, that is the bottom of the hole
 */
function fill(tcx, node) {
    var triangle = new Triangle(node.prev.point, node.point, node.next.point);

    // TODO: should copy the constrained_edge value from neighbor triangles
    //       for now constrained_edge values are copied during the legalize
    triangle.markNeighbor(node.prev.triangle);
    triangle.markNeighbor(node.triangle);

    tcx.addToMap(triangle);

    // Update the advancing front
    node.prev.next = node.next;
    node.next.prev = node.prev;


    // If it was legalized the triangle has already been mapped
    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    //tcx.removeNode(node);
}

/**
 * Fills holes in the Advancing Front
 * @param {!SweepContext} tcx - SweepContext object
 */
function fillAdvancingFront(tcx, n) {
    // Fill right holes
    var node = n.next;
    while (node.next) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.next;
    }

    // Fill left holes
    node = n.prev;
    while (node.prev) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.prev;
    }

    // Fill right basins
    if (n.next && n.next.next) {
        if (isBasinAngleRight(n)) {
            fillBasin(tcx, n);
        }
    }
}

/**
 * The basin angle is decided against the horizontal line [1,0].
 * @param {Node} node
 * @return {boolean} true if angle < 3*/4
 */
function isBasinAngleRight(node) {
    var ax = node.point.x - node.next.next.point.x;
    var ay = node.point.y - node.next.next.point.y;
    assert(ay >= 0, "unordered y");
    return (ax >= 0 || Math.abs(ax) < ay);
}

/**
 * Returns true if triangle was legalized
 * @param {!SweepContext} tcx - SweepContext object
 * @return {boolean}
 */
function legalize(tcx, t) {
    // To legalize a triangle we start by finding if any of the three edges
    // violate the Delaunay condition
    for (var i = 0; i < 3; ++i) {
        if (t.delaunay_edge[i]) {
            continue;
        }
        var ot = t.getNeighbor(i);
        if (ot) {
            var p = t.getPoint(i);
            var op = ot.oppositePoint(t, p);
            var oi = ot.index(op);

            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
            // then we should not try to legalize
            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                t.constrained_edge[i] = ot.constrained_edge[oi];
                continue;
            }

            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);
            if (inside) {
                // Lets mark this shared edge as Delaunay
                t.delaunay_edge[i] = true;
                ot.delaunay_edge[oi] = true;

                // Lets rotate shared edge one vertex CW to legalize it
                rotateTrianglePair(t, p, ot, op);

                // We now got one valid Delaunay Edge shared by two triangles
                // This gives us 4 new edges to check for Delaunay

                // Make sure that triangle to node mapping is done only one time for a specific triangle
                var not_legalized = !legalize(tcx, t);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(t);
                }

                not_legalized = !legalize(tcx, ot);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(ot);
                }
                // Reset the Delaunay edges, since they only are valid Delaunay edges
                // until we add a new triangle or point.
                // XXX: need to think about this. Can these edges be tried after we
                //      return to previous recursive level?
                t.delaunay_edge[i] = false;
                ot.delaunay_edge[oi] = false;

                // If triangle have been legalized no need to check the other edges since
                // the recursive legalization will handles those so we can end here.
                return true;
            }
        }
    }
    return false;
}

/**
 * <b>Requirement</b>:<br>
 * 1. a,b and c form a triangle.<br>
 * 2. a and d is know to be on opposite side of bc<br>
 * <pre>
 *                a
 *                +
 *               / \
 *              /   \
 *            b/     \c
 *            +-------+
 *           /    d    \
 *          /           \
 * </pre>
 * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
 *  a,b and c<br>
 *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
 *  This preknowledge gives us a way to optimize the incircle test
 * @param pa - triangle point, opposite d
 * @param pb - triangle point
 * @param pc - triangle point
 * @param pd - point opposite a
 * @return {boolean} true if d is inside circle, false if on circle edge
 */
function inCircle(pa, pb, pc, pd) {
    var adx = pa.x - pd.x;
    var ady = pa.y - pd.y;
    var bdx = pb.x - pd.x;
    var bdy = pb.y - pd.y;

    var adxbdy = adx * bdy;
    var bdxady = bdx * ady;
    var oabd = adxbdy - bdxady;
    if (oabd <= 0) {
        return false;
    }

    var cdx = pc.x - pd.x;
    var cdy = pc.y - pd.y;

    var cdxady = cdx * ady;
    var adxcdy = adx * cdy;
    var ocad = cdxady - adxcdy;
    if (ocad <= 0) {
        return false;
    }

    var bdxcdy = bdx * cdy;
    var cdxbdy = cdx * bdy;

    var alift = adx * adx + ady * ady;
    var blift = bdx * bdx + bdy * bdy;
    var clift = cdx * cdx + cdy * cdy;

    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
    return det > 0;
}

/**
 * Rotates a triangle pair one vertex CW
 *<pre>
 *       n2                    n2
 *  P +-----+             P +-----+
 *    | t  /|               |\  t |
 *    |   / |               | \   |
 *  n1|  /  |n3           n1|  \  |n3
 *    | /   |    after CW   |   \ |
 *    |/ oT |               | oT \|
 *    +-----+ oP            +-----+
 *       n4                    n4
 * </pre>
 */
function rotateTrianglePair(t, p, ot, op) {
    var n1, n2, n3, n4;
    n1 = t.neighborCCW(p);
    n2 = t.neighborCW(p);
    n3 = ot.neighborCCW(op);
    n4 = ot.neighborCW(op);

    var ce1, ce2, ce3, ce4;
    ce1 = t.getConstrainedEdgeCCW(p);
    ce2 = t.getConstrainedEdgeCW(p);
    ce3 = ot.getConstrainedEdgeCCW(op);
    ce4 = ot.getConstrainedEdgeCW(op);

    var de1, de2, de3, de4;
    de1 = t.getDelaunayEdgeCCW(p);
    de2 = t.getDelaunayEdgeCW(p);
    de3 = ot.getDelaunayEdgeCCW(op);
    de4 = ot.getDelaunayEdgeCW(op);

    t.legalize(p, op);
    ot.legalize(op, p);

    // Remap delaunay_edge
    ot.setDelaunayEdgeCCW(p, de1);
    t.setDelaunayEdgeCW(p, de2);
    t.setDelaunayEdgeCCW(op, de3);
    ot.setDelaunayEdgeCW(op, de4);

    // Remap constrained_edge
    ot.setConstrainedEdgeCCW(p, ce1);
    t.setConstrainedEdgeCW(p, ce2);
    t.setConstrainedEdgeCCW(op, ce3);
    ot.setConstrainedEdgeCW(op, ce4);

    // Remap neighbors
    // XXX: might optimize the markNeighbor by keeping track of
    //      what side should be assigned to what neighbor after the
    //      rotation. Now mark neighbor does lots of testing to find
    //      the right side.
    t.clearNeighbors();
    ot.clearNeighbors();
    if (n1) {
        ot.markNeighbor(n1);
    }
    if (n2) {
        t.markNeighbor(n2);
    }
    if (n3) {
        t.markNeighbor(n3);
    }
    if (n4) {
        ot.markNeighbor(n4);
    }
    t.markNeighbor(ot);
}

/**
 * Fills a basin that has formed on the Advancing Front to the right
 * of given node.<br>
 * First we decide a left,bottom and right node that forms the
 * boundaries of the basin. Then we do a reqursive fill.
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - starting node, this or next node will be left node
 */
function fillBasin(tcx, node) {
    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
        tcx.basin.left_node = node.next.next;
    } else {
        tcx.basin.left_node = node.next;
    }

    // Find the bottom and right node
    tcx.basin.bottom_node = tcx.basin.left_node;
    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
        tcx.basin.bottom_node = tcx.basin.bottom_node.next;
    }
    if (tcx.basin.bottom_node === tcx.basin.left_node) {
        // No valid basin
        return;
    }

    tcx.basin.right_node = tcx.basin.bottom_node;
    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
        tcx.basin.right_node = tcx.basin.right_node.next;
    }
    if (tcx.basin.right_node === tcx.basin.bottom_node) {
        // No valid basins
        return;
    }

    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

    fillBasinReq(tcx, tcx.basin.bottom_node);
}

/**
 * Recursive algorithm to fill a Basin with triangles
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - bottom_node
 */
function fillBasinReq(tcx, node) {
    // if shallow stop filling
    if (isShallow(tcx, node)) {
        return;
    }

    fill(tcx, node);

    var o;
    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
        return;
    } else if (node.prev === tcx.basin.left_node) {
        o = orient2d(node.point, node.next.point, node.next.next.point);
        if (o === Orientation.CW) {
            return;
        }
        node = node.next;
    } else if (node.next === tcx.basin.right_node) {
        o = orient2d(node.point, node.prev.point, node.prev.prev.point);
        if (o === Orientation.CCW) {
            return;
        }
        node = node.prev;
    } else {
        // Continue with the neighbor node with lowest Y value
        if (node.prev.point.y < node.next.point.y) {
            node = node.prev;
        } else {
            node = node.next;
        }
    }

    fillBasinReq(tcx, node);
}

function isShallow(tcx, node) {
    var height;
    if (tcx.basin.left_highest) {
        height = tcx.basin.left_node.point.y - node.point.y;
    } else {
        height = tcx.basin.right_node.point.y - node.point.y;
    }

    // if shallow stop filling
    if (tcx.basin.width > height) {
        return true;
    }
    return false;
}

function fillEdgeEvent(tcx, edge, node) {
    if (tcx.edge_event.right) {
        fillRightAboveEdgeEvent(tcx, edge, node);
    } else {
        fillLeftAboveEdgeEvent(tcx, edge, node);
    }
}

function fillRightAboveEdgeEvent(tcx, edge, node) {
    while (node.next.point.x < edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            fillRightBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.next;
        }
    }
}

function fillRightBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x < edge.p.x) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            // Concave
            fillRightConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillRightConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillRightBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillRightConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.next);
    if (node.next.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            // Below
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                // Next is concave
                fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function fillRightConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
        // Concave
        fillRightConcaveEdgeEvent(tcx, edge, node.next);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
            // Below
            fillRightConvexEdgeEvent(tcx, edge, node.next);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftAboveEdgeEvent(tcx, edge, node) {
    while (node.prev.point.x > edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            fillLeftBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.prev;
        }
    }
}

function fillLeftBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x > edge.p.x) {
        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
            // Concave
            fillLeftConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillLeftConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillLeftBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillLeftConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
        // Concave
        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
            // Below
            fillLeftConvexEdgeEvent(tcx, edge, node.prev);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.prev);
    if (node.prev.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            // Below
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                // Next is concave
                fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function flipEdgeEvent(tcx, ep, eq, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle!");

    var op = ot.oppositePoint(t, p);

    // Additional check from Java version (see issue #88)
    if (t.getConstrainedEdgeAcross(p)) {
        var index = t.index(p);
        throw new PointError("poly2tri Intersecting Constraints",
                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);
    }

    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
        // Lets rotate shared edge one vertex CW
        rotateTrianglePair(t, p, ot, op);
        tcx.mapTriangleToNodes(t);
        tcx.mapTriangleToNodes(ot);

        // XXX: in the original C++ code for the next 2 lines, we are
        // comparing point values (and not pointers). In this JavaScript
        // code, we are comparing point references (pointers). This works
        // because we can't have 2 different points with the same values.
        // But to be really equivalent, we should use "Point.equals" here.
        if (p === eq && op === ep) {
            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
                t.markConstrainedEdgeByPoints(ep, eq);
                ot.markConstrainedEdgeByPoints(ep, eq);
                legalize(tcx, t);
                legalize(tcx, ot);
            } else {
                // XXX: I think one of the triangles should be legalized here?
                /* jshint noempty:false */
            }
        } else {
            var o = orient2d(eq, op, ep);
            t = nextFlipTriangle(tcx, o, t, ot, p, op);
            flipEdgeEvent(tcx, ep, eq, t, p);
        }
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
        edgeEventByPoints(tcx, ep, eq, t, p);
    }
}

/**
 * After a flip we have two triangles and know that only one will still be
 * intersecting the edge. So decide which to contiune with and legalize the other
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param o - should be the result of an orient2d( eq, op, ep )
 * @param t - triangle 1
 * @param ot - triangle 2
 * @param p - a point shared by both triangles
 * @param op - another point shared by both triangles
 * @return returns the triangle still intersecting the edge
 */
function nextFlipTriangle(tcx, o, t, ot, p, op) {
    var edge_index;
    if (o === Orientation.CCW) {
        // ot is not crossing edge after flip
        edge_index = ot.edgeIndex(p, op);
        ot.delaunay_edge[edge_index] = true;
        legalize(tcx, ot);
        ot.clearDelaunayEdges();
        return t;
    }

    // t is not crossing edge after flip
    edge_index = t.edgeIndex(p, op);

    t.delaunay_edge[edge_index] = true;
    legalize(tcx, t);
    t.clearDelaunayEdges();
    return ot;
}

/**
 * When we need to traverse from one triangle to the next we need
 * the point in current triangle that is the opposite point to the next
 * triangle.
 */
function nextFlipPoint(ep, eq, ot, op) {
    var o2d = orient2d(eq, op, ep);
    if (o2d === Orientation.CW) {
        // Right
        return ot.pointCCW(op);
    } else if (o2d === Orientation.CCW) {
        // Left
        return ot.pointCW(op);
    } else {
        throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
    }
}

/**
 * Scan part of the FlipScan algorithm<br>
 * When a triangle pair isn't flippable we will scan for the next
 * point that is inside the flip triangle scan area. When found
 * we generate a new flipEdgeEvent
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param ep - last point on the edge we are traversing
 * @param eq - first point on the edge we are traversing
 * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge
 * @param t
 * @param p
 */
function flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle");

    var op = ot.oppositePoint(t, p);

    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
        // flip with new edge op.eq
        flipEdgeEvent(tcx, eq, op, ot, op);
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
    }
}


// ----------------------------------------------------------------------Exports

exports.triangulate = triangulate;

},{"./advancingfront":2,"./assert":3,"./pointerror":5,"./triangle":9,"./utils":10}],8:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:6 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var PointError = _dereq_('./pointerror');
var Point = _dereq_('./point');
var Triangle = _dereq_('./triangle');
var sweep = _dereq_('./sweep');
var AdvancingFront = _dereq_('./advancingfront');
var Node = AdvancingFront.Node;


// ------------------------------------------------------------------------utils

/**
 * Initial triangle factor, seed triangle will extend 30% of
 * PointSet width to both left and right.
 * @private
 * @const
 */
var kAlpha = 0.3;


// -------------------------------------------------------------------------Edge
/**
 * Represents a simple polygon's edge
 * @constructor
 * @struct
 * @private
 * @param {Point} p1
 * @param {Point} p2
 * @throw {PointError} if p1 is same as p2
 */
var Edge = function(p1, p2) {
    this.p = p1;
    this.q = p2;

    if (p1.y > p2.y) {
        this.q = p1;
        this.p = p2;
    } else if (p1.y === p2.y) {
        if (p1.x > p2.x) {
            this.q = p1;
            this.p = p2;
        } else if (p1.x === p2.x) {
            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
        }
    }

    if (!this.q._p2t_edge_list) {
        this.q._p2t_edge_list = [];
    }
    this.q._p2t_edge_list.push(this);
};


// ------------------------------------------------------------------------Basin
/**
 * @constructor
 * @struct
 * @private
 */
var Basin = function() {
    /** @type {Node} */
    this.left_node = null;
    /** @type {Node} */
    this.bottom_node = null;
    /** @type {Node} */
    this.right_node = null;
    /** @type {number} */
    this.width = 0.0;
    /** @type {boolean} */
    this.left_highest = false;
};

Basin.prototype.clear = function() {
    this.left_node = null;
    this.bottom_node = null;
    this.right_node = null;
    this.width = 0.0;
    this.left_highest = false;
};

// --------------------------------------------------------------------EdgeEvent
/**
 * @constructor
 * @struct
 * @private
 */
var EdgeEvent = function() {
    /** @type {Edge} */
    this.constrained_edge = null;
    /** @type {boolean} */
    this.right = false;
};

// ----------------------------------------------------SweepContext (public API)
/**
 * SweepContext constructor option
 * @typedef {Object} SweepContextOptions
 * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters
 *                  (contour, holes). Points inside arrays are never copied.
 *                  Default is <code>false</code> : keep a reference to the array arguments,
 *                  who will be modified in place.
 */
/**
 * Constructor for the triangulation context.
 * It accepts a simple polyline (with non repeating points), 
 * which defines the constrained edges.
 *
 * @example
 *          var contour = [
 *              new poly2tri.Point(100, 100),
 *              new poly2tri.Point(100, 300),
 *              new poly2tri.Point(300, 300),
 *              new poly2tri.Point(300, 100)
 *          ];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @example
 *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @constructor
 * @public
 * @struct
 * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,
 *          or any "Point like" custom class with <code>{x, y}</code> attributes.
 * @param {SweepContextOptions=} options - constructor options
 */
var SweepContext = function(contour, options) {
    options = options || {};
    this.triangles_ = [];
    this.map_ = [];
    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
    this.edge_list = [];

    // Bounding box of all points. Computed at the start of the triangulation, 
    // it is stored in case it is needed by the caller.
    this.pmin_ = this.pmax_ = null;

    /**
     * Advancing front
     * @private
     * @type {AdvancingFront}
     */
    this.front_ = null;

    /**
     * head point used with advancing front
     * @private
     * @type {Point}
     */
    this.head_ = null;

    /**
     * tail point used with advancing front
     * @private
     * @type {Point}
     */
    this.tail_ = null;

    /**
     * @private
     * @type {Node}
     */
    this.af_head_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_middle_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_tail_ = null;

    this.basin = new Basin();
    this.edge_event = new EdgeEvent();

    this.initEdges(this.points_);
};


/**
 * Add a hole to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var hole = [
 *          new poly2tri.Point(200, 200),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addHole(hole);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} polyline - array of "Point like" objects with {x,y}
 */
SweepContext.prototype.addHole = function(polyline) {
    this.initEdges(polyline);
    var i, len = polyline.length;
    for (i = 0; i < len; i++) {
        this.points_.push(polyline[i]);
    }
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addHole} instead
 */
SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


/**
 * Add several holes to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],
 *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]
 *      ];
 *      swctx.addHoles(holes);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],
 *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]
 *      ];
 *      swctx.addHoles(holes);
 * @public
 * @param {Array.<Array.<XY>>} holes - array of array of "Point like" objects with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addHoles = function(holes) {
    var i, len = holes.length;
    for (i = 0; i < len; i++) {
        this.initEdges(holes[i]);
    }
    this.points_ = this.points_.concat.apply(this.points_, holes);
    return this; // for chaining
};


/**
 * Add a Steiner point to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var point = new poly2tri.Point(150, 150);
 *      swctx.addPoint(point);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoint({x:150, y:150});
 * @public
 * @param {XY} point - any "Point like" object with {x,y}
 */
SweepContext.prototype.addPoint = function(point) {
    this.points_.push(point);
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addPoint} instead
 */
SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


/**
 * Add several Steiner points to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var points = [
 *          new poly2tri.Point(150, 150),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addPoints(points);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} points - array of "Point like" object with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addPoints = function(points) {
    this.points_ = this.points_.concat(points);
    return this; // for chaining
};


/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @public
 */
// Shortcut method for sweep.triangulate(SweepContext).
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.triangulate = function() {
    sweep.triangulate(this);
    return this; // for chaining
};


/**
 * Get the bounding box of the provided constraints (contour, holes and 
 * Steinter points). Warning : these values are not available if the triangulation 
 * has not been done yet.
 * @public
 * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.getBoundingBox = function() {
    return {min: this.pmin_, max: this.pmax_};
};

/**
 * Get result of triangulation.
 * The output triangles have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      //  "number"
 * @public
 * @returns {array<Triangle>}   array of triangles
 */
SweepContext.prototype.getTriangles = function() {
    return this.triangles_;
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#getTriangles} instead
 */
SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


// ---------------------------------------------------SweepContext (private API)

/** @private */
SweepContext.prototype.front = function() {
    return this.front_;
};

/** @private */
SweepContext.prototype.pointCount = function() {
    return this.points_.length;
};

/** @private */
SweepContext.prototype.head = function() {
    return this.head_;
};

/** @private */
SweepContext.prototype.setHead = function(p1) {
    this.head_ = p1;
};

/** @private */
SweepContext.prototype.tail = function() {
    return this.tail_;
};

/** @private */
SweepContext.prototype.setTail = function(p1) {
    this.tail_ = p1;
};

/** @private */
SweepContext.prototype.getMap = function() {
    return this.map_;
};

/** @private */
SweepContext.prototype.initTriangulation = function() {
    var xmax = this.points_[0].x;
    var xmin = this.points_[0].x;
    var ymax = this.points_[0].y;
    var ymin = this.points_[0].y;

    // Calculate bounds
    var i, len = this.points_.length;
    for (i = 1; i < len; i++) {
        var p = this.points_[i];
        /* jshint expr:true */
        (p.x > xmax) && (xmax = p.x);
        (p.x < xmin) && (xmin = p.x);
        (p.y > ymax) && (ymax = p.y);
        (p.y < ymin) && (ymin = p.y);
    }
    this.pmin_ = new Point(xmin, ymin);
    this.pmax_ = new Point(xmax, ymax);

    var dx = kAlpha * (xmax - xmin);
    var dy = kAlpha * (ymax - ymin);
    this.head_ = new Point(xmax + dx, ymin - dy);
    this.tail_ = new Point(xmin - dx, ymin - dy);

    // Sort points along y-axis
    this.points_.sort(Point.compare);
};

/** @private */
SweepContext.prototype.initEdges = function(polyline) {
    var i, len = polyline.length;
    for (i = 0; i < len; ++i) {
        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
    }
};

/** @private */
SweepContext.prototype.getPoint = function(index) {
    return this.points_[index];
};

/** @private */
SweepContext.prototype.addToMap = function(triangle) {
    this.map_.push(triangle);
};

/** @private */
SweepContext.prototype.locateNode = function(point) {
    return this.front_.locateNode(point.x);
};

/** @private */
SweepContext.prototype.createAdvancingFront = function() {
    var head;
    var middle;
    var tail;
    // Initial triangle
    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

    this.map_.push(triangle);

    head = new Node(triangle.getPoint(1), triangle);
    middle = new Node(triangle.getPoint(0), triangle);
    tail = new Node(triangle.getPoint(2));

    this.front_ = new AdvancingFront(head, tail);

    head.next = middle;
    middle.next = tail;
    middle.prev = head;
    tail.prev = middle;
};

/** @private */
SweepContext.prototype.removeNode = function(node) {
    // do nothing
    /* jshint unused:false */
};

/** @private */
SweepContext.prototype.mapTriangleToNodes = function(t) {
    for (var i = 0; i < 3; ++i) {
        if (!t.getNeighbor(i)) {
            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
            if (n) {
                n.triangle = t;
            }
        }
    }
};

/** @private */
SweepContext.prototype.removeFromMap = function(triangle) {
    var i, map = this.map_, len = map.length;
    for (i = 0; i < len; i++) {
        if (map[i] === triangle) {
            map.splice(i, 1);
            break;
        }
    }
};

/**
 * Do a depth first traversal to collect triangles
 * @private
 * @param {Triangle} triangle start
 */
SweepContext.prototype.meshClean = function(triangle) {
    // New implementation avoids recursive calls and use a loop instead.
    // Cf. issues # 57, 65 and 69.
    var triangles = [triangle], t, i;
    /* jshint boss:true */
    while (t = triangles.pop()) {
        if (!t.isInterior()) {
            t.setInterior(true);
            this.triangles_.push(t);
            for (i = 0; i < 3; i++) {
                if (!t.constrained_edge[i]) {
                    triangles.push(t.getNeighbor(i));
                }
            }
        }
    }
};

// ----------------------------------------------------------------------Exports

module.exports = SweepContext;

},{"./advancingfront":2,"./point":4,"./pointerror":5,"./sweep":7,"./triangle":9}],9:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:10 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = _dereq_("./xy");


// ---------------------------------------------------------------------Triangle
/**
 * Triangle class.<br>
 * Triangle-based data structures are known to have better performance than
 * quad-edge structures.
 * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
 * Delaunay Triangulator", "Triangulations in CGAL"
 *
 * @constructor
 * @struct
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 */
var Triangle = function(a, b, c) {
    /**
     * Triangle points
     * @private
     * @type {Array.<XY>}
     */
    this.points_ = [a, b, c];

    /**
     * Neighbor list
     * @private
     * @type {Array.<Triangle>}
     */
    this.neighbors_ = [null, null, null];

    /**
     * Has this triangle been marked as an interior triangle?
     * @private
     * @type {boolean}
     */
    this.interior_ = false;

    /**
     * Flags to determine if an edge is a Constrained edge
     * @private
     * @type {Array.<boolean>}
     */
    this.constrained_edge = [false, false, false];

    /**
     * Flags to determine if an edge is a Delauney edge
     * @private
     * @type {Array.<boolean>}
     */
    this.delaunay_edge = [false, false, false];
};

var p2s = xy.toString;
/**
 * For pretty printing ex. <code>"[(5;42)(10;20)(21;30)]"</code>.
 * @public
 * @return {string}
 */
Triangle.prototype.toString = function() {
    return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
};

/**
 * Get one vertice of the triangle.
 * The output triangles of a triangulation have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      //  "number"
 * @param {number} index - vertice index: 0, 1 or 2
 * @public
 * @returns {XY}
 */
Triangle.prototype.getPoint = function(index) {
    return this.points_[index];
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode Triangle#getPoint} instead
 */
Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

/**
 * Get all 3 vertices of the triangle as an array
 * @public
 * @return {Array.<XY>}
 */
// Method added in the JavaScript version (was not present in the c++ version)
Triangle.prototype.getPoints = function() {
    return this.points_;
};

/**
 * @private
 * @param {number} index
 * @returns {?Triangle}
 */
Triangle.prototype.getNeighbor = function(index) {
    return this.neighbors_[index];
};

/**
 * Test if this Triangle contains the Point object given as parameter as one of its vertices.
 * Only point references are compared, not values.
 * @public
 * @param {XY} point - point object with {x,y}
 * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,
 *         <code>false</code> otherwise.
 */
Triangle.prototype.containsPoint = function(point) {
    var points = this.points_;
    // Here we are comparing point references, not values
    return (point === points[0] || point === points[1] || point === points[2]);
};

/**
 * Test if this Triangle contains the Edge object given as parameter as its
 * bounding edges. Only point references are compared, not values.
 * @private
 * @param {Edge} edge
 * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding
 *         edges, <code>false</code> otherwise.
 */
Triangle.prototype.containsEdge = function(edge) {
    return this.containsPoint(edge.p) && this.containsPoint(edge.q);
};

/**
 * Test if this Triangle contains the two Point objects given as parameters among its vertices.
 * Only point references are compared, not values.
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {boolean}
 */
Triangle.prototype.containsPoints = function(p1, p2) {
    return this.containsPoint(p1) && this.containsPoint(p2);
};

/**
 * Has this triangle been marked as an interior triangle?
 * @returns {boolean}
 */
Triangle.prototype.isInterior = function() {
    return this.interior_;
};

/**
 * Mark this triangle as an interior triangle
 * @private
 * @param {boolean} interior
 * @returns {Triangle} this
 */
Triangle.prototype.setInterior = function(interior) {
    this.interior_ = interior;
    return this;
};

/**
 * Update neighbor pointers.
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @param {Triangle} t Triangle object.
 * @throws {Error} if can't find objects
 */
Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
        this.neighbors_[0] = t;
    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
        this.neighbors_[1] = t;
    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
        this.neighbors_[2] = t;
    } else {
        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
    }
};

/**
 * Exhaustive search to update neighbor pointers
 * @private
 * @param {!Triangle} t
 */
Triangle.prototype.markNeighbor = function(t) {
    var points = this.points_;
    if (t.containsPoints(points[1], points[2])) {
        this.neighbors_[0] = t;
        t.markNeighborPointers(points[1], points[2], this);
    } else if (t.containsPoints(points[0], points[2])) {
        this.neighbors_[1] = t;
        t.markNeighborPointers(points[0], points[2], this);
    } else if (t.containsPoints(points[0], points[1])) {
        this.neighbors_[2] = t;
        t.markNeighborPointers(points[0], points[1], this);
    }
};


Triangle.prototype.clearNeighbors = function() {
    this.neighbors_[0] = null;
    this.neighbors_[1] = null;
    this.neighbors_[2] = null;
};

Triangle.prototype.clearDelaunayEdges = function() {
    this.delaunay_edge[0] = false;
    this.delaunay_edge[1] = false;
    this.delaunay_edge[2] = false;
};

/**
 * Returns the point clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[2];
    } else if (p === points[1]) {
        return points[0];
    } else if (p === points[2]) {
        return points[1];
    } else {
        return null;
    }
};

/**
 * Returns the point counter-clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[1];
    } else if (p === points[1]) {
        return points[2];
    } else if (p === points[2]) {
        return points[0];
    } else {
        return null;
    }
};

/**
 * Returns the neighbor clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[1];
    } else if (p === this.points_[1]) {
        return this.neighbors_[2];
    } else {
        return this.neighbors_[0];
    }
};

/**
 * Returns the neighbor counter-clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[2];
    } else if (p === this.points_[1]) {
        return this.neighbors_[0];
    } else {
        return this.neighbors_[1];
    }
};

Triangle.prototype.getConstrainedEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[1];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[2];
    } else {
        return this.constrained_edge[0];
    }
};

Triangle.prototype.getConstrainedEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[2];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[0];
    } else {
        return this.constrained_edge[1];
    }
};

// Additional check from Java version (see issue #88)
Triangle.prototype.getConstrainedEdgeAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[0];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[1];
    } else {
        return this.constrained_edge[2];
    }
};

Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[1] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[2] = ce;
    } else {
        this.constrained_edge[0] = ce;
    }
};

Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[2] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[0] = ce;
    } else {
        this.constrained_edge[1] = ce;
    }
};

Triangle.prototype.getDelaunayEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[1];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[2];
    } else {
        return this.delaunay_edge[0];
    }
};

Triangle.prototype.getDelaunayEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[2];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[0];
    } else {
        return this.delaunay_edge[1];
    }
};

Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[1] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[2] = e;
    } else {
        this.delaunay_edge[0] = e;
    }
};

Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[2] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[0] = e;
    } else {
        this.delaunay_edge[1] = e;
    }
};

/**
 * The neighbor across to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {Triangle}
 */
Triangle.prototype.neighborAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[0];
    } else if (p === this.points_[1]) {
        return this.neighbors_[1];
    } else {
        return this.neighbors_[2];
    }
};

/**
 * @private
 * @param {!Triangle} t Triangle object.
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.oppositePoint = function(t, p) {
    var cw = t.pointCW(p);
    return this.pointCW(cw);
};

/**
 * Legalize triangle by rotating clockwise around oPoint
 * @private
 * @param {XY} opoint - point object with {x,y}
 * @param {XY} npoint - point object with {x,y}
 * @throws {Error} if oPoint can not be found
 */
Triangle.prototype.legalize = function(opoint, npoint) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (opoint === points[0]) {
        points[1] = points[0];
        points[0] = points[2];
        points[2] = npoint;
    } else if (opoint === points[1]) {
        points[2] = points[1];
        points[1] = points[0];
        points[0] = npoint;
    } else if (opoint === points[2]) {
        points[0] = points[2];
        points[2] = points[1];
        points[1] = npoint;
    } else {
        throw new Error('poly2tri Invalid Triangle.legalize() call');
    }
};

/**
 * Returns the index of a point in the triangle. 
 * The point *must* be a reference to one of the triangle's vertices.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {number} index 0, 1 or 2
 * @throws {Error} if p can not be found
 */
Triangle.prototype.index = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return 0;
    } else if (p === points[1]) {
        return 1;
    } else if (p === points[2]) {
        return 2;
    } else {
        throw new Error('poly2tri Invalid Triangle.index() call');
    }
};

/**
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {number} index 0, 1 or 2, or -1 if errror
 */
Triangle.prototype.edgeIndex = function(p1, p2) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p1 === points[0]) {
        if (p2 === points[1]) {
            return 2;
        } else if (p2 === points[2]) {
            return 1;
        }
    } else if (p1 === points[1]) {
        if (p2 === points[2]) {
            return 0;
        } else if (p2 === points[0]) {
            return 2;
        }
    } else if (p1 === points[2]) {
        if (p2 === points[0]) {
            return 1;
        } else if (p2 === points[1]) {
            return 0;
        }
    }
    return -1;
};

/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {number} index - edge index
 */
Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
    this.constrained_edge[index] = true;
};
/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {Edge} edge instance
 */
Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
    this.markConstrainedEdgeByPoints(edge.p, edge.q);
};
/**
 * Mark an edge of this triangle as constrained.
 * This method takes two Point instances defining the edge of the triangle.
 * @private
 * @param {XY} p - point object with {x,y}
 * @param {XY} q - point object with {x,y}
 */
Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
    var points = this.points_;
    // Here we are comparing point references, not values        
    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
        this.constrained_edge[2] = true;
    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
        this.constrained_edge[1] = true;
    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
        this.constrained_edge[0] = true;
    }
};


// ---------------------------------------------------------Exports (public API)

module.exports = Triangle;

},{"./xy":11}],10:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/**
 * Precision to detect repeated or collinear points
 * @private
 * @const {number}
 * @default
 */
var EPSILON = 1e-12;
exports.EPSILON = EPSILON;

/**
 * @private
 * @enum {number}
 * @readonly
 */
var Orientation = {
    "CW": 1,
    "CCW": -1,
    "COLLINEAR": 0
};
exports.Orientation = Orientation;


/**
 * Formula to calculate signed area<br>
 * Positive if CCW<br>
 * Negative if CW<br>
 * 0 if collinear<br>
 * <pre>
 * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
 *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
 * </pre>
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {Orientation}
 */
function orient2d(pa, pb, pc) {
    var detleft = (pa.x - pc.x) * (pb.y - pc.y);
    var detright = (pa.y - pc.y) * (pb.x - pc.x);
    var val = detleft - detright;
    if (val > -(EPSILON) && val < (EPSILON)) {
        return Orientation.COLLINEAR;
    } else if (val > 0) {
        return Orientation.CCW;
    } else {
        return Orientation.CW;
    }
}
exports.orient2d = orient2d;


/**
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @param {!XY} pd  point object with {x,y}
 * @return {boolean}
 */
function inScanArea(pa, pb, pc, pd) {
    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);
    if (oadb >= -EPSILON) {
        return false;
    }

    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);
    if (oadc <= EPSILON) {
        return false;
    }
    return true;
}
exports.inScanArea = inScanArea;


/**
 * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > /2 || angle < -/2)
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {boolean} true if angle is obtuse
 */
function isAngleObtuse(pa, pb, pc) {
    var ax = pb.x - pa.x;
    var ay = pb.y - pa.y;
    var bx = pc.x - pa.x;
    var by = pc.y - pa.y;
    return (ax * bx + ay * by) < 0;
}
exports.isAngleObtuse = isAngleObtuse;


},{}],11:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/**
 * The following functions operate on "Point" or any "Point like" object with {x,y},
 * as defined by the {@link XY} type
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 * @module
 * @private
 */

/**
 * poly2tri.js supports using custom point class instead of {@linkcode Point}.
 * Any "Point like" object with <code>{x, y}</code> attributes is supported
 * to initialize the SweepContext polylines and points
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 *
 * poly2tri.js might add extra fields to the point objects when computing the
 * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions
 * with fields in the custom class.
 *
 * @example
 *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *
 * @typedef {Object} XY
 * @property {number} x - x coordinate
 * @property {number} y - y coordinate
 */


/**
 * Point pretty printing : prints x and y coordinates.
 * @example
 *      xy.toStringBase({x:5, y:42})
 *      //  "(5;42)"
 * @protected
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toStringBase(p) {
    return ("(" + p.x + ";" + p.y + ")");
}

/**
 * Point pretty printing. Delegates to the point's custom "toString()" method if exists,
 * else simply prints x and y coordinates.
 * @example
 *      xy.toString({x:5, y:42})
 *      //  "(5;42)"
 * @example
 *      xy.toString({x:5,y:42,toString:function() {return this.x+":"+this.y;}})
 *      //  "5:42"
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toString(p) {
    // Try a custom toString first, and fallback to own implementation if none
    var s = p.toString();
    return (s === '[object Object]' ? toStringBase(p) : s);
}


/**
 * Compare two points component-wise. Ordered by y axis first, then x axis.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,
 *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
 *         <code>0</code> otherwise.
 */
function compare(a, b) {
    if (a.y === b.y) {
        return a.x - b.x;
    } else {
        return a.y - b.y;
    }
}

/**
 * Test two Point objects for equality.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
 */
function equals(a, b) {
    return a.x === b.x && a.y === b.y;
}


module.exports = {
    toString: toString,
    toStringBase: toStringBase,
    compare: compare,
    equals: equals
};

},{}]},{},[6])
(6)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/Lau/www/svjelly/src/core/Commands.js":[function(require,module,exports){
module.exports = {
	MOVE_TO: 1,
	LINE_TO: 2,
	BEZIER_TO: 3,
	QUADRA_TO: 4,
	ARC: 5,
	ELLIPSE: 6
};

},{}],"/Users/Lau/www/svjelly/src/core/ConfObject.js":[function(require,module,exports){
module.exports = {

	definition: 1,
	worldWidth: 150,
	multiCanvas: true,
	wind: 5,
	debug: false,
	simRenderFreq: 50,
	gravity: [0, -9.8],
	groups:
	{
		default: { fixed: true, physics: { bodyType: 'ghost' } },
		ghost: { fixed: true, physics: { bodyType: 'ghost' } },
		soft:
		{
			structure: 'triangulate',
			nodeRadius: 0.1,
			physics:
			{
				distanceConstraint:
				{
					stiffness: 100000,
					relaxation: 1
				},
				mass: 1,
				bodyType: 'soft'
			}
		},
		tree:
		{
			structure: 'triangulate',
			nodeRadius: 0.1,
			physics:
			{
				distanceConstraint: null,
				lockConstraint:
				{
					stiffness: 10000,
					relaxation: 0.9
				},
				mass: 5,
				damping: 0.8,
				structuralMassDecay: 3,
				bodyType: 'soft'
			}
		},
		flora:
		{
			structure: 'line',
			nodeRadius: 0.1,
			physics:
			{
				distanceConstraint: null,
				lockConstraint:
				{
					stiffness: 1000,
					relaxation: 1
				},
				mass: 0.1,
				structuralMassDecay: 3,
				bodyType: 'soft'
			}
		},
		jelly:
		{
			structure: 'hexaFill',
			innerStructureDef: 0.01,
			nodeRadius: 0.1,
			physics:
			{
				distanceConstraint:
				{
					stiffness: 10000,
					relaxation: 30
				},
				mass: 1,
				bodyType: 'soft'
			}
		},
		line:
		{
			structure: 'line',
			nodeRadius: 0.1,
			physics:
			{
				distanceConstraint: null,
				lockConstraint:
				{
					stiffness: 10,
					relaxation: 1
				},
				mass: 1,
				bodyType: 'soft'
			}
		},
		rope:
		{
			structure: 'line',
			nodeRadius: 0.1,
			physics:
			{
				distanceConstraint:
				{
					stiffness: 1000,
					relaxation: 1
				},
				mass: 1,
				bodyType: 'soft'
			}
		},
		hard:
		{
			physics:
			{
				mass: 1,
				bodyType: 'hard'
			}
		},
		metal:
		{
			physics:
			{
				mass: 10,
				bodyType: 'hard'
			}
		},
		wood:
		{
			physics:
			{
				mass: 1,
				bodyType: 'hard'
			}
		},
		balloon:
		{
			physics:
			{
				mass: 0.01,
				gravityScale: -10,
				bodyType: 'hard'
			}
		},
		static:
		{
			fixed: true,
			physics:
			{
				mass: 0,
				bodyType: 'hard'
			}
		},
		noCollide:
		{
			physics:
			{
				mass: 1,
				bodyType: 'hard',
				noCollide: true
			}
		},
		leaves:
		{
			physics:
			{
				mass: 0.001,
				gravityScale: 0,
				bodyType: 'hard',
				noCollide: true
			}
		}
	}
};


},{}],"/Users/Lau/www/svjelly/src/core/Grid.js":[function(require,module,exports){
var Grid =
{
	init: function ($graph)
	{
		this._graph = $graph;
		var nodesArray = this._nodesArray = [];
		this._graph.forEach(function ($line)
		{
			if ($line)
			{
				$line.forEach(function ($node)
				{
					if ($node) { nodesArray.push($node); }
				});
			}
		});
		return this;
	},

	createFromPolygon: function ($polygon, $def, $hexa)
	{
		var boundingBox = $polygon.getBoundingBox();

		var def = $def;
		//var def = width / $def;
		var toReturn = [];
		var yInc = $hexa ? def * (Math.sqrt(3) / 2) : def;
		var halfDef = def * 0.5;
		for (var yPos = boundingBox[0][1]; yPos <= boundingBox[1][1]; yPos += yInc)
		{
			var line = [];
			//var intersections = $polygon.getIntersectionsAtY(yPos);
			var xPos = boundingBox[0][0];
			xPos = ($hexa && toReturn.length % 2 !== 0) ? xPos + halfDef : xPos;
			for (xPos; xPos <= boundingBox[1][0] + halfDef; xPos += def)
			{
				if ($polygon.isInside([xPos, yPos])) { line.push([xPos, yPos]); }
				else { line.push(null); }
			}
			toReturn.push(line);
		}
		return Object.create(Grid).init(toReturn);
	},

	getGraph: function () { return this._graph; },

	getNodesArray: function () { return this._nodesArray; },

	getClosest: function ($x, $y, $size)
	{
		var size = $size || 1;
		var closest = this._nodesArray.concat();
		closest.sort(function ($a, $b)
		{
			if ($a === null || $b === null) { return true; }
			var sideX1 = Math.abs($a[0] - $x);
			var sideY1 = Math.abs($a[1] - $y);
			var dist1 = Math.sqrt(sideX1 * sideX1 + sideY1 * sideY1);

			var sideX2 = Math.abs($b[0] - $x);
			var sideY2 = Math.abs($b[1] - $y);
			var dist2 = Math.sqrt(sideX2 * sideX2 + sideY2 * sideY2);

			return dist1 - dist2;
		});
		return closest.slice(0, size);
	},

	getNeighbours: function ($x, $y, $returnEmpty)
	{
		var toReturn = [];
		var graph = this._graph;
		var even = $y % 2 > 0;
		var left = even ? $x : $x - 1;
		var right = even ? $x + 1 : $x;

		var NE = graph[$y - 1] && graph[$y - 1][right] ? graph[$y - 1][right] : null;
		var E = graph[$y + 0] && graph[$y + 0][$x + 1] ? graph[$y][$x + 1] : null;
		var SE = graph[$y + 1] && graph[$y + 1][right] ? graph[$y + 1][right] : null;
		var SW = graph[$y + 1] && graph[$y + 1][left] ? graph[$y + 1][left] : null;
		var W = graph[$y + 0] && graph[$y + 0][$x - 1] ? graph[$y][$x - 1] : null;
		var NW = graph[$y - 1] && graph[$y - 1][left] ? graph[$y - 1][left] : null;

		if (NE || $returnEmpty) { toReturn.push(NE); }
		if (E || $returnEmpty) { toReturn.push(E); }
		if (SE || $returnEmpty) { toReturn.push(SE); }
		if (SW || $returnEmpty) { toReturn.push(SW); }
		if (W || $returnEmpty) { toReturn.push(W); }
		if (NW || $returnEmpty) { toReturn.push(NW); }

		return toReturn;
	},

	getNetwork: function ()
	{
		var graph = this._graph;
		var network = [];
		var visited = [];
		var i = 0;
		var rowsLength = graph.length;
		for (i; i < rowsLength; i += 1)
		{
			var k = 0;
			var pointsLength = graph[i].length;
			for (k; k < pointsLength; k += 1)
			{
				var currPoint = graph[i][k];
				if (currPoint)
				{
					var currPointNeighbours = this.getNeighbours(k, i);
					for (var m = 0, neighboursLength = currPointNeighbours.length; m < neighboursLength; m += 1)
					{
						var currNeigh = currPointNeighbours[m];
						if (currNeigh && visited.indexOf(currNeigh) === -1)
						{
							network.push([currPoint, currNeigh]);
						}
					}
					visited.push(currPoint);
				}
			}
		}
		return network;
	},

	getOutline: function ()
	{
		if (!this.outline)
		{
			var graph = this._graph;
			var outlineGraph = [];
			for (var i = 0, rowsLength = graph.length; i < rowsLength; i += 1)
			{
				outlineGraph[i] = [];
				for (var k = 0, pointsLength = graph[i].length; k < pointsLength; k += 1)
				{
					var point = graph[i][k];
					outlineGraph[i][k] = null;
					if (point)
					{
						var isEdge = this.getNeighbours(k, i).length < 6;
						if (isEdge)
						{
							outlineGraph[i][k] = [k, i];
						}
					}
				}
			}
			this.outline = Object.create(Grid).init(outlineGraph);
		}

		return this.outline;
	},

	getShapePath: function ()
	{
		var path = [];
		var currentOutline = this.getOutlines()[0];
		var outlineGraph = currentOutline.getGraph();
		var getStartingIndex = function ()
		{
			for (var i = 0, length = outlineGraph.length; i < length; i += 1)
			{
				if (!outlineGraph[i]) { continue; }
				for (var k = 0, pointsLength = outlineGraph[i].length; k < pointsLength; k += 1)
				{
					var currPoint = outlineGraph[i][k];
					// if (currPoint)
					// {
					// 	console.log(currPoint, currentOutline.getNeighbours(currPoint[0], currPoint[1]));
					// }
					if (currPoint && currentOutline.getNeighbours(currPoint[0], currPoint[1]).length === 2)
					{
						return currPoint;
					}
				}
			}
		};

		var visited = [];
		var startingIndex = getStartingIndex.call(this);
		if (!startingIndex) { return; }

		var getAngle = function ($index)
		{
			var angle = ($index + 1) * 60;
			angle = angle === 0 ? 360 : angle;
			return angle;
		};
		var getNeighbourIndex = function ($point, $neighbour)
		{
			return currentOutline.getNeighbours($point[0], $point[1], true).indexOf($neighbour);
		};

		var next = currentOutline.getNeighbours(startingIndex[0], startingIndex[1])[0];
		var lastAngle = getAngle(getNeighbourIndex(startingIndex, next));
		var currIndex = next;
		path.push(this._graph[startingIndex[1]][startingIndex[0]]);
		path.push(this._graph[next[1]][next[0]]);
		visited.push(startingIndex);

		var best;
		var neighbours;
		var bestAngle;
		var outlineNodesArray = currentOutline.getNodesArray();
		var outlinePointsLength = outlineNodesArray.length;

		while (visited.length < outlinePointsLength - 1)//currIndex !== startingIndex)
		{
			neighbours = currentOutline.getNeighbours(currIndex[0], currIndex[1]);
			var bestScore = 0;
			best = undefined;

			for (var i = 0, length = neighbours.length; i < length; i += 1)
			{
				var currNeigh = neighbours[i];
				var currScore = 0;
				var currAngle = getAngle(getNeighbourIndex(currIndex, currNeigh));
				currScore = currAngle - lastAngle;
				if (currScore > 180) { currScore = currScore - 360; }
				if (currScore < -180) { currScore = currScore + 360; }
				var neighIndex = visited.indexOf(currNeigh);
				if (neighIndex !== -1) { currScore = neighIndex / visited.length * 10000 + 10000 + currScore; }
				if (!best || currScore < bestScore)
				{
					bestScore = currScore;
					best = currNeigh;
					bestAngle = currAngle;
				}
			}
			lastAngle = bestAngle;
			if (visited.indexOf(currIndex) !== -1) { visited.splice(visited.indexOf(currIndex), 1); }
			visited.push(currIndex);
			currIndex = best;

			path.push(this._graph[currIndex[1]][currIndex[0]]);
		}
		return path;
	},

	getOutlines: function ()
	{
		var toReturn = [];
		var currentGraph;
		var outline = this.getOutline();
		var remaining = outline.getNodesArray().concat();

		var recur = function ($point)
		{
			currentGraph[$point[1]] = currentGraph[$point[1]] || [];
			currentGraph[$point[1]][$point[0]] = $point;
			var neighbours = outline.getNeighbours($point[0], $point[1]);
			remaining.splice(remaining.indexOf($point), 1);
			for (var i = 0, length = neighbours.length; i < length; i += 1)
			{
				var neigh = neighbours[i];
				if (remaining.indexOf(neigh) !== -1) { recur(neigh); }
			}
		};

		while (remaining.length)
		{
			currentGraph = [];
			var startingPoint = remaining[0];
			recur(startingPoint);
			toReturn.push(Object.create(Grid).init(currentGraph));
		}
		return toReturn;
	}
};

module.exports = Grid;


},{}],"/Users/Lau/www/svjelly/src/core/NodeGraph.js":[function(require,module,exports){
var NodeGraph = function ()
{
	this.vertices = [];
	this.edges = [];
};

NodeGraph.prototype.getVertex = function ($node)
{
	for (var i = 0, length = this.vertices.length; i < length; i += 1)
	{
		var vertex = this.vertices[i];
		if (vertex.node === $node)
		{
			return vertex;
		}
	}
};

NodeGraph.prototype.createVertex = function ($node)
{
	var vertex = { node: $node };
	this.vertices.push(vertex);
	return vertex;
};

NodeGraph.prototype.getEdgeWeight = function ($edge)
{
	var dX = Math.abs($edge.vertexA.node.oX - $edge.vertexB.node.oX);
	var dY = Math.abs($edge.vertexA.node.oY - $edge.vertexB.node.oY);
	var dist = Math.sqrt(dX * dX + dY * dY);
	return dist;
};

NodeGraph.prototype.getVertexEdges = function ($vertex)
{
	var toReturn = [];
	for (var i = 0, length = this.edges.length; i < length; i += 1)
	{
		var edge = this.edges[i];
		if (edge.vertexA === $vertex || edge.vertexB === $vertex)
		{
			toReturn.push(edge);
		}
	}
	return toReturn;
};

NodeGraph.prototype.connect = function ($ANode, $BNode)
{
	var vertexA = this.getVertex($ANode) || this.createVertex($ANode);
	var vertexB = this.getVertex($BNode) || this.createVertex($BNode);

	var exists = false;
	for (var i = 0, length = this.edges.length; i < length; i += 1)
	{
		var edge = this.edges[i];
		if ((edge.vertexA === vertexA &&
			edge.vertexB === vertexB) ||
			(edge.vertexA === vertexB &&
			edge.vertexB === vertexA))
		{
			exists = true;
		}
	}
	if (!exists)
	{
		this.edges.push({ vertexA: vertexA, vertexB: vertexB });
	}
};

NodeGraph.prototype.traverse = function ($startingVertices)
{
	var i;
	var openList = [];
	var edgesLength;
	var vertexEdges;
	var startingVerticesLength = $startingVertices.length;
	for (i = 0; i < startingVerticesLength; i += 1)
	{
		$startingVertices[i].mapValue = 0;
		$startingVertices[i].opened = true;
		openList.push($startingVertices[i]);
	}

	while (openList.length)
	{
		var closedVertex = openList.shift();
		closedVertex.closed = true;

		vertexEdges = this.getVertexEdges(closedVertex);
		edgesLength = vertexEdges.length;
		for (i = 0; i < edgesLength; i += 1)
		{
			var currEdge = vertexEdges[i];
			var otherVertex = currEdge.vertexA === closedVertex ? currEdge.vertexB : currEdge.vertexA;
			if (otherVertex.closed) { continue; }
			
			if (!otherVertex.opened)
			{
				otherVertex.opened = true;
				openList.push(otherVertex);
			}
			var val = closedVertex.mapValue + this.getEdgeWeight(currEdge);
			otherVertex.mapValue = otherVertex.mapValue < val ? otherVertex.mapValue : val; //works even if undefined
		}
	}
};

module.exports = NodeGraph;

},{}],"/Users/Lau/www/svjelly/src/core/Polygon.js":[function(require,module,exports){
var Polygon =
{
	init: function ($points)
	{
		var polygon = Object.create(Polygon);
		polygon.points = $points;
		polygon._boundingBox = undefined;
		return polygon;
	},

	getArea: function ()
	{
		var sumA = 0;
		var sumB = 0;
		for (var i = 0, length = this.points.length; i < length; i += 1)
		{
			var currPoint = this.points[i];
			var next = i === length - 1 ? this.points[0] : this.points[i + 1];
			sumA += currPoint[0] * next[1];
			sumB += currPoint[1] * next[0];
		}

		return Math.abs((sumA - sumB) * 0.5);
	},

	getBoundingBox: function ()
	{
		if (!this._boundingBox)
		{
			var minX = this.points[0][0];
			var maxX = minX;
			var minY = this.points[0][1];
			var maxY = minY;

			for (var i = 0, length = this.points.length; i < length; i += 1)
			{
				var point = this.points[i];
				minX = Math.min(minX, point[0]);
				maxX = Math.max(maxX, point[0]);
				minY = Math.min(minY, point[1]);
				maxY = Math.max(maxY, point[1]);
			}
			this._boundingBox = [[minX, minY], [maxX, maxY]];
		}
		return this._boundingBox;
	},

	getSegments: function ()
	{
		var segments = [];
		for (var i = 0, length = this.points.length - 1; i < length; i += 1)
		{
			segments.push([this.points[i], this.points[i + 1]]);
		}
		segments.push([this.points[this.points.length - 1], this.points[0]]);
		return segments;
	},

	getIntersectionsAtY: function ($testY)
	{
		var segments = this.getSegments();
		var intersections = [];
		for (var i = 0, length = segments.length; i < length; i += 1)
		{
			var currSegment = segments[i];
			var x1 = currSegment[0][0];
			var y1 = currSegment[0][1];
			var x2 = currSegment[1][0];
			var y2 = currSegment[1][1];
			var smallY = Math.min(y1, y2);
			var bigY = Math.max(y1, y2);

			if ($testY > smallY && $testY < bigY)
			{
				var pY = y2 - $testY;
				var segY = y2 - y1;
				var segX = x2 - x1;
				var pX = pY * segX / segY;
				intersections.push(x2 - pX);
			}
		}
		return intersections;
	},

	isInside: function ($point)
	{
		var infNumber = 0;
		var intersections = this.getIntersectionsAtY($point[1]);
		for (var i = 0, length = intersections.length; i < length; i += 1)
		{
			if ($point[0] < intersections[i]) { infNumber += 1; }
		}
		return infNumber % 2 > 0;
	}
};

module.exports = Polygon;


},{}],"/Users/Lau/www/svjelly/src/core/SVGParser.js":[function(require,module,exports){
var Commands = require('./Commands');
var ARC = Commands.ARC;
var LINE_TO = Commands.LINE_TO;
var MOVE_TO = Commands.MOVE_TO;
var BEZIER_TO = Commands.BEZIER_TO;
var QUADRA_TO = Commands.QUADRA_TO;
var ELLIPSE = Commands.ELLIPSE;

var SVGParser = function () {};
//var isPolygon = /polygon|rect/ig;
// var isLine = /polyline|line|path/ig;
// var lineTags = 'polyline, line, path';

SVGParser.prototype.parse = function ($world, $SVG)
{
	this.SVG = $SVG;
	var viewBoxAttr = this.SVG.getAttribute('viewBox');
	this.viewBoxWidth = viewBoxAttr ? Number(viewBoxAttr.split(' ')[2]) : Number(this.SVG.getAttribute('width'));
	this.viewBoxHeight = viewBoxAttr ? Number(viewBoxAttr.split(' ')[3]) : Number(this.SVG.getAttribute('height'));
	this.ratio = $world.getWidth() / this.viewBoxWidth;
	this.world = $world;
	this.world.setHeight(this.viewBoxHeight * this.ratio);

	//temp
	this.elementsQuery = '*:not(defs):not(g):not(title):not(linearGradient):not(radialGradient):not(stop):not([id*="joint"]):not([id*="constraint"])';
	var elemRaws = this.SVG.querySelectorAll(this.elementsQuery);

	var i = 0;
	var rawGroupPairings = [];
	var elemsLength = elemRaws.length;

	for (i = 0; i < elemsLength; i += 1)
	{
		var rawElement = elemRaws[i];
		//if (rawElement.nodeType === 3) { continue; }
		var groupInfos = this.getGroupInfos(rawElement);
		var currGroup = $world.createGroup(groupInfos.type, groupInfos.ID);
		currGroup.rawSVGElement = rawElement;

		//var elements = rawElement;
		//this.parseElements(elements, currGroup);

		var drawingCommands = this.parseElement(rawElement);
		var nodesToDraw = currGroup.structure.create(drawingCommands);
		this.setGraphicInstructions(currGroup, rawElement, nodesToDraw, drawingCommands);

		// var hasGroup;
		// for (var k = 0, length = rawGroupPairings.length; k < length; k += 1)
		// {
		// 	var curr = rawGroupPairings[k];
		// 	if (curr.group === currGroup)
		// 	{
		// 		hasGroup = true;
		// 		break;
		// 	}
		// }
		// if (!hasGroup) { rawGroupPairings.push({ group: currGroup, raw: rawElement.parentNode }); }
		rawGroupPairings.push({ group: currGroup, raw: rawElement.parentNode });
	}

	// var pairingsLength = rawGroupPairings.length;
	// for (i = 0; i < pairingsLength; i += 1)
	// {
	// 	var pairing = rawGroupPairings[i];
	// 	// this.parseAnchors(pairing.raw, pairing.group);
	// 	this.parseConstraints(pairing.raw, pairing.group);
	// 	this.parseCustomJoints(pairing.raw, pairing.group);
	// }

	this.parseConstraints();

	this.world.addGroupsToWorld();
};

SVGParser.prototype.getGroupInfos = function ($rawGroup)
{
	var groupElement = (!$rawGroup.id || $rawGroup.id.indexOf('svg') === 0) && $rawGroup.parentNode.tagName !== 'svg' ? $rawGroup.parentNode : $rawGroup;
	var type;
	var ID;
	var regex = /([a-z\d]+)\w*/igm;
	var first = regex.exec(groupElement.id);
	var second = regex.exec(groupElement.id);
	//if (first) { type = second ? second[1] : first[1]; }
	//var groupType = groupElement.id.match();
	//if (groupType) { return groupType[1] || groupType[0]; }
	//automatic for lines
	// if (!first && (groupElement.querySelectorAll(lineTags).length > 0 || groupElement.tagName.search(isLine) > -1))
	// {
	// 	type = 'line';
	// }
	type = first ? first[1] : undefined;
	ID = second ? second[1] : null;
	var title = groupElement.querySelector('title');
	if (ID === null) { ID = title ? title.nodeValue : ID; }
	// if ($rawGroup.parentNode.id === 'tree-tree')
	// {
	// 	console.log($rawGroup, $rawGroup.id, type, ID);
	// 	debugger;
	// }
	return { ID: ID, type: type };
};

SVGParser.prototype.getPoints = function ($pointCommands)
{
	var points = [];
	for (var i = 0, length = $pointCommands.length; i < length; i += 1)
	{
		var currPointCommand = $pointCommands[i];
		points.push(currPointCommand.point);
	}
	return points;
};

SVGParser.prototype.getGroupFromRawSVGElement = function ($raw)
{
	for (var i = 0, length = this.world.groups.length; i < length; i += 1)
	{
		var currGroup = this.world.groups[i];
		if (currGroup.rawSVGElement === $raw) { return currGroup; }
	}
};

SVGParser.prototype.parseConstraints = function ()
{
	var rawConstraints = this.SVG.querySelectorAll('[id*="constraint"]');
	for (var i = 0, length = rawConstraints.length; i < length; i += 1)
	{
		var currRawConstraint = rawConstraints[i];
		var rawElements = currRawConstraint.parentNode.querySelectorAll(this.elementsQuery);
		var points = this.getPoints(this.parseElement(currRawConstraint).pointCommands);
		var result = /constraint-([a-z\d]*)/ig.exec(currRawConstraint.id);
		var parentGroupID = result ? result[1] : undefined;
		var parentGroup = parentGroupID ? this.world.getGroupByID(parentGroupID) : undefined;

		for (var k = 0, rawElementsLength = rawElements.length; k < rawElementsLength; k += 1)
		{
			var currRawElement = rawElements[k];
			var group = this.getGroupFromRawSVGElement(currRawElement);
			//console.log(group);
			this.world.constrainGroups(group, parentGroup, points);
		}
	}
	// var children = $rawGroup.childNodes;//$rawGroup.querySelectorAll('[id*="constraint"]');

	// for (var i = 0, childrenLength = children.length; i < childrenLength; i += 1)
	// {
	// 	if (children[i].nodeType === Node.TEXT_NODE || children[i].id.search(/constraint/i) < 0) { continue; }
	// 	var currConstraint = children[i];
	// 	var result = /constraint-([a-z\d]*)/ig.exec(currConstraint.id);

	// 	var parentGroupID = result ? result[1] : undefined;
	// 	var parentGroup = parentGroupID ? this.world.getGroupByID(parentGroupID) : undefined;
	// 	var pointCommands = this.parseElement(currConstraint).pointCommands;
	// 	// console.log($group.ID, parentGroup ? parentGroup.ID : undefined);
	// 	this.world.constrainGroups($group, parentGroup, this.getPoints(pointCommands));
	// }
};

// SVGParser.prototype.parseElements = function ($elements, $group)
// {
// 	for (var i = 0, elementsLength = $elements.length; i < elementsLength; i += 1)
// 	{
// 		var rawElement = $elements[i];

// 		var element = this.parseElement(rawElement);

// 		var nodesToDraw = $group.structure.create(element);
// 		this.setGraphicInstructions($group, rawElement, nodesToDraw, element);
// 	}
// };

SVGParser.prototype.parseElement = function ($rawElement)
{
	var tagName = $rawElement.tagName;

	switch (tagName)
	{
		case 'line':
			return this.parseLine($rawElement);
		case 'rect':
			return this.parseRect($rawElement);

		case 'polygon':
		case 'polyline':
			return this.parsePoly($rawElement);

		case 'path':
			return this.parsePath($rawElement);

		case 'circle':
		case 'ellipse':
			return this.parseCircle($rawElement);
	}
};

SVGParser.prototype.setGraphicInstructions = function ($group, $raw, $nodesToDraw, $drawingCommands)
{
	var drawing = $group.drawing = {};
	drawing.nodes = $nodesToDraw;
	var props = drawing.properties = {};
	//sorting nodesToDraw so the path is drawn correctly
	var start;
	for (var i = 0, length = $nodesToDraw.length; i < length; i += 1)
	{
		var currNode = $nodesToDraw[i];
		if (currNode.drawing.command === MOVE_TO || i === length - 1)
		{
			if (start) { start.drawing.endNode = currNode; }
			start = currNode;
		}

		$group.nodes.splice($group.nodes.indexOf(currNode), 1);
		$group.nodes.splice(i, 0, currNode);
	}

	var rawFill = $raw.getAttribute('fill');
	var rawStrokeWidth = $raw.getAttribute('stroke-width');
	var rawStroke = $raw.getAttribute('stroke');
	var rawLinecap = $raw.getAttribute('stroke-linecap');
	var rawLinejoin = $raw.getAttribute('stroke-linejoin');
	var rawOpacity = $raw.getAttribute('opacity');

	props.fill = rawFill || '#000000';
	props.lineWidth = rawStrokeWidth * this.ratio || 0;
	props.stroke = rawStroke && props.lineWidth !== 0 ? rawStroke : 'none';
	props.lineCap = rawLinecap && rawLinecap !== 'null' ? rawLinecap : 'butt';
	props.lineJoin = rawLinejoin && rawLinejoin !== 'null' ? rawLinejoin : 'miter';
	props.opacity = rawOpacity || 1;

	props.closePath = $drawingCommands.closePath;

	props.radiusX = $drawingCommands.radiusX;
	props.radiusY = $drawingCommands.radiusY;

	props.strokeGradient = this.getGradient(props.stroke);
	props.dynamicGradient = $group.conf.structure === 'line' && props.strokeGradient;
	props.fillGradient = this.getGradient(props.fill);
};

SVGParser.prototype.getGradient = function ($value)
{
	var gradientID = /url\(#(.*)\)/im.exec($value);
	if (gradientID)
	{
		var gradientElement = this.SVG.querySelector('#' + gradientID[1]);
		var m = this.getMatrix(gradientElement.getAttribute('gradientTransform'));

		if (gradientElement.tagName !== 'linearGradient' && gradientElement.tagName !== 'radialGradient') { return; }

		var gradient = { stops: [], type: gradientElement.tagName };

		if (gradientElement.tagName === 'linearGradient')
		{
			gradient.x1 = this.getCoord(gradientElement.getAttribute('x1'));
			gradient.y1 = this.getCoord(gradientElement.getAttribute('y1'));
			gradient.x2 = this.getCoord(gradientElement.getAttribute('x2'));
			gradient.y2 = this.getCoord(gradientElement.getAttribute('y2'));

			if (m)
			{
				var tfX1 = m[0] * gradient.x1 + m[1] * gradient.y1 + m[2];
				var tfY1 = m[3] * gradient.x1 + m[4] * gradient.y1 + m[5];
				var tfX2 = m[0] * gradient.x2 + m[1] * gradient.y2 + m[2];
				var tfY2 = m[3] * gradient.x2 + m[4] * gradient.y2 + m[5];

				gradient.x1 = tfX1;
				gradient.y1 = tfY1;
				gradient.x2 = tfX2;
				gradient.y2 = tfY2;
			}
		}
		if (gradientElement.tagName === 'radialGradient')
		{
			gradient.cx = this.getCoord(gradientElement.getAttribute('cx'));
			gradient.cy = this.getCoord(gradientElement.getAttribute('cy'));
			gradient.fx = gradientElement.getAttribute('fx') ? this.getCoord(gradientElement.getAttribute('fx')) : gradient.cx;
			gradient.fy = gradientElement.getAttribute('fy') ? this.getCoord(gradientElement.getAttribute('fy')) : gradient.cy;
			gradient.r = this.getCoord(gradientElement.getAttribute('r'));

			if (m)
			{
				var tfCX = m[0] * gradient.cx + m[1] * gradient.cy + m[2];
				var tfCY = m[3] * gradient.cx + m[4] * gradient.cy + m[5];
				var tfFX = m[0] * gradient.fx + m[1] * gradient.fy + m[2];
				var tfFY = m[3] * gradient.fx + m[4] * gradient.fy + m[5];

				gradient.cx = tfCX;
				gradient.cy = tfCY;
				gradient.fx = tfFX;
				gradient.fy = tfFY;
				// gradient.r = 10;
			}
		}

		var stops = gradientElement.querySelectorAll('stop');
		for (var k = 0, stopLength = stops.length; k < stopLength; k += 1)
		{
			var currStop = stops[k];
			var offset = Number(currStop.getAttribute('offset'));
			var color = currStop.getAttribute('stop-color') || /stop-color:(#[0-9A-F]+)/im.exec(currStop.getAttribute('style'))[1];
			var opacity = currStop.getAttribute('stop-opacity');
			gradient.stops.push({ offset: offset, color: color, opacity: opacity });
		}

		return gradient;
	}
};

SVGParser.prototype.parseCircle = function ($rawCircle)
{
	var xPos = this.getCoord($rawCircle.getAttribute('cx') || 0);
	var yPos = this.getCoord($rawCircle.getAttribute('cy') || 0);
	var radiusAttrX = $rawCircle.getAttribute('r') || $rawCircle.getAttribute('rx');
	var radiusAttrY = $rawCircle.getAttribute('ry');
	var radiusX = this.getCoord(radiusAttrX);
	var radiusY = this.getCoord(radiusAttrY) || radiusX;
	var rotation = this.getRotation($rawCircle.getAttribute('transform'));
	var pointCommands = [{ command: radiusY !== radiusX ? ELLIPSE : ARC, point: [xPos, yPos], options: [radiusX, radiusY, rotation] }];
	return { type: 'ellipse', pointCommands: pointCommands, radiusX: radiusX, radiusY: radiusY, closePath: false };
};

SVGParser.prototype.parseLine = function ($rawLine)
{
	var x1 = this.getCoord($rawLine.getAttribute('x1'));
	var x2 = this.getCoord($rawLine.getAttribute('x2'));
	var y1 = this.getCoord($rawLine.getAttribute('y1'));
	var y2 = this.getCoord($rawLine.getAttribute('y2'));
	var pointCommands = [];
	pointCommands.push({ command: MOVE_TO, point: [x1, y1], options: [] });
	pointCommands.push({ command: LINE_TO, point: [x2, y2], options: [] });
	return { type: 'line', pointCommands: pointCommands, closePath: false };
};

SVGParser.prototype.parseRect = function ($rawRect)
{
	var x1 = $rawRect.getAttribute('x') ? this.getCoord($rawRect.getAttribute('x')) : 0;
	var y1 = $rawRect.getAttribute('y') ? this.getCoord($rawRect.getAttribute('y')) : 0;
	var x2 = x1 + this.getCoord($rawRect.getAttribute('width'));
	var y2 = y1 + this.getCoord($rawRect.getAttribute('height'));

	var points =
	[
		[x1, y1],
		[x1, y2],
		[x2, y2],
		[x2, y1]
	];

	var m = this.getMatrix($rawRect.getAttribute('transform'));
	if (m)
	{
		points =
		[
			this.multiplyPointByMatrix(points[0], m),
			this.multiplyPointByMatrix(points[1], m),
			this.multiplyPointByMatrix(points[2], m),
			this.multiplyPointByMatrix(points[3], m)
			// [m[0] * x1 + m[1] * y1 + m[2], m[3] * x1 + m[4] * y1 + m[5]],
			// [m[0] * x1 + m[1] * y2 + m[2], m[3] * x1 + m[4] * y2 + m[5]],
			// [m[0] * x2 + m[1] * y2 + m[2], m[3] * x2 + m[4] * y2 + m[5]],
			// [m[0] * x2 + m[1] * y1 + m[2], m[3] * x2 + m[4] * y1 + m[5]]
		];
	}

	var pointCommands = [];
	pointCommands.push({ command: MOVE_TO, point: points[0], options: [] });
	pointCommands.push({ command: LINE_TO, point: points[1], options: [] });
	pointCommands.push({ command: LINE_TO, point: points[2], options: [] });
	pointCommands.push({ command: LINE_TO, point: points[3], options: [] });

	return { type: 'polygon', pointCommands: pointCommands, closePath: true };
};

SVGParser.prototype.parsePoly = function ($rawPoly)
{
	var regex = /([\-.\d]+)[, ]([\-.\d]+)/ig;
	var result = regex.exec($rawPoly.getAttribute('points'));
	var pointCommands = [];

	while (result)
	{
		var command = pointCommands.length === 0 ? MOVE_TO : LINE_TO;
		var point = [this.getCoord(result[1]), this.getCoord(result[2])];
		pointCommands.push({ command: command, point: point, options: [] });
		result = regex.exec($rawPoly.getAttribute('points'));
	}
	return { type: $rawPoly.tagName, pointCommands: pointCommands, closePath: $rawPoly.tagName !== 'polyline' };

	// var splits = $rawPoly.getAttribute('points').split(' ');
	// var pointCommands = {};

	// for (var i = 0, splitsLength = splits.length; i < splitsLength; i += 1)
	// {
	// 	var currSplit = splits[i];

	// 	if (currSplit !== '')
	// 	{
	// 		var point = currSplit.split(',');
	// 		var pointX = this.getCoord(point[0]);
	// 		var pointY = this.getCoord(point[1]);
	// 		var exists = false;
	// 		for (var k = 0, otherCoordsArrayLength = points.length; k < otherCoordsArrayLength; k += 1)
	// 		{
	// 			var otherPoint = points[k];
	// 			var otherX = otherPoint[0];
	// 			var otherY = otherPoint[1];
	// 			if (otherX === pointX && otherY === pointY)
	// 			{
	// 				exists = true;
	// 			}
	// 		}
	// 		if (exists === false)
	// 		{
	// 			points.push([pointX, pointY]);
	// 		}
	// 	}
	//}

	// var thickness = this.getCoord($rawPoly.getAttribute('stroke-width'));
	// var type = $rawPoly.tagName === 'polyline' ? 'polyline' : 'polygon';
	// return { type: type, pointCommands: points, thickness: thickness };
};

SVGParser.prototype.parsePath = function ($rawPath)
{
	var d = $rawPath.getAttribute('d');
	var pathReg = /([a-y])([.\-,\d]+)/igm;
	var result;
	var closePath = /z/igm.test(d);
	var coordsRegex = /-?[\d.]+/igm;
	var pointCommands = [];
	var lastX = this.getCoord(0);
	var lastY = this.getCoord(0);

	var that = this;
	var getPoint = function ($x, $y, $relative)
	{
		var x = $x === undefined ? lastX : that.getCoord($x);
		var y = $y === undefined ? lastY : that.getCoord($y);
		if ($relative)
		{
			x = lastX + x;
			y = lastY + y;
		}
		return [x, y];
	};

	var getRelativePoint = function ($point, $x, $y, $relative)
	{
		var x = that.getCoord($x);
		var y = that.getCoord($y);
		if ($relative)
		{
			x = lastX + x;
			y = lastY + y;
		}
		x = x - $point[0];
		y = y - $point[1];
		return [x, y];
	};

	var createPoint = function ($command, $point, $options)
	{
		var info = { command: $command, point: $point, options: $options || [] };
		lastX = info.point[0];
		lastY = info.point[1];
		pointCommands.push(info);
	};

	var point;
	var cubic1;
	var cubic2;
	var quadra1;

	do
	{
		result = pathReg.exec(d);
		if (result === null)
		{
			break;
		}
		var instruction = result[1].toLowerCase();
		var coords = result[2].match(coordsRegex);
		var isLowserCase = /[a-z]/.test(result[1]);

		switch (instruction)
		{
			default:
			case 'm':
				quadra1 = null;
				cubic2 = null;
				point = getPoint(coords[0], coords[1], isLowserCase);
				createPoint(MOVE_TO, point);
				break;
			case 'l':
				quadra1 = null;
				cubic2 = null;
				point = getPoint(coords[0], coords[1], isLowserCase);
				createPoint(LINE_TO, point);
				break;
			case 'v':
				quadra1 = null;
				cubic2 = null;
				point = getPoint(undefined, coords[0], isLowserCase);
				createPoint(LINE_TO, point);
				break;
			case 'h':
				quadra1 = null;
				cubic2 = null;
				point = getPoint(coords[0], undefined, isLowserCase);
				createPoint(LINE_TO, point);
				break;
			case 'c':
				quadra1 = null;
				point = getPoint(coords[4], coords[5], isLowserCase);
				cubic1 = getRelativePoint(point, coords[0], coords[1], isLowserCase);
				cubic2 = getRelativePoint(point, coords[2], coords[3], isLowserCase);
				createPoint(BEZIER_TO, point, [cubic1, cubic2]);
				break;
			case 's':
				quadra1 = null;
				point = getPoint(coords[2], coords[3], isLowserCase);
				cubic1 = cubic2 ? [lastX - cubic2[0] - point[0], lastY - cubic2[1] - point[1]] : undefined;
				cubic2 = getRelativePoint(point, coords[0], coords[1], isLowserCase);
				cubic1 = cubic1 || [cubic2[0], cubic2[1]];
				createPoint(BEZIER_TO, point, [cubic1, cubic2]);
				break;
			case 'q':
				cubic2 = null;
				point = getPoint(coords[2], coords[3], isLowserCase);
				quadra1 = getRelativePoint(point, coords[0], coords[1], isLowserCase);
				createPoint(QUADRA_TO, point, [quadra1]);
				break;
			case 't':
				cubic2 = null;
				quadra1 = quadra1 ? quadra1 : point;
				point = getPoint(coords[0], coords[1], isLowserCase);
				createPoint(QUADRA_TO, point, [quadra1]);
				break;
			case 'a':
				cubic2 = null;
				quadra1 = null;
				point = getPoint(coords[5], coords[6], isLowserCase);
				createPoint('arcTo', point);
				console.warn('not supported');
				break;
		}
	}
	while (result);

	return { type: 'path', pointCommands: pointCommands, closePath: closePath };
	//var points =
	// var pathReg = /([mlscvh])(-?[\d\.]*[,-]+[\d\.]*),?(-?[\d\.]*,?-?[\d\.]*),?(-?[\d\.]*,?-?[\d\.]*)/igm;
	// var points = [];
	// var lastCoordX = this.getCoord(0);
	// var lastCoordY = this.getCoord(0);
	// console.log(pathReg.exec(d));
	// debugger;
	// for (var array = pathReg.exec(d); array !== null; array = pathReg.exec(d))
	// {
	// 	var coordString;
	// 	var numberCoordX;
	// 	var numberCoordY;
	// 	if (array[1] === 'v')
	// 	{
	// 		numberCoordX = lastCoordX;
	// 		numberCoordY = lastCoordY + this.getCoord(array[2]);
	// 	}
	// 	else if (array[1] === 'h')
	// 	{
	// 		numberCoordX = lastCoordX + this.getCoord(array[2]);
	// 		numberCoordY = lastCoordY;
	// 	}
	// 	else
	// 	{
	// 		if (array[4] !== '')
	// 		{
	// 			coordString = array[4];
	// 		}
	// 		else if (array[3] !== '')
	// 		{
	// 			coordString = array[3];
	// 		}
	// 		else
	// 		{
	// 			coordString = array[2];
	// 		}
	// 		var coordReg = /(-?\d+\.?\d*)/igm;
	// 		var coords = coordString.match(coordReg);

	// 		numberCoordX = lastCoordX + this.getCoord(coords[0]);
	// 		numberCoordY = lastCoordY + this.getCoord(coords[1]);
	// 	}
	// 	//console.log(numberCoordX, numberCoordY);
	// 	points.push([numberCoordX, numberCoordY]);

	// 	lastCoordX = numberCoordX;
	// 	lastCoordY = numberCoordY;
	// }
	// console.log(points);
	// debugger;

	// var thickness = this.getCoord($rawPath.getAttribute('stroke-width'));
	// return { type: 'path', points: points, thickness: thickness };
};

SVGParser.prototype.round = function ($number)
{
	// var number = Number($number);
	// return Math.floor(number * 100) / 100;
	return $number;
	//return Math.floor(Number($number));
};

SVGParser.prototype.getMatrix = function ($attribute)
{
	if (!$attribute) { return null; }

	var TFType = $attribute.match(/([a-z]+)/igm)[0];
	var values = $attribute.match(/(-?[\d.]+)/igm);

	var matrices = [];
	var tX;
	var tY;
	var angle;

	if (TFType === 'matrix')
	{
		return [Number(values[0]), Number(values[2]), this.getCoord(values[4]), Number(values[1]), Number(values[3]), this.getCoord(values[5]), 0, 0, 1];
	}
	else if (TFType === 'rotate')
	{
		angle = Number(values[0]) * (Math.PI / 180);
		tX = this.getCoord(Number(values[1] || 0));
		tY = this.getCoord(Number(values[2] || 0));
		var m1 = [1, 0, tX, 0, 1, tY, 0, 0, 1];
		var m2 = [Math.cos(angle), -Math.sin(angle), 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 1];
		var m3 = [1, 0, -tX, 0, 1, -tY, 0, 0, 1];

		matrices.push(m1, m2, m3);
		var p = m1;

		for (var i = 1, matricesLength = matrices.length; i < matricesLength; i += 1)
		{
			var currMat = matrices[i];
			var newP = [0, 0, 0, 0, 0, 0, 0, 0, 0];
			for (var k = 0; k < 9; k += 1)
			{
				var row = Math.floor(k / 3);
				var col = k % 3;
				//var mVal = p[row * col - 1];
				for (var pos = 0; pos < 3; pos += 1)
				{
					newP[k] = newP[k] + p[row * 3 + pos] * currMat[pos * 3 + col];
				}
			}
			p = newP;
		}
		return p;
	}
	else if (TFType === 'translate')
	{
		tX = this.getCoord(Number(values[0] || 0));
		tY = this.getCoord(Number(values[1] || 0));
		return [1, 0, tX, 0, 1, tY, 0, 0, 1];
	}
	else if (TFType === 'scale')
	{
		var sX = this.getCoord(Number(values[0] || 0));
		var sY = this.getCoord(Number(values[1] || 0));
		return [sX, 0, 0, 0, sY, 0];
	}
	else if (TFType === 'skewX')
	{
		angle = Number(values[0]) * (Math.PI / 180);
		return [1, Math.tan(angle), 0, 0, 1, 0, 0, 0, 1];
	}
	else if (TFType === 'skewY')
	{
		angle = Number(values[0]) * (Math.PI / 180);
		return [1, 0, 0, Math.tan(angle), 1, 0, 0, 0, 1];
	}
};

SVGParser.prototype.multiplyPointByMatrix = function ($point, m)
{
	var h = [$point[0], $point[1], 1];
	var p =
	[
		m[0] * h[0] + m[1] * h[1] + m[2] * h[2],
		m[3] * h[0] + m[4] * h[1] + m[5] * h[2],
		m[6] * h[0] + m[7] * h[1] + m[8] * h[2]
	];
	return [p[0] / p[2], p[1] / p[2]];
};

SVGParser.prototype.getRotation = function ($attribute)
{
	var matrix = this.getMatrix($attribute);
	if (matrix)
	{
		return Math.atan2(matrix[0], matrix[3]);
	}
	return 0;
};

SVGParser.prototype.getCoord = function ($coordSTR)
{
	var number = this.round($coordSTR);
	return number * this.ratio;
};

SVGParser.prototype.parseCustomJoints = function ($rawGroup, $group)
{
	var children = $rawGroup.childNodes;//$rawGroup.querySelectorAll('[id*="constraint"]');

	for (var i = 0, childrenLength = children.length; i < childrenLength; i += 1)
	{
		if (children[i].nodeType === Node.TEXT_NODE || children[i].id.search(/joint/i) < 0) { continue; }

		var currRawJoint = children[i];
		var p1x = this.getCoord(currRawJoint.getAttribute('x1'));
		var p1y = this.getCoord(currRawJoint.getAttribute('y1'));
		var p2x = this.getCoord(currRawJoint.getAttribute('x2'));
		var p2y = this.getCoord(currRawJoint.getAttribute('y2'));

		var n1 = $group.getNodeAtPoint(p1x, p1y) || $group.createNode(p1x, p1y);
		var n2 = $group.getNodeAtPoint(p2x, p2y) || $group.createNode(p2x, p2y);
		$group.createJoint(n1, n2);
	}
};

module.exports = SVGParser;


},{"./Commands":"/Users/Lau/www/svjelly/src/core/Commands.js"}],"/Users/Lau/www/svjelly/src/core/SVJellyGroup.js":[function(require,module,exports){
var SVJellyNode = require('./SVJellyNode');
var SVJellyJoint = require('./SVJellyJoint');

var SVJellyGroup = function ($type, $conf, $ID)
{
	this.physicsManager = undefined;
	this.drawing = undefined;
	this.structure = undefined;
	this.conf = $conf;
	this.fixed = this.conf.fixed;
	this.type = $type;
	this.nodes = [];
	this.joints = [];
	this.ID = $ID;
};

SVJellyGroup.prototype.getNodeAtPoint = function ($x, $y)
{
	for (var i = 0, nodesLength = this.nodes.length; i < nodesLength; i += 1)
	{
		var node = this.nodes[i];

		if (node.oX === $x && node.oY === $y)
		{
			return node;
		}
	}
};

SVJellyGroup.prototype.createNode = function ($px, $py, $options, $overwrite)
{
	var node = this.getNodeAtPoint($px, $py);
	if (node !== undefined && $overwrite)
	{
		node.setOptions($options);
	}
	else
	{
		node = new SVJellyNode($px, $py, $options);
		this.nodes.push(node);
	}

	//this.physicsManager.addNodeToWorld(node);

	return node;
};

SVJellyGroup.prototype.getClosestPoint = function ($points, $nodes)
{
	var nodes = $nodes || this.nodes;
	var closestDist = Infinity;
	var closestPoint;
	var closestNode;
	var closestOffsetX;
	var closestOffsetY;

	for (var i = 0, length = $points.length; i < length; i += 1)
	{
		var currPoint = $points[i];
		for (var k = 0, nodesLength = nodes.length; k < nodesLength; k += 1)
		{
			var currNode = nodes[k];
			var offsetX = currPoint[0] - currNode.oX;
			var offsetY = currPoint[1] - currNode.oY;
			var cX = Math.abs(offsetX);
			var cY = Math.abs(offsetY);
			var dist = Math.sqrt(cX * cX + cY * cY);
			if (dist < closestDist)
			{
				closestNode = currNode;
				closestPoint = currPoint;
				closestDist = dist;
				closestOffsetX = offsetX;
				closestOffsetY = offsetY;
			}
		}
	}

	return closestPoint;
};

SVJellyGroup.prototype.getClosestNode = function ($coord, $nodes)
{
	var nodes = $nodes || this.nodes;
	var closestDist = Infinity;
	var closest;
	for (var i = 0, length = nodes.length; i < length; i += 1)
	{
		var node = nodes[i];
		var offsetX = $coord[0] - node.oX;
		var offsetY = $coord[1] - node.oY;
		var cX = Math.abs(offsetX);
		var cY = Math.abs(offsetY);
		var dist = Math.sqrt(cX * cX + cY * cY);
		if (dist < closestDist)
		{
			closest = node;
			closestDist = dist;
		}
	}
	return closest;
};

SVJellyGroup.prototype.getNodesInside = function ($points)
{
	var Polygon = require('./Polygon');
	var toReturn = [];
	var polygon = Polygon.init($points);
	for (var i = 0, length = this.nodes.length; i < length; i += 1)
	{
		var node = this.nodes[i];
		if (polygon.isInside([node.oX, node.oY]))
		{
			toReturn.push(node);
		}
	}
	return toReturn;
};

SVJellyGroup.prototype.getBoundingBox = function ()
{
	var minX;
	var maxX;
	var minY;
	var maxY;
	for (var i = 0, length = this.nodes.length; i < length; i += 1)
	{
		var node = this.nodes[i];
		minX = minX > node.oX || minX === undefined ? node.oX : minX;
		maxX = maxX < node.oX || maxX === undefined ? node.oX : maxX;
		minY = minY > node.oY || minY === undefined ? node.oY : minY;
		maxY = maxY < node.oY || maxY === undefined ? node.oY : maxY;
	}
	return [[minX, minY], [maxX, maxY]];
};

//TODO : to remove
SVJellyGroup.prototype.hitTest = function ($point)
{
	var currX = $point[0];
	var currY = $point[1];
	var bounding = this.getBoundingBox();
	if (currX >= bounding[0][0] && currX <= bounding[1][0] &&
		currY >= bounding[0][1] && currY <= bounding[1][1])
	{
		return true;
	}
	return false;
};

SVJellyGroup.prototype.createJoint = function ($node1, $node2)
{
	for (var i = 0, jointsLength = this.joints.length; i < jointsLength; i += 1)
	{
		var currJoint = this.joints[i];
		if ((currJoint.node1 === $node1 && currJoint.node2 === $node2) || (currJoint.node2 === $node1 && currJoint.node1 === $node2))
		{
			return;
		}
	}

	var joint = new SVJellyJoint($node1, $node2);

	this.joints.push(joint);

	//this.physicsManager.addJointToWorld(joint);
};

SVJellyGroup.prototype.addNodesToWorld = function ()
{
	this.physicsManager.addNodesToWorld();
};

SVJellyGroup.prototype.addJointsToWorld = function ()
{
	this.physicsManager.addJointsToWorld();
};

module.exports = SVJellyGroup;


},{"./Polygon":"/Users/Lau/www/svjelly/src/core/Polygon.js","./SVJellyJoint":"/Users/Lau/www/svjelly/src/core/SVJellyJoint.js","./SVJellyNode":"/Users/Lau/www/svjelly/src/core/SVJellyNode.js"}],"/Users/Lau/www/svjelly/src/core/SVJellyJoint.js":[function(require,module,exports){
var SVJellyJoint = function ($node1, $node2)
{
	this.node1 = $node1;
	this.node2 = $node2;
};

module.exports = SVJellyJoint;


},{}],"/Users/Lau/www/svjelly/src/core/SVJellyNode.js":[function(require,module,exports){
var SVJellyNode = function ($oX, $oY, $options)
{
	this.jointsArray = [];
	this.oX = $oX;
	this.oY = $oY;
	this.drawing = undefined;
	this.fixed = false;
	this.isStart = false;
	this.endNode = undefined;
	this.setOptions($options);
};

//raccourci
SVJellyNode.prototype.setOptions = function ($options)
{
	if ($options)
	{
		// var = $ === undefined ? {} : $options;
		if ($options.fixed !== undefined) { this.fixed = $options.fixed; }
	}
};

SVJellyNode.prototype.setFixed = function ($fixed)
{
	this.fixed = $fixed;
	this.physicsManager.setFixed($fixed);
};

SVJellyNode.prototype.getX = function ()
{
	return this.physicsManager.getX();
};

//raccourci
SVJellyNode.prototype.getY = function ()
{
	return this.physicsManager.getY();
};

module.exports = SVJellyNode;


},{}],"/Users/Lau/www/svjelly/src/core/SVJellyUtils.js":[function(require,module,exports){
module.exports = {
	extend: function ($toExtend, $extension)
	{
		var recur = function ($object, $extend)
		{
			for (var name in $extend)
			{
				if (typeof $extend[name] === 'object' && !Array.isArray($extend[name]) && $extend[name] !== null)
				{
					if ($object[name] === undefined) { $object[name] = {}; }
					recur($object[name], $extend[name]);
				}
				else
				{
					$object[name] = $extend[name];
				}
			}
		};
		recur($toExtend, $extension);

		return $toExtend;
	}
};


},{}],"/Users/Lau/www/svjelly/src/core/SVJellyWorld.js":[function(require,module,exports){
var SVJellyGroup = require('./SVJellyGroup');
var Structure = require('./Structure');

var SVJellyWorld = function ($physicsManager, $conf)
{
	this.physicsManager = $physicsManager;
	this.groups = [];
	this.conf = $conf;
	this.worldNodes = [];
	this.groupConstraints = [];
	this.worldWidth = this.physicsManager.worldWidth = $conf.worldWidth;
};

SVJellyWorld.prototype.setHeight = function ($height)
{
	this.worldHeight = this.physicsManager.worldHeight = $height;
};

SVJellyWorld.prototype.getWidth = function ()
{
	return this.worldWidth;
};

SVJellyWorld.prototype.getGroupByID = function ($ID)
{
	for (var i = 0, length = this.groups.length; i < length; i += 1)
	{
		var currGroup = this.groups[i];
		if (currGroup.ID === $ID) { return currGroup; }
	}
};

SVJellyWorld.prototype.createGroup = function ($type, $ID)
{
	var conf = this.conf.groups[$type] || this.conf.groups.default;
	var group = new SVJellyGroup($type, conf, $ID);
	group.physicsManager = this.physicsManager.getGroupPhysicsManager(group);
	group.structure = new Structure(group, this);
	this.groups.push(group);
	return group;
};

SVJellyWorld.prototype.constrainGroups = function ($groupA, $groupB, $points)
{
	var points = $points;
	var groupA = $groupA;
	var groupB = $groupB;

	if (points.length < 3)
	{
		var anchorA = groupA.physicsManager.createAnchorFromLine(points);
		points.splice(points.indexOf(anchorA.point), 1);
		var anchorB = groupB ? groupB.physicsManager.createAnchorFromPoint(points[0]) : this.physicsManager.createGhostAnchorFromPoint(points[0]);
		this.groupConstraints.push({ anchorA: anchorA, anchorB: anchorB });
	}
	else
	{
		var anchorsA = groupA.physicsManager.createAnchors(points);
		//console.log('A', groupA.ID, anchorsA.length, 'B', groupB ? groupB.ID : groupB);
		for (var i = 0, nodesLength = anchorsA.length; i < nodesLength; i += 1)
		{
			var currAnchorA = anchorsA[i];
			if (!groupB)
			{
				currAnchorA.setFixed(true);
			}
			else
			{
				var anchorsB = groupB.physicsManager.createAnchors(points);
				for (var k = 0, anchorsBLength = anchorsB.length; k < anchorsBLength; k += 1)
				{
					var currAnchorB = anchorsB[k];
					this.groupConstraints.push({ anchorA: currAnchorA, anchorB: currAnchorB });
				}
			}
		}
	}
};

SVJellyWorld.prototype.addGroupsToWorld = function ()
{
	for (var i = 0, groupsLength = this.groups.length; i < groupsLength; i += 1)
	{
		var currGroup = this.groups[i];
		currGroup.addNodesToWorld();
		currGroup.addJointsToWorld();
		this.worldNodes = this.worldNodes.concat(currGroup.nodes);
	}

	var toConstrainLength = this.groupConstraints.length;
	for (i = 0; i < toConstrainLength; i += 1)
	{
		var currToConstrain = this.groupConstraints[i];
		this.physicsManager.constrainGroups(currToConstrain.anchorA, currToConstrain.anchorB);
	}
};

module.exports = SVJellyWorld;


},{"./SVJellyGroup":"/Users/Lau/www/svjelly/src/core/SVJellyGroup.js","./Structure":"/Users/Lau/www/svjelly/src/core/Structure.js"}],"/Users/Lau/www/svjelly/src/core/Structure.js":[function(require,module,exports){
var Triangulator = require('./Triangulator');
var Polygon = require('./Polygon');
var Grid = require('./Grid');
var Commands = require('./Commands');

var Structure = function ($group, $world)
{
	this.world = $world;
	this.group = $group;
	this.innerStructure = undefined;
};

Structure.prototype.create = function ($drawingCommands)
{
	var nodesToDraw;

	this.points = this.getPoints($drawingCommands);
	this.drawingCommands = $drawingCommands;

	// console.log('points', points.length, this.group.conf.structure);

	this.area = this.calculateArea(this.points, $drawingCommands);
	this.radiusX = $drawingCommands.radiusX;
	this.radiusY = $drawingCommands.radiusY;

	switch (this.group.conf.structure)
	{
		case 'triangulate':
			this.removeDuplicates(this.drawingCommands);
			var triPoints = this.getPoints(this.drawingCommands);
			nodesToDraw = this.createNodesFromPoints(triPoints);
			this.setNodeDrawingCommands(nodesToDraw);
			this.createJointsFromTriangles(triPoints);
			break;
		case 'line':
			nodesToDraw = this.createNodesFromPoints(this.points);
			this.setNodeDrawingCommands(nodesToDraw);
			this.createJointsFromPoints(this.points, true);
			//nodesToDraw[0].fixed = true;//to remove later maybe ?
			break;
		case 'preciseHexaFill':
			nodesToDraw = this.createPreciseHexaFillStructure(this.points);
			// structureNodes.forEach(function ($element) { $element.drawing = { notToDraw: true }; });
			break;
		case 'hexaFill':
			nodesToDraw = this.createHexaFillStructure(this.points);
			break;
		default:
			nodesToDraw = this.createNodesFromPoints(this.points);
			this.setNodeDrawingCommands(nodesToDraw);
			break;
	}

	return nodesToDraw;
};

Structure.prototype.calculateArea = function ($points, $drawingCommands)
{
	if ($drawingCommands.type === 'ellipse')
	{
		return Math.pow(Math.PI * $drawingCommands.radiusX, 2);
	}
	if (this.group.conf.structure !== 'line')
	{
		var polygon = Polygon.init($points);
		return polygon.getArea();
	}
	else
	{
		var area = 0;
		for (var i = 1, length = $points.length; i < length; i += 1)
		{
			var currPoint = $points[i];
			var lastPoint = $points[i - 1];
			var dX = Math.abs(currPoint[0] - lastPoint[0]);
			var dY = Math.abs(currPoint[1] - lastPoint[1]);
			area += Math.sqrt(dX * dX + dY * dY);
		}
		return area;
	}
};

Structure.prototype.createHexaFillStructure = function ($points)
{
	this.createInnerStructure($points);
	var path = this.innerStructure.getShapePath();
	var nodesToDraw = [];
	for (var i = 0, length = path.length; i < length; i += 1)
	{
		var node = this.group.getNodeAtPoint(path[i][0], path[i][1]);
		nodesToDraw.push(node);
		node.drawing = {};
		node.drawing.command = i === 0 ? Commands.MOVE_TO : Commands.LINE_TO;
		node.drawing.point = [path[i][0], path[i][1]];
		node.drawing.options = [];
	}
	return nodesToDraw;
};

Structure.prototype.setNodeDrawingCommands = function ($nodes)
{
	for (var i = 0, length = $nodes.length; i < length; i += 1)
	{
		var node = $nodes[i];
		node.drawing = this.drawingCommands.pointCommands[i];
	}
};

Structure.prototype.createPreciseHexaFillStructure = function ($points)
{
	var nodesToDraw = this.createNodesFromPoints($points);
	this.setNodeDrawingCommands(nodesToDraw);
	this.createInnerStructure($points);

	this.createJointsFromPoints($points, false);
	var i = 0;
	var length = $points.length;
	for (i; i < length; i += 1)
	{
		var currPoint = $points[i];
		var closest = this.innerStructure.getClosest(currPoint[0], currPoint[1], 2);
		for (var k = 0, closestLength = closest.length; k < closestLength; k += 1)
		{
			var currClosest = closest[k];
			var n1 = this.group.getNodeAtPoint(currPoint[0], currPoint[1]);
			var n2 = this.group.getNodeAtPoint(currClosest[0], currClosest[1]);
			this.group.createJoint(n1, n2);
		}
	}
	return nodesToDraw;
};

Structure.prototype.createJointsFromTriangles = function ($points)
{
	var triangulator = new Triangulator();
	var triangles = triangulator.triangulate($points);

	var trianglesLength = triangles.length;
	for (var i = 0; i < trianglesLength; i += 1)
	{
		var currTriangle = triangles[i];
		var n0 = this.group.getNodeAtPoint(currTriangle[0].x, currTriangle[0].y);
		var n1 = this.group.getNodeAtPoint(currTriangle[1].x, currTriangle[1].y);
		var n2 = this.group.getNodeAtPoint(currTriangle[2].x, currTriangle[2].y);
		this.group.createJoint(n0, n1);
		this.group.createJoint(n1, n2);
		this.group.createJoint(n2, n0);
	}
};

Structure.prototype.getPoints = function ($drawingCommands)
{
	var points = [];
	for (var i = 0, length = $drawingCommands.pointCommands.length; i < length; i += 1)
	{
		var curr = $drawingCommands.pointCommands[i];
		points.push(curr.point);
	}
	return points;
};

Structure.prototype.createNodesFromPoints = function ($points)
{
	var pointsLength = $points.length;
	var toReturn = [];
	for (var i = 0; i < pointsLength; i += 1)
	{
		var currPoint = $points[i];
		var node = this.group.createNode(currPoint[0], currPoint[1], undefined, false);
		toReturn.push(node);
	}
	return toReturn;
};

Structure.prototype.removeDuplicates = function ($drawingCommands)
{
	var visitedPoints = [];
	var commands = $drawingCommands.pointCommands;
	for (var i = 0; i < commands.length; i += 1)
	{
		var point = commands[i].point;
		for (var k = 0; k < visitedPoints.length; k += 1)
		{
			var visited = visitedPoints[k];
			if (visited[0] === point[0] && visited[1] === point[1])
			{
				console.log(i, 'duplicate found !', visited[0], visited[1], point[0], point[1]);
				commands.splice(i, 1);
				i = i - 1;
			}
		}
		visitedPoints.push(point);
	}
};

Structure.prototype.createInnerStructure = function ($points)
{
	var polygon = Polygon.init($points);
	var diam = this.world.getWidth() * this.group.conf.innerStructureDef;//width / 10;//this.world.getWidth() / 30;
	this.innerRadius = this.group.conf.nodeRadius || diam / 2;
	this.innerStructure = Grid.createFromPolygon(polygon, diam, true);
	this.structureNodes = this.createNodesFromPoints(this.innerStructure.getNodesArray());

	var network = this.innerStructure.getNetwork();
	var i = 0;
	var length = network.length;
	for (i; i < length; i += 1)
	{
		var currLink = network[i];
		var n1 = this.group.getNodeAtPoint(currLink[0][0], currLink[0][1]);
		var n2 = this.group.getNodeAtPoint(currLink[1][0], currLink[1][1]);
		this.group.createJoint(n1, n2);
	}
	return this.structureNodes;
};

Structure.prototype.createJointsFromPoints = function ($points, $noClose)
{
	var pointsLength = $points.length;
	for (var i = 1; i < pointsLength; i += 1)
	{
		var currPoint = $points[i];
		var lastPoint = $points[i - 1];
		var lastNode = this.group.getNodeAtPoint(lastPoint[0], lastPoint[1]);
		var currNode = this.group.getNodeAtPoint(currPoint[0], currPoint[1]);
		this.group.createJoint(lastNode, currNode);
		if (i === pointsLength - 1 && $noClose !== true)
		{
			var firstNode = this.group.getNodeAtPoint($points[0][0], $points[0][1]);
			this.group.createJoint(currNode, firstNode);
		}
	}
};

module.exports = Structure;


},{"./Commands":"/Users/Lau/www/svjelly/src/core/Commands.js","./Grid":"/Users/Lau/www/svjelly/src/core/Grid.js","./Polygon":"/Users/Lau/www/svjelly/src/core/Polygon.js","./Triangulator":"/Users/Lau/www/svjelly/src/core/Triangulator.js"}],"/Users/Lau/www/svjelly/src/core/Triangulator.js":[function(require,module,exports){
var poly2tri = require('../../libs/poly2tri/dist/poly2tri');

var Triangulator = function ()
{
};

Triangulator.prototype.triangulate = function ($coords)
{
	var poly2triContour = [];
	//debugger;

	for (var i = 0, pointsLength = $coords.length; i < pointsLength; i += 1)
	{
		var point = $coords[i];
		poly2triContour.push(new poly2tri.Point(point[0], point[1]));
	}

	var swctx;
	try
	{
		// prepare SweepContext
		swctx = new poly2tri.SweepContext(poly2triContour, { cloneArrays: true });

		// triangulate
		swctx.triangulate();
	}
	catch (e)
	{
		throw e;
		// console.log(e);
		// console.log(e.points);
	}
	var triangles = swctx.getTriangles();

	var pointsArray = [];

	var trianglesLength = triangles.length;
	for (i = 0; i < trianglesLength; i += 1)
	{
		var currTriangle = triangles[i];
		/*jshint camelcase:false*/
		//jscs:disable disallowDanglingUnderscores
		pointsArray.push(currTriangle.points_);
		//jscs:enable disallowDanglingUnderscores
		/*jshint camelcase:true*/
	}

	return pointsArray;
};

module.exports = Triangulator;


},{"../../libs/poly2tri/dist/poly2tri":"/Users/Lau/www/svjelly/libs/poly2tri/dist/poly2tri.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2GhostPhysicsManager.js":[function(require,module,exports){
var AnchorP2GhostPhysicsManager = function ($p2, $p2World, $worldHeight)
{
	this.p2 = $p2;
	this.p2World = $p2World;
	this.offset = [0, 0];
	this.worldHeight = $worldHeight;
};

AnchorP2GhostPhysicsManager.prototype.setFromPoint = function ($point)
{
	this.point = $point;
};

AnchorP2GhostPhysicsManager.prototype.addToWorld = function ()
{
	this.body = new this.p2.Body({
		position: [this.point[0], this.worldHeight - this.point[1]]
	});
	this.p2World.addBody(this.body);
};

AnchorP2GhostPhysicsManager.prototype.getX = function ()
{
	return this.body.position[0];
};

AnchorP2GhostPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - this.body.position[1];
};

module.exports = AnchorP2GhostPhysicsManager;

},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2HardPhysicsManager.js":[function(require,module,exports){
var AnchorP2HardPhysicsManager = function ($group) { this.group = $group; };

AnchorP2HardPhysicsManager.prototype.setFromPoint = function ($point)
{
	this.point = $point;
};

AnchorP2HardPhysicsManager.prototype.addToWorld = function ()
{
	this.body = this.group.physicsManager.body;
	this.worldHeight = this.group.physicsManager.worldHeight;
	this.offset = [this.point[0] - this.body.interpolatedPosition[0], (this.worldHeight - this.point[1]) - this.body.interpolatedPosition[1]];
	var dX = this.offset[0];
	var dY = this.offset[1];
	this.angle = Math.atan2(dY, dX);
	this.hyp = Math.sqrt(dX * dX + dY * dY);
};

AnchorP2HardPhysicsManager.prototype.setFixed = function ($fixed)
{
	this.group.fixed = $fixed;
};

AnchorP2HardPhysicsManager.prototype.getX = function ()
{
	return this.body.interpolatedPosition[0] + this.hyp * Math.cos(this.body.angle + this.angle);
};

AnchorP2HardPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - (this.body.interpolatedPosition[1] + this.hyp * Math.sin(this.body.angle + this.angle));
};

module.exports = AnchorP2HardPhysicsManager;

},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2SoftPhysicsManager.js":[function(require,module,exports){
var AnchorP2SoftPhysicsManager = function ($group) { this.group = $group; };

AnchorP2SoftPhysicsManager.prototype.setFromPoint = function ($point)
{
	this.point = $point;
	this.node = this.group.getClosestNode($point);
	this.worldHeight = this.group.physicsManager.worldHeight;
	this.offset = [0, 0];
};

AnchorP2SoftPhysicsManager.prototype.addToWorld = function ()
{
	this.body = this.node.physicsManager.body;
};

AnchorP2SoftPhysicsManager.prototype.setFixed = function ($fixed)
{
	this.node.fixed = $fixed;
};

AnchorP2SoftPhysicsManager.prototype.getX = function ()
{
	return this.body.interpolatedPosition[0];
};

AnchorP2SoftPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - this.body.interpolatedPosition[1];
};

module.exports = AnchorP2SoftPhysicsManager;

},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/GroupGhostPhysicsManager.js":[function(require,module,exports){
var GroupGhostPhysicsManager = function ($group)
{
	this.group = $group;
};

GroupGhostPhysicsManager.prototype.addJointsToWorld = function ()
{
	return null;
};

GroupGhostPhysicsManager.prototype.addNodesToWorld = function ()
{
	var getX = function ($nodeOX) { return function () { return $nodeOX; }; };
	var getY = function ($nodeOY) { return function () { return $nodeOY; }; };
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		var node = this.group.nodes[i];
		var manager = {};
		manager.getX = getX(node.oX);
		manager.getY = getY(node.oY);
		node.physicsManager = manager;
	}
};

module.exports = GroupGhostPhysicsManager;


},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2HardPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var p2 = require('../../../libs/p2');
var NodeP2HardPhysicsManager = require('./NodeP2HardPhysicsManager');
var AnchorP2HardPhysicsManager = require('./AnchorP2HardPhysicsManager');

var GroupP2HardPhysicsManager = function ($P2World, $worldHeight, $group, $conf)
{
	this.group = $group;
	this.worldHeight = $worldHeight;
	this.P2World = $P2World;
	this.conf = $conf;
};

GroupP2HardPhysicsManager.prototype.createAnchorFromPoint = function ($point)
{
	var anchor = new AnchorP2HardPhysicsManager(this.group);
	anchor.setFromPoint($point);
	return anchor;
};

GroupP2HardPhysicsManager.prototype.createAnchorFromLine = function ($linePoints)
{
	var closestPoint = this.group.getClosestPoint($linePoints);
	var anchor = new AnchorP2HardPhysicsManager(this.group);
	anchor.setFromPoint(closestPoint);
	return anchor;
};

GroupP2HardPhysicsManager.prototype.createAnchors = function ($points)
{
	var toReturn = [];
	var nodes = this.group.getNodesInside($points);
	if (!nodes.length)
	{
		var defaultAnchor = new AnchorP2HardPhysicsManager(this.group);
		var closest = this.group.getClosestPoint($points);
		defaultAnchor.setFromPoint(closest);
		return [defaultAnchor];
	}
	for (var i = 0, length = nodes.length; i < length; i += 1)
	{
		var node = nodes[i];
		var currAnchorA = new AnchorP2HardPhysicsManager(this.group);
		currAnchorA.setFromPoint([node.oX, node.oY]);
		toReturn.push(currAnchorA);
	}
	return toReturn;
};

GroupP2HardPhysicsManager.prototype.addJointsToWorld = function () { return; };

GroupP2HardPhysicsManager.prototype.addNodesToWorld = function ()
{
	var path = [];
	var boundingBox = this.group.getBoundingBox();
	var width = boundingBox[1][0] - boundingBox[0][0];
	var height = boundingBox[1][1] - boundingBox[0][1];
	var startX = boundingBox[0][0] + width * 0.5;
	var startY = boundingBox[0][1] + height * 0.5;

	//startX = this.group.nodes[0].oX;
	//startY = this.group.nodes[0].oY;
	var initX = startX;
	var initY = this.worldHeight - startY;

	this.body = new p2.Body({
		mass: this.group.fixed ? 0 : 1,
		position: [startX, this.worldHeight - startY]
	});
	var node;
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		node = this.group.nodes[i];
		var pos = [node.oX - startX, -(node.oY - startY)];
		node.physicsManager = new NodeP2HardPhysicsManager(this.body, pos, this.worldHeight);
		path.push(pos);
	}

	if (length > 1)
	{
		this.body.fromPolygon(path);
		var offset = [initX - this.body.position[0], this.body.position[1] - initY];
		i = 0;
		for (i; i < length; i += 1)
		{
			node = this.group.nodes[i];
			node.physicsManager.setOffset(offset);
		}
	}
	else
	{
		var radius = this.group.structure.radiusX;
		var circleShape = new p2.Circle(radius);
		this.body.addShape(circleShape);
	}

	this.body.gravityScale = this.conf.gravityScale !== undefined ? this.conf.gravityScale : 1;
	// console.log(startX, this.worldHeight - startY, this.body.position[0], this.body.position[1]);
	//this.body.mass = this.conf.mass;
	//if (this.group.conf.fixed) { node.physicsManager.setFixed(this.group.conf.fixed); }
	//this.body.updateMassProperties();
	this.P2World.addBody(this.body);
	this.body.mass = this.body.getArea() * this.conf.mass;
	this.body.updateMassProperties();
	this.body.collisionResponse = !this.conf.noCollide;

	if (this.group.ID === 'ground')
	{
		console.log(this.body);
	}

	this.body.interpolatedPosition[0] = this.body.position[0];
	this.body.interpolatedPosition[1] = this.body.position[1];
	//node.physicsManager.setFixed(this.group.conf.fixed);
	// console.log(this.body.shapes);
	// debugger;
};

module.exports = GroupP2HardPhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js","./AnchorP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2HardPhysicsManager.js","./NodeP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2HardPhysicsManager.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2SoftPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var p2 = require('../../../libs/p2');
var NodeP2SoftPhysicsManager = require('./NodeP2SoftPhysicsManager');
var AnchorP2SoftPhysicsManager = require('./AnchorP2SoftPhysicsManager');

var GroupP2SoftPhysicsManager = function ($world, $worldHeight, $group, $conf)
{
	this.group = $group;
	this.world = $world;
	this.worldHeight = $worldHeight;
	this.conf = $conf;
	//this.nodesDiameter = this.conf.nodesDiameter;
};

GroupP2SoftPhysicsManager.prototype.createAnchorFromPoint = function ($point)
{
	var anchor = new AnchorP2SoftPhysicsManager(this.group);
	anchor.setFromPoint($point);
	return anchor;
};

GroupP2SoftPhysicsManager.prototype.createAnchorFromLine = function ($linePoints)
{
	var closestPoint = this.group.getClosestPoint($linePoints);
	var anchor = new AnchorP2SoftPhysicsManager(this.group);
	anchor.setFromPoint(closestPoint);
	return anchor;
};

GroupP2SoftPhysicsManager.prototype.createAnchors = function ($points)
{
	var toReturn = [];
	var nodes = this.group.getNodesInside($points);
	for (var i = 0, length = nodes.length; i < length; i += 1)
	{
		var node = nodes[i];
		var currAnchorA = new AnchorP2SoftPhysicsManager(this.group);
		currAnchorA.setFromPoint([node.oX, node.oY]);
		toReturn.push(currAnchorA);
	}
	return toReturn;
};

GroupP2SoftPhysicsManager.prototype.addJointsToWorld = function ()
{
	for (var i = 0, length = this.group.joints.length; i < length; i += 1)
	{
		var joint = this.group.joints[i];
		var lock = this.conf.lockConstraint;
		var distance = this.conf.distanceConstraint;
		var linearSpring = this.conf.linearSpring;
		var rotationalSpring = this.conf.rotationalSpring;

		if (lock)
		{
			var constraint1 = new p2.LockConstraint(joint.node1.physicsManager.body, joint.node2.physicsManager.body);
			if (lock.stiffness) { constraint1.setStiffness(lock.stiffness); } //default 20
			if (lock.relaxation) { constraint1.setRelaxation(lock.relaxation); }
			this.world.addConstraint(constraint1);
		}
		if (distance)
		{
			var constraint2 = new p2.DistanceConstraint(joint.node1.physicsManager.body, joint.node2.physicsManager.body);
			if (distance.stiffness) { constraint2.setStiffness(distance.stiffness); } // default 500
			if (distance.relaxation) { constraint2.setRelaxation(distance.relaxation); }// default 0.1
			this.world.addConstraint(constraint2);
		}
		if (linearSpring)
		{
			var constraint3 = new p2.LinearSpring(joint.node1.physicsManager.body, joint.node2.physicsManager.body);
			if (linearSpring.stiffness) { constraint3.stiffness = linearSpring.stiffness; }
			if (linearSpring.damping) { constraint3.damping = linearSpring.damping; }
			this.world.addSpring(constraint3);
		}
		if (rotationalSpring)
		{
			var constraint4 = new p2.RotationalSpring(joint.node1.physicsManager.body, joint.node2.physicsManager.body);
			if (rotationalSpring.stiffness) { constraint4.stiffness = rotationalSpring.stiffness; }
			if (rotationalSpring.damping) { constraint4.damping = rotationalSpring.damping; }
			//this.world.addSpring(constraint4);
		}
	}
};

GroupP2SoftPhysicsManager.prototype.setNodesMassFromJoints = function ()
{
	var NodeGraph = require('../../core/NodeGraph');
	var nodeGraph = new NodeGraph();
	var i;
	var startingVertices = [];
	var nodesLength = this.group.nodes.length;
	var jointsLength = this.group.joints.length;
	for (i = 0; i < jointsLength; i += 1)
	{
		var currJoint = this.group.joints[i];
		nodeGraph.connect(currJoint.node1, currJoint.node2);
	}
	for (i = 0; i < nodesLength; i += 1)
	{
		var node = this.group.nodes[i];
		if (node.fixed)
		{
			startingVertices.push(nodeGraph.getVertex(node));
		}
	}
	if (startingVertices.length === 0)
	{
		return;
	}
	nodeGraph.traverse(startingVertices);
	var verticesLength = nodeGraph.vertices.length;
	for (i = 0; i < verticesLength; i += 1)
	{
		var vertex = nodeGraph.vertices[i];
		var decay = Number(this.group.conf.physics.structuralMassDecay);
		var value = Math.pow(decay, vertex.mapValue / 5);//Math.pow(2, vertex.mapValue / 7.33);
		var body = vertex.node.physicsManager.body;
		if (!vertex.node.fixed)
		{
			//body.mass = this.conf.mass / this.group.nodes.length / value * body.getArea();
			//vertex.node.debugText = body.mass;
			//body.updateMassProperties();
			var massVariance = this.conf.massVariance || 0;
			var random = -massVariance + Math.random() * massVariance * 2;
			var baseMass = this.group.structure.area * this.conf.mass;
			var mass = baseMass + baseMass * random;
			body.mass = mass / value;
			body.invMass = 1 / body.mass;
			body.inertia = body.mass / 2;
			body.invInertia = 1 / body.inertia;
		}
	}
};

GroupP2SoftPhysicsManager.prototype.addNodesToWorld = function ()
{
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		var node = this.group.nodes[i];
		//var fractionMass = this.conf.mass / this.group.nodes.length;
		var area = this.group.structure.area;
		var nodeMass = area * this.conf.mass / this.group.nodes.length;
		//var mass = 500;
		//var mass = this.conf.mass;//Math.random() * 10 + 1;
		var body = new p2.Body({
			mass: node.fixed ? 0 : nodeMass,
			position: [node.oX, this.worldHeight - node.oY]
		});
		body.interpolatedPosition[0] = body.position[0];
		body.interpolatedPosition[1] = body.position[1];

		//if (node.fixed) { body.type = p2.Body.STATIC; }
		//console.log(node.oX, node.oY);
		//this.body.fixedRotation = true;
		body.gravityScale = this.conf.gravityScale || 1;//0;// -1;

		// var radius = this.conf.nodeRadius;
		// var circleShape = new p2.Circle(radius);
		// body.addShape(circleShape);
		if (this.group.structure.innerRadius)
		{
			var radius = this.group.structure.innerRadius;
			var circleShape = new p2.Circle(radius);
			body.addShape(circleShape);
		}
		else
		{
			// var particleShape = new p2.Particle();
			// body.addShape(particleShape);
			var circledShape = new p2.Circle(this.group.conf.nodeRadius);
			body.addShape(circledShape);
			// body.mass = nodeMass;
			// body.updateMassProperties();
		}

		//console.log(this.body.getArea());

		//this.body.setDensity(node.type === 'line' ? 1 : 5000);

		//body.damping = 1;
		//body.mass = mass;
		node.physicsManager = new NodeP2SoftPhysicsManager(p2, body, this.worldHeight);
		//node.physicsManager.setFixed(node.fixed);
		//body.setDensity(0.1);
		this.world.addBody(body);

		//body.mass = body.getArea() * this.conf.mass;
		//body.gravityScale = 0.1;
		//body.updateMassProperties();
		// body.mass = 0;
		// body.setDensity(0);
		//node.physicsManager.applyForce([0, 0]);
		// body.mass = 10;
		var massVariance = this.conf.massVariance || 0;
		var random = -massVariance + Math.random() * massVariance * 2;
		body.mass = body.mass + body.mass * random;
		//body.mass = body.mass;
		body.invMass = 1 / body.mass;
		body.inertia = body.mass * 0.5;
		body.invInertia = 1 / body.inertia;
		
		body.angularDamping = this.conf.angularDamping || body.angularDamping;
		body.damping = this.conf.damping || body.damping;
	}

	if (this.conf.structuralMassDecay) { this.setNodesMassFromJoints(); }
};

module.exports = GroupP2SoftPhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js","../../core/NodeGraph":"/Users/Lau/www/svjelly/src/core/NodeGraph.js","./AnchorP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2SoftPhysicsManager.js","./NodeP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2SoftPhysicsManager.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2HardPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/
var p2 = require('../../../libs/p2');

var NodeP2HardPhysicsManager = function ($body, $position, $worldHeight)
{
	this.body = $body;
	this.position = $position;
	this.worldHeight = $worldHeight;
	this.offset = [0, 0];
	this.getX = this.getXSimple;
	this.getY = this.getYSimple;
};

NodeP2HardPhysicsManager.prototype.setFixed = function ($fixed)
{
	if ($fixed)
	{
		this.body.type = p2.Body.STATIC;
		this.body.updateMassProperties();
	}
};

NodeP2HardPhysicsManager.prototype.setOffset = function ($offset)
{
	var dX = this.position[0] + $offset[0];
	var dY = this.position[1] - $offset[1];
	this.angle = Math.atan2(dY, dX);
	this.hyp = Math.sqrt(dX * dX + dY * dY);
	this.getX = this.getXOffset;
	this.getY = this.getYOffset;
};

NodeP2HardPhysicsManager.prototype.getXSimple = function ()
{
	return this.body.interpolatedPosition[0];
};

NodeP2HardPhysicsManager.prototype.getYSimple = function ()
{
	return this.worldHeight - this.body.interpolatedPosition[1];
};

NodeP2HardPhysicsManager.prototype.getXOffset = function ()
{
	return this.body.interpolatedPosition[0] + this.hyp * Math.cos(this.body.interpolatedAngle + this.angle);
};

NodeP2HardPhysicsManager.prototype.getYOffset = function ()
{
	return this.worldHeight - (this.body.interpolatedPosition[1] + this.hyp * Math.sin(this.body.interpolatedAngle + this.angle));
};

module.exports = NodeP2HardPhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2SoftPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var NodeP2SoftPhysicsManager = function ($p2, $body, $worldHeight)
{
	this.p2 = $p2;
	this.body = $body;
	this.worldHeight = $worldHeight;
};

NodeP2SoftPhysicsManager.prototype.applyForce = function ($vec)
{
	//console.log('nop', this.body.applyForceLocal, $vec);
	var loc = [];
	this.body.toWorldFrame(loc, [0, 0]);
	this.body.applyForce($vec, loc);
};

NodeP2SoftPhysicsManager.prototype.setFixed = function ($fixed)
{
	if ($fixed)
	{
		this.body.type = this.p2.Body.STATIC;
	}
};

NodeP2SoftPhysicsManager.prototype.getX = function ()
{
	//console.log(this.body.GetWorldCenter().get_x());
	return this.body.interpolatedPosition[0];
};

NodeP2SoftPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - this.body.interpolatedPosition[1];
};

module.exports = NodeP2SoftPhysicsManager;


},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/P2PhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var p2 = require('../../../libs/p2');
var GroupP2SoftPhysicsManager = require('./GroupP2SoftPhysicsManager');
var GroupP2HardPhysicsManager = require('./GroupP2HardPhysicsManager');
var GroupGhostPhysicsManager = require('./GroupGhostPhysicsManager');
var AnchorP2GhostPhysicsManager = require('./AnchorP2GhostPhysicsManager');

var P2PhysicsManager = function ($conf)
{
	this.p2World = new p2.World($conf);
	this.p2 = p2;
	this.conf = $conf;
	this.worldWidth = undefined;
	this.worldHeight = undefined;
	this.newTime = undefined;
	this.lastTime = undefined;
	//this.p2World.gravity = this.conf.gravity;
};

P2PhysicsManager.prototype.step = function ($time)
{
	this.newTime = $time - this.lastTime || 0;
	this.lastTime = $time;
	this.p2World.step(1 / 60, this.newTime, 5);
};

P2PhysicsManager.prototype.constrainGroups = function ($anchorA, $anchorB)
{
	$anchorA.addToWorld();
	$anchorB.addToWorld();
	var constraint = new p2.DistanceConstraint($anchorA.body, $anchorB.body,
	{
		localAnchorA: $anchorA.offset, // Point on bodyA
		localAnchorB: $anchorB.offset // Point on bodyB
	});
	this.p2World.addConstraint(constraint);
};

P2PhysicsManager.prototype.createGhostAnchorFromPoint = function ($point)
{
	var anchor = new AnchorP2GhostPhysicsManager(this.p2, this.p2World, this.worldHeight);
	anchor.setFromPoint($point);
	return anchor;
};

P2PhysicsManager.prototype.getGroupPhysicsManager = function ($group)
{
	switch ($group.conf.physics.bodyType)
	{
		case 'ghost': return new GroupGhostPhysicsManager($group);
		case 'hard': return new GroupP2HardPhysicsManager(this.p2World, this.worldHeight, $group, $group.conf.physics);
		case 'soft': return new GroupP2SoftPhysicsManager(this.p2World, this.worldHeight, $group, $group.conf.physics);
	}
};

module.exports = P2PhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js","./AnchorP2GhostPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2GhostPhysicsManager.js","./GroupGhostPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/GroupGhostPhysicsManager.js","./GroupP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2HardPhysicsManager.js","./GroupP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2SoftPhysicsManager.js"}],"/Users/Lau/www/svjelly/src/renderer/svjelly/SVJellyRenderer.js":[function(require,module,exports){
var Commands = require('../../core/Commands');
var ARC = Commands.ARC;
var LINE_TO = Commands.LINE_TO;
var MOVE_TO = Commands.MOVE_TO;
var BEZIER_TO = Commands.BEZIER_TO;
var QUADRA_TO = Commands.QUADRA_TO;
var ELLIPSE = Commands.ELLIPSE;

var SVJellyRenderer =//function ($world, $canvas)
{
	create: function ($world, $canvas)
	{
		var inst = Object.create(SVJellyRenderer);

		inst.mainContainer = inst.mainCanvas = $canvas;
		inst.world = $world;
		inst.multiCanvas = $world.conf.multiCanvas;
		inst.mainContext = inst.mainCanvas.getContext('2d');
		inst.debug = $world.conf.debug;
		inst.staticCanvas = [];
		inst.dynamicCanvas = [];
		inst.cachedHard = [];
		inst.dynamicGroups = [];
		inst.dynamicGroupsLength = undefined;

		inst.width = inst.mainCanvas.width;
		inst.height = inst.mainCanvas.height;

		inst.scaleX = inst.scaleY = inst.mainCanvas.width / inst.world.getWidth();

		inst.drawingGroups = [];
		var k = 0;
		var i;
		for (var groupsLength = inst.world.groups.length; k < groupsLength; k += 1)
		{
			var currGroup = inst.world.groups[k];
			inst.createDrawingGroup(currGroup);
		}
		inst.drawingGroupsLength = inst.drawingGroups.length;

		var drawingGroup;

		//caching non moving groups
		i = 0;
		var canvas;
		var context;
		for (i; i < inst.drawingGroupsLength; i += 1)
		{
			drawingGroup = inst.drawingGroups[i];
			if (drawingGroup.isStatic)
			{
				//if some static layers are on top of each other, no need to create
				//a new canvas, you can just draw the layers on the same one
				canvas = inst.staticCanvas[i - 1] || inst.createCanvas();
				context = canvas.getContext('2d');
				inst.staticCanvas[i] = canvas;
			}
			else
			{
				canvas = inst.dynamicCanvas[i - 1] || inst.createCanvas();
				context = canvas.getContext('2d');
				inst.dynamicCanvas[i] = canvas;
				inst.dynamicGroups.push(drawingGroup);
			}
			drawingGroup.canvas = canvas;
			drawingGroup.context = context;
		}
		inst.dynamicGroupsLength = inst.dynamicGroups.length;
		//

		//caching gradients and precalculating
		for (i = 0; i < inst.drawingGroupsLength; i += 1)
		{
			drawingGroup = inst.drawingGroups[i];
			//precalculating some instructions
			drawingGroup.properties.lineWidth = drawingGroup.properties.lineWidth * inst.scaleX;
			drawingGroup.properties.radiusX = drawingGroup.properties.radiusX * inst.scaleX;
			drawingGroup.properties.radiusY = drawingGroup.properties.radiusY * inst.scaleY;
			var nodesLength = drawingGroup.nodes.length;
			for (k = 0; k < nodesLength; k += 1)
			{
				var currNode = drawingGroup.nodes[k];
				var command = currNode.drawing.command;
				var options = currNode.drawing.options;
				if (drawingGroup.isSimpleDrawing && (command === BEZIER_TO || command === QUADRA_TO))
				{
					command = LINE_TO;
				}
				if (drawingGroup.isSimpleDrawing && (command === ELLIPSE))
				{
					command = ARC;
				}
				//precalculationg control points and radix;
				if (command === BEZIER_TO || command === QUADRA_TO)
				{
					for (var m = 0, length = options.length; m < length; m += 1)
					{
						var currOption = options[m];
						currOption[0] = currOption[0] * inst.scaleX;
						currOption[1] = currOption[1] * inst.scaleY;
					}
				}
				else if (command === ELLIPSE || command === ARC)
				{
					options[0] = options[0] * inst.scaleX;
					options[1] = options[1] * inst.scaleX;
				}
			}
			drawingGroup.nodesLength = drawingGroup.nodes.length;
			//
			if (drawingGroup.properties.strokeGradient)
			{
				drawingGroup.properties.stroke = inst.createGradient(drawingGroup.context, drawingGroup.properties.strokeGradient);
			}
			if (drawingGroup.properties.fillGradient)
			{
				drawingGroup.properties.fill = inst.createGradient(drawingGroup.context, drawingGroup.properties.fillGradient);
			}
		}

		// multi canvas
		if (inst.multiCanvas)
		{
			inst.container = document.createElement('div');
			inst.mainContainer = inst.container;
			inst.container.style.position = 'relative';
			inst.container.className = inst.mainCanvas.className;
			inst.mainCanvas.parentNode.replaceChild(inst.container, inst.mainCanvas);

			for (i = 0; i < inst.drawingGroupsLength; i += 1)
			{
				drawingGroup = inst.drawingGroups[i];
				inst.addLayer(inst.container, drawingGroup.canvas, !drawingGroup.isStatic);
				// if (!container.contains(drawingGroup.canvas)) { container.appendChild(drawingGroup.canvas); }
			}
		}
		inst.draw = inst.multiCanvas ? inst.drawMultiCanvas : inst.drawSingleCanvas;
		//

		//drawingGroups once
		for (i = 0; i < inst.drawingGroupsLength; i += 1)
		{
			drawingGroup = inst.drawingGroups[i];
			inst.drawGroup(drawingGroup, drawingGroup.context);
		}

		if (inst.debug)
		{
			inst.debugCanvas = inst.createCanvas();
			inst.debugContext = inst.debugCanvas.getContext('2d');
			inst.addLayer(inst.multiCanvas ? inst.container : inst.mainCanvas.parentNode, inst.debugCanvas, false);
		}

		if (!inst.multiCanvas) { inst.container = inst.mainCanvas; }

		return inst;
		//caching hard stuff - not interesting performance-wise yet
		// for (i = 0; i < inst.drawingGroupsLength; i += 1)
		// {
		// 	drawingGroup = inst.drawingGroups[i];
		// 	if (drawingGroup.bodyType === 'hard' && !drawingGroup.fixed)
		// 	{
		// 		canvas = inst.createCanvas();
		// 		inst.drawGroup(drawingGroup, canvas.getContext('2d'));
		// 		inst.cachedHard[i] = canvas;
		// 	}
		// }
	},

	addLayer: function ($parent, $canvas, $pointerEvents)
	{
		if ($parent.contains($canvas)) { return; }
		$parent.appendChild($canvas);
		$canvas.style.position = 'absolute';
		$canvas.style.top = this.mainCanvas.offsetTop + 'px';
		$canvas.style.left = this.mainCanvas.offsetLeft + 'px';
		$canvas.style.pointerEvents = $pointerEvents ? 'auto' : 'none';
	},
	createCanvas: function ()
	{
		var canvas = window.document.createElement('canvas');
		canvas.width = this.width;
		canvas.height = this.height;
		canvas.id = Math.random() * 10000000;
		return canvas;
	},

	createGradient: function ($context, $properties)
	{
		var x1 = $properties.x1 * this.scaleX;
		var y1 = $properties.y1 * this.scaleY;
		var x2 = $properties.x2 * this.scaleX;
		var y2 = $properties.y2 * this.scaleY;

		var cx = $properties.cx * this.scaleX;
		var cy = $properties.cy * this.scaleY;
		var fx = $properties.fx * this.scaleX || cx;
		var fy = $properties.fy * this.scaleY || cy;
		var r = $properties.r * this.scaleX;

		var gradient = $properties.type === 'linearGradient' ? $context.createLinearGradient(x1, y1, x2, y2) : $context.createRadialGradient(cx, cy, 0, fx, fy, r);

		for (var stopN = 0, stopLength = $properties.stops.length; stopN < stopLength; stopN += 1)
		{
			gradient.addColorStop($properties.stops[stopN].offset, $properties.stops[stopN].color);
		}

		return gradient;
	},

	createDrawingGroup: function ($group)
	{
		var drawingGroup;
		for (var i = 0, length = this.world.groups.length; i < length; i += 1)
		{
			var currGroup = this.world.groups[i];
			if (!currGroup.drawingGroup) { continue; }
			if (this.compareProperties(currGroup.drawingGroup.properties, $group.drawing.properties) &&
				this.willNotIntersect(currGroup, $group) &&
				!this.isStatic($group) &&
				this.isSimpleDrawing($group) === this.isSimpleDrawing(currGroup))
			{
				drawingGroup = $group.drawingGroup = currGroup.drawingGroup;
			}
		}
		if (!drawingGroup)
		{
			drawingGroup =
			{
				properties: $group.drawing.properties,
				isStatic: this.isStatic($group),
				isSimpleDrawing: this.isSimpleDrawing($group),
				nodes: []
			};
			$group.drawingGroup = drawingGroup;
			this.drawingGroups.push(drawingGroup);
		}
		drawingGroup.nodes = drawingGroup.nodes.concat($group.drawing.nodes);
		return drawingGroup;
	},

	isStatic: function ($group)
	{
		return $group.conf.fixed === true;
	},

	getCollisionGroup: function ($group)
	{
		return $group.conf.physics.bodyType;
	},

	willNotIntersect: function ($groupA, $groupB)
	{
		if ($groupA.conf.physics.bodyType === 'hard' || $groupB.conf.physics.bodyType === 'hard')
		{
			return false;
		}
		return true;
	},
	isSimpleDrawing: function ($group)
	{
		if ($group.conf.physics.bodyType === 'hard' || $group.conf.physics.bodyType === 'soft')
		{
			return true;
		}
		return false;
	},

	compareProperties: function ($one, $two)
	{
		var comparison = true;
		for (var name in $two)
		{
			if ($one[name] !== $two[name]) { comparison = false; }
		}
		return comparison;
	},

	drawMultiCanvas: function ()
	{
		//this.mainContext.clearRect(0, 0, this.width, this.height);
		var previous;
		for (var i = 0; i < this.dynamicGroupsLength; i += 1)
		{
			var drawingGroup = this.dynamicGroups[i];
			if (previous !== drawingGroup.context) { drawingGroup.context.clearRect(0, 0, this.width, this.height); }
			previous = drawingGroup.context;
			this.drawGroup(drawingGroup, drawingGroup.context);
		}

		if (this.debug) { this.debugDraw(true); }
	},

	drawSingleCanvas: function ()
	{
		this.mainContext.clearRect(0, 0, this.width, this.height);
		//this.context.miterLimit = 1;
		var previousCached;
		for (var i = 0; i < this.drawingGroupsLength; i += 1)
		{
			var drawingGroup = this.drawingGroups[i];
			if (this.staticCanvas[i])
			{
				if (this.staticCanvas[i] === previousCached) { continue; }
				this.mainContext.drawImage(this.staticCanvas[i], 0, 0);
				previousCached = this.staticCanvas[i];
			}
			else
			{
				this.drawGroup(drawingGroup, this.mainContext);
			}
		}

		if (this.debug) { this.debugDraw(true); }
	},

	drawGroup: function (drawing, context)
	{
		context.beginPath();

		if (context.fillStyle !== drawing.properties.fill) { context.fillStyle = drawing.properties.fill; }
		if (context.strokeStyle !== drawing.properties.stroke) { context.strokeStyle = drawing.properties.stroke; }
		if (context.lineWidth !== drawing.properties.lineWidth) { context.lineWidth = drawing.properties.lineWidth; }
		if (context.lineCap !== drawing.properties.lineCap) { context.lineCap = drawing.properties.lineCap; }
		if (context.lineJoin !== drawing.properties.lineJoin) { context.lineJoin = drawing.properties.lineJoin; }
		if (context.globalAlpha !== drawing.properties.opacity) { context.globalAlpha = drawing.properties.opacity; }

		for (var k = 0; k < drawing.nodesLength; k += 1)
		{
			var currNode = drawing.nodes[k];
			if (currNode.drawing.command === MOVE_TO)
			{
				context.moveTo(currNode.getX() * this.scaleX, currNode.getY() * this.scaleY);

				//special case for lines with nice dynamic gradients
				if (drawing.properties.dynamicGradient)
				{
					var x1 = currNode.getX() * this.scaleX;
					var y1 = currNode.getY() * this.scaleY;
					var x2 = currNode.drawing.endNode.getX() * this.scaleX;
					var y2 = currNode.drawing.endNode.getY() * this.scaleY;
					var gradient = context.createLinearGradient(x1, y1, x2, y2);
					for (var stopN = 0, stopLength = drawing.properties.strokeGradient.stops.length; stopN < stopLength; stopN += 1)
					{
						gradient.addColorStop(1 - drawing.properties.strokeGradient.stops[stopN].offset, drawing.properties.strokeGradient.stops[stopN].color);
					}
					context.strokeStyle = gradient;
				}
				//
			}
			else if (currNode.drawing.command === LINE_TO)
			{
				context.lineTo(currNode.getX() * this.scaleX, currNode.getY() * this.scaleY);
				continue;
			}
			else if (currNode.drawing.command === ARC)
			{
				context.moveTo(currNode.getX() * this.scaleX, currNode.getY() * this.scaleY);
				context.arc(currNode.getX() * this.scaleX, currNode.getY() * this.scaleY, currNode.drawing.options[0], 0, Math.PI * 2);
			}
			if (!drawing.isSimpleDrawing)
			{
				var options = currNode.drawing.options;
				var baseX = currNode.getX() * this.scaleX;
				var baseY = currNode.getY() * this.scaleY;
				var cp1x;
				var cp1y;

				if (currNode.drawing.command === BEZIER_TO || currNode.drawing.command === QUADRA_TO)
				{
					cp1x = baseX + options[0][0];
					cp1y = baseY + options[0][1];
				}

				if (currNode.drawing.command === BEZIER_TO)
				{
					var cp2x = baseX + options[1][0];
					var cp2y = baseY + options[1][1];
					context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, baseX, baseY);
					//context.lineTo(baseX, baseY);
				}
				else if (currNode.drawing.command === QUADRA_TO)
				{
					context.quadraticCurveTo(cp1x, cp1y, baseX, baseY);
				}
				else if (currNode.drawing.command === MOVE_TO)
				{
					context.moveTo(currNode.getX() * this.scaleX, currNode.getY() * this.scaleY);
				}
				else if (currNode.drawing.command === ELLIPSE)
				{
					context.moveTo(currNode.getX() * this.scaleX, currNode.getY() * this.scaleY);
					context.ellipse(currNode.getX() * this.scaleX, currNode.getY() * this.scaleY, currNode.drawing.options[0], currNode.drawing.options[1], currNode.drawing.options[2], 0, Math.PI * 2);
				}
			}
		}

		if (drawing.properties.closePath) { context.closePath(); }
		if (drawing.properties.fill !== 'none') { context.fill(); }
		if (drawing.properties.stroke !== 'none') { context.stroke(); }
		if (drawing.properties.opacity !== 1) { context.globalAlpha = 1; }
	},

	debugDraw: function ($clear)
	{
		if ($clear !== undefined) { this.debugContext.clearRect(0, 0, this.width, this.height); }

		this.debugContext.strokeStyle = 'yellow';
		this.debugContext.lineCap = 'butt';
		this.debugContext.lineJoin = 'miter';
		this.debugContext.lineWidth = 1;
		this.debugContext.beginPath();
		var currGroup;
		var i;
		var k;
		var groupsLength = this.world.groups.length;
		var nodesLength;
		for (k = 0; k < groupsLength; k += 1)
		{
			currGroup = this.world.groups[k];

			nodesLength = currGroup.nodes.length;
			for (i = 0; i < nodesLength; i += 1)
			{
				var currNode = currGroup.nodes[i];
				this.debugContext.moveTo(currNode.getX() * this.scaleX, currNode.getY() * this.scaleY);
				var radius = currGroup.structure.innerRadius || currGroup.conf.nodeRadius || currGroup.structure.radiusX || 0.01;
				radius *= this.scaleX;
				// console.log(currGroup.structure.innerRadius, currGroup.conf.nodeRadius, currGroup.structure.radiusX);
				// console.log(radius);
				// debugger;
				this.debugContext.arc(currNode.getX() * this.scaleX, currNode.getY() * this.scaleY, radius, 0, Math.PI * 2);
			}
		}
		this.debugContext.stroke();

		this.debugContext.strokeStyle = 'rgba(255,1,1,1)';
		this.debugContext.beginPath();
		for (k = 0; k < groupsLength; k += 1)
		{
			currGroup = this.world.groups[k];
			var jointsLength = currGroup.joints.length;

			for (i = 0; i < jointsLength; i += 1)
			{
				var currJoint = currGroup.joints[i];
				this.debugContext.moveTo(currJoint.node1.getX() * this.scaleX, currJoint.node1.getY() * this.scaleY);
				this.debugContext.lineTo(currJoint.node2.getX() * this.scaleX, currJoint.node2.getY() * this.scaleY);
			}
		}
		this.debugContext.stroke();

		this.debugContext.strokeStyle = 'blue';
		this.debugContext.beginPath();
		var length = this.world.groupConstraints.length;
		for (k = 0; k < length; k += 1)
		{
			var currLock = this.world.groupConstraints[k];
			this.debugContext.moveTo(currLock.anchorA.getX() * this.scaleX, currLock.anchorA.getY() * this.scaleY);
			this.debugContext.lineTo(currLock.anchorB.getX() * this.scaleX, currLock.anchorB.getY() * this.scaleY);
		}
		this.debugContext.stroke();

		this.debugContext.fillStyle = 'black';
		for (k = 0; k < groupsLength; k += 1)
		{
			var group = this.world.groups[k];
			nodesLength = group.nodes.length;
			for (i = 0; i < nodesLength; i += 1)
			{
				var node = group.nodes[i];
				if (node.debugText) { this.debugContext.fillText(node.debugText, node.getX() * this.scaleX, node.getY() * this.scaleY); }
			}
		}
	}
};

module.exports = SVJellyRenderer;


},{"../../core/Commands":"/Users/Lau/www/svjelly/src/core/Commands.js"}],"/Users/Lau/www/svjelly/src/svjellymaker.js":[function(require,module,exports){
var SVJellyWorld = require('./core/SVJellyWorld');
var SVJellyRenderer = require('./renderer/svjelly/SVJellyRenderer');
var SVGParser = require('./core/SVGParser');
var P2PhysicsManager = require('./physics/p2physics/P2PhysicsManager');
var SVJellyUtils = require('./core/SVJellyUtils');
var confObject = require('./core/ConfObject');

var requestAnimFrame = window.requestAnimationFrame ||
						window.webkitRequestAnimationFrame ||
						window.mozRequestAnimationFrame;

var cancelAnimFrame = window.cancelAnimationFrame ||
						window.webkitCancelAnimationFrame ||
						window.mozCancelAnimationFrame;

//TODO promise polyfill
var SVJellyMaker =
{
	createFromURL: function ($canvas, $URL, $physicsManager, $Renderer)
	{
		var svjellyMaker = Object.create(SVJellyMaker);
		svjellyMaker.canvas = $canvas;
		svjellyMaker.Renderer = $Renderer;
		svjellyMaker.physicsManager = $physicsManager;
		svjellyMaker.promise = new window.Promise(function (resolve)
		{
			svjellyMaker.loadFile($URL, function ($SVG)
			{
				svjellyMaker.create($canvas, $SVG);
				resolve();
			}, true);
		});
		return svjellyMaker;
	},
	createFromConfig: function ($canvas, $configURL, $physicsManager, $Renderer)
	{
		var svjellyMaker = Object.create(SVJellyMaker);
		svjellyMaker.canvas = $canvas;
		svjellyMaker.Renderer = $Renderer;
		svjellyMaker.physicsManager = $physicsManager;

		svjellyMaker.promise = new window.Promise(function (resolve)
		{
			var loadConfigComplete = function ($configData)
			{
				var JSONConfig = JSON.parse($configData);
				svjellyMaker.conf = SVJellyUtils.extend(confObject, JSONConfig);

				SVJellyMaker.loadFile(svjellyMaker.conf.source, function ($SVG)
				{
					svjellyMaker.create($canvas, $SVG);
					resolve();
				}, true);
			};
			SVJellyMaker.loadFile($configURL, loadConfigComplete);
		});

		return svjellyMaker;
	},
	createFromString: function ($canvas, $string)
	{
		var parser = new DOMParser();
		var doc = parser.parseFromString($string, 'image/svg+xml');
		var svjellyMaker = Object.create(SVJellyMaker);
		svjellyMaker.promise = new window.Promise(function (resolve)
		{
			svjellyMaker.create($canvas, doc);
			resolve();
		});
		return svjellyMaker;
	},
	createFromPageSVG: function ($physicsManager, $Renderer)
	{
		var svjellies = document.querySelectorAll('[data-svjelly]');

		var createViewer = function ($element)
		{
			var svjellyMaker = Object.create(SVJellyMaker);
			var currSVG = $element;
			var appendCanvas = function ($config)
			{
				svjellyMaker.conf = $config;
				var canvas = document.createElement('canvas');
				canvas.width = currSVG.clientWidth;
				canvas.height = currSVG.clientHeight;
				currSVG.parentElement.insertBefore(canvas, currSVG);
				currSVG.remove();
				svjellyMaker.canvas = canvas;
				svjellyMaker.Renderer = $Renderer;
				svjellyMaker.physicsManager = $physicsManager;
				var wrapper = document.createElement('div');
				wrapper.appendChild(currSVG);
				svjellyMaker.create(canvas, wrapper);
			};
			var configURL = currSVG.getAttribute('data-svjelly');
			if (configURL)
			{
				SVJellyMaker.loadFile(configURL, function ($configData)
				{
					var JSONConfig = JSON.parse($configData);
					appendCanvas(SVJellyUtils.extend(confObject, JSONConfig));
				});
			}
			else
			{
				appendCanvas();
			}
		};

		for (var i = 0, length = svjellies.length; i < length; i += 1)
		{
			var currSVG = svjellies[i];
			createViewer(currSVG);
		}
	},

	create: function ($canvas, $SVG)
	{
		var conf = this.conf || confObject;
		this.canvas = $canvas;

		this.physicsManager = this.physicsManager || new P2PhysicsManager(conf);
		var svjellyWorld = this.svjellyWorld = new SVJellyWorld(this.physicsManager, conf);

		var canvasDefinition = conf.definition;
		var svgDef = $SVG.querySelector('svg');
		var parser = new SVGParser();
		parser.parse(svjellyWorld, svgDef);
		var canvasWidth = this.canvas.clientWidth * canvasDefinition;
		var canvasHeight = this.canvas.clientWidth * (parser.viewBoxHeight / parser.viewBoxWidth) * canvasDefinition;

		this.canvas.width = canvasWidth;
		this.canvas.height = canvasHeight;
		this.canvas.style.transformOrigin = '0 0';
		this.canvas.style.transform = 'scale(' + 1 / canvasDefinition + ')';

		this.renderer = this.Renderer ? this.Renderer.create(svjellyWorld, this.canvas) : SVJellyRenderer.create(svjellyWorld, this.canvas);

		var requestID = '';
		var lastRender = window.performance.now();
		var diffRender;
		var renderTargetFPS = 0;
		var that = this;

		var update = function ($now)
		{
			if (that.updateCallback) { that.updateCallback($now); }

			diffRender = $now - lastRender;

			that.svjellyWorld.physicsManager.step($now);
			if (diffRender >= renderTargetFPS)
			{
				that.renderer.draw();
				lastRender = $now;
			}
			requestID = requestAnimFrame(update);
		};

		var addAnimRequest = function ()
		{
			cancelAnimFrame(requestID);
			requestID = requestAnimFrame(update);
		};
		var cancelAnimRequest = function ()
		{
			cancelAnimFrame(requestID);
		};

		window.addEventListener('focus', addAnimRequest);
		window.addEventListener('blur', cancelAnimRequest);
		addAnimRequest();

		this.remove = function ()
		{
			cancelAnimRequest();
			window.removeEventListener('focus', addAnimRequest);
			window.removeEventListener('blur', cancelAnimRequest);
		};
	},

	loadFile: function ($URL, $successCallback, $XML)
	{
		var error = function ()
		{
			console.log('error', $URL);
		};

		var handler = function ()
		{
			$successCallback($XML ? this.responseXML : this.responseText);
		};

		var request = new XMLHttpRequest();
		request.addEventListener('load', handler);
		request.addEventListener('error', error);
		request.open('get', $URL, true);
		request.send();
	},

	addBasicMouseControls: function ()
	{
		var world = this.svjellyWorld;
		var p2 = world.physicsManager.p2;
		var p2World = world.physicsManager.p2World;
		var container = this.renderer.container;

		//MOUSE
		var mouseBody = new p2.Body();
		p2World.addBody(mouseBody);

		var mouseConstraint;
		var bodies = p2World.bodies.concat();
		var body;
		var scale = this.renderer.scaleX;
		var renderer = this.renderer;

		var getPhysicsCoord = function (mouseEvent)
		{
			var x = mouseEvent.clientX - container.offsetLeft;
			var y = mouseEvent.clientY - container.offsetTop;

			x = x / scale;
			// console.log(container.offsetLeft, container.offsetTop, mouseEvent.clientX, mouseEvent.clientY, scale);
			y = (renderer.height - y) / scale;
			return [x, y];
		};

		var mouseMove = function (event)
		{
			var position = getPhysicsCoord(event);
			mouseBody.position[0] = position[0];
			mouseBody.position[1] = position[1];
		};

		var mouseDown = function (event)
		{
			var position = getPhysicsCoord(event);

			// Check if the cursor is inside the box
			var hitBodies = p2World.hitTest(position, bodies);

			if (hitBodies.length)
			{
				body = hitBodies[0];
				// Move the mouse body to the cursor position

				mouseBody.position[0] = position[0];
				mouseBody.position[1] = position[1];

				// Create a RevoluteConstraint.
				// This constraint lets the bodies rotate around a common point
				mouseConstraint = new p2.RevoluteConstraint(mouseBody, body,
				{
					worldPivot: position,
					collideConnected: false
				});
				p2World.addConstraint(mouseConstraint);
				container.addEventListener('mousemove', mouseMove);
			}
		};

		var mouseUp = function ()
		{
			p2World.removeConstraint(mouseConstraint);
			mouseConstraint = null;
			container.removeEventListener('mousemove', mouseMove);
		};

		container.addEventListener('mousedown', mouseDown);
		// Remove the mouse constraint on mouse up
		container.addEventListener('mouseup', mouseUp);

		this.removeBasicMouseControls = function ()
		{
			container.removeEventListener('mousemove', mouseMove);
			container.removeEventListener('mousedown', mouseDown);
			container.removeEventListener('mouseup', mouseUp);
		};
	}
};

if (document.querySelector('[data-svjelly-auto]'))
{
	var windowLoadHandler = function ()
	{
		SVJellyMaker.createFromPageSVG();
	};
	window.addEventListener('load', windowLoadHandler);
}

module.exports = SVJellyMaker;

},{"./core/ConfObject":"/Users/Lau/www/svjelly/src/core/ConfObject.js","./core/SVGParser":"/Users/Lau/www/svjelly/src/core/SVGParser.js","./core/SVJellyUtils":"/Users/Lau/www/svjelly/src/core/SVJellyUtils.js","./core/SVJellyWorld":"/Users/Lau/www/svjelly/src/core/SVJellyWorld.js","./physics/p2physics/P2PhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/P2PhysicsManager.js","./renderer/svjelly/SVJellyRenderer":"/Users/Lau/www/svjelly/src/renderer/svjelly/SVJellyRenderer.js"}]},{},["/Users/Lau/www/svjelly/src/svjellymaker.js"])("/Users/Lau/www/svjelly/src/svjellymaker.js")
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWJzL3AyLmpzIiwibGlicy9wb2x5MnRyaS9kaXN0L3BvbHkydHJpLmpzIiwic3JjL2NvcmUvQ29tbWFuZHMuanMiLCJzcmMvY29yZS9Db25mT2JqZWN0LmpzIiwic3JjL2NvcmUvR3JpZC5qcyIsInNyYy9jb3JlL05vZGVHcmFwaC5qcyIsInNyYy9jb3JlL1BvbHlnb24uanMiLCJzcmMvY29yZS9TVkdQYXJzZXIuanMiLCJzcmMvY29yZS9TVkplbGx5R3JvdXAuanMiLCJzcmMvY29yZS9TVkplbGx5Sm9pbnQuanMiLCJzcmMvY29yZS9TVkplbGx5Tm9kZS5qcyIsInNyYy9jb3JlL1NWSmVsbHlVdGlscy5qcyIsInNyYy9jb3JlL1NWSmVsbHlXb3JsZC5qcyIsInNyYy9jb3JlL1N0cnVjdHVyZS5qcyIsInNyYy9jb3JlL1RyaWFuZ3VsYXRvci5qcyIsInNyYy9waHlzaWNzL3AycGh5c2ljcy9BbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL0dyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5qcyIsInNyYy9waHlzaWNzL3AycGh5c2ljcy9Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL1AyUGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcmVuZGVyZXIvc3ZqZWxseS9TVkplbGx5UmVuZGVyZXIuanMiLCJzcmMvc3ZqZWxseW1ha2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzc5WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9kQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IHAyLmpzIGF1dGhvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4hZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZmYWxzZSlkZWZpbmUoZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYucDI9ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2NhbGFyID0gX2RlcmVxXygnLi9TY2FsYXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgbGluZS1yZWxhdGVkIGZ1bmN0aW9uc1xuICogQGNsYXNzIExpbmVcbiAqL1xuZnVuY3Rpb24gTGluZSgpe307XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGxpbmVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBsaW5lSW50XG4gKiBAcGFyYW0gIHtBcnJheX0gIGwxICAgICAgICAgIExpbmUgdmVjdG9yIDFcbiAqIEBwYXJhbSAge0FycmF5fSAgbDIgICAgICAgICAgTGluZSB2ZWN0b3IgMlxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBQcmVjaXNpb24gdG8gdXNlIHdoZW4gY2hlY2tpbmcgaWYgdGhlIGxpbmVzIGFyZSBwYXJhbGxlbFxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxuICovXG5MaW5lLmxpbmVJbnQgPSBmdW5jdGlvbihsMSxsMixwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICAgIHZhciBpID0gWzAsMF07IC8vIHBvaW50XG4gICAgdmFyIGExLCBiMSwgYzEsIGEyLCBiMiwgYzIsIGRldDsgLy8gc2NhbGFyc1xuICAgIGExID0gbDFbMV1bMV0gLSBsMVswXVsxXTtcbiAgICBiMSA9IGwxWzBdWzBdIC0gbDFbMV1bMF07XG4gICAgYzEgPSBhMSAqIGwxWzBdWzBdICsgYjEgKiBsMVswXVsxXTtcbiAgICBhMiA9IGwyWzFdWzFdIC0gbDJbMF1bMV07XG4gICAgYjIgPSBsMlswXVswXSAtIGwyWzFdWzBdO1xuICAgIGMyID0gYTIgKiBsMlswXVswXSArIGIyICogbDJbMF1bMV07XG4gICAgZGV0ID0gYTEgKiBiMiAtIGEyKmIxO1xuICAgIGlmICghU2NhbGFyLmVxKGRldCwgMCwgcHJlY2lzaW9uKSkgeyAvLyBsaW5lcyBhcmUgbm90IHBhcmFsbGVsXG4gICAgICAgIGlbMF0gPSAoYjIgKiBjMSAtIGIxICogYzIpIC8gZGV0O1xuICAgICAgICBpWzFdID0gKGExICogYzIgLSBhMiAqIGMxKSAvIGRldDtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RzLlxuICogQG1ldGhvZCBzZWdtZW50c0ludGVyc2VjdFxuICogQHBhcmFtIHtBcnJheX0gcDEgVGhlIHN0YXJ0IHZlcnRleCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcDIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHExIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBxMiBUaGUgZW5kIHZlcnRleCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdFxuICovXG5MaW5lLnNlZ21lbnRzSW50ZXJzZWN0ID0gZnVuY3Rpb24ocDEsIHAyLCBxMSwgcTIpe1xuICAgdmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcbiAgIHZhciBkeSA9IHAyWzFdIC0gcDFbMV07XG4gICB2YXIgZGEgPSBxMlswXSAtIHExWzBdO1xuICAgdmFyIGRiID0gcTJbMV0gLSBxMVsxXTtcblxuICAgLy8gc2VnbWVudHMgYXJlIHBhcmFsbGVsXG4gICBpZihkYSpkeSAtIGRiKmR4ID09IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgIHZhciBzID0gKGR4ICogKHExWzFdIC0gcDFbMV0pICsgZHkgKiAocDFbMF0gLSBxMVswXSkpIC8gKGRhICogZHkgLSBkYiAqIGR4KVxuICAgdmFyIHQgPSAoZGEgKiAocDFbMV0gLSBxMVsxXSkgKyBkYiAqIChxMVswXSAtIHAxWzBdKSkgLyAoZGIgKiBkeCAtIGRhICogZHkpXG5cbiAgIHJldHVybiAocz49MCAmJiBzPD0xICYmIHQ+PTAgJiYgdDw9MSk7XG59O1xuXG5cbn0se1wiLi9TY2FsYXJcIjo0fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG4vKipcbiAqIFBvaW50IHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAY2xhc3MgUG9pbnRcbiAqL1xuZnVuY3Rpb24gUG9pbnQoKXt9O1xuXG4vKipcbiAqIEdldCB0aGUgYXJlYSBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIGdpdmVuIHBvaW50cy4gTm90ZSB0aGF0IHRoZSBhcmVhIHdpbGwgYmUgbmVnYXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgbm90IGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBhcmVhXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblBvaW50LmFyZWEgPSBmdW5jdGlvbihhLGIsYyl7XG4gICAgcmV0dXJuICgoKGJbMF0gLSBhWzBdKSooY1sxXSAtIGFbMV0pKS0oKGNbMF0gLSBhWzBdKSooYlsxXSAtIGFbMV0pKSk7XG59O1xuXG5Qb2ludC5sZWZ0ID0gZnVuY3Rpb24oYSxiLGMpe1xuICAgIHJldHVybiBQb2ludC5hcmVhKGEsYixjKSA+IDA7XG59O1xuXG5Qb2ludC5sZWZ0T24gPSBmdW5jdGlvbihhLGIsYykge1xuICAgIHJldHVybiBQb2ludC5hcmVhKGEsIGIsIGMpID49IDA7XG59O1xuXG5Qb2ludC5yaWdodCA9IGZ1bmN0aW9uKGEsYixjKSB7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPCAwO1xufTtcblxuUG9pbnQucmlnaHRPbiA9IGZ1bmN0aW9uKGEsYixjKSB7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPD0gMDtcbn07XG5cbnZhciB0bXBQb2ludDEgPSBbXSxcbiAgICB0bXBQb2ludDIgPSBbXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxuICogQG1ldGhvZCBjb2xsaW5lYXJcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEBwYXJhbSAge051bWJlcn0gW3RocmVzaG9sZEFuZ2xlPTBdIFRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBjb21wYXJpbmcgdGhlIHZlY3RvcnMuIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSByZXN1bHRpbmcgdmVjdG9ycyBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZS4gVXNlIHplcm8gZm9yIG1heCBwcmVjaXNpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Qb2ludC5jb2xsaW5lYXIgPSBmdW5jdGlvbihhLGIsYyx0aHJlc2hvbGRBbmdsZSkge1xuICAgIGlmKCF0aHJlc2hvbGRBbmdsZSlcbiAgICAgICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPT0gMDtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFiID0gdG1wUG9pbnQxLFxuICAgICAgICAgICAgYmMgPSB0bXBQb2ludDI7XG5cbiAgICAgICAgYWJbMF0gPSBiWzBdLWFbMF07XG4gICAgICAgIGFiWzFdID0gYlsxXS1hWzFdO1xuICAgICAgICBiY1swXSA9IGNbMF0tYlswXTtcbiAgICAgICAgYmNbMV0gPSBjWzFdLWJbMV07XG5cbiAgICAgICAgdmFyIGRvdCA9IGFiWzBdKmJjWzBdICsgYWJbMV0qYmNbMV0sXG4gICAgICAgICAgICBtYWdBID0gTWF0aC5zcXJ0KGFiWzBdKmFiWzBdICsgYWJbMV0qYWJbMV0pLFxuICAgICAgICAgICAgbWFnQiA9IE1hdGguc3FydChiY1swXSpiY1swXSArIGJjWzFdKmJjWzFdKSxcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hY29zKGRvdC8obWFnQSptYWdCKSk7XG4gICAgICAgIHJldHVybiBhbmdsZSA8IHRocmVzaG9sZEFuZ2xlO1xuICAgIH1cbn07XG5cblBvaW50LnNxZGlzdCA9IGZ1bmN0aW9uKGEsYil7XG4gICAgdmFyIGR4ID0gYlswXSAtIGFbMF07XG4gICAgdmFyIGR5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufTtcblxufSx7fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTGluZSA9IF9kZXJlcV8oXCIuL0xpbmVcIilcbiwgICBQb2ludCA9IF9kZXJlcV8oXCIuL1BvaW50XCIpXG4sICAgU2NhbGFyID0gX2RlcmVxXyhcIi4vU2NhbGFyXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcblxuLyoqXG4gKiBQb2x5Z29uIGNsYXNzLlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQb2x5Z29uKCl7XG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNlcyB0aGF0IHRoaXMgcG9seWdvbiBjb25zaXN0cyBvZi4gQW4gYXJyYXkgb2YgYXJyYXkgb2YgbnVtYmVycywgZXhhbXBsZTogW1swLDBdLFsxLDBdLC4uXVxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG59XG5cbi8qKlxuICogR2V0IGEgdmVydGV4IGF0IHBvc2l0aW9uIGkuIEl0IGRvZXMgbm90IG1hdHRlciBpZiBpIGlzIG91dCBvZiBib3VuZHMsIHRoaXMgZnVuY3Rpb24gd2lsbCBqdXN0IGN5Y2xlLlxuICogQG1ldGhvZCBhdFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpKXtcbiAgICB2YXIgdiA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIHMgPSB2Lmxlbmd0aDtcbiAgICByZXR1cm4gdltpIDwgMCA/IGkgJSBzICsgcyA6IGkgJSBzXTtcbn07XG5cbi8qKlxuICogR2V0IGZpcnN0IHZlcnRleFxuICogQG1ldGhvZCBmaXJzdFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNlc1swXTtcbn07XG5cbi8qKlxuICogR2V0IGxhc3QgdmVydGV4XG4gKiBAbWV0aG9kIGxhc3RcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNlc1t0aGlzLnZlcnRpY2VzLmxlbmd0aC0xXTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIHBvbHlnb24gZGF0YVxuICogQG1ldGhvZCBjbGVhclxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnZlcnRpY2VzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIEFwcGVuZCBwb2ludHMgXCJmcm9tXCIgdG8gXCJ0b1wiLTEgZnJvbSBhbiBvdGhlciBwb2x5Z29uIFwicG9seVwiIG9udG8gdGhpcyBvbmUuXG4gKiBAbWV0aG9kIGFwcGVuZFxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5IFRoZSBwb2x5Z29uIHRvIGdldCBwb2ludHMgZnJvbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgZnJvbSBUaGUgdmVydGV4IGluZGV4IGluIFwicG9seVwiLlxuICogQHBhcmFtIHtOdW1iZXJ9ICB0byBUaGUgZW5kIHZlcnRleCBpbmRleCBpbiBcInBvbHlcIi4gTm90ZSB0aGF0IHRoaXMgdmVydGV4IGlzIE5PVCBpbmNsdWRlZCB3aGVuIGFwcGVuZGluZy5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihwb2x5LGZyb20sdG8pe1xuICAgIGlmKHR5cGVvZihmcm9tKSA9PSBcInVuZGVmaW5lZFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJGcm9tIGlzIG5vdCBnaXZlbiFcIik7XG4gICAgaWYodHlwZW9mKHRvKSA9PSBcInVuZGVmaW5lZFwiKSAgIHRocm93IG5ldyBFcnJvcihcIlRvIGlzIG5vdCBnaXZlbiFcIik7XG5cbiAgICBpZih0by0xIDwgZnJvbSkgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxvbDFcIik7XG4gICAgaWYodG8gPiBwb2x5LnZlcnRpY2VzLmxlbmd0aCkgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2wyXCIpO1xuICAgIGlmKGZyb20gPCAwKSAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9sM1wiKTtcblxuICAgIGZvcih2YXIgaT1mcm9tOyBpPHRvOyBpKyspe1xuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gocG9seS52ZXJ0aWNlc1tpXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhhdCB0aGUgcG9seWdvbiB2ZXJ0aWNlcyBhcmUgb3JkZXJlZCBjb3VudGVyLWNsb2Nrd2lzZS5cbiAqIEBtZXRob2QgbWFrZUNDV1xuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5tYWtlQ0NXID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYnIgPSAwLFxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlcztcblxuICAgIC8vIGZpbmQgYm90dG9tIHJpZ2h0IHBvaW50XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh2W2ldWzFdIDwgdlticl1bMV0gfHwgKHZbaV1bMV0gPT0gdlticl1bMV0gJiYgdltpXVswXSA+IHZbYnJdWzBdKSkge1xuICAgICAgICAgICAgYnIgPSBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV2ZXJzZSBwb2x5IGlmIGNsb2Nrd2lzZVxuICAgIGlmICghUG9pbnQubGVmdCh0aGlzLmF0KGJyIC0gMSksIHRoaXMuYXQoYnIpLCB0aGlzLmF0KGJyICsgMSkpKSB7XG4gICAgICAgIHRoaXMucmV2ZXJzZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV2ZXJzZSB0aGUgdmVydGljZXMgaW4gdGhlIHBvbHlnb25cbiAqIEBtZXRob2QgcmV2ZXJzZVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdG1wID0gW107XG4gICAgZm9yKHZhciBpPTAsIE49dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB0bXAucHVzaCh0aGlzLnZlcnRpY2VzLnBvcCgpKTtcbiAgICB9XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHRtcDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpbiB0aGUgcG9seWdvbiBpcyBhIHJlZmxleCBwb2ludFxuICogQG1ldGhvZCBpc1JlZmxleFxuICogQHBhcmFtICB7TnVtYmVyfSAgaVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuaXNSZWZsZXggPSBmdW5jdGlvbihpKXtcbiAgICByZXR1cm4gUG9pbnQucmlnaHQodGhpcy5hdChpIC0gMSksIHRoaXMuYXQoaSksIHRoaXMuYXQoaSArIDEpKTtcbn07XG5cbnZhciB0bXBMaW5lMT1bXSxcbiAgICB0bXBMaW5lMj1bXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVydGljZXMgaW4gdGhlIHBvbHlnb24gY2FuIHNlZSBlYWNoIG90aGVyXG4gKiBAbWV0aG9kIGNhblNlZVxuICogQHBhcmFtICB7TnVtYmVyfSBhIFZlcnRleCBpbmRleCAxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGIgVmVydGV4IGluZGV4IDJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmNhblNlZSA9IGZ1bmN0aW9uKGEsYikge1xuICAgIHZhciBwLCBkaXN0LCBsMT10bXBMaW5lMSwgbDI9dG1wTGluZTI7XG5cbiAgICBpZiAoUG9pbnQubGVmdE9uKHRoaXMuYXQoYSArIDEpLCB0aGlzLmF0KGEpLCB0aGlzLmF0KGIpKSAmJiBQb2ludC5yaWdodE9uKHRoaXMuYXQoYSAtIDEpLCB0aGlzLmF0KGEpLCB0aGlzLmF0KGIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRpc3QgPSBQb2ludC5zcWRpc3QodGhpcy5hdChhKSwgdGhpcy5hdChiKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHsgLy8gZm9yIGVhY2ggZWRnZVxuICAgICAgICBpZiAoKGkgKyAxKSAlIHRoaXMudmVydGljZXMubGVuZ3RoID09PSBhIHx8IGkgPT09IGEpIC8vIGlnbm9yZSBpbmNpZGVudCBlZGdlc1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChQb2ludC5sZWZ0T24odGhpcy5hdChhKSwgdGhpcy5hdChiKSwgdGhpcy5hdChpICsgMSkpICYmIFBvaW50LnJpZ2h0T24odGhpcy5hdChhKSwgdGhpcy5hdChiKSwgdGhpcy5hdChpKSkpIHsgLy8gaWYgZGlhZyBpbnRlcnNlY3RzIGFuIGVkZ2VcbiAgICAgICAgICAgIGwxWzBdID0gdGhpcy5hdChhKTtcbiAgICAgICAgICAgIGwxWzFdID0gdGhpcy5hdChiKTtcbiAgICAgICAgICAgIGwyWzBdID0gdGhpcy5hdChpKTtcbiAgICAgICAgICAgIGwyWzFdID0gdGhpcy5hdChpICsgMSk7XG4gICAgICAgICAgICBwID0gTGluZS5saW5lSW50KGwxLGwyKTtcbiAgICAgICAgICAgIGlmIChQb2ludC5zcWRpc3QodGhpcy5hdChhKSwgcCkgPCBkaXN0KSB7IC8vIGlmIGVkZ2UgaXMgYmxvY2tpbmcgdmlzaWJpbGl0eSB0byBiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHBvbHlnb24gZnJvbSB2ZXJ0ZXggaSB0byB2ZXJ0ZXggai5cbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSAge1BvbHlnb259IFt0YXJnZXRQb2x5XSAgIE9wdGlvbmFsIHRhcmdldCBwb2x5Z29uIHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSAgICAgICAgICAgICAgICBUaGUgcmVzdWx0aW5nIGNvcHkuXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihpLGosdGFyZ2V0UG9seSl7XG4gICAgdmFyIHAgPSB0YXJnZXRQb2x5IHx8IG5ldyBQb2x5Z29uKCk7XG4gICAgcC5jbGVhcigpO1xuICAgIGlmIChpIDwgaikge1xuICAgICAgICAvLyBJbnNlcnQgYWxsIHZlcnRpY2VzIGZyb20gaSB0byBqXG4gICAgICAgIGZvcih2YXIgaz1pOyBrPD1qOyBrKyspXG4gICAgICAgICAgICBwLnZlcnRpY2VzLnB1c2godGhpcy52ZXJ0aWNlc1trXSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyAwIHRvIGpcbiAgICAgICAgZm9yKHZhciBrPTA7IGs8PWo7IGsrKylcbiAgICAgICAgICAgIHAudmVydGljZXMucHVzaCh0aGlzLnZlcnRpY2VzW2tdKTtcblxuICAgICAgICAvLyBJbnNlcnQgdmVydGljZXMgaSB0byBlbmRcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGsrKylcbiAgICAgICAgICAgIHAudmVydGljZXMucHVzaCh0aGlzLnZlcnRpY2VzW2tdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qKlxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIGNvbnZleCBwaWVjZXMuIFJldHVybnMgYSBsaXN0IG9mIGVkZ2VzIFtbcDEscDJdLFtwMixwM10sLi4uXSB0aGF0IGN1dHMgdGhlIHBvbHlnb24uXG4gKiBOb3RlIHRoYXQgdGhpcyBhbGdvcml0aG0gaGFzIGNvbXBsZXhpdHkgTyhOXjQpIGFuZCB3aWxsIGJlIHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtYW55IHZlcnRpY2VzLlxuICogQG1ldGhvZCBnZXRDdXRFZGdlc1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmdldEN1dEVkZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1pbj1bXSwgdG1wMT1bXSwgdG1wMj1bXSwgdG1wUG9seSA9IG5ldyBQb2x5Z29uKCk7XG4gICAgdmFyIG5EaWFncyA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWZsZXgoaSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhblNlZShpLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICB0bXAxID0gdGhpcy5jb3B5KGksIGosIHRtcFBvbHkpLmdldEN1dEVkZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcDIgPSB0aGlzLmNvcHkoaiwgaSwgdG1wUG9seSkuZ2V0Q3V0RWRnZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgazx0bXAyLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wMS5wdXNoKHRtcDJba10pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0bXAxLmxlbmd0aCA8IG5EaWFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gdG1wMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5EaWFncyA9IHRtcDEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluLnB1c2goW3RoaXMuYXQoaSksIHRoaXMuYXQoaildKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW47XG59O1xuXG4vKipcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBvbmUgb3IgbW9yZSBjb252ZXggc3ViLVBvbHlnb25zLlxuICogQG1ldGhvZCBkZWNvbXBcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvciBQb2x5Z29uIG9iamVjdHMuXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmRlY29tcCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5nZXRDdXRFZGdlcygpO1xuICAgIGlmKGVkZ2VzLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKGVkZ2VzKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBbdGhpc107XG59O1xuXG4vKipcbiAqIFNsaWNlcyB0aGUgcG9seWdvbiBnaXZlbiBvbmUgb3IgbW9yZSBjdXQgZWRnZXMuIElmIGdpdmVuIG9uZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0d28gcG9seWdvbnMgKGZhbHNlIG9uIGZhaWx1cmUpLiBJZiBtYW55LCBhbiBhcnJheSBvZiBwb2x5Z29ucy5cbiAqIEBtZXRob2Qgc2xpY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGN1dEVkZ2VzIEEgbGlzdCBvZiBlZGdlcywgYXMgcmV0dXJuZWQgYnkgLmdldEN1dEVkZ2VzKClcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGN1dEVkZ2VzKXtcbiAgICBpZihjdXRFZGdlcy5sZW5ndGggPT0gMCkgcmV0dXJuIFt0aGlzXTtcbiAgICBpZihjdXRFZGdlcyBpbnN0YW5jZW9mIEFycmF5ICYmIGN1dEVkZ2VzLmxlbmd0aCAmJiBjdXRFZGdlc1swXSBpbnN0YW5jZW9mIEFycmF5ICYmIGN1dEVkZ2VzWzBdLmxlbmd0aD09MiAmJiBjdXRFZGdlc1swXVswXSBpbnN0YW5jZW9mIEFycmF5KXtcblxuICAgICAgICB2YXIgcG9seXMgPSBbdGhpc107XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8Y3V0RWRnZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGN1dEVkZ2UgPSBjdXRFZGdlc1tpXTtcbiAgICAgICAgICAgIC8vIEN1dCBhbGwgcG9seXNcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHBvbHlzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICB2YXIgcG9seSA9IHBvbHlzW2pdO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwb2x5LnNsaWNlKGN1dEVkZ2UpO1xuICAgICAgICAgICAgICAgIGlmKHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIHBvbHkhIEN1dCBhbmQgcXVpdFxuICAgICAgICAgICAgICAgICAgICBwb2x5cy5zcGxpY2UoaiwxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seXMucHVzaChyZXN1bHRbMF0scmVzdWx0WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbHlzO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gV2FzIGdpdmVuIG9uZSBlZGdlXG4gICAgICAgIHZhciBjdXRFZGdlID0gY3V0RWRnZXM7XG4gICAgICAgIHZhciBpID0gdGhpcy52ZXJ0aWNlcy5pbmRleE9mKGN1dEVkZ2VbMF0pO1xuICAgICAgICB2YXIgaiA9IHRoaXMudmVydGljZXMuaW5kZXhPZihjdXRFZGdlWzFdKTtcblxuICAgICAgICBpZihpICE9IC0xICYmIGogIT0gLTEpe1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmNvcHkoaSxqKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3B5KGosaSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgdGhhdCB0aGUgbGluZSBzZWdtZW50cyBvZiB0aGlzIHBvbHlnb24gZG8gbm90IGludGVyc2VjdCBlYWNoIG90aGVyLlxuICogQG1ldGhvZCBpc1NpbXBsZVxuICogQHBhcmFtICB7QXJyYXl9IHBhdGggQW4gYXJyYXkgb2YgdmVydGljZXMgZS5nLiBbWzAsMF0sWzAsMV0sLi4uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEB0b2RvIFNob3VsZCBpdCBjaGVjayBhbGwgc2VnbWVudHMgd2l0aCBhbGwgb3RoZXJzP1xuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5pc1NpbXBsZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhdGggPSB0aGlzLnZlcnRpY2VzO1xuICAgIC8vIENoZWNrXG4gICAgZm9yKHZhciBpPTA7IGk8cGF0aC5sZW5ndGgtMTsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aS0xOyBqKyspe1xuICAgICAgICAgICAgaWYoTGluZS5zZWdtZW50c0ludGVyc2VjdChwYXRoW2ldLCBwYXRoW2krMV0sIHBhdGhbal0sIHBhdGhbaisxXSApKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgc2VnbWVudCBiZXR3ZWVuIHRoZSBsYXN0IGFuZCB0aGUgZmlyc3QgcG9pbnQgdG8gYWxsIG90aGVyc1xuICAgIGZvcih2YXIgaT0xOyBpPHBhdGgubGVuZ3RoLTI7IGkrKyl7XG4gICAgICAgIGlmKExpbmUuc2VnbWVudHNJbnRlcnNlY3QocGF0aFswXSwgcGF0aFtwYXRoLmxlbmd0aC0xXSwgcGF0aFtpXSwgcGF0aFtpKzFdICkpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25Qb2ludChwMSwgcDIsIHExLCBxMiwgZGVsdGEpe1xuICAgIGRlbHRhID0gZGVsdGEgfHwgMDtcbiAgIHZhciBhMSA9IHAyWzFdIC0gcDFbMV07XG4gICB2YXIgYjEgPSBwMVswXSAtIHAyWzBdO1xuICAgdmFyIGMxID0gKGExICogcDFbMF0pICsgKGIxICogcDFbMV0pO1xuICAgdmFyIGEyID0gcTJbMV0gLSBxMVsxXTtcbiAgIHZhciBiMiA9IHExWzBdIC0gcTJbMF07XG4gICB2YXIgYzIgPSAoYTIgKiBxMVswXSkgKyAoYjIgKiBxMVsxXSk7XG4gICB2YXIgZGV0ID0gKGExICogYjIpIC0gKGEyICogYjEpO1xuXG4gICBpZighU2NhbGFyLmVxKGRldCwwLGRlbHRhKSlcbiAgICAgIHJldHVybiBbKChiMiAqIGMxKSAtIChiMSAqIGMyKSkgLyBkZXQsICgoYTEgKiBjMikgLSAoYTIgKiBjMSkpIC8gZGV0XVxuICAgZWxzZVxuICAgICAgcmV0dXJuIFswLDBdXG59XG5cbi8qKlxuICogUXVpY2tseSBkZWNvbXBvc2UgdGhlIFBvbHlnb24gaW50byBjb252ZXggc3ViLXBvbHlnb25zLlxuICogQG1ldGhvZCBxdWlja0RlY29tcFxuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxuICogQHBhcmFtICB7QXJyYXl9IFtyZWZsZXhWZXJ0aWNlc11cbiAqIEBwYXJhbSAge0FycmF5fSBbc3RlaW5lclBvaW50c11cbiAqIEBwYXJhbSAge051bWJlcn0gW2RlbHRhXVxuICogQHBhcmFtICB7TnVtYmVyfSBbbWF4bGV2ZWxdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtsZXZlbF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5xdWlja0RlY29tcCA9IGZ1bmN0aW9uKHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKXtcbiAgICBtYXhsZXZlbCA9IG1heGxldmVsIHx8IDEwMDtcbiAgICBsZXZlbCA9IGxldmVsIHx8IDA7XG4gICAgZGVsdGEgPSBkZWx0YSB8fCAyNTtcbiAgICByZXN1bHQgPSB0eXBlb2YocmVzdWx0KSE9XCJ1bmRlZmluZWRcIiA/IHJlc3VsdCA6IFtdO1xuICAgIHJlZmxleFZlcnRpY2VzID0gcmVmbGV4VmVydGljZXMgfHwgW107XG4gICAgc3RlaW5lclBvaW50cyA9IHN0ZWluZXJQb2ludHMgfHwgW107XG5cbiAgICB2YXIgdXBwZXJJbnQ9WzAsMF0sIGxvd2VySW50PVswLDBdLCBwPVswLDBdOyAvLyBQb2ludHNcbiAgICB2YXIgdXBwZXJEaXN0PTAsIGxvd2VyRGlzdD0wLCBkPTAsIGNsb3Nlc3REaXN0PTA7IC8vIHNjYWxhcnNcbiAgICB2YXIgdXBwZXJJbmRleD0wLCBsb3dlckluZGV4PTAsIGNsb3Nlc3RJbmRleD0wOyAvLyBJbnRlZ2Vyc1xuICAgIHZhciBsb3dlclBvbHk9bmV3IFBvbHlnb24oKSwgdXBwZXJQb2x5PW5ldyBQb2x5Z29uKCk7IC8vIHBvbHlnb25zXG4gICAgdmFyIHBvbHkgPSB0aGlzLFxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlcztcblxuICAgIGlmKHYubGVuZ3RoIDwgMykgcmV0dXJuIHJlc3VsdDtcblxuICAgIGxldmVsKys7XG4gICAgaWYobGV2ZWwgPiBtYXhsZXZlbCl7XG4gICAgICAgIGNvbnNvbGUud2FybihcInF1aWNrRGVjb21wOiBtYXggbGV2ZWwgKFwiK21heGxldmVsK1wiKSByZWFjaGVkLlwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHBvbHkuaXNSZWZsZXgoaSkpIHtcbiAgICAgICAgICAgIHJlZmxleFZlcnRpY2VzLnB1c2gocG9seS52ZXJ0aWNlc1tpXSk7XG4gICAgICAgICAgICB1cHBlckRpc3QgPSBsb3dlckRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChQb2ludC5sZWZ0KHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgUG9pbnQucmlnaHRPbihwb2x5LmF0KGkgLSAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqIC0gMSkpKSB7IC8vIGlmIGxpbmUgaW50ZXJzZWN0cyB3aXRoIGFuIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgcCA9IGdldEludGVyc2VjdGlvblBvaW50KHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopLCBwb2x5LmF0KGogLSAxKSk7IC8vIGZpbmQgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoUG9pbnQucmlnaHQocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHApKSB7IC8vIG1ha2Ugc3VyZSBpdCdzIGluc2lkZSB0aGUgcG9seVxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IFBvaW50LnNxZGlzdChwb2x5LnZlcnRpY2VzW2ldLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgbG93ZXJEaXN0KSB7IC8vIGtlZXAgb25seSB0aGUgY2xvc2VzdCBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckRpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySW50ID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoUG9pbnQubGVmdChwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqICsgMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBQb2ludC5yaWdodE9uKHBvbHkuYXQoaSArIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaiksIHBvbHkuYXQoaiArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBvaW50LmxlZnQocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gUG9pbnQuc3FkaXN0KHBvbHkudmVydGljZXNbaV0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCB1cHBlckRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckRpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVySW50ID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHZlcnRpY2VzIHRvIGNvbm5lY3QgdG8sIGNob29zZSBhIHBvaW50IGluIHRoZSBtaWRkbGVcbiAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID09ICh1cHBlckluZGV4ICsgMSkgJSB0aGlzLnZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDE6IFZlcnRleChcIitpK1wiKSwgbG93ZXJJbmRleChcIitsb3dlckluZGV4K1wiKSwgdXBwZXJJbmRleChcIit1cHBlckluZGV4K1wiKSwgcG9seS5zaXplKFwiK3RoaXMudmVydGljZXMubGVuZ3RoK1wiKVwiKTtcbiAgICAgICAgICAgICAgICBwWzBdID0gKGxvd2VySW50WzBdICsgdXBwZXJJbnRbMF0pIC8gMjtcbiAgICAgICAgICAgICAgICBwWzFdID0gKGxvd2VySW50WzFdICsgdXBwZXJJbnRbMV0pIC8gMjtcbiAgICAgICAgICAgICAgICBzdGVpbmVyUG9pbnRzLnB1c2gocCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IHVwcGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksIGksIHVwcGVySW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkudmVydGljZXMucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggIT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBsb3dlckluZGV4LCBwb2x5LmVuZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSxsb3dlckluZGV4LHBvbHkudmVydGljZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LDAsaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGksIHBvbHkuZW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LGkscG9seS52ZXJ0aWNlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksMCx1cHBlckluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkudmVydGljZXMucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LnZlcnRpY2VzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGxvd2VySW5kZXgsIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LGxvd2VySW5kZXgsaSsxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgd2l0aGluIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDI6IFZlcnRleChcIitpK1wiKSwgY2xvc2VzdEluZGV4KFwiK2Nsb3Nlc3RJbmRleCtcIiksIHBvbHkuc2l6ZShcIit0aGlzLnZlcnRpY2VzLmxlbmd0aCtcIilcXG5cIik7XG5cbiAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCA+IHVwcGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCArPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgICAgICAgICAgaWYodXBwZXJJbmRleCA8IGxvd2VySW5kZXgpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBsb3dlckluZGV4OyBqIDw9IHVwcGVySW5kZXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUG9pbnQubGVmdE9uKHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIFBvaW50LnJpZ2h0T24ocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gUG9pbnQuc3FkaXN0KHBvbHkuYXQoaSksIHBvbHkuYXQoaikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBjbG9zZXN0RGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBqICUgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IGNsb3Nlc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksaSxjbG9zZXN0SW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0SW5kZXggIT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksY2xvc2VzdEluZGV4LHYubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksMCxpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LGksdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSwwLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LGNsb3Nlc3RJbmRleCxpKzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc29sdmUgc21hbGxlc3QgcG9seSBmaXJzdFxuICAgICAgICAgICAgaWYgKGxvd2VyUG9seS52ZXJ0aWNlcy5sZW5ndGggPCB1cHBlclBvbHkudmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG93ZXJQb2x5LnF1aWNrRGVjb21wKHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgICAgICB1cHBlclBvbHkucXVpY2tEZWNvbXAocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cHBlclBvbHkucXVpY2tEZWNvbXAocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxvd2VyUG9seS5xdWlja0RlY29tcChyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2godGhpcyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZW1vdmUgY29sbGluZWFyIHBvaW50cyBpbiB0aGUgcG9seWdvbi5cbiAqIEBtZXRob2QgcmVtb3ZlQ29sbGluZWFyUG9pbnRzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dIFRoZSB0aHJlc2hvbGQgYW5nbGUgdG8gdXNlIHdoZW4gZGV0ZXJtaW5pbmcgd2hldGhlciB0d28gZWRnZXMgYXJlIGNvbGxpbmVhci4gVXNlIHplcm8gZm9yIGZpbmVzdCBwcmVjaXNpb24uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHBvaW50cyByZW1vdmVkXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnJlbW92ZUNvbGxpbmVhclBvaW50cyA9IGZ1bmN0aW9uKHByZWNpc2lvbil7XG4gICAgdmFyIG51bSA9IDA7XG4gICAgZm9yKHZhciBpPXRoaXMudmVydGljZXMubGVuZ3RoLTE7IHRoaXMudmVydGljZXMubGVuZ3RoPjMgJiYgaT49MDsgLS1pKXtcbiAgICAgICAgaWYoUG9pbnQuY29sbGluZWFyKHRoaXMuYXQoaS0xKSx0aGlzLmF0KGkpLHRoaXMuYXQoaSsxKSxwcmVjaXNpb24pKXtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbWlkZGxlIHBvaW50XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnNwbGljZShpJXRoaXMudmVydGljZXMubGVuZ3RoLDEpO1xuICAgICAgICAgICAgaS0tOyAvLyBKdW1wIG9uZSBwb2ludCBmb3J3YXJkLiBPdGhlcndpc2Ugd2UgbWF5IGdldCBhIGNoYWluIHJlbW92YWxcbiAgICAgICAgICAgIG51bSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG59O1xuXG59LHtcIi4vTGluZVwiOjEsXCIuL1BvaW50XCI6MixcIi4vU2NhbGFyXCI6NH1dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBTY2FsYXI7XG5cbi8qKlxuICogU2NhbGFyIGZ1bmN0aW9uc1xuICogQGNsYXNzIFNjYWxhclxuICovXG5mdW5jdGlvbiBTY2FsYXIoKXt9XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHNjYWxhcnMgYXJlIGVxdWFsXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGVxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYlxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuU2NhbGFyLmVxID0gZnVuY3Rpb24oYSxiLHByZWNpc2lvbil7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEtYikgPCBwcmVjaXNpb247XG59O1xuXG59LHt9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFBvbHlnb24gOiBfZGVyZXFfKFwiLi9Qb2x5Z29uXCIpLFxuICAgIFBvaW50IDogX2RlcmVxXyhcIi4vUG9pbnRcIiksXG59O1xuXG59LHtcIi4vUG9pbnRcIjoyLFwiLi9Qb2x5Z29uXCI6M31dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJwMlwiLFxuICBcInZlcnNpb25cIjogXCIwLjYuMVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBKYXZhU2NyaXB0IDJEIHBoeXNpY3MgZW5naW5lLlwiLFxuICBcImF1dGhvclwiOiBcIlN0ZWZhbiBIZWRtYW4gPHNjaHRlcHBlQGdtYWlsLmNvbT4gKGh0dHA6Ly9zdGVmZmUuc2UpXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwicDIuanNcIixcbiAgICBcInAyXCIsXG4gICAgXCJwaHlzaWNzXCIsXG4gICAgXCJlbmdpbmVcIixcbiAgICBcIjJkXCJcbiAgXSxcbiAgXCJtYWluXCI6IFwiLi9zcmMvcDIuanNcIixcbiAgXCJlbmdpbmVzXCI6IHtcbiAgICBcIm5vZGVcIjogXCIqXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS9wMi5qcy5naXRcIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3AyLmpzL2lzc3Vlc1wiXG4gIH0sXG4gIFwibGljZW5zZXNcIjogW1xuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcIk1JVFwiXG4gICAgfVxuICBdLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJncnVudFwiOiBcIn4wLjQuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1qc2hpbnRcIjogXCJ+MC45LjJcIixcbiAgICBcImdydW50LWNvbnRyaWItbm9kZXVuaXRcIjogXCJ+MC4xLjJcIixcbiAgICBcImdydW50LWNvbnRyaWItdWdsaWZ5XCI6IFwifjAuNC4wXCIsXG4gICAgXCJncnVudC1jb250cmliLXdhdGNoXCI6IFwifjAuNS4wXCIsXG4gICAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwifjIuMC4xXCIsXG4gICAgXCJncnVudC1jb250cmliLWNvbmNhdFwiOiBcIl4wLjQuMFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcInBvbHktZGVjb21wXCI6IFwiMC4xLjBcIlxuICB9XG59XG5cbn0se31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBQUJCO1xuXG4vKipcbiAqIEF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggY2xhc3MuXG4gKiBAY2xhc3MgQUFCQlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy51cHBlckJvdW5kXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb3dlckJvdW5kXVxuICovXG5mdW5jdGlvbiBBQUJCKG9wdGlvbnMpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHByb3BlcnR5IGxvd2VyQm91bmRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb3dlckJvdW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zICYmIG9wdGlvbnMubG93ZXJCb3VuZCl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmxvd2VyQm91bmQsIG9wdGlvbnMubG93ZXJCb3VuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHByb3BlcnR5IHVwcGVyQm91bmRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy51cHBlckJvdW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zICYmIG9wdGlvbnMudXBwZXJCb3VuZCl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLnVwcGVyQm91bmQsIG9wdGlvbnMudXBwZXJCb3VuZCk7XG4gICAgfVxufVxuXG52YXIgdG1wID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBTZXQgdGhlIEFBQkIgYm91bmRzIGZyb20gYSBzZXQgb2YgcG9pbnRzLlxuICogQG1ldGhvZCBzZXRGcm9tUG9pbnRzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQW4gYXJyYXkgb2YgdmVjMidzLlxuICovXG5BQUJCLnByb3RvdHlwZS5zZXRGcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBwb3NpdGlvbiwgYW5nbGUsIHNraW5TaXplKXtcbiAgICB2YXIgbCA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdSA9IHRoaXMudXBwZXJCb3VuZDtcblxuICAgIGlmKHR5cGVvZihhbmdsZSkgIT09IFwibnVtYmVyXCIpe1xuICAgICAgICBhbmdsZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRvIHRoZSBmaXJzdCBwb2ludFxuICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUobCwgcG9pbnRzWzBdLCBhbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmVjMi5jb3B5KGwsIHBvaW50c1swXSk7XG4gICAgfVxuICAgIHZlYzIuY29weSh1LCBsKTtcblxuICAgIC8vIENvbXB1dGUgY29zaW5lcyBhbmQgc2luZXMganVzdCBvbmNlXG4gICAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBmb3IodmFyIGkgPSAxOyBpPHBvaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgICAgIHZhciB4ID0gcFswXSxcbiAgICAgICAgICAgICAgICB5ID0gcFsxXTtcbiAgICAgICAgICAgIHRtcFswXSA9IGNvc0FuZ2xlICogeCAtc2luQW5nbGUgKiB5O1xuICAgICAgICAgICAgdG1wWzFdID0gc2luQW5nbGUgKiB4ICtjb3NBbmdsZSAqIHk7XG4gICAgICAgICAgICBwID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8MjsgaisrKXtcbiAgICAgICAgICAgIGlmKHBbal0gPiB1W2pdKXtcbiAgICAgICAgICAgICAgICB1W2pdID0gcFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHBbal0gPCBsW2pdKXtcbiAgICAgICAgICAgICAgICBsW2pdID0gcFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBvZmZzZXRcbiAgICBpZihwb3NpdGlvbil7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMubG93ZXJCb3VuZCwgdGhpcy5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMudXBwZXJCb3VuZCwgdGhpcy51cHBlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYoc2tpblNpemUpe1xuICAgICAgICB0aGlzLmxvd2VyQm91bmRbMF0gLT0gc2tpblNpemU7XG4gICAgICAgIHRoaXMubG93ZXJCb3VuZFsxXSAtPSBza2luU2l6ZTtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kWzBdICs9IHNraW5TaXplO1xuICAgICAgICB0aGlzLnVwcGVyQm91bmRbMV0gKz0gc2tpblNpemU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb3B5IGJvdW5kcyBmcm9tIGFuIEFBQkIgdG8gdGhpcyBBQUJCXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuQUFCQi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZlYzIuY29weSh0aGlzLmxvd2VyQm91bmQsIGFhYmIubG93ZXJCb3VuZCk7XG4gICAgdmVjMi5jb3B5KHRoaXMudXBwZXJCb3VuZCwgYWFiYi51cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIHRoaXMgQUFCQiBzbyB0aGF0IGl0IGNvdmVycyB0aGUgZ2l2ZW4gQUFCQiB0b28uXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICovXG5BQUJCLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihhYWJiKXtcbiAgICAvLyBMb29wIG92ZXIgeCBhbmQgeVxuICAgIHZhciBpID0gMjtcbiAgICB3aGlsZShpLS0pe1xuICAgICAgICAvLyBFeHRlbmQgbG93ZXIgYm91bmRcbiAgICAgICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmRbaV07XG4gICAgICAgIGlmKHRoaXMubG93ZXJCb3VuZFtpXSA+IGwpe1xuICAgICAgICAgICAgdGhpcy5sb3dlckJvdW5kW2ldID0gbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwcGVyXG4gICAgICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kW2ldO1xuICAgICAgICBpZih0aGlzLnVwcGVyQm91bmRbaV0gPCB1KXtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZFtpXSA9IHU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBvdmVybGFwcyB0aGlzIEFBQkIuXG4gKiBAbWV0aG9kIG92ZXJsYXBzXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5BQUJCLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdTEgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgIGwyID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcblxuICAgIC8vICAgICAgbDIgICAgICAgIHUyXG4gICAgLy8gICAgICB8LS0tLS0tLS0tfFxuICAgIC8vIHwtLS0tLS0tLXxcbiAgICAvLyBsMSAgICAgICB1MVxuXG4gICAgcmV0dXJuICgobDJbMF0gPD0gdTFbMF0gJiYgdTFbMF0gPD0gdTJbMF0pIHx8IChsMVswXSA8PSB1MlswXSAmJiB1MlswXSA8PSB1MVswXSkpICYmXG4gICAgICAgICAgICgobDJbMV0gPD0gdTFbMV0gJiYgdTFbMV0gPD0gdTJbMV0pIHx8IChsMVsxXSA8PSB1MlsxXSAmJiB1MlsxXSA8PSB1MVsxXSkpO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyb2FkcGhhc2U7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAY2xhc3MgQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJyb2FkcGhhc2UodHlwZSl7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyBvdmVybGFwcGluZyBwYWlycy4gV2lsbCBiZSBmaWxsZWQgd2l0aCByZXN1bHRzIGR1cmluZyAuZ2V0Q29sbGlzaW9uUGFpcnMoKS5cbiAgICAgKiBAcHJvcGVydHkgcmVzdWx0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQgdG8gc2VhcmNoIGZvciBjb2xsaXNpb24gcGFpcnMgaW4uIFRvIGNoYW5nZSBpdCwgdXNlIC5zZXRXb3JsZCgpXG4gICAgICogQHByb3BlcnR5IHdvcmxkXG4gICAgICogQHR5cGUge1dvcmxkfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvdW5kaW5nIHZvbHVtZSB0eXBlIHRvIHVzZSBpbiB0aGUgYnJvYWRwaGFzZSBhbGdvcml0aG1zLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBib3VuZGluZ1ZvbHVtZVR5cGVcbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kaW5nVm9sdW1lVHlwZSA9IEJyb2FkcGhhc2UuQUFCQjtcbn1cblxuLyoqXG4gKiBBeGlzIGFsaWduZWQgYm91bmRpbmcgYm94IHR5cGUuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQUFCQlxuICovXG5Ccm9hZHBoYXNlLkFBQkIgPSAxO1xuXG4vKipcbiAqIEJvdW5kaW5nIGNpcmNsZSB0eXBlLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEJPVU5ESU5HX0NJUkNMRVxuICovXG5Ccm9hZHBoYXNlLkJPVU5ESU5HX0NJUkNMRSA9IDI7XG5cbi8qKlxuICogU2V0IHRoZSB3b3JsZCB0aGF0IHdlIGFyZSBzZWFyY2hpbmcgZm9yIGNvbGxpc2lvbiBwYWlycyBpblxuICogQG1ldGhvZCBzZXRXb3JsZFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbn07XG5cbi8qKlxuICogR2V0IGFsbCBwb3RlbnRpYWwgaW50ZXJzZWN0aW5nIGJvZHkgcGFpcnMuXG4gKiBAbWV0aG9kIGdldENvbGxpc2lvblBhaXJzXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGQgVGhlIHdvcmxkIHRvIHNlYXJjaCBpbi5cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgYm9kaWVzLCBvcmRlcmVkIGluIHBhaXJzLiBFeGFtcGxlOiBBIHJlc3VsdCBvZiBbYSxiLGMsZF0gbWVhbnMgdGhhdCB0aGUgcG90ZW50aWFsIHBhaXJzIGFyZTogKGEsYiksIChjLGQpLlxuICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRDb2xsaXNpb25QYWlycyBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgc3ViY2xhc3MhXCIpO1xufTtcblxudmFyIGRpc3QgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0d28gYm9kaWVzIG92ZXJsYXAuXG4gKiBAbWV0aG9kICBib3VuZGluZ1JhZGl1c0NoZWNrXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkJyb2FkcGhhc2UuYm91bmRpbmdSYWRpdXNDaGVjayA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmVjMi5zdWIoZGlzdCwgYm9keUEucG9zaXRpb24sIGJvZHlCLnBvc2l0aW9uKTtcbiAgICB2YXIgZDIgPSB2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCksXG4gICAgICAgIHIgPSBib2R5QS5ib3VuZGluZ1JhZGl1cyArIGJvZHlCLmJvdW5kaW5nUmFkaXVzO1xuICAgIHJldHVybiBkMiA8PSByKnI7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0d28gYm9kaWVzIG92ZXJsYXAuXG4gKiBAbWV0aG9kICBib3VuZGluZ1JhZGl1c0NoZWNrXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkJyb2FkcGhhc2UuYWFiYkNoZWNrID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICByZXR1cm4gYm9keUEuZ2V0QUFCQigpLm92ZXJsYXBzKGJvZHlCLmdldEFBQkIoKSk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0d28gYm9kaWVzIG92ZXJsYXAuXG4gKiBAbWV0aG9kICBib3VuZGluZ1JhZGl1c0NoZWNrXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmJvdW5kaW5nVm9sdW1lQ2hlY2sgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBzd2l0Y2godGhpcy5ib3VuZGluZ1ZvbHVtZVR5cGUpe1xuICAgIGNhc2UgQnJvYWRwaGFzZS5CT1VORElOR19DSVJDTEU6XG4gICAgICAgIHJlc3VsdCA9ICBCcm9hZHBoYXNlLmJvdW5kaW5nUmFkaXVzQ2hlY2soYm9keUEsYm9keUIpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIEJyb2FkcGhhc2UuQUFCQjpcbiAgICAgICAgcmVzdWx0ID0gQnJvYWRwaGFzZS5hYWJiQ2hlY2soYm9keUEsYm9keUIpO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kaW5nIHZvbHVtZSB0eXBlIG5vdCByZWNvZ25pemVkOiAnK3RoaXMuYm91bmRpbmdWb2x1bWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gYm9kaWVzIGFyZSBhbGxvd2VkIHRvIGNvbGxpZGUgYXQgYWxsLlxuICogQG1ldGhvZCAgY2FuQ29sbGlkZVxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLmNhbkNvbGxpZGUgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgc3RhdGljIGJvZGllc1xuICAgIGlmKGJvZHlBLnR5cGUgPT09IEJvZHkuU1RBVElDICYmIGJvZHlCLnR5cGUgPT09IEJvZHkuU1RBVElDKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENhbm5vdCBjb2xsaWRlIHN0YXRpYyB2cyBraW5lbWF0aWMgYm9kaWVzXG4gICAgaWYoIChib2R5QS50eXBlID09PSBCb2R5LktJTkVNQVRJQyAmJiBib2R5Qi50eXBlID09PSBCb2R5LlNUQVRJQykgfHxcbiAgICAgICAgKGJvZHlBLnR5cGUgPT09IEJvZHkuU1RBVElDICAgICYmIGJvZHlCLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBraW5lbWF0aWMgdnMga2luZW1hdGljXG4gICAgaWYoYm9keUEudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMgJiYgYm9keUIudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgYm90aCBzbGVlcGluZyBib2RpZXNcbiAgICBpZihib2R5QS5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HICYmIGJvZHlCLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgaWYgb25lIGlzIHN0YXRpYyBhbmQgdGhlIG90aGVyIGlzIHNsZWVwaW5nXG4gICAgaWYoIChib2R5QS5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HICYmIGJvZHlCLnR5cGUgPT09IEJvZHkuU1RBVElDKSB8fFxuICAgICAgICAoYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBib2R5QS50eXBlID09PSBCb2R5LlNUQVRJQykpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Ccm9hZHBoYXNlLk5BSVZFID0gMTtcbkJyb2FkcGhhc2UuU0FQID0gMjtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL29iamVjdHMvQm9keVwiOjMyfV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ2lyY2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL0NpcmNsZScpXG4sICAgUGxhbmUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGxhbmUnKVxuLCAgIFBhcnRpY2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL1BhcnRpY2xlJylcbiwgICBCcm9hZHBoYXNlID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBCcm9hZHBoYXNlIHRoYXQgdXNlcyBheGlzLWFsaWduZWQgYmlucy5cbiAqIEBjbGFzcyBHcmlkQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMueG1pbl0gICBMb3dlciB4IGJvdW5kIG9mIHRoZSBncmlkXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMueG1heF0gICBVcHBlciB4IGJvdW5kXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMueW1pbl0gICBMb3dlciB5IGJvdW5kXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMueW1heF0gICBVcHBlciB5IGJvdW5kXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubnhdICAgICBOdW1iZXIgb2YgYmlucyBhbG9uZyB4IGF4aXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ueV0gICAgIE51bWJlciBvZiBiaW5zIGFsb25nIHkgYXhpc1xuICogQHRvZG8gU2hvdWxkIGhhdmUgYW4gb3B0aW9uIGZvciBkeW5hbWljIHNjZW5lIHNpemVcbiAqL1xuZnVuY3Rpb24gR3JpZEJyb2FkcGhhc2Uob3B0aW9ucyl7XG4gICAgQnJvYWRwaGFzZS5hcHBseSh0aGlzKTtcblxuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcbiAgICAgICAgeG1pbjogICAtMTAwLFxuICAgICAgICB4bWF4OiAgIDEwMCxcbiAgICAgICAgeW1pbjogICAtMTAwLFxuICAgICAgICB5bWF4OiAgIDEwMCxcbiAgICAgICAgbng6ICAgICAxMCxcbiAgICAgICAgbnk6ICAgICAxMFxuICAgIH0pO1xuXG4gICAgdGhpcy54bWluID0gb3B0aW9ucy54bWluO1xuICAgIHRoaXMueW1pbiA9IG9wdGlvbnMueW1pbjtcbiAgICB0aGlzLnhtYXggPSBvcHRpb25zLnhtYXg7XG4gICAgdGhpcy55bWF4ID0gb3B0aW9ucy55bWF4O1xuICAgIHRoaXMubnggPSBvcHRpb25zLm54O1xuICAgIHRoaXMubnkgPSBvcHRpb25zLm55O1xuXG4gICAgdGhpcy5iaW5zaXplWCA9ICh0aGlzLnhtYXgtdGhpcy54bWluKSAvIHRoaXMubng7XG4gICAgdGhpcy5iaW5zaXplWSA9ICh0aGlzLnltYXgtdGhpcy55bWluKSAvIHRoaXMubnk7XG59XG5HcmlkQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JpZEJyb2FkcGhhc2U7XG5cbi8qKlxuICogR2V0IGNvbGxpc2lvbiBwYWlycy5cbiAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbkdyaWRCcm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgTmNvbGxpZGluZyA9IGJvZGllcy5sZW5ndGgsXG4gICAgICAgIGJpbnNpemVYID0gdGhpcy5iaW5zaXplWCxcbiAgICAgICAgYmluc2l6ZVkgPSB0aGlzLmJpbnNpemVZLFxuICAgICAgICBueCA9IHRoaXMubngsXG4gICAgICAgIG55ID0gdGhpcy5ueSxcbiAgICAgICAgeG1pbiA9IHRoaXMueG1pbixcbiAgICAgICAgeW1pbiA9IHRoaXMueW1pbixcbiAgICAgICAgeG1heCA9IHRoaXMueG1heCxcbiAgICAgICAgeW1heCA9IHRoaXMueW1heDtcblxuICAgIC8vIFRvZG86IG1ha2UgZ2FyYmFnZSBmcmVlXG4gICAgdmFyIGJpbnM9W10sIE5iaW5zPW54Km55O1xuICAgIGZvcih2YXIgaT0wOyBpPE5iaW5zOyBpKyspe1xuICAgICAgICBiaW5zLnB1c2goW10pO1xuICAgIH1cblxuICAgIHZhciB4bXVsdCA9IG54IC8gKHhtYXgteG1pbik7XG4gICAgdmFyIHltdWx0ID0gbnkgLyAoeW1heC15bWluKTtcblxuICAgIC8vIFB1dCBhbGwgYm9kaWVzIGludG8gYmluc1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmNvbGxpZGluZzsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICB2YXIgYWFiYiA9IGJpLmFhYmI7XG4gICAgICAgIHZhciBsb3dlclggPSBNYXRoLm1heChhYWJiLmxvd2VyQm91bmRbMF0sIHhtaW4pO1xuICAgICAgICB2YXIgbG93ZXJZID0gTWF0aC5tYXgoYWFiYi5sb3dlckJvdW5kWzFdLCB5bWluKTtcbiAgICAgICAgdmFyIHVwcGVyWCA9IE1hdGgubWluKGFhYmIudXBwZXJCb3VuZFswXSwgeG1heCk7XG4gICAgICAgIHZhciB1cHBlclkgPSBNYXRoLm1pbihhYWJiLnVwcGVyQm91bmRbMV0sIHltYXgpO1xuICAgICAgICB2YXIgeGkxID0gTWF0aC5mbG9vcih4bXVsdCAqIChsb3dlclggLSB4bWluKSk7XG4gICAgICAgIHZhciB5aTEgPSBNYXRoLmZsb29yKHltdWx0ICogKGxvd2VyWSAtIHltaW4pKTtcbiAgICAgICAgdmFyIHhpMiA9IE1hdGguZmxvb3IoeG11bHQgKiAodXBwZXJYIC0geG1pbikpO1xuICAgICAgICB2YXIgeWkyID0gTWF0aC5mbG9vcih5bXVsdCAqICh1cHBlclkgLSB5bWluKSk7XG5cbiAgICAgICAgLy8gUHV0IGluIGJpblxuICAgICAgICBmb3IodmFyIGo9eGkxOyBqPD14aTI7IGorKyl7XG4gICAgICAgICAgICBmb3IodmFyIGs9eWkxOyBrPD15aTI7IGsrKyl7XG4gICAgICAgICAgICAgICAgdmFyIHhpID0gajtcbiAgICAgICAgICAgICAgICB2YXIgeWkgPSBrO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSB4aSoobnktMSkgKyB5aTtcbiAgICAgICAgICAgICAgICBpZihpZHggPj0gMCAmJiBpZHggPCBOYmlucyl7XG4gICAgICAgICAgICAgICAgICAgIGJpbnNbIGlkeCBdLnB1c2goYmkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGVhY2ggYmluXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYmluczsgaSsrKXtcbiAgICAgICAgdmFyIGJpbiA9IGJpbnNbaV07XG5cbiAgICAgICAgZm9yKHZhciBqPTAsIE5ib2RpZXNJbkJpbj1iaW4ubGVuZ3RoOyBqIT09TmJvZGllc0luQmluOyBqKyspe1xuICAgICAgICAgICAgdmFyIGJpID0gYmluW2pdO1xuICAgICAgICAgICAgZm9yKHZhciBrPTA7IGshPT1qOyBrKyspe1xuICAgICAgICAgICAgICAgIHZhciBiaiA9IGJpbltrXTtcbiAgICAgICAgICAgICAgICBpZihCcm9hZHBoYXNlLmNhbkNvbGxpZGUoYmksYmopICYmIHRoaXMuYm91bmRpbmdWb2x1bWVDaGVjayhiaSxiaikpe1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaSxiaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG59LHtcIi4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlXCI6OCxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vc2hhcGVzL0NpcmNsZVwiOjM4LFwiLi4vc2hhcGVzL1BhcnRpY2xlXCI6NDIsXCIuLi9zaGFwZXMvUGxhbmVcIjo0MyxcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ2lyY2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL0NpcmNsZScpLFxuICAgIFBsYW5lID0gX2RlcmVxXygnLi4vc2hhcGVzL1BsYW5lJyksXG4gICAgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKSxcbiAgICBQYXJ0aWNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QYXJ0aWNsZScpLFxuICAgIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYWl2ZUJyb2FkcGhhc2U7XG5cbi8qKlxuICogTmFpdmUgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbi4gRG9lcyBOXjIgdGVzdHMuXG4gKlxuICogQGNsYXNzIE5haXZlQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXG4gKi9cbmZ1bmN0aW9uIE5haXZlQnJvYWRwaGFzZSgpe1xuICAgIEJyb2FkcGhhc2UuY2FsbCh0aGlzLCBCcm9hZHBoYXNlLk5BSVZFKTtcbn1cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5haXZlQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbGxpZGluZyBwYWlyc1xuICogQG1ldGhvZCBnZXRDb2xsaXNpb25QYWlyc1xuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdDtcblxuICAgIHJlc3VsdC5sZW5ndGggPSAwO1xuXG4gICAgZm9yKHZhciBpPTAsIE5jb2xsaWRpbmc9Ym9kaWVzLmxlbmd0aDsgaSE9PU5jb2xsaWRpbmc7IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcblxuICAgICAgICBmb3IodmFyIGo9MDsgajxpOyBqKyspe1xuICAgICAgICAgICAgdmFyIGJqID0gYm9kaWVzW2pdO1xuXG4gICAgICAgICAgICBpZihCcm9hZHBoYXNlLmNhbkNvbGxpZGUoYmksYmopICYmIHRoaXMuYm91bmRpbmdWb2x1bWVDaGVjayhiaSxiaikpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpLGJqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGJvZGllcyBpbi5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICAgIHZhciBib2RpZXMgPSB3b3JsZC5ib2RpZXM7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGIudXBkYXRlQUFCQigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKXtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG59LHtcIi4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlXCI6OCxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vc2hhcGVzL0NpcmNsZVwiOjM4LFwiLi4vc2hhcGVzL1BhcnRpY2xlXCI6NDIsXCIuLi9zaGFwZXMvUGxhbmVcIjo0MyxcIi4uL3NoYXBlcy9TaGFwZVwiOjQ1fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIHN1YiA9IHZlYzIuc3ViXG4sICAgYWRkID0gdmVjMi5hZGRcbiwgICBkb3QgPSB2ZWMyLmRvdFxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIFR1cGxlRGljdGlvbmFyeSA9IF9kZXJlcV8oJy4uL3V0aWxzL1R1cGxlRGljdGlvbmFyeScpXG4sICAgRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKVxuLCAgIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKVxuLCAgIEZyaWN0aW9uRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpXG4sICAgQ2lyY2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL0NpcmNsZScpXG4sICAgQ29udmV4ID0gX2RlcmVxXygnLi4vc2hhcGVzL0NvbnZleCcpXG4sICAgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKVxuLCAgIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKVxuLCAgIFJlY3RhbmdsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9SZWN0YW5nbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYXJyb3dwaGFzZTtcblxuLy8gVGVtcCB0aGluZ3NcbnZhciB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuXG52YXIgdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wNCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wNSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wNiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wNyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wOCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wOSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTAgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDExID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxNSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTYgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE3ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxOCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wQXJyYXkgPSBbXTtcblxuLyoqXG4gKiBOYXJyb3dwaGFzZS4gQ3JlYXRlcyBjb250YWN0cyBhbmQgZnJpY3Rpb24gZ2l2ZW4gc2hhcGVzIGFuZCB0cmFuc2Zvcm1zLlxuICogQGNsYXNzIE5hcnJvd3BoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTmFycm93cGhhc2UoKXtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0RXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uRXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gbWFrZSBmcmljdGlvbiBlcXVhdGlvbnMgaW4gdGhlIHVwY29taW5nIGNvbnRhY3RzLlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVGcmljdGlvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBtYWtlIGVxdWF0aW9ucyBlbmFibGVkIGluIHVwY29taW5nIGNvbnRhY3RzLlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVkRXF1YXRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkRXF1YXRpb25zID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmljdGlvbiBzbGlwIGZvcmNlIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGZyaWN0aW9uIGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgc2xpcEZvcmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNsaXBGb3JjZSA9IDEwLjA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJpY3Rpb24gdmFsdWUgdG8gdXNlIGluIHRoZSB1cGNvbWluZyBmcmljdGlvbiBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uQ29lZmZpY2llbnRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25Db2VmZmljaWVudCA9IDAuMztcblxuICAgIC8qKlxuICAgICAqIFdpbGwgYmUgdGhlIC5yZWxhdGl2ZVZlbG9jaXR5IGluIGVhY2ggcHJvZHVjZWQgRnJpY3Rpb25FcXVhdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3VyZmFjZVZlbG9jaXR5XG4gICAgICovXG4gICAgdGhpcy5zdXJmYWNlVmVsb2NpdHkgPSAwO1xuXG4gICAgdGhpcy5yZXVzZU9iamVjdHMgPSB0cnVlO1xuICAgIHRoaXMucmV1c2FibGVDb250YWN0RXF1YXRpb25zID0gW107XG4gICAgdGhpcy5yZXVzYWJsZUZyaWN0aW9uRXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdGl0dXRpb24gdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGNvbnRhY3QgZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0aXR1dGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3RpZmZuZXNzXG4gICAgICovXG4gICAgdGhpcy5zdGlmZm5lc3MgPSBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGlmZm5lc3MgdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGNvbnRhY3QgZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdGlmZm5lc3NcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF4YXRpb24gPSBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBmcmljdGlvbiBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uU3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uU3RpZmZuZXNzID0gRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVsYXhhdGlvbiB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblJlbGF4YXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25SZWxheGF0aW9uID0gRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHJlZHVjdGlvbiBvZiBmcmljdGlvbiBlcXVhdGlvbnMuIElmIGRpc2FibGVkLCBhIGJveCBvbiBhIHBsYW5lIHdpbGwgZ2VuZXJhdGUgMiBjb250YWN0IGVxdWF0aW9ucyBhbmQgMiBmcmljdGlvbiBlcXVhdGlvbnMuIElmIGVuYWJsZWQsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgZnJpY3Rpb24gZXF1YXRpb24uIFNhbWUga2luZCBvZiBzaW1wbGlmaWNhdGlvbnMgYXJlIG1hZGUgIGZvciBhbGwgY29sbGlzaW9uIHR5cGVzLlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVGcmljdGlvblJlZHVjdGlvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgZmxhZyB3aWxsIGJlIHJlbW92ZWQgd2hlbiB0aGUgZmVhdHVyZSBpcyBzdGFibGUgZW5vdWdoLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjb2xsaWRpbmcgYm9kaWVzIGxhc3Qgc3RlcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaWRpbmdCb2RpZXNMYXN0U3RlcFxuICAgICAqIEB0eXBlIHtUdXBsZURpY3Rpb25hcnl9XG4gICAgICovXG4gICAgdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcCA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhY3Qgc2tpbiBzaXplIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29udGFjdFNraW5TaXplXG4gICAgICogQGRlZmF1bHQgMC4wMVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFNraW5TaXplID0gMC4wMTtcbn1cblxudmFyIGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgYm9kaWVzT3ZlcmxhcFxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuYm9kaWVzT3ZlcmxhcCA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmFyIHNoYXBlUG9zaXRpb25BID0gYm9kaWVzT3ZlcmxhcF9zaGFwZVBvc2l0aW9uQTtcbiAgICB2YXIgc2hhcGVQb3NpdGlvbkIgPSBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25CO1xuXG4gICAgLy8gTG9vcCBvdmVyIGFsbCBzaGFwZXMgb2YgYm9keUFcbiAgICBmb3IodmFyIGs9MCwgTnNoYXBlc2k9Ym9keUEuc2hhcGVzLmxlbmd0aDsgayE9PU5zaGFwZXNpOyBrKyspe1xuICAgICAgICB2YXIgc2hhcGVBID0gYm9keUEuc2hhcGVzW2tdLFxuICAgICAgICAgICAgcG9zaXRpb25BID0gYm9keUEuc2hhcGVPZmZzZXRzW2tdLFxuICAgICAgICAgICAgYW5nbGVBID0gYm9keUEuc2hhcGVBbmdsZXNba107XG5cbiAgICAgICAgYm9keUEudG9Xb3JsZEZyYW1lKHNoYXBlUG9zaXRpb25BLCBwb3NpdGlvbkEpO1xuXG4gICAgICAgIC8vIEFsbCBzaGFwZXMgb2YgYm9keSBqXG4gICAgICAgIGZvcih2YXIgbD0wLCBOc2hhcGVzaj1ib2R5Qi5zaGFwZXMubGVuZ3RoOyBsIT09TnNoYXBlc2o7IGwrKyl7XG4gICAgICAgICAgICB2YXIgc2hhcGVCID0gYm9keUIuc2hhcGVzW2xdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uQiA9IGJvZHlCLnNoYXBlT2Zmc2V0c1tsXSxcbiAgICAgICAgICAgICAgICBhbmdsZUIgPSBib2R5Qi5zaGFwZUFuZ2xlc1tsXTtcblxuICAgICAgICAgICAgYm9keUIudG9Xb3JsZEZyYW1lKHNoYXBlUG9zaXRpb25CLCBwb3NpdGlvbkIpO1xuXG4gICAgICAgICAgICBpZih0aGlzW3NoYXBlQS50eXBlIHwgc2hhcGVCLnR5cGVdKFxuICAgICAgICAgICAgICAgIGJvZHlBLFxuICAgICAgICAgICAgICAgIHNoYXBlQSxcbiAgICAgICAgICAgICAgICBzaGFwZVBvc2l0aW9uQSxcbiAgICAgICAgICAgICAgICBzaGFwZUEuYW5nbGUgKyBib2R5QS5hbmdsZSxcbiAgICAgICAgICAgICAgICBib2R5QixcbiAgICAgICAgICAgICAgICBzaGFwZUIsXG4gICAgICAgICAgICAgICAgc2hhcGVQb3NpdGlvbkIsXG4gICAgICAgICAgICAgICAgc2hhcGVCLmFuZ2xlICsgYm9keUIuYW5nbGUsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBib2RpZXMgd2VyZSBpbiBjb250YWN0IHNpbmNlIHRoZSBsYXN0IHJlc2V0KCkuXG4gKiBAbWV0aG9kIGNvbGxpZGVkTGFzdFN0ZXBcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbGxpZGVkTGFzdFN0ZXAgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZhciBpZDEgPSBib2R5QS5pZHwwLFxuICAgICAgICBpZDIgPSBib2R5Qi5pZHwwO1xuICAgIHJldHVybiAhIXRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAuZ2V0KGlkMSwgaWQyKTtcbn07XG5cbi8qKlxuICogVGhyb3dzIGF3YXkgdGhlIG9sZCBlcXVhdGlvbnMgYW5kIGdldHMgcmVhZHkgdG8gY3JlYXRlIG5ld1xuICogQG1ldGhvZCByZXNldFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAucmVzZXQoKTtcblxuICAgIHZhciBlcXMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvbnM7XG4gICAgdmFyIGwgPSBlcXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tsXSxcbiAgICAgICAgICAgIGlkMSA9IGVxLmJvZHlBLmlkLFxuICAgICAgICAgICAgaWQyID0gZXEuYm9keUIuaWQ7XG4gICAgICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAuc2V0KGlkMSwgaWQyLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZih0aGlzLnJldXNlT2JqZWN0cyl7XG4gICAgICAgIHZhciBjZSA9IHRoaXMuY29udGFjdEVxdWF0aW9ucyxcbiAgICAgICAgICAgIGZlID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucyxcbiAgICAgICAgICAgIHJmZSA9IHRoaXMucmV1c2FibGVGcmljdGlvbkVxdWF0aW9ucyxcbiAgICAgICAgICAgIHJjZSA9IHRoaXMucmV1c2FibGVDb250YWN0RXF1YXRpb25zO1xuICAgICAgICBVdGlscy5hcHBlbmRBcnJheShyY2UsY2UpO1xuICAgICAgICBVdGlscy5hcHBlbmRBcnJheShyZmUsZmUpO1xuICAgIH1cblxuICAgIC8vIFJlc2V0XG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIENvbnRhY3RFcXVhdGlvbiwgZWl0aGVyIGJ5IHJldXNpbmcgYW4gZXhpc3Rpbmcgb2JqZWN0IG9yIGNyZWF0aW5nIGEgbmV3IG9uZS5cbiAqIEBtZXRob2QgY3JlYXRlQ29udGFjdEVxdWF0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbiA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qiwgc2hhcGVBLCBzaGFwZUIpe1xuICAgIHZhciBjID0gdGhpcy5yZXVzYWJsZUNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID8gdGhpcy5yZXVzYWJsZUNvbnRhY3RFcXVhdGlvbnMucG9wKCkgOiBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICBjLmJvZHlBID0gYm9keUE7XG4gICAgYy5ib2R5QiA9IGJvZHlCO1xuICAgIGMuc2hhcGVBID0gc2hhcGVBO1xuICAgIGMuc2hhcGVCID0gc2hhcGVCO1xuICAgIGMucmVzdGl0dXRpb24gPSB0aGlzLnJlc3RpdHV0aW9uO1xuICAgIGMuZmlyc3RJbXBhY3QgPSAhdGhpcy5jb2xsaWRlZExhc3RTdGVwKGJvZHlBLGJvZHlCKTtcbiAgICBjLnN0aWZmbmVzcyA9IHRoaXMuc3RpZmZuZXNzO1xuICAgIGMucmVsYXhhdGlvbiA9IHRoaXMucmVsYXhhdGlvbjtcbiAgICBjLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBjLmVuYWJsZWQgPSB0aGlzLmVuYWJsZWRFcXVhdGlvbnM7XG4gICAgYy5vZmZzZXQgPSB0aGlzLmNvbnRhY3RTa2luU2l6ZTtcblxuICAgIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgRnJpY3Rpb25FcXVhdGlvbiwgZWl0aGVyIGJ5IHJldXNpbmcgYW4gZXhpc3Rpbmcgb2JqZWN0IG9yIGNyZWF0aW5nIGEgbmV3IG9uZS5cbiAqIEBtZXRob2QgY3JlYXRlRnJpY3Rpb25FcXVhdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtGcmljdGlvbkVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbiA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qiwgc2hhcGVBLCBzaGFwZUIpe1xuICAgIHZhciBjID0gdGhpcy5yZXVzYWJsZUZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCA/IHRoaXMucmV1c2FibGVGcmljdGlvbkVxdWF0aW9ucy5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICBjLmJvZHlBID0gYm9keUE7XG4gICAgYy5ib2R5QiA9IGJvZHlCO1xuICAgIGMuc2hhcGVBID0gc2hhcGVBO1xuICAgIGMuc2hhcGVCID0gc2hhcGVCO1xuICAgIGMuc2V0U2xpcEZvcmNlKHRoaXMuc2xpcEZvcmNlKTtcbiAgICBjLmZyaWN0aW9uQ29lZmZpY2llbnQgPSB0aGlzLmZyaWN0aW9uQ29lZmZpY2llbnQ7XG4gICAgYy5yZWxhdGl2ZVZlbG9jaXR5ID0gdGhpcy5zdXJmYWNlVmVsb2NpdHk7XG4gICAgYy5lbmFibGVkID0gdGhpcy5lbmFibGVkRXF1YXRpb25zO1xuICAgIGMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGMuc3RpZmZuZXNzID0gdGhpcy5mcmljdGlvblN0aWZmbmVzcztcbiAgICBjLnJlbGF4YXRpb24gPSB0aGlzLmZyaWN0aW9uUmVsYXhhdGlvbjtcbiAgICBjLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIEZyaWN0aW9uRXF1YXRpb24gZ2l2ZW4gdGhlIGRhdGEgaW4gdGhlIENvbnRhY3RFcXVhdGlvbi4gVXNlcyBzYW1lIG9mZnNldCB2ZWN0b3JzIHJpIGFuZCByaiwgYnV0IHRoZSB0YW5nZW50IHZlY3RvciB3aWxsIGJlIGNvbnN0cnVjdGVkIGZyb20gdGhlIGNvbGxpc2lvbiBub3JtYWwuXG4gKiBAbWV0aG9kIGNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3RcbiAqIEBwYXJhbSAge0NvbnRhY3RFcXVhdGlvbn0gY29udGFjdEVxdWF0aW9uXG4gKiBAcmV0dXJuIHtGcmljdGlvbkVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdCA9IGZ1bmN0aW9uKGMpe1xuICAgIHZhciBlcSA9IHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbihjLmJvZHlBLCBjLmJvZHlCLCBjLnNoYXBlQSwgYy5zaGFwZUIpO1xuICAgIHZlYzIuY29weShlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgIHZlYzIuY29weShlcS5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIpO1xuICAgIHZlYzIucm90YXRlOTBjdyhlcS50LCBjLm5vcm1hbEEpO1xuICAgIGVxLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcbiAgICByZXR1cm4gZXE7XG59O1xuXG4vLyBUYWtlIHRoZSBhdmVyYWdlIE4gbGF0ZXN0IGNvbnRhY3QgcG9pbnQgb24gdGhlIHBsYW5lLlxuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UgPSBmdW5jdGlvbihudW1Db250YWN0cyl7XG4gICAgdmFyIGMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvbnNbdGhpcy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIHZhciBlcSA9IHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbihjLmJvZHlBLCBjLmJvZHlCLCBjLnNoYXBlQSwgYy5zaGFwZUIpO1xuICAgIHZhciBib2R5QSA9IGMuYm9keUE7XG4gICAgdmFyIGJvZHlCID0gYy5ib2R5QjtcbiAgICB2ZWMyLnNldChlcS5jb250YWN0UG9pbnRBLCAwLCAwKTtcbiAgICB2ZWMyLnNldChlcS5jb250YWN0UG9pbnRCLCAwLCAwKTtcbiAgICB2ZWMyLnNldChlcS50LCAwLCAwKTtcbiAgICBmb3IodmFyIGk9MDsgaSE9PW51bUNvbnRhY3RzOyBpKyspe1xuICAgICAgICBjID0gdGhpcy5jb250YWN0RXF1YXRpb25zW3RoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIGlmKGMuYm9keUEgPT09IGJvZHlBKXtcbiAgICAgICAgICAgIHZlYzIuYWRkKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlYzIuc3ViKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEIpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRBKTtcbiAgICAgICAgfVxuICAgICAgICBlcS5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgdmFyIGludk51bUNvbnRhY3RzID0gMS9udW1Db250YWN0cztcbiAgICB2ZWMyLnNjYWxlKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGludk51bUNvbnRhY3RzKTtcbiAgICB2ZWMyLnNjYWxlKGVxLmNvbnRhY3RQb2ludEIsIGVxLmNvbnRhY3RQb2ludEIsIGludk51bUNvbnRhY3RzKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShlcS50LCBlcS50KTtcbiAgICB2ZWMyLnJvdGF0ZTkwY3coZXEudCwgZXEudCk7XG4gICAgcmV0dXJuIGVxO1xufTtcblxuLyoqXG4gKiBDb252ZXgvbGluZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjb252ZXhMaW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjb252ZXhBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBqdXN0VGVzdFxuICogQHRvZG8gSW1wbGVtZW50IG1lIVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuTElORSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleExpbmUgPSBmdW5jdGlvbihcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBsaW5lQm9keSxcbiAgICBsaW5lU2hhcGUsXG4gICAgbGluZU9mZnNldCxcbiAgICBsaW5lQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgLy8gVE9ET1xuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGluZS9yZWN0YW5nbGUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgbGluZVJlY3RhbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICByZWN0YW5nbGVCb2R5XG4gKiBAcGFyYW0gIHtSZWN0YW5nbGV9ICByZWN0YW5nbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVjdGFuZ2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICByZWN0YW5nbGVBbmdsZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICAganVzdFRlc3RcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkxJTkUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5saW5lUmVjdGFuZ2xlID0gZnVuY3Rpb24oXG4gICAgbGluZUJvZHksXG4gICAgbGluZVNoYXBlLFxuICAgIGxpbmVPZmZzZXQsXG4gICAgbGluZUFuZ2xlLFxuICAgIHJlY3RhbmdsZUJvZHksXG4gICAgcmVjdGFuZ2xlU2hhcGUsXG4gICAgcmVjdGFuZ2xlT2Zmc2V0LFxuICAgIHJlY3RhbmdsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIC8vIFRPRE9cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShjb252ZXhTaGFwZSwgY2Fwc3VsZVNoYXBlKXtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1swXSwgLWNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsIC1jYXBzdWxlU2hhcGUucmFkaXVzKTtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1sxXSwgIGNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsIC1jYXBzdWxlU2hhcGUucmFkaXVzKTtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1syXSwgIGNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsICBjYXBzdWxlU2hhcGUucmFkaXVzKTtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1szXSwgLWNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsICBjYXBzdWxlU2hhcGUucmFkaXVzKTtcbn1cblxudmFyIGNvbnZleENhcHN1bGVfdGVtcFJlY3QgPSBuZXcgUmVjdGFuZ2xlKDEsMSksXG4gICAgY29udmV4Q2Fwc3VsZV90ZW1wVmVjID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBDb252ZXgvY2Fwc3VsZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjb252ZXhDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY29udmV4UG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjYXBzdWxlQm9keVxuICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgY2Fwc3VsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBjYXBzdWxlUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNhcHN1bGVBbmdsZVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0FQU1VMRSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhDYXBzdWxlID0gZnVuY3Rpb24oXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhQb3NpdGlvbixcbiAgICBjb252ZXhBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcblxuICAgIC8vIENoZWNrIHRoZSBjaXJjbGVzXG4gICAgLy8gQWRkIG9mZnNldHMhXG4gICAgdmFyIGNpcmNsZVBvcyA9IGNvbnZleENhcHN1bGVfdGVtcFZlYztcbiAgICB2ZWMyLnNldChjaXJjbGVQb3MsIGNhcHN1bGVTaGFwZS5sZW5ndGgvMiwwKTtcbiAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSk7XG4gICAgdmVjMi5hZGQoY2lyY2xlUG9zLGNpcmNsZVBvcyxjYXBzdWxlUG9zaXRpb24pO1xuICAgIHZhciByZXN1bHQxID0gdGhpcy5jaXJjbGVDb252ZXgoY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNpcmNsZVBvcyxjYXBzdWxlQW5nbGUsIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zaXRpb24sY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzKTtcblxuICAgIHZlYzIuc2V0KGNpcmNsZVBvcywtY2Fwc3VsZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSk7XG4gICAgdmVjMi5hZGQoY2lyY2xlUG9zLGNpcmNsZVBvcyxjYXBzdWxlUG9zaXRpb24pO1xuICAgIHZhciByZXN1bHQyID0gdGhpcy5jaXJjbGVDb252ZXgoY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNpcmNsZVBvcyxjYXBzdWxlQW5nbGUsIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zaXRpb24sY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzKTtcblxuICAgIGlmKGp1c3RUZXN0ICYmIChyZXN1bHQxIHx8IHJlc3VsdDIpKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY2VudGVyIHJlY3RcbiAgICB2YXIgciA9IGNvbnZleENhcHN1bGVfdGVtcFJlY3Q7XG4gICAgc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUocixjYXBzdWxlU2hhcGUpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnZleENvbnZleChjb252ZXhCb2R5LGNvbnZleFNoYXBlLGNvbnZleFBvc2l0aW9uLGNvbnZleEFuZ2xlLCBjYXBzdWxlQm9keSxyLGNhcHN1bGVQb3NpdGlvbixjYXBzdWxlQW5nbGUsIGp1c3RUZXN0KTtcblxuICAgIHJldHVybiByZXN1bHQgKyByZXN1bHQxICsgcmVzdWx0Mjtcbn07XG5cbi8qKlxuICogQ2Fwc3VsZS9saW5lIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGxpbmVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gICAgICAgbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBsaW5lUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGxpbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgY2Fwc3VsZUJvZHlcbiAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIGNhcHN1bGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY2Fwc3VsZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjYXBzdWxlQW5nbGVcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5MSU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUNhcHN1bGUgPSBmdW5jdGlvbihcbiAgICBsaW5lQm9keSxcbiAgICBsaW5lU2hhcGUsXG4gICAgbGluZVBvc2l0aW9uLFxuICAgIGxpbmVBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICAvLyBUT0RPXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxudmFyIGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMxID0gdmVjMi5jcmVhdGUoKTtcbnZhciBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgY2Fwc3VsZUNhcHN1bGVfdGVtcFJlY3QxID0gbmV3IFJlY3RhbmdsZSgxLDEpO1xuXG4vKipcbiAqIENhcHN1bGUvY2Fwc3VsZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjYXBzdWxlQ2Fwc3VsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIHNpXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICB4aVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYWlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKiBAcGFyYW0gIHtDYXBzdWxlfSAgICBzalxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgeGpcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DQVBTVUxFIHwgU2hhcGUuQ0FQU1VMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNhcHN1bGVDYXBzdWxlID0gZnVuY3Rpb24oYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCl7XG5cbiAgICB2YXIgZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG5cbiAgICAvLyBDaGVjayB0aGUgY2lyY2xlc1xuICAgIC8vIEFkZCBvZmZzZXRzIVxuICAgIHZhciBjaXJjbGVQb3NpID0gY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzEsXG4gICAgICAgIGNpcmNsZVBvc2ogPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMjtcblxuICAgIHZhciBudW1Db250YWN0cyA9IDA7XG5cblxuICAgIC8vIE5lZWQgNCBjaXJjbGUgY2hlY2tzLCBiZXR3ZWVuIGFsbFxuICAgIGZvcih2YXIgaT0wOyBpPDI7IGkrKyl7XG5cbiAgICAgICAgdmVjMi5zZXQoY2lyY2xlUG9zaSwoaT09PTA/LTE6MSkqc2kubGVuZ3RoLzIsMCk7XG4gICAgICAgIHZlYzIucm90YXRlKGNpcmNsZVBvc2ksY2lyY2xlUG9zaSxhaSk7XG4gICAgICAgIHZlYzIuYWRkKGNpcmNsZVBvc2ksY2lyY2xlUG9zaSx4aSk7XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8MjsgaisrKXtcblxuICAgICAgICAgICAgdmVjMi5zZXQoY2lyY2xlUG9zaiwoaj09PTA/LTE6MSkqc2oubGVuZ3RoLzIsIDApO1xuICAgICAgICAgICAgdmVjMi5yb3RhdGUoY2lyY2xlUG9zaixjaXJjbGVQb3NqLGFqKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGNpcmNsZVBvc2osY2lyY2xlUG9zaix4aik7XG5cbiAgICAgICAgICAgIC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jaXJjbGVDaXJjbGUoYmksc2ksY2lyY2xlUG9zaSxhaSwgYmosc2osY2lyY2xlUG9zaixhaiwganVzdFRlc3QsIHNpLnJhZGl1cywgc2oucmFkaXVzKTtcblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCAmJiByZXN1bHQpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBudW1Db250YWN0cyArPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cbiAgICAgICAgZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY2lyY2xlcyBhZ2FpbnN0IHRoZSBjZW50ZXIgcmVjdGFuZ2xlc1xuICAgIHZhciByZWN0ID0gY2Fwc3VsZUNhcHN1bGVfdGVtcFJlY3QxO1xuICAgIHNldENvbnZleFRvQ2Fwc3VsZVNoYXBlTWlkZGxlKHJlY3Qsc2kpO1xuICAgIHZhciByZXN1bHQxID0gdGhpcy5jb252ZXhDYXBzdWxlKGJpLHJlY3QseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0ICYmIHJlc3VsdDEpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbnVtQ29udGFjdHMgKz0gcmVzdWx0MTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxuICAgICAgICB2YXIgZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUocmVjdCxzaik7XG4gICAgdmFyIHJlc3VsdDIgPSB0aGlzLmNvbnZleENhcHN1bGUoYmoscmVjdCx4aixhaiwgYmksc2kseGksYWksIGp1c3RUZXN0KTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3QgJiYgcmVzdWx0Mil7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBudW1Db250YWN0cyArPSByZXN1bHQyO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGlmKG51bUNvbnRhY3RzICYmIHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTtcblxuLyoqXG4gKiBMaW5lL2xpbmUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgbGluZUxpbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJvZHlBXG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBzaGFwZUFcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBvc2l0aW9uQVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGVBXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBib2R5QlxuICogQHBhcmFtICB7TGluZX0gICAgICAgc2hhcGVCXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBwb3NpdGlvbkJcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlQlxuICogQHRvZG8gSW1wbGVtZW50IG1lIVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuTElORSB8IFNoYXBlLkxJTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5saW5lTGluZSA9IGZ1bmN0aW9uKFxuICAgIGJvZHlBLFxuICAgIHNoYXBlQSxcbiAgICBwb3NpdGlvbkEsXG4gICAgYW5nbGVBLFxuICAgIGJvZHlCLFxuICAgIHNoYXBlQixcbiAgICBwb3NpdGlvbkIsXG4gICAgYW5nbGVCLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIC8vIFRPRE9cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFBsYW5lL2xpbmUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgcGxhbmVMaW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgIHBsYW5lQm9keVxuICogQHBhcmFtICB7UGxhbmV9ICBwbGFuZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBsYW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9ICAgbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gIGxpbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gbGluZUFuZ2xlXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkxJTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUxpbmUgPSBmdW5jdGlvbihwbGFuZUJvZHksIHBsYW5lU2hhcGUsIHBsYW5lT2Zmc2V0LCBwbGFuZUFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVCb2R5LCAgbGluZVNoYXBlLCAgbGluZU9mZnNldCwgIGxpbmVBbmdsZSwganVzdFRlc3Qpe1xuICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLFxuICAgICAgICB3b3JsZFZlcnRleDEgPSB0bXAyLFxuICAgICAgICB3b3JsZFZlcnRleDAxID0gdG1wMyxcbiAgICAgICAgd29ybGRWZXJ0ZXgxMSA9IHRtcDQsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDUsXG4gICAgICAgIHdvcmxkRWRnZVVuaXQgPSB0bXA2LFxuICAgICAgICBkaXN0ID0gdG1wNyxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXA4LFxuICAgICAgICB3b3JsZFRhbmdlbnQgPSB0bXA5LFxuICAgICAgICB2ZXJ0cyA9IHRtcEFycmF5LFxuICAgICAgICBudW1Db250YWN0cyA9IDA7XG5cbiAgICAvLyBHZXQgc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAgICB2ZWMyLnNldCh3b3JsZFZlcnRleDAsIC1saW5lU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIuc2V0KHdvcmxkVmVydGV4MSwgIGxpbmVTaGFwZS5sZW5ndGgvMiwgMCk7XG5cbiAgICAvLyBOb3Qgc3VyZSB3aHkgd2UgaGF2ZSB0byB1c2Ugd29ybGRWZXJ0ZXgqMSBoZXJlLCBidXQgaXQgd29uJ3Qgd29yayBvdGhlcndpc2UuIFRpcmVkLlxuICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MDEsIHdvcmxkVmVydGV4MCwgbGluZUFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDEsIGxpbmVBbmdsZSk7XG5cbiAgICBhZGQod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwMSwgbGluZU9mZnNldCk7XG4gICAgYWRkKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MTEsIGxpbmVPZmZzZXQpO1xuXG4gICAgdmVjMi5jb3B5KHdvcmxkVmVydGV4MCx3b3JsZFZlcnRleDAxKTtcbiAgICB2ZWMyLmNvcHkod29ybGRWZXJ0ZXgxLHdvcmxkVmVydGV4MTEpO1xuXG4gICAgLy8gR2V0IHZlY3RvciBhbG9uZyB0aGUgbGluZVxuICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xuXG4gICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuXG4gICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkVGFuZ2VudCwgd29ybGRFZGdlVW5pdCk7XG5cbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xuXG4gICAgLy8gQ2hlY2sgbGluZSBlbmRzXG4gICAgdmVydHNbMF0gPSB3b3JsZFZlcnRleDA7XG4gICAgdmVydHNbMV0gPSB3b3JsZFZlcnRleDE7XG4gICAgZm9yKHZhciBpPTA7IGk8dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuXG4gICAgICAgIHN1YihkaXN0LCB2LCBwbGFuZU9mZnNldCk7XG5cbiAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgaWYoZCA8IDApe1xuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LGxpbmVCb2R5LHBsYW5lU2hhcGUsbGluZVNoYXBlKTtcbiAgICAgICAgICAgIG51bUNvbnRhY3RzKys7XG5cbiAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAvLyBkaXN0YW5jZSB2ZWN0b3IgYWxvbmcgcGxhbmUgbm9ybWFsXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGRpc3QsIHdvcmxkTm9ybWFsLCBkKTtcblxuICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gcGxhbmUgY2VudGVyIHRvIGNvbnRhY3RcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHYsIGRpc3QpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAvLyBGcm9tIGxpbmUgY2VudGVyIHRvIGNvbnRhY3RcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHYsICAgIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGlmKG51bUNvbnRhY3RzICYmIHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTtcblxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuQ0FQU1VMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBhcnRpY2xlQ2Fwc3VsZSA9IGZ1bmN0aW9uKFxuICAgIHBhcnRpY2xlQm9keSxcbiAgICBwYXJ0aWNsZVNoYXBlLFxuICAgIHBhcnRpY2xlUG9zaXRpb24sXG4gICAgcGFydGljbGVBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICByZXR1cm4gdGhpcy5jaXJjbGVMaW5lKHBhcnRpY2xlQm9keSxwYXJ0aWNsZVNoYXBlLHBhcnRpY2xlUG9zaXRpb24scGFydGljbGVBbmdsZSwgY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNhcHN1bGVQb3NpdGlvbixjYXBzdWxlQW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzLCAwKTtcbn07XG5cbi8qKlxuICogQ2lyY2xlL2xpbmUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2lyY2xlTGluZVxuICogQHBhcmFtICB7Qm9keX0gY2lyY2xlQm9keVxuICogQHBhcmFtICB7Q2lyY2xlfSBjaXJjbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNpcmNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9IGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGxpbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gbGluZUFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0IElmIHNldCB0byB0cnVlLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgKGludGVyc2VjdGlvbiBvciBub3QpIHdpdGhvdXQgYWRkaW5nIGVxdWF0aW9ucy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lUmFkaXVzIFJhZGl1cyB0byBhZGQgdG8gdGhlIGxpbmUuIENhbiBiZSB1c2VkIHRvIHRlc3QgQ2Fwc3VsZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gY2lyY2xlUmFkaXVzIElmIHNldCwgdGhpcyB2YWx1ZSBvdmVycmlkZXMgdGhlIGNpcmNsZSBzaGFwZSByYWRpdXMuXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5MSU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlTGluZSA9IGZ1bmN0aW9uKFxuICAgIGNpcmNsZUJvZHksXG4gICAgY2lyY2xlU2hhcGUsXG4gICAgY2lyY2xlT2Zmc2V0LFxuICAgIGNpcmNsZUFuZ2xlLFxuICAgIGxpbmVCb2R5LFxuICAgIGxpbmVTaGFwZSxcbiAgICBsaW5lT2Zmc2V0LFxuICAgIGxpbmVBbmdsZSxcbiAgICBqdXN0VGVzdCxcbiAgICBsaW5lUmFkaXVzLFxuICAgIGNpcmNsZVJhZGl1c1xuKXtcbiAgICB2YXIgbGluZVJhZGl1cyA9IGxpbmVSYWRpdXMgfHwgMCxcbiAgICAgICAgY2lyY2xlUmFkaXVzID0gdHlwZW9mKGNpcmNsZVJhZGl1cykhPT1cInVuZGVmaW5lZFwiID8gY2lyY2xlUmFkaXVzIDogY2lyY2xlU2hhcGUucmFkaXVzLFxuXG4gICAgICAgIG9ydGhvRGlzdCA9IHRtcDEsXG4gICAgICAgIGxpbmVUb0NpcmNsZU9ydGhvVW5pdCA9IHRtcDIsXG4gICAgICAgIHByb2plY3RlZFBvaW50ID0gdG1wMyxcbiAgICAgICAgY2VudGVyRGlzdCA9IHRtcDQsXG4gICAgICAgIHdvcmxkVGFuZ2VudCA9IHRtcDUsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDYsXG4gICAgICAgIHdvcmxkRWRnZVVuaXQgPSB0bXA3LFxuICAgICAgICB3b3JsZFZlcnRleDAgPSB0bXA4LFxuICAgICAgICB3b3JsZFZlcnRleDEgPSB0bXA5LFxuICAgICAgICB3b3JsZFZlcnRleDAxID0gdG1wMTAsXG4gICAgICAgIHdvcmxkVmVydGV4MTEgPSB0bXAxMSxcbiAgICAgICAgZGlzdCA9IHRtcDEyLFxuICAgICAgICBsaW5lVG9DaXJjbGUgPSB0bXAxMyxcbiAgICAgICAgbGluZUVuZFRvTGluZVJhZGl1cyA9IHRtcDE0LFxuXG4gICAgICAgIHZlcnRzID0gdG1wQXJyYXk7XG5cbiAgICAvLyBHZXQgc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAgICB2ZWMyLnNldCh3b3JsZFZlcnRleDAsIC1saW5lU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIuc2V0KHdvcmxkVmVydGV4MSwgIGxpbmVTaGFwZS5sZW5ndGgvMiwgMCk7XG5cbiAgICAvLyBOb3Qgc3VyZSB3aHkgd2UgaGF2ZSB0byB1c2Ugd29ybGRWZXJ0ZXgqMSBoZXJlLCBidXQgaXQgd29uJ3Qgd29yayBvdGhlcndpc2UuIFRpcmVkLlxuICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MDEsIHdvcmxkVmVydGV4MCwgbGluZUFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDEsIGxpbmVBbmdsZSk7XG5cbiAgICBhZGQod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwMSwgbGluZU9mZnNldCk7XG4gICAgYWRkKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MTEsIGxpbmVPZmZzZXQpO1xuXG4gICAgdmVjMi5jb3B5KHdvcmxkVmVydGV4MCx3b3JsZFZlcnRleDAxKTtcbiAgICB2ZWMyLmNvcHkod29ybGRWZXJ0ZXgxLHdvcmxkVmVydGV4MTEpO1xuXG4gICAgLy8gR2V0IHZlY3RvciBhbG9uZyB0aGUgbGluZVxuICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xuXG4gICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuXG4gICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkVGFuZ2VudCwgd29ybGRFZGdlVW5pdCk7XG5cbiAgICAvLyBDaGVjayBkaXN0YW5jZSBmcm9tIHRoZSBwbGFuZSBzcGFubmVkIGJ5IHRoZSBlZGdlIHZzIHRoZSBjaXJjbGVcbiAgICBzdWIoZGlzdCwgY2lyY2xlT2Zmc2V0LCB3b3JsZFZlcnRleDApO1xuICAgIHZhciBkID0gZG90KGRpc3QsIHdvcmxkVGFuZ2VudCk7IC8vIERpc3RhbmNlIGZyb20gY2VudGVyIG9mIGxpbmUgdG8gY2lyY2xlIGNlbnRlclxuICAgIHN1YihjZW50ZXJEaXN0LCB3b3JsZFZlcnRleDAsIGxpbmVPZmZzZXQpO1xuXG4gICAgc3ViKGxpbmVUb0NpcmNsZSwgY2lyY2xlT2Zmc2V0LCBsaW5lT2Zmc2V0KTtcblxuICAgIHZhciByYWRpdXNTdW0gPSBjaXJjbGVSYWRpdXMgKyBsaW5lUmFkaXVzO1xuXG4gICAgaWYoTWF0aC5hYnMoZCkgPCByYWRpdXNTdW0pe1xuXG4gICAgICAgIC8vIE5vdyBwcm9qZWN0IHRoZSBjaXJjbGUgb250byB0aGUgZWRnZVxuICAgICAgICB2ZWMyLnNjYWxlKG9ydGhvRGlzdCwgd29ybGRUYW5nZW50LCBkKTtcbiAgICAgICAgc3ViKHByb2plY3RlZFBvaW50LCBjaXJjbGVPZmZzZXQsIG9ydGhvRGlzdCk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBtaXNzaW5nIGxpbmUgcmFkaXVzXG4gICAgICAgIHZlYzIuc2NhbGUobGluZVRvQ2lyY2xlT3J0aG9Vbml0LCB3b3JsZFRhbmdlbnQsIGRvdCh3b3JsZFRhbmdlbnQsIGxpbmVUb0NpcmNsZSkpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShsaW5lVG9DaXJjbGVPcnRob1VuaXQsbGluZVRvQ2lyY2xlT3J0aG9Vbml0KTtcbiAgICAgICAgdmVjMi5zY2FsZShsaW5lVG9DaXJjbGVPcnRob1VuaXQsIGxpbmVUb0NpcmNsZU9ydGhvVW5pdCwgbGluZVJhZGl1cyk7XG4gICAgICAgIGFkZChwcm9qZWN0ZWRQb2ludCxwcm9qZWN0ZWRQb2ludCxsaW5lVG9DaXJjbGVPcnRob1VuaXQpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGVkZ2Ugc3BhblxuICAgICAgICB2YXIgcG9zID0gIGRvdCh3b3JsZEVkZ2VVbml0LCBwcm9qZWN0ZWRQb2ludCk7XG4gICAgICAgIHZhciBwb3MwID0gZG90KHdvcmxkRWRnZVVuaXQsIHdvcmxkVmVydGV4MCk7XG4gICAgICAgIHZhciBwb3MxID0gZG90KHdvcmxkRWRnZVVuaXQsIHdvcmxkVmVydGV4MSk7XG5cbiAgICAgICAgaWYocG9zID4gcG9zMCAmJiBwb3MgPCBwb3MxKXtcbiAgICAgICAgICAgIC8vIFdlIGdvdCBjb250YWN0IVxuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxsaW5lQm9keSxjaXJjbGVTaGFwZSxsaW5lU2hhcGUpO1xuXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGMubm9ybWFsQSwgb3J0aG9EaXN0LCAtMSk7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsIGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgIHZlYzIuc2NhbGUoIGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCAgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHByb2plY3RlZFBvaW50LCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBjb3JuZXJcbiAgICB2ZXJ0c1swXSA9IHdvcmxkVmVydGV4MDtcbiAgICB2ZXJ0c1sxXSA9IHdvcmxkVmVydGV4MTtcblxuICAgIGZvcih2YXIgaT0wOyBpPHZlcnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcblxuICAgICAgICBzdWIoZGlzdCwgdiwgY2lyY2xlT2Zmc2V0KTtcblxuICAgICAgICBpZih2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCkgPCBNYXRoLnBvdyhyYWRpdXNTdW0sIDIpKXtcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksbGluZUJvZHksY2lyY2xlU2hhcGUsbGluZVNoYXBlKTtcblxuICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgZGlzdCk7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gY2lyY2xlIHRvIGNvbnRhY3QgcG9pbnQgaXMgdGhlIG5vcm1hbCB0aW1lcyB0aGUgY2lyY2xlIHJhZGl1c1xuICAgICAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHYsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgdmVjMi5zY2FsZShsaW5lRW5kVG9MaW5lUmFkaXVzLCBjLm5vcm1hbEEsIC1saW5lUmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUVuZFRvTGluZVJhZGl1cyk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQ2lyY2xlL2NhcHN1bGUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2lyY2xlQ2Fwc3VsZVxuICogQHBhcmFtICB7Qm9keX0gICBiaVxuICogQHBhcmFtICB7Q2lyY2xlfSBzaVxuICogQHBhcmFtICB7QXJyYXl9ICB4aVxuICogQHBhcmFtICB7TnVtYmVyfSBhaVxuICogQHBhcmFtICB7Qm9keX0gICBialxuICogQHBhcmFtICB7TGluZX0gICBzalxuICogQHBhcmFtICB7QXJyYXl9ICB4alxuICogQHBhcmFtICB7TnVtYmVyfSBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuQ0FQU1VMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUNhcHN1bGUgPSBmdW5jdGlvbihiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0KXtcbiAgICByZXR1cm4gdGhpcy5jaXJjbGVMaW5lKGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3QsIHNqLnJhZGl1cyk7XG59O1xuXG4vKipcbiAqIENpcmNsZS9jb252ZXggTmFycm93cGhhc2UuXG4gKiBAbWV0aG9kIGNpcmNsZUNvbnZleFxuICogQHBhcmFtICB7Qm9keX0gY2lyY2xlQm9keVxuICogQHBhcmFtICB7Q2lyY2xlfSBjaXJjbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNpcmNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxuICogQHBhcmFtICB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqIEBwYXJhbSAge051bWJlcn0gY2lyY2xlUmFkaXVzXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVDb252ZXggPSBmdW5jdGlvbihcbiAgICBjaXJjbGVCb2R5LFxuICAgIGNpcmNsZVNoYXBlLFxuICAgIGNpcmNsZU9mZnNldCxcbiAgICBjaXJjbGVBbmdsZSxcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBqdXN0VGVzdCxcbiAgICBjaXJjbGVSYWRpdXNcbil7XG4gICAgdmFyIGNpcmNsZVJhZGl1cyA9IHR5cGVvZihjaXJjbGVSYWRpdXMpPT09XCJudW1iZXJcIiA/IGNpcmNsZVJhZGl1cyA6IGNpcmNsZVNoYXBlLnJhZGl1cztcblxuICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLFxuICAgICAgICB3b3JsZFZlcnRleDEgPSB0bXAyLFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXAzLFxuICAgICAgICB3b3JsZEVkZ2VVbml0ID0gdG1wNCxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXA1LFxuICAgICAgICBjZW50ZXJEaXN0ID0gdG1wNixcbiAgICAgICAgY29udmV4VG9DaXJjbGUgPSB0bXA3LFxuICAgICAgICBvcnRob0Rpc3QgPSB0bXA4LFxuICAgICAgICBwcm9qZWN0ZWRQb2ludCA9IHRtcDksXG4gICAgICAgIGRpc3QgPSB0bXAxMCxcbiAgICAgICAgd29ybGRWZXJ0ZXggPSB0bXAxMSxcblxuICAgICAgICBjbG9zZXN0RWRnZSA9IC0xLFxuICAgICAgICBjbG9zZXN0RWRnZURpc3RhbmNlID0gbnVsbCxcbiAgICAgICAgY2xvc2VzdEVkZ2VPcnRob0Rpc3QgPSB0bXAxMixcbiAgICAgICAgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCA9IHRtcDEzLFxuICAgICAgICBjYW5kaWRhdGUgPSB0bXAxNCxcbiAgICAgICAgY2FuZGlkYXRlRGlzdCA9IHRtcDE1LFxuICAgICAgICBtaW5DYW5kaWRhdGUgPSB0bXAxNixcblxuICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICB2YXIgbnVtUmVwb3J0ZWQgPSAwO1xuXG4gICAgLy8gTmV3IGFsZ29yaXRobTpcbiAgICAvLyAxLiBDaGVjayBzbyBjZW50ZXIgb2YgY2lyY2xlIGlzIG5vdCBpbnNpZGUgdGhlIHBvbHlnb24uIElmIGl0IGlzLCB0aGlzIHdvbnQgd29yay4uLlxuICAgIC8vIDIuIEZvciBlYWNoIGVkZ2VcbiAgICAvLyAyLiAxLiBHZXQgcG9pbnQgb24gY2lyY2xlIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgZWRnZSAoc2NhbGUgbm9ybWFsIHdpdGggLXJhZGl1cylcbiAgICAvLyAyLiAyLiBDaGVjayBpZiBwb2ludCBpcyBpbnNpZGUuXG5cbiAgICB2YXIgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcztcblxuICAgIC8vIENoZWNrIGFsbCBlZGdlcyBmaXJzdFxuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoKzE7IGkrKyl7XG4gICAgICAgIHZhciB2MCA9IHZlcnRzW2kldmVydHMubGVuZ3RoXSxcbiAgICAgICAgICAgIHYxID0gdmVydHNbKGkrMSkldmVydHMubGVuZ3RoXTtcblxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAsIHYwLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MSwgdjEsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDEsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcblxuICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xuXG4gICAgICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLiBQb2ludHMgb3V0IG9mIHRoZSBDb252ZXhcbiAgICAgICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkTm9ybWFsLCB3b3JsZEVkZ2VVbml0KTtcblxuICAgICAgICAvLyBHZXQgcG9pbnQgb24gY2lyY2xlLCBjbG9zZXN0IHRvIHRoZSBwb2x5Z29uXG4gICAgICAgIHZlYzIuc2NhbGUoY2FuZGlkYXRlLHdvcmxkTm9ybWFsLC1jaXJjbGVTaGFwZS5yYWRpdXMpO1xuICAgICAgICBhZGQoY2FuZGlkYXRlLGNhbmRpZGF0ZSxjaXJjbGVPZmZzZXQpO1xuXG4gICAgICAgIGlmKHBvaW50SW5Db252ZXgoY2FuZGlkYXRlLGNvbnZleFNoYXBlLGNvbnZleE9mZnNldCxjb252ZXhBbmdsZSkpe1xuXG4gICAgICAgICAgICB2ZWMyLnN1YihjYW5kaWRhdGVEaXN0LHdvcmxkVmVydGV4MCxjYW5kaWRhdGUpO1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZURpc3RhbmNlID0gTWF0aC5hYnModmVjMi5kb3QoY2FuZGlkYXRlRGlzdCx3b3JsZE5vcm1hbCkpO1xuXG4gICAgICAgICAgICBpZihjYW5kaWRhdGVEaXN0YW5jZSA8IG1pbkNhbmRpZGF0ZURpc3RhbmNlKXtcbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkobWluQ2FuZGlkYXRlLGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgbWluQ2FuZGlkYXRlRGlzdGFuY2UgPSBjYW5kaWRhdGVEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsd29ybGROb3JtYWwsY2FuZGlkYXRlRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIHZlYzIuYWRkKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCxjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGZvdW5kKXtcblxuICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxjb252ZXhCb2R5LGNpcmNsZVNoYXBlLGNvbnZleFNoYXBlKTtcbiAgICAgICAgdmVjMi5zdWIoYy5ub3JtYWxBLCBtaW5DYW5kaWRhdGUsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcblxuICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QSwgIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCggdGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBhbGwgdmVydGljZXNcbiAgICBpZihjaXJjbGVSYWRpdXMgPiAwKXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGxvY2FsVmVydGV4ID0gdmVydHNbaV07XG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleCwgbG9jYWxWZXJ0ZXgsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgICAgIGFkZCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA8IE1hdGgucG93KGNpcmNsZVJhZGl1cywgMikpe1xuXG4gICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksY29udmV4Qm9keSxjaXJjbGVTaGFwZSxjb252ZXhTaGFwZSk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcbiAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50Qiwgd29ybGRWZXJ0ZXgsIGNvbnZleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4Qm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xufTtcblxudmFyIHBpY193b3JsZFZlcnRleDAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBpY193b3JsZFZlcnRleDEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBpY19yMCA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGljX3IxID0gdmVjMi5jcmVhdGUoKTtcblxuLypcbiAqIENoZWNrIGlmIGEgcG9pbnQgaXMgaW4gYSBwb2x5Z29uXG4gKi9cbmZ1bmN0aW9uIHBvaW50SW5Db252ZXgod29ybGRQb2ludCxjb252ZXhTaGFwZSxjb252ZXhPZmZzZXQsY29udmV4QW5nbGUpe1xuICAgIHZhciB3b3JsZFZlcnRleDAgPSBwaWNfd29ybGRWZXJ0ZXgwLFxuICAgICAgICB3b3JsZFZlcnRleDEgPSBwaWNfd29ybGRWZXJ0ZXgxLFxuICAgICAgICByMCA9IHBpY19yMCxcbiAgICAgICAgcjEgPSBwaWNfcjEsXG4gICAgICAgIHBvaW50ID0gd29ybGRQb2ludCxcbiAgICAgICAgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcyxcbiAgICAgICAgbGFzdENyb3NzID0gbnVsbDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PXZlcnRzLmxlbmd0aCsxOyBpKyspe1xuICAgICAgICB2YXIgdjAgPSB2ZXJ0c1tpJXZlcnRzLmxlbmd0aF0sXG4gICAgICAgICAgICB2MSA9IHZlcnRzWyhpKzEpJXZlcnRzLmxlbmd0aF07XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIHZlcnRpY2VzIHRvIHdvcmxkXG4gICAgICAgIC8vIEB0b2RvIFRoZSBwb2ludCBzaG91bGQgYmUgdHJhbnNmb3JtZWQgdG8gbG9jYWwgY29vcmRpbmF0ZXMgaW4gdGhlIGNvbnZleCwgbm8gbmVlZCB0byB0cmFuc2Zvcm0gZWFjaCB2ZXJ0ZXhcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwLCB2MCwgY29udmV4QW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDEsIHYxLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDAsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgxLCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIHN1YihyMCwgd29ybGRWZXJ0ZXgwLCBwb2ludCk7XG4gICAgICAgIHN1YihyMSwgd29ybGRWZXJ0ZXgxLCBwb2ludCk7XG4gICAgICAgIHZhciBjcm9zcyA9IHZlYzIuY3Jvc3NMZW5ndGgocjAscjEpO1xuXG4gICAgICAgIGlmKGxhc3RDcm9zcz09PW51bGwpe1xuICAgICAgICAgICAgbGFzdENyb3NzID0gY3Jvc3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBnb3QgYSBkaWZmZXJlbnQgc2lnbiBvZiB0aGUgZGlzdGFuY2UgdmVjdG9yLCB0aGUgcG9pbnQgaXMgb3V0IG9mIHRoZSBwb2x5Z29uXG4gICAgICAgIGlmKGNyb3NzKmxhc3RDcm9zcyA8PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Q3Jvc3MgPSBjcm9zcztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUGFydGljbGUvY29udmV4IE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIHBhcnRpY2xlQ29udmV4XG4gKiBAcGFyYW0gIHtCb2R5fSBwYXJ0aWNsZUJvZHlcbiAqIEBwYXJhbSAge1BhcnRpY2xlfSBwYXJ0aWNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGFydGljbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGFydGljbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxuICogQHRvZG8gdXNlIHBvaW50SW5Db252ZXggYW5kIGNvZGUgbW9yZSBzaW1pbGFyIHRvIGNpcmNsZUNvbnZleFxuICogQHRvZG8gZG9uJ3QgdHJhbnNmb3JtIGVhY2ggdmVydGV4LCBidXQgdHJhbnNmb3JtIHRoZSBwYXJ0aWNsZSBwb3NpdGlvbiB0byBjb252ZXgtbG9jYWwgaW5zdGVhZFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUEFSVElDTEUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLlJFQ1RBTkdMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBhcnRpY2xlQ29udmV4ID0gZnVuY3Rpb24oXG4gICAgcGFydGljbGVCb2R5LFxuICAgIHBhcnRpY2xlU2hhcGUsXG4gICAgcGFydGljbGVPZmZzZXQsXG4gICAgcGFydGljbGVBbmdsZSxcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgd29ybGRWZXJ0ZXgwID0gdG1wMSxcbiAgICAgICAgd29ybGRWZXJ0ZXgxID0gdG1wMixcbiAgICAgICAgd29ybGRFZGdlID0gdG1wMyxcbiAgICAgICAgd29ybGRFZGdlVW5pdCA9IHRtcDQsXG4gICAgICAgIHdvcmxkVGFuZ2VudCA9IHRtcDUsXG4gICAgICAgIGNlbnRlckRpc3QgPSB0bXA2LFxuICAgICAgICBjb252ZXhUb3BhcnRpY2xlID0gdG1wNyxcbiAgICAgICAgb3J0aG9EaXN0ID0gdG1wOCxcbiAgICAgICAgcHJvamVjdGVkUG9pbnQgPSB0bXA5LFxuICAgICAgICBkaXN0ID0gdG1wMTAsXG4gICAgICAgIHdvcmxkVmVydGV4ID0gdG1wMTEsXG4gICAgICAgIGNsb3Nlc3RFZGdlID0gLTEsXG4gICAgICAgIGNsb3Nlc3RFZGdlRGlzdGFuY2UgPSBudWxsLFxuICAgICAgICBjbG9zZXN0RWRnZU9ydGhvRGlzdCA9IHRtcDEyLFxuICAgICAgICBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50ID0gdG1wMTMsXG4gICAgICAgIHIwID0gdG1wMTQsIC8vIHZlY3RvciBmcm9tIHBhcnRpY2xlIHRvIHZlcnRleDBcbiAgICAgICAgcjEgPSB0bXAxNSxcbiAgICAgICAgbG9jYWxQb2ludCA9IHRtcDE2LFxuICAgICAgICBjYW5kaWRhdGVEaXN0ID0gdG1wMTcsXG4gICAgICAgIG1pbkVkZ2VOb3JtYWwgPSB0bXAxOCxcbiAgICAgICAgbWluQ2FuZGlkYXRlRGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgdmFyIG51bVJlcG9ydGVkID0gMCxcbiAgICAgICAgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcztcblxuICAgIC8vIENoZWNrIGlmIHRoZSBwYXJ0aWNsZSBpcyBpbiB0aGUgcG9seWdvbiBhdCBhbGxcbiAgICBpZighcG9pbnRJbkNvbnZleChwYXJ0aWNsZU9mZnNldCxjb252ZXhTaGFwZSxjb252ZXhPZmZzZXQsY29udmV4QW5nbGUpKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBlZGdlcyBmaXJzdFxuICAgIHZhciBsYXN0Q3Jvc3MgPSBudWxsO1xuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoKzE7IGkrKyl7XG4gICAgICAgIHZhciB2MCA9IHZlcnRzW2kldmVydHMubGVuZ3RoXSxcbiAgICAgICAgICAgIHYxID0gdmVydHNbKGkrMSkldmVydHMubGVuZ3RoXTtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gdmVydGljZXMgdG8gd29ybGRcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwLCB2MCwgY29udmV4QW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDEsIHYxLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDAsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgxLCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIC8vIEdldCB3b3JsZCBlZGdlXG4gICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUod29ybGRFZGdlVW5pdCwgd29ybGRFZGdlKTtcblxuICAgICAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS4gUG9pbnRzIG91dCBvZiB0aGUgQ29udmV4XG4gICAgICAgIHZlYzIucm90YXRlOTBjdyh3b3JsZFRhbmdlbnQsIHdvcmxkRWRnZVVuaXQpO1xuXG4gICAgICAgIC8vIENoZWNrIGRpc3RhbmNlIGZyb20gdGhlIGluZmluaXRlIGxpbmUgKHNwYW5uZWQgYnkgdGhlIGVkZ2UpIHRvIHRoZSBwYXJ0aWNsZVxuICAgICAgICBzdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIHdvcmxkVmVydGV4MCk7XG4gICAgICAgIHZhciBkID0gZG90KGRpc3QsIHdvcmxkVGFuZ2VudCk7XG4gICAgICAgIHN1YihjZW50ZXJEaXN0LCB3b3JsZFZlcnRleDAsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgc3ViKGNvbnZleFRvcGFydGljbGUsIHBhcnRpY2xlT2Zmc2V0LCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIHZlYzIuc3ViKGNhbmRpZGF0ZURpc3Qsd29ybGRWZXJ0ZXgwLHBhcnRpY2xlT2Zmc2V0KTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZURpc3RhbmNlID0gTWF0aC5hYnModmVjMi5kb3QoY2FuZGlkYXRlRGlzdCx3b3JsZFRhbmdlbnQpKTtcblxuICAgICAgICBpZihjYW5kaWRhdGVEaXN0YW5jZSA8IG1pbkNhbmRpZGF0ZURpc3RhbmNlKXtcbiAgICAgICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gY2FuZGlkYXRlRGlzdGFuY2U7XG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsd29ybGRUYW5nZW50LGNhbmRpZGF0ZURpc3RhbmNlKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCxwYXJ0aWNsZU9mZnNldCk7XG4gICAgICAgICAgICB2ZWMyLmNvcHkobWluRWRnZU5vcm1hbCx3b3JsZFRhbmdlbnQpO1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZm91bmQpe1xuICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBhcnRpY2xlQm9keSxjb252ZXhCb2R5LHBhcnRpY2xlU2hhcGUsY29udmV4U2hhcGUpO1xuXG4gICAgICAgIHZlYzIuc2NhbGUoYy5ub3JtYWxBLCBtaW5FZGdlTm9ybWFsLCAtMSk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcblxuICAgICAgICAvLyBQYXJ0aWNsZSBoYXMgbm8gZXh0ZW50IHRvIHRoZSBjb250YWN0IHBvaW50XG4gICAgICAgIHZlYzIuc2V0KGMuY29udGFjdFBvaW50QSwgIDAsIDApO1xuICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBhcnRpY2xlT2Zmc2V0KTtcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgIC8vIEZyb20gY29udmV4IGNlbnRlciB0byBwb2ludFxuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4Qm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG5cbiAgICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQ2lyY2xlL2NpcmNsZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjaXJjbGVDaXJjbGVcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtDaXJjbGV9IHNoYXBlQVxuICogQHBhcmFtICB7QXJyYXl9IG9mZnNldEFcbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHBhcmFtICB7Q2lyY2xlfSBzaGFwZUJcbiAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRCXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlQlxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXNBXSBPcHRpb25hbCByYWRpdXMgdG8gdXNlIGZvciBzaGFwZUFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzQl0gT3B0aW9uYWwgcmFkaXVzIHRvIHVzZSBmb3Igc2hhcGVCXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVDaXJjbGUgPSBmdW5jdGlvbihcbiAgICBib2R5QSxcbiAgICBzaGFwZUEsXG4gICAgb2Zmc2V0QSxcbiAgICBhbmdsZUEsXG4gICAgYm9keUIsXG4gICAgc2hhcGVCLFxuICAgIG9mZnNldEIsXG4gICAgYW5nbGVCLFxuICAgIGp1c3RUZXN0LFxuICAgIHJhZGl1c0EsXG4gICAgcmFkaXVzQlxuKXtcblxuICAgIHZhciBkaXN0ID0gdG1wMSxcbiAgICAgICAgcmFkaXVzQSA9IHJhZGl1c0EgfHwgc2hhcGVBLnJhZGl1cyxcbiAgICAgICAgcmFkaXVzQiA9IHJhZGl1c0IgfHwgc2hhcGVCLnJhZGl1cztcblxuICAgIHN1YihkaXN0LG9mZnNldEEsb2Zmc2V0Qik7XG4gICAgdmFyIHIgPSByYWRpdXNBICsgcmFkaXVzQjtcbiAgICBpZih2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCkgPiBNYXRoLnBvdyhyLDIpKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCLHNoYXBlQSxzaGFwZUIpO1xuICAgIHN1YihjLm5vcm1hbEEsIG9mZnNldEIsIG9mZnNldEEpO1xuICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgdmVjMi5zY2FsZSggYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsICByYWRpdXNBKTtcbiAgICB2ZWMyLnNjYWxlKCBjLmNvbnRhY3RQb2ludEIsIGMubm9ybWFsQSwgLXJhZGl1c0IpO1xuXG4gICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBvZmZzZXRBKTtcbiAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGJvZHlBLnBvc2l0aW9uKTtcblxuICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50Qiwgb2Zmc2V0Qik7XG4gICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBib2R5Qi5wb3NpdGlvbik7XG5cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIFBsYW5lL0NvbnZleCBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBwbGFuZUNvbnZleFxuICogQHBhcmFtICB7Qm9keX0gcGxhbmVCb2R5XG4gKiBAcGFyYW0gIHtQbGFuZX0gcGxhbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IHBsYW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNvbnZleEJvZHlcbiAqIEBwYXJhbSAge0NvbnZleH0gY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjb252ZXhPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY29udmV4QW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuQ09OVkVYXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUNvbnZleCA9IGZ1bmN0aW9uKFxuICAgIHBsYW5lQm9keSxcbiAgICBwbGFuZVNoYXBlLFxuICAgIHBsYW5lT2Zmc2V0LFxuICAgIHBsYW5lQW5nbGUsXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhPZmZzZXQsXG4gICAgY29udmV4QW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgdmFyIHdvcmxkVmVydGV4ID0gdG1wMSxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXAyLFxuICAgICAgICBkaXN0ID0gdG1wMztcblxuICAgIHZhciBudW1SZXBvcnRlZCA9IDA7XG4gICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09Y29udmV4U2hhcGUudmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IGNvbnZleFNoYXBlLnZlcnRpY2VzW2ldO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleCwgdiwgY29udmV4QW5nbGUpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4LCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgcGxhbmVPZmZzZXQpO1xuXG4gICAgICAgIGlmKGRvdChkaXN0LHdvcmxkTm9ybWFsKSA8PSAwKXtcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3VuZCB2ZXJ0ZXhcbiAgICAgICAgICAgIG51bVJlcG9ydGVkKys7XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LGNvbnZleEJvZHkscGxhbmVTaGFwZSxjb252ZXhTaGFwZSk7XG5cbiAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgcGxhbmVPZmZzZXQpO1xuXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgICAgIHZhciBkID0gZG90KGRpc3QsIGMubm9ybWFsQSk7XG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGRpc3QsIGMubm9ybWFsQSwgZCk7XG5cbiAgICAgICAgICAgIC8vIHJqIGlzIGZyb20gY29udmV4IGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB3b3JsZFZlcnRleCwgY29udmV4Qm9keS5wb3NpdGlvbik7XG5cblxuICAgICAgICAgICAgLy8gcmkgaXMgZnJvbSBwbGFuZSBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgc3ViKCBjLmNvbnRhY3RQb2ludEEsIHdvcmxkVmVydGV4LCBkaXN0KTtcbiAgICAgICAgICAgIHN1YiggYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uICYmIG51bVJlcG9ydGVkKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtUmVwb3J0ZWQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1SZXBvcnRlZDtcbn07XG5cbi8qKlxuICogTmFycm93cGhhc2UgZm9yIHBhcnRpY2xlIHZzIHBsYW5lXG4gKiBAbWV0aG9kIHBhcnRpY2xlUGxhbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHBhcnRpY2xlQm9keVxuICogQHBhcmFtICB7UGFydGljbGV9ICAgcGFydGljbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcGFydGljbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIHBhcnRpY2xlQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHBsYW5lQm9keVxuICogQHBhcmFtICB7UGxhbmV9ICAgICAgcGxhbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcGxhbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIHBsYW5lQW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgIGp1c3RUZXN0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLlBMQU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGFydGljbGVQbGFuZSA9IGZ1bmN0aW9uKFxuICAgIHBhcnRpY2xlQm9keSxcbiAgICBwYXJ0aWNsZVNoYXBlLFxuICAgIHBhcnRpY2xlT2Zmc2V0LFxuICAgIHBhcnRpY2xlQW5nbGUsXG4gICAgcGxhbmVCb2R5LFxuICAgIHBsYW5lU2hhcGUsXG4gICAgcGxhbmVPZmZzZXQsXG4gICAgcGxhbmVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgZGlzdCA9IHRtcDEsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wMjtcblxuICAgIHBsYW5lQW5nbGUgPSBwbGFuZUFuZ2xlIHx8IDA7XG5cbiAgICBzdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIHBsYW5lT2Zmc2V0KTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xuXG4gICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGROb3JtYWwpO1xuXG4gICAgaWYoZCA+IDApe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSxwYXJ0aWNsZUJvZHkscGxhbmVTaGFwZSxwYXJ0aWNsZVNoYXBlKTtcblxuICAgIHZlYzIuY29weShjLm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcbiAgICB2ZWMyLnNjYWxlKCBkaXN0LCBjLm5vcm1hbEEsIGQgKTtcbiAgICAvLyBkaXN0IGlzIG5vdyB0aGUgZGlzdGFuY2UgdmVjdG9yIGluIHRoZSBub3JtYWwgZGlyZWN0aW9uXG5cbiAgICAvLyByaSBpcyB0aGUgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIGRvd24gb250byB0aGUgcGxhbmUsIGZyb20gdGhlIHBsYW5lIGNlbnRlclxuICAgIHN1YiggYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZU9mZnNldCwgZGlzdCk7XG4gICAgc3ViKCBjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgIC8vIHJqIGlzIGZyb20gdGhlIGJvZHkgY2VudGVyIHRvIHRoZSBwYXJ0aWNsZSBjZW50ZXJcbiAgICBzdWIoIGMuY29udGFjdFBvaW50QiwgcGFydGljbGVPZmZzZXQsIHBhcnRpY2xlQm9keS5wb3NpdGlvbiApO1xuXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvUGFydGljbGUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2lyY2xlUGFydGljbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNpcmNsZUJvZHlcbiAqIEBwYXJhbSAge0NpcmNsZX0gY2lyY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjaXJjbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY2lyY2xlQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IHBhcnRpY2xlQm9keVxuICogQHBhcmFtICB7UGFydGljbGV9IHBhcnRpY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBwYXJ0aWNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwYXJ0aWNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb29sZWFufSBqdXN0VGVzdFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuUEFSVElDTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVQYXJ0aWNsZSA9IGZ1bmN0aW9uKFxuICAgIGNpcmNsZUJvZHksXG4gICAgY2lyY2xlU2hhcGUsXG4gICAgY2lyY2xlT2Zmc2V0LFxuICAgIGNpcmNsZUFuZ2xlLFxuICAgIHBhcnRpY2xlQm9keSxcbiAgICBwYXJ0aWNsZVNoYXBlLFxuICAgIHBhcnRpY2xlT2Zmc2V0LFxuICAgIHBhcnRpY2xlQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgdmFyIGRpc3QgPSB0bXAxO1xuXG4gICAgc3ViKGRpc3QsIHBhcnRpY2xlT2Zmc2V0LCBjaXJjbGVPZmZzZXQpO1xuICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA+IE1hdGgucG93KGNpcmNsZVNoYXBlLnJhZGl1cywgMikpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHkscGFydGljbGVCb2R5LGNpcmNsZVNoYXBlLHBhcnRpY2xlU2hhcGUpO1xuICAgIHZlYzIuY29weShjLm5vcm1hbEEsIGRpc3QpO1xuICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgLy8gVmVjdG9yIGZyb20gY2lyY2xlIHRvIGNvbnRhY3QgcG9pbnQgaXMgdGhlIG5vcm1hbCB0aW1lcyB0aGUgY2lyY2xlIHJhZGl1c1xuICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsIGNpcmNsZVNoYXBlLnJhZGl1cyk7XG4gICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAvLyBWZWN0b3IgZnJvbSBwYXJ0aWNsZSBjZW50ZXIgdG8gY29udGFjdCBwb2ludCBpcyB6ZXJvXG4gICAgc3ViKGMuY29udGFjdFBvaW50QiwgcGFydGljbGVPZmZzZXQsIHBhcnRpY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbn07XG5cbnZhciBwbGFuZUNhcHN1bGVfdG1wQ2lyY2xlID0gbmV3IENpcmNsZSgxKSxcbiAgICBwbGFuZUNhcHN1bGVfdG1wMSA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGxhbmVDYXBzdWxlX3RtcDIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBsYW5lQ2Fwc3VsZV90bXAzID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHBsYW5lQ2Fwc3VsZVxuICogQHBhcmFtICB7Qm9keX0gcGxhbmVCb2R5XG4gKiBAcGFyYW0gIHtDaXJjbGV9IHBsYW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBwbGFuZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwbGFuZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjYXBzdWxlQm9keVxuICogQHBhcmFtICB7UGFydGljbGV9IGNhcHN1bGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNhcHN1bGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY2Fwc3VsZUFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkNBUFNVTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUNhcHN1bGUgPSBmdW5jdGlvbihcbiAgICBwbGFuZUJvZHksXG4gICAgcGxhbmVTaGFwZSxcbiAgICBwbGFuZU9mZnNldCxcbiAgICBwbGFuZUFuZ2xlLFxuICAgIGNhcHN1bGVCb2R5LFxuICAgIGNhcHN1bGVTaGFwZSxcbiAgICBjYXBzdWxlT2Zmc2V0LFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgZW5kMSA9IHBsYW5lQ2Fwc3VsZV90bXAxLFxuICAgICAgICBlbmQyID0gcGxhbmVDYXBzdWxlX3RtcDIsXG4gICAgICAgIGNpcmNsZSA9IHBsYW5lQ2Fwc3VsZV90bXBDaXJjbGUsXG4gICAgICAgIGRzdCA9IHBsYW5lQ2Fwc3VsZV90bXAzO1xuXG4gICAgLy8gQ29tcHV0ZSB3b3JsZCBlbmQgcG9zaXRpb25zXG4gICAgdmVjMi5zZXQoZW5kMSwgLWNhcHN1bGVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5yb3RhdGUoZW5kMSxlbmQxLGNhcHN1bGVBbmdsZSk7XG4gICAgYWRkKGVuZDEsZW5kMSxjYXBzdWxlT2Zmc2V0KTtcblxuICAgIHZlYzIuc2V0KGVuZDIsICBjYXBzdWxlU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIucm90YXRlKGVuZDIsZW5kMixjYXBzdWxlQW5nbGUpO1xuICAgIGFkZChlbmQyLGVuZDIsY2Fwc3VsZU9mZnNldCk7XG5cbiAgICBjaXJjbGUucmFkaXVzID0gY2Fwc3VsZVNoYXBlLnJhZGl1cztcblxuICAgIHZhciBlbmFibGVGcmljdGlvbkJlZm9yZTtcblxuICAgIC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIERvIE5hcnJvd3BoYXNlIGFzIHR3byBjaXJjbGVzXG4gICAgdmFyIG51bUNvbnRhY3RzMSA9IHRoaXMuY2lyY2xlUGxhbmUoY2Fwc3VsZUJvZHksY2lyY2xlLGVuZDEsMCwgcGxhbmVCb2R5LHBsYW5lU2hhcGUscGxhbmVPZmZzZXQscGxhbmVBbmdsZSwganVzdFRlc3QpLFxuICAgICAgICBudW1Db250YWN0czIgPSB0aGlzLmNpcmNsZVBsYW5lKGNhcHN1bGVCb2R5LGNpcmNsZSxlbmQyLDAsIHBsYW5lQm9keSxwbGFuZVNoYXBlLHBsYW5lT2Zmc2V0LHBsYW5lQW5nbGUsIGp1c3RUZXN0KTtcblxuICAgIC8vIFJlc3RvcmUgZnJpY3Rpb25cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIG51bUNvbnRhY3RzMSB8fCBudW1Db250YWN0czI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG51bVRvdGFsID0gbnVtQ29udGFjdHMxICsgbnVtQ29udGFjdHMyO1xuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgIGlmKG51bVRvdGFsKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bVRvdGFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bVRvdGFsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBDb250YWN0RXF1YXRpb25zIGFuZCBGcmljdGlvbkVxdWF0aW9ucyBmb3IgYSBjb2xsaXNpb24uXG4gKiBAbWV0aG9kIGNpcmNsZVBsYW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgICBiaSAgICAgVGhlIGZpcnN0IGJvZHkgdGhhdCBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBlcXVhdGlvbnMuXG4gKiBAcGFyYW0gIHtDaXJjbGV9ICBzaSAgICAgVGhlIGNpcmNsZSBzaGFwZSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb2xsaXNpb24uXG4gKiBAcGFyYW0gIHtBcnJheX0gICB4aSAgICAgRXh0cmEgb2Zmc2V0IHRvIHRha2UgaW50byBhY2NvdW50IGZvciB0aGUgU2hhcGUsIGluIGFkZGl0aW9uIHRvIHRoZSBvbmUgaW4gY2lyY2xlQm9keS5wb3NpdGlvbi4gV2lsbCAqbm90KiBiZSByb3RhdGVkIGJ5IGNpcmNsZUJvZHkuYW5nbGUgKG1heWJlIGl0IHNob3VsZCwgZm9yIHNha2Ugb2YgaG9tb2dlbml0eT8pLiBTZXQgdG8gbnVsbCBpZiBub25lLlxuICogQHBhcmFtICB7Qm9keX0gICAgYmogICAgIFRoZSBzZWNvbmQgYm9keSB0aGF0IHNob3VsZCBiZSBjb25uZWN0ZWQgdG8gdGhlIGVxdWF0aW9ucy5cbiAqIEBwYXJhbSAge1BsYW5lfSAgIHNqICAgICBUaGUgUGxhbmUgc2hhcGUgdGhhdCBpcyBwYXJ0aWNpcGF0aW5nXG4gKiBAcGFyYW0gIHtBcnJheX0gICB4aiAgICAgRXh0cmEgb2Zmc2V0IGZvciB0aGUgcGxhbmUgc2hhcGUuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBhaiAgICAgRXh0cmEgYW5nbGUgdG8gYXBwbHkgdG8gdGhlIHBsYW5lXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5QTEFORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZVBsYW5lID0gZnVuY3Rpb24oICAgYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCApe1xuICAgIHZhciBjaXJjbGVCb2R5ID0gYmksXG4gICAgICAgIGNpcmNsZVNoYXBlID0gc2ksXG4gICAgICAgIGNpcmNsZU9mZnNldCA9IHhpLCAvLyBPZmZzZXQgZnJvbSBib2R5IGNlbnRlciwgcm90YXRlZCFcbiAgICAgICAgcGxhbmVCb2R5ID0gYmosXG4gICAgICAgIHNoYXBlQiA9IHNqLFxuICAgICAgICBwbGFuZU9mZnNldCA9IHhqLFxuICAgICAgICBwbGFuZUFuZ2xlID0gYWo7XG5cbiAgICBwbGFuZUFuZ2xlID0gcGxhbmVBbmdsZSB8fCAwO1xuXG4gICAgLy8gVmVjdG9yIGZyb20gcGxhbmUgdG8gY2lyY2xlXG4gICAgdmFyIHBsYW5lVG9DaXJjbGUgPSB0bXAxLFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDIsXG4gICAgICAgIHRlbXAgPSB0bXAzO1xuXG4gICAgc3ViKHBsYW5lVG9DaXJjbGUsIGNpcmNsZU9mZnNldCwgcGxhbmVPZmZzZXQpO1xuXG4gICAgLy8gV29ybGQgcGxhbmUgbm9ybWFsXG4gICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcblxuICAgIC8vIE5vcm1hbCBkaXJlY3Rpb24gZGlzdGFuY2VcbiAgICB2YXIgZCA9IGRvdCh3b3JsZE5vcm1hbCwgcGxhbmVUb0NpcmNsZSk7XG5cbiAgICBpZihkID4gY2lyY2xlU2hhcGUucmFkaXVzKXtcbiAgICAgICAgcmV0dXJuIDA7IC8vIE5vIG92ZXJsYXAuIEFib3J0LlxuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGNvbnRhY3RcbiAgICB2YXIgY29udGFjdCA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSxjaXJjbGVCb2R5LHNqLHNpKTtcblxuICAgIC8vIG5pIGlzIHRoZSBwbGFuZSB3b3JsZCBub3JtYWxcbiAgICB2ZWMyLmNvcHkoY29udGFjdC5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XG5cbiAgICAvLyByaiBpcyB0aGUgdmVjdG9yIGZyb20gY2lyY2xlIGNlbnRlciB0byB0aGUgY29udGFjdCBwb2ludFxuICAgIHZlYzIuc2NhbGUoY29udGFjdC5jb250YWN0UG9pbnRCLCBjb250YWN0Lm5vcm1hbEEsIC1jaXJjbGVTaGFwZS5yYWRpdXMpO1xuICAgIGFkZChjb250YWN0LmNvbnRhY3RQb2ludEIsIGNvbnRhY3QuY29udGFjdFBvaW50QiwgY2lyY2xlT2Zmc2V0KTtcbiAgICBzdWIoY29udGFjdC5jb250YWN0UG9pbnRCLCBjb250YWN0LmNvbnRhY3RQb2ludEIsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgLy8gcmkgaXMgdGhlIGRpc3RhbmNlIGZyb20gcGxhbmUgY2VudGVyIHRvIGNvbnRhY3QuXG4gICAgdmVjMi5zY2FsZSh0ZW1wLCBjb250YWN0Lm5vcm1hbEEsIGQpO1xuICAgIHN1Yihjb250YWN0LmNvbnRhY3RQb2ludEEsIHBsYW5lVG9DaXJjbGUsIHRlbXAgKTsgLy8gU3VidHJhY3Qgbm9ybWFsIGRpc3RhbmNlIHZlY3RvciBmcm9tIHRoZSBkaXN0YW5jZSB2ZWN0b3JcbiAgICBhZGQoY29udGFjdC5jb250YWN0UG9pbnRBLCBjb250YWN0LmNvbnRhY3RQb2ludEEsIHBsYW5lT2Zmc2V0KTtcbiAgICBzdWIoY29udGFjdC5jb250YWN0UG9pbnRBLCBjb250YWN0LmNvbnRhY3RQb2ludEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjb250YWN0KTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjb250YWN0KSApO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBDb252ZXgvY29udmV4IE5hcnJvd3BoYXNlLlNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy5hbHRkZXZibG9nYWRheS5jb20vMjAxMS8wNS8xMy9jb250YWN0LWdlbmVyYXRpb24tYmV0d2Vlbi0zZC1jb252ZXgtbWVzaGVzL1wiPnRoaXMgYXJ0aWNsZTwvYT4gZm9yIG1vcmUgaW5mby5cbiAqIEBtZXRob2QgY29udmV4Q29udmV4XG4gKiBAcGFyYW0gIHtCb2R5fSBiaVxuICogQHBhcmFtICB7Q29udmV4fSBzaVxuICogQHBhcmFtICB7QXJyYXl9IHhpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFpXG4gKiBAcGFyYW0gIHtCb2R5fSBialxuICogQHBhcmFtICB7Q29udmV4fSBzalxuICogQHBhcmFtICB7QXJyYXl9IHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVggfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhDb252ZXggPSBmdW5jdGlvbiggIGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3QsIHByZWNpc2lvbiApe1xuICAgIHZhciBzZXBBeGlzID0gdG1wMSxcbiAgICAgICAgd29ybGRQb2ludCA9IHRtcDIsXG4gICAgICAgIHdvcmxkUG9pbnQwID0gdG1wMyxcbiAgICAgICAgd29ybGRQb2ludDEgPSB0bXA0LFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXA1LFxuICAgICAgICBwcm9qZWN0ZWQgPSB0bXA2LFxuICAgICAgICBwZW5ldHJhdGlvblZlYyA9IHRtcDcsXG4gICAgICAgIGRpc3QgPSB0bXA4LFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDksXG4gICAgICAgIG51bUNvbnRhY3RzID0gMCxcbiAgICAgICAgcHJlY2lzaW9uID0gdHlwZW9mKHByZWNpc2lvbikgPT09ICdudW1iZXInID8gcHJlY2lzaW9uIDogMDtcblxuICAgIHZhciBmb3VuZCA9IE5hcnJvd3BoYXNlLmZpbmRTZXBhcmF0aW5nQXhpcyhzaSx4aSxhaSxzaix4aixhaixzZXBBeGlzKTtcbiAgICBpZighZm91bmQpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIHNlcGFyYXRpbmcgYXhpcyBpcyBkaXJlY3RlZCBmcm9tIHNoYXBlIGkgdG8gc2hhcGUgalxuICAgIHN1YihkaXN0LHhqLHhpKTtcbiAgICBpZihkb3Qoc2VwQXhpcyxkaXN0KSA+IDApe1xuICAgICAgICB2ZWMyLnNjYWxlKHNlcEF4aXMsc2VwQXhpcywtMSk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBlZGdlcyB3aXRoIG5vcm1hbHMgY2xvc2VzdCB0byB0aGUgc2VwYXJhdGluZyBheGlzXG4gICAgdmFyIGNsb3Nlc3RFZGdlMSA9IE5hcnJvd3BoYXNlLmdldENsb3Nlc3RFZGdlKHNpLGFpLHNlcEF4aXMsdHJ1ZSksIC8vIEZsaXBwZWQgYXhpc1xuICAgICAgICBjbG9zZXN0RWRnZTIgPSBOYXJyb3dwaGFzZS5nZXRDbG9zZXN0RWRnZShzaixhaixzZXBBeGlzKTtcblxuICAgIGlmKGNsb3Nlc3RFZGdlMSA9PT0gLTEgfHwgY2xvc2VzdEVkZ2UyID09PSAtMSl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIExvb3Agb3ZlciB0aGUgc2hhcGVzXG4gICAgZm9yKHZhciBrPTA7IGs8MjsgaysrKXtcblxuICAgICAgICB2YXIgY2xvc2VzdEVkZ2VBID0gY2xvc2VzdEVkZ2UxLFxuICAgICAgICAgICAgY2xvc2VzdEVkZ2VCID0gY2xvc2VzdEVkZ2UyLFxuICAgICAgICAgICAgc2hhcGVBID0gIHNpLCBzaGFwZUIgPSAgc2osXG4gICAgICAgICAgICBvZmZzZXRBID0geGksIG9mZnNldEIgPSB4aixcbiAgICAgICAgICAgIGFuZ2xlQSA9IGFpLCBhbmdsZUIgPSBhaixcbiAgICAgICAgICAgIGJvZHlBID0gYmksIGJvZHlCID0gYmo7XG5cbiAgICAgICAgaWYoayA9PT0gMCl7XG4gICAgICAgICAgICAvLyBTd2FwIVxuICAgICAgICAgICAgdmFyIHRtcDtcbiAgICAgICAgICAgIHRtcCA9IGNsb3Nlc3RFZGdlQTtcbiAgICAgICAgICAgIGNsb3Nlc3RFZGdlQSA9IGNsb3Nlc3RFZGdlQjtcbiAgICAgICAgICAgIGNsb3Nlc3RFZGdlQiA9IHRtcDtcblxuICAgICAgICAgICAgdG1wID0gc2hhcGVBO1xuICAgICAgICAgICAgc2hhcGVBID0gc2hhcGVCO1xuICAgICAgICAgICAgc2hhcGVCID0gdG1wO1xuXG4gICAgICAgICAgICB0bXAgPSBvZmZzZXRBO1xuICAgICAgICAgICAgb2Zmc2V0QSA9IG9mZnNldEI7XG4gICAgICAgICAgICBvZmZzZXRCID0gdG1wO1xuXG4gICAgICAgICAgICB0bXAgPSBhbmdsZUE7XG4gICAgICAgICAgICBhbmdsZUEgPSBhbmdsZUI7XG4gICAgICAgICAgICBhbmdsZUIgPSB0bXA7XG5cbiAgICAgICAgICAgIHRtcCA9IGJvZHlBO1xuICAgICAgICAgICAgYm9keUEgPSBib2R5QjtcbiAgICAgICAgICAgIGJvZHlCID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIDIgcG9pbnRzIGluIGNvbnZleCBCXG4gICAgICAgIGZvcih2YXIgaj1jbG9zZXN0RWRnZUI7IGo8Y2xvc2VzdEVkZ2VCKzI7IGorKyl7XG5cbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBwb2ludFxuICAgICAgICAgICAgdmFyIHYgPSBzaGFwZUIudmVydGljZXNbKGorc2hhcGVCLnZlcnRpY2VzLmxlbmd0aCklc2hhcGVCLnZlcnRpY2VzLmxlbmd0aF07XG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50LCB2LCBhbmdsZUIpO1xuICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQsIHdvcmxkUG9pbnQsIG9mZnNldEIpO1xuXG4gICAgICAgICAgICB2YXIgaW5zaWRlTnVtRWRnZXMgPSAwO1xuXG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgdGhlIDMgY2xvc2VzdCBlZGdlcyBpbiBjb252ZXggQVxuICAgICAgICAgICAgZm9yKHZhciBpPWNsb3Nlc3RFZGdlQS0xOyBpPGNsb3Nlc3RFZGdlQSsyOyBpKyspe1xuXG4gICAgICAgICAgICAgICAgdmFyIHYwID0gc2hhcGVBLnZlcnRpY2VzWyhpICArc2hhcGVBLnZlcnRpY2VzLmxlbmd0aCklc2hhcGVBLnZlcnRpY2VzLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgICAgIHYxID0gc2hhcGVBLnZlcnRpY2VzWyhpKzErc2hhcGVBLnZlcnRpY2VzLmxlbmd0aCklc2hhcGVBLnZlcnRpY2VzLmxlbmd0aF07XG5cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MCwgdjAsIGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDEsIHYxLCBhbmdsZUEpO1xuICAgICAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50MCwgd29ybGRQb2ludDAsIG9mZnNldEEpO1xuICAgICAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50MSwgd29ybGRQb2ludDEsIG9mZnNldEEpO1xuXG4gICAgICAgICAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRQb2ludDEsIHdvcmxkUG9pbnQwKTtcblxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlOTBjdyh3b3JsZE5vcm1hbCwgd29ybGRFZGdlKTsgLy8gTm9ybWFsIHBvaW50cyBvdXQgb2YgY29udmV4IDFcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZE5vcm1hbCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRQb2ludCwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkb3Qod29ybGROb3JtYWwsZGlzdCk7XG5cbiAgICAgICAgICAgICAgICBpZigoaSA9PT0gY2xvc2VzdEVkZ2VBICYmIGQgPD0gcHJlY2lzaW9uKSB8fCAoaSAhPT0gY2xvc2VzdEVkZ2VBICYmIGQgPD0gMCkpe1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGVOdW1FZGdlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoaW5zaWRlTnVtRWRnZXMgPj0gMyl7XG5cbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHdvcmxkUG9pbnQgd2FzIG9uIHRoZSBcImluc2lkZVwiIHNpZGUgb2YgZWFjaCBvZiB0aGUgMyBjaGVja2VkIGVkZ2VzLlxuICAgICAgICAgICAgICAgIC8vIFByb2plY3QgaXQgdG8gdGhlIGNlbnRlciBlZGdlIGFuZCB1c2UgdGhlIHByb2plY3Rpb24gZGlyZWN0aW9uIGFzIG5vcm1hbFxuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGNvbnRhY3RcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCLHNoYXBlQSxzaGFwZUIpO1xuICAgICAgICAgICAgICAgIG51bUNvbnRhY3RzKys7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY2VudGVyIGVkZ2UgZnJvbSBib2R5IEFcbiAgICAgICAgICAgICAgICB2YXIgdjAgPSBzaGFwZUEudmVydGljZXNbKGNsb3Nlc3RFZGdlQSkgICAlIHNoYXBlQS52ZXJ0aWNlcy5sZW5ndGhdLFxuICAgICAgICAgICAgICAgICAgICB2MSA9IHNoYXBlQS52ZXJ0aWNlc1soY2xvc2VzdEVkZ2VBKzEpICUgc2hhcGVBLnZlcnRpY2VzLmxlbmd0aF07XG5cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MCwgdjAsIGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDEsIHYxLCBhbmdsZUEpO1xuICAgICAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50MCwgd29ybGRQb2ludDAsIG9mZnNldEEpO1xuICAgICAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50MSwgd29ybGRQb2ludDEsIG9mZnNldEEpO1xuXG4gICAgICAgICAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRQb2ludDEsIHdvcmxkUG9pbnQwKTtcblxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlOTBjdyhjLm5vcm1hbEEsIHdvcmxkRWRnZSk7IC8vIE5vcm1hbCBwb2ludHMgb3V0IG9mIGNvbnZleCBBXG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRQb2ludCwgd29ybGRQb2ludDApOyAvLyBGcm9tIGVkZ2UgcG9pbnQgdG8gdGhlIHBlbmV0cmF0aW5nIHBvaW50XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkb3QoYy5ub3JtYWxBLGRpc3QpOyAgICAgICAgICAgICAvLyBQZW5ldHJhdGlvblxuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUocGVuZXRyYXRpb25WZWMsIGMubm9ybWFsQSwgZCk7ICAgICAvLyBWZWN0b3IgcGVuZXRyYXRpb25cblxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHdvcmxkUG9pbnQsIG9mZnNldEEpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGVuZXRyYXRpb25WZWMpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgb2Zmc2V0QSk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBib2R5QS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB3b3JsZFBvaW50LCBvZmZzZXRCKTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIG9mZnNldEIpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgYm9keUIucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgICAgICAvLyBUb2RvIHJlZHVjZSB0byAxIGZyaWN0aW9uIGVxdWF0aW9uIGlmIHdlIGhhdmUgMiBjb250YWN0IHBvaW50c1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uICYmIG51bUNvbnRhY3RzKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1Db250YWN0cztcbn07XG5cbi8vIC5wcm9qZWN0Q29udmV4IGlzIGNhbGxlZCBieSBvdGhlciBmdW5jdGlvbnMsIG5lZWQgbG9jYWwgdG1wIHZlY3RvcnNcbnZhciBwY29hX3RtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBQcm9qZWN0IGEgQ29udmV4IG9udG8gYSB3b3JsZC1vcmllbnRlZCBheGlzXG4gKiBAbWV0aG9kIHByb2plY3RDb252ZXhPbnRvQXhpc1xuICogQHN0YXRpY1xuICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxuICogQHBhcmFtICB7QXJyYXl9IHdvcmxkQXhpc1xuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxuICovXG5OYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMgPSBmdW5jdGlvbihjb252ZXhTaGFwZSwgY29udmV4T2Zmc2V0LCBjb252ZXhBbmdsZSwgd29ybGRBeGlzLCByZXN1bHQpe1xuICAgIHZhciBtYXg9bnVsbCxcbiAgICAgICAgbWluPW51bGwsXG4gICAgICAgIHYsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBsb2NhbEF4aXMgPSBwY29hX3RtcDE7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSBheGlzIHRvIGxvY2FsIGNvb3JkcyBvZiB0aGUgYm9keVxuICAgIHZlYzIucm90YXRlKGxvY2FsQXhpcywgd29ybGRBeGlzLCAtY29udmV4QW5nbGUpO1xuXG4gICAgLy8gR2V0IHByb2plY3RlZCBwb3NpdGlvbiBvZiBhbGwgdmVydGljZXNcbiAgICBmb3IodmFyIGk9MDsgaTxjb252ZXhTaGFwZS52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHYgPSBjb252ZXhTaGFwZS52ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmFsdWUgPSBkb3Qodixsb2NhbEF4aXMpO1xuICAgICAgICBpZihtYXggPT09IG51bGwgfHwgdmFsdWUgPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYobWluID09PSBudWxsIHx8IHZhbHVlIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYobWluID4gbWF4KXtcbiAgICAgICAgdmFyIHQgPSBtaW47XG4gICAgICAgIG1pbiA9IG1heDtcbiAgICAgICAgbWF4ID0gdDtcbiAgICB9XG5cbiAgICAvLyBQcm9qZWN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keSBvbnRvIHRoZSBheGlzIC0gbmVlZCB0byBhZGQgdGhpcyB0byB0aGUgcmVzdWx0XG4gICAgdmFyIG9mZnNldCA9IGRvdChjb252ZXhPZmZzZXQsIHdvcmxkQXhpcyk7XG5cbiAgICB2ZWMyLnNldCggcmVzdWx0LCBtaW4gKyBvZmZzZXQsIG1heCArIG9mZnNldCk7XG59O1xuXG4vLyAuZmluZFNlcGFyYXRpbmdBeGlzIGlzIGNhbGxlZCBieSBvdGhlciBmdW5jdGlvbnMsIG5lZWQgbG9jYWwgdG1wIHZlY3RvcnNcbnZhciBmc2FfdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXAzID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wNCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDUgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXA2ID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogRmluZCBhIHNlcGFyYXRpbmcgYXhpcyBiZXR3ZWVuIHRoZSBzaGFwZXMsIHRoYXQgbWF4aW1pemVzIHRoZSBzZXBhcmF0aW5nIGRpc3RhbmNlIGJldHdlZW4gdGhlbS5cbiAqIEBtZXRob2QgZmluZFNlcGFyYXRpbmdBeGlzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjMVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgb2Zmc2V0MVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGUxXG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjMlxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgb2Zmc2V0MlxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGUyXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBzZXBBeGlzICAgICBUaGUgcmVzdWx0aW5nIGF4aXNcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgIFdoZXRoZXIgdGhlIGF4aXMgY291bGQgYmUgZm91bmQuXG4gKi9cbk5hcnJvd3BoYXNlLmZpbmRTZXBhcmF0aW5nQXhpcyA9IGZ1bmN0aW9uKGMxLG9mZnNldDEsYW5nbGUxLGMyLG9mZnNldDIsYW5nbGUyLHNlcEF4aXMpe1xuICAgIHZhciBtYXhEaXN0ID0gbnVsbCxcbiAgICAgICAgb3ZlcmxhcCA9IGZhbHNlLFxuICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICBlZGdlID0gZnNhX3RtcDEsXG4gICAgICAgIHdvcmxkUG9pbnQwID0gZnNhX3RtcDIsXG4gICAgICAgIHdvcmxkUG9pbnQxID0gZnNhX3RtcDMsXG4gICAgICAgIG5vcm1hbCA9IGZzYV90bXA0LFxuICAgICAgICBzcGFuMSA9IGZzYV90bXA1LFxuICAgICAgICBzcGFuMiA9IGZzYV90bXA2O1xuXG4gICAgaWYoYzEgaW5zdGFuY2VvZiBSZWN0YW5nbGUgJiYgYzIgaW5zdGFuY2VvZiBSZWN0YW5nbGUpe1xuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09MjsgaisrKXtcbiAgICAgICAgICAgIHZhciBjID0gYzEsXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTE7XG4gICAgICAgICAgICBpZihqPT09MSl7XG4gICAgICAgICAgICAgICAgYyA9IGMyO1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSE9PTI7IGkrKyl7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHdvcmxkIGVkZ2VcbiAgICAgICAgICAgICAgICBpZihpID09PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5zZXQobm9ybWFsLCAwLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLnNldChub3JtYWwsIDEsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihhbmdsZSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKG5vcm1hbCwgbm9ybWFsLCBhbmdsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUHJvamVjdCBodWxscyBvbnRvIHRoYXQgbm9ybWFsXG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMxLG9mZnNldDEsYW5nbGUxLG5vcm1hbCxzcGFuMSk7XG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMyLG9mZnNldDIsYW5nbGUyLG5vcm1hbCxzcGFuMik7XG5cbiAgICAgICAgICAgICAgICAvLyBPcmRlciBieSBzcGFuIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGE9c3BhbjEsXG4gICAgICAgICAgICAgICAgICAgIGI9c3BhbjIsXG4gICAgICAgICAgICAgICAgICAgIHN3YXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZihzcGFuMVswXSA+IHNwYW4yWzBdKXtcbiAgICAgICAgICAgICAgICAgICAgYj1zcGFuMTtcbiAgICAgICAgICAgICAgICAgICAgYT1zcGFuMjtcbiAgICAgICAgICAgICAgICAgICAgc3dhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHNlcGFyYXRpbmcgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGJbMF0gLSBhWzFdO1xuICAgICAgICAgICAgICAgIG92ZXJsYXAgPSAoZGlzdCA8PSAwKTtcblxuICAgICAgICAgICAgICAgIGlmKG1heERpc3Q9PT1udWxsIHx8IGRpc3QgPiBtYXhEaXN0KXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5jb3B5KHNlcEF4aXMsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIG1heERpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09MjsgaisrKXtcbiAgICAgICAgICAgIHZhciBjID0gYzEsXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTE7XG4gICAgICAgICAgICBpZihqPT09MSl7XG4gICAgICAgICAgICAgICAgYyA9IGMyO1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWMudmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgd29ybGQgZWRnZVxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQwLCBjLnZlcnRpY2VzW2ldLCBhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDEsIGMudmVydGljZXNbKGkrMSklYy52ZXJ0aWNlcy5sZW5ndGhdLCBhbmdsZSk7XG5cbiAgICAgICAgICAgICAgICBzdWIoZWRnZSwgd29ybGRQb2ludDEsIHdvcmxkUG9pbnQwKTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBub3JtYWwgLSBqdXN0IHJvdGF0ZSA5MCBkZWdyZWVzIHNpbmNlIHZlcnRpY2VzIGFyZSBnaXZlbiBpbiBDQ1dcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cobm9ybWFsLCBlZGdlKTtcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTtcblxuICAgICAgICAgICAgICAgIC8vIFByb2plY3QgaHVsbHMgb250byB0aGF0IG5vcm1hbFxuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMSxvZmZzZXQxLGFuZ2xlMSxub3JtYWwsc3BhbjEpO1xuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMixvZmZzZXQyLGFuZ2xlMixub3JtYWwsc3BhbjIpO1xuXG4gICAgICAgICAgICAgICAgLy8gT3JkZXIgYnkgc3BhbiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHZhciBhPXNwYW4xLFxuICAgICAgICAgICAgICAgICAgICBiPXNwYW4yLFxuICAgICAgICAgICAgICAgICAgICBzd2FwcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoc3BhbjFbMF0gPiBzcGFuMlswXSl7XG4gICAgICAgICAgICAgICAgICAgIGI9c3BhbjE7XG4gICAgICAgICAgICAgICAgICAgIGE9c3BhbjI7XG4gICAgICAgICAgICAgICAgICAgIHN3YXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEdldCBzZXBhcmF0aW5nIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBiWzBdIC0gYVsxXTtcbiAgICAgICAgICAgICAgICBvdmVybGFwID0gKGRpc3QgPD0gMCk7XG5cbiAgICAgICAgICAgICAgICBpZihtYXhEaXN0PT09bnVsbCB8fCBkaXN0ID4gbWF4RGlzdCl7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIuY29weShzZXBBeGlzLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICBtYXhEaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLypcbiAgICAvLyBOZWVkcyB0byBiZSB0ZXN0ZWQgc29tZSBtb3JlXG4gICAgZm9yKHZhciBqPTA7IGohPT0yOyBqKyspe1xuICAgICAgICB2YXIgYyA9IGMxLFxuICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTE7XG4gICAgICAgIGlmKGo9PT0xKXtcbiAgICAgICAgICAgIGMgPSBjMjtcbiAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUyO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1jLmF4ZXMubGVuZ3RoOyBpKyspe1xuXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gYy5heGVzW2ldO1xuXG4gICAgICAgICAgICAvLyBQcm9qZWN0IGh1bGxzIG9udG8gdGhhdCBub3JtYWxcbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMSwgb2Zmc2V0MSwgYW5nbGUxLCBub3JtYWwsIHNwYW4xKTtcbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMiwgb2Zmc2V0MiwgYW5nbGUyLCBub3JtYWwsIHNwYW4yKTtcblxuICAgICAgICAgICAgLy8gT3JkZXIgYnkgc3BhbiBwb3NpdGlvblxuICAgICAgICAgICAgdmFyIGE9c3BhbjEsXG4gICAgICAgICAgICAgICAgYj1zcGFuMixcbiAgICAgICAgICAgICAgICBzd2FwcGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZihzcGFuMVswXSA+IHNwYW4yWzBdKXtcbiAgICAgICAgICAgICAgICBiPXNwYW4xO1xuICAgICAgICAgICAgICAgIGE9c3BhbjI7XG4gICAgICAgICAgICAgICAgc3dhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBzZXBhcmF0aW5nIGRpc3RhbmNlXG4gICAgICAgICAgICB2YXIgZGlzdCA9IGJbMF0gLSBhWzFdO1xuICAgICAgICAgICAgb3ZlcmxhcCA9IChkaXN0IDw9IE5hcnJvd3BoYXNlLmNvbnZleFByZWNpc2lvbik7XG5cbiAgICAgICAgICAgIGlmKG1heERpc3Q9PT1udWxsIHx8IGRpc3QgPiBtYXhEaXN0KXtcbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoc2VwQXhpcywgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICBtYXhEaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IG92ZXJsYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgKi9cblxuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8vIC5nZXRDbG9zZXN0RWRnZSBpcyBjYWxsZWQgYnkgb3RoZXIgZnVuY3Rpb25zLCBuZWVkIGxvY2FsIHRtcCB2ZWN0b3JzXG52YXIgZ2NlX3RtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGdjZV90bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBnY2VfdG1wMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIEdldCB0aGUgZWRnZSB0aGF0IGhhcyBhIG5vcm1hbCBjbG9zZXN0IHRvIGFuIGF4aXMuXG4gKiBAbWV0aG9kIGdldENsb3Nlc3RFZGdlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgYXhpc1xuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgZmxpcFxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICBJbmRleCBvZiB0aGUgZWRnZSB0aGF0IGlzIGNsb3Nlc3QuIFRoaXMgaW5kZXggYW5kIHRoZSBuZXh0IHNwYW5zIHRoZSByZXN1bHRpbmcgZWRnZS4gUmV0dXJucyAtMSBpZiBmYWlsZWQuXG4gKi9cbk5hcnJvd3BoYXNlLmdldENsb3Nlc3RFZGdlID0gZnVuY3Rpb24oYyxhbmdsZSxheGlzLGZsaXApe1xuICAgIHZhciBsb2NhbEF4aXMgPSBnY2VfdG1wMSxcbiAgICAgICAgZWRnZSA9IGdjZV90bXAyLFxuICAgICAgICBub3JtYWwgPSBnY2VfdG1wMztcblxuICAgIC8vIENvbnZlcnQgdGhlIGF4aXMgdG8gbG9jYWwgY29vcmRzIG9mIHRoZSBib2R5XG4gICAgdmVjMi5yb3RhdGUobG9jYWxBeGlzLCBheGlzLCAtYW5nbGUpO1xuICAgIGlmKGZsaXApe1xuICAgICAgICB2ZWMyLnNjYWxlKGxvY2FsQXhpcyxsb2NhbEF4aXMsLTEpO1xuICAgIH1cblxuICAgIHZhciBjbG9zZXN0RWRnZSA9IC0xLFxuICAgICAgICBOID0gYy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIG1heERvdCA9IC0xO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgLy8gR2V0IHRoZSBlZGdlXG4gICAgICAgIHN1YihlZGdlLCBjLnZlcnRpY2VzWyhpKzEpJU5dLCBjLnZlcnRpY2VzW2klTl0pO1xuXG4gICAgICAgIC8vIEdldCBub3JtYWwgLSBqdXN0IHJvdGF0ZSA5MCBkZWdyZWVzIHNpbmNlIHZlcnRpY2VzIGFyZSBnaXZlbiBpbiBDQ1dcbiAgICAgICAgdmVjMi5yb3RhdGU5MGN3KG5vcm1hbCwgZWRnZSk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuXG4gICAgICAgIHZhciBkID0gZG90KG5vcm1hbCxsb2NhbEF4aXMpO1xuICAgICAgICBpZihjbG9zZXN0RWRnZSA9PT0gLTEgfHwgZCA+IG1heERvdCl7XG4gICAgICAgICAgICBjbG9zZXN0RWRnZSA9IGkgJSBOO1xuICAgICAgICAgICAgbWF4RG90ID0gZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9zZXN0RWRnZTtcbn07XG5cbnZhciBjaXJjbGVIZWlnaHRmaWVsZF9jYW5kaWRhdGUgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX2Rpc3QgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX3YwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF92MSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF93b3JsZE5vcm1hbCA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlTm9ybWFsID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNpcmNsZUhlaWdodGZpZWxkXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICAgICAgYmlcbiAqIEBwYXJhbSAge0NpcmNsZX0gICAgICAgICBzaVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIHhpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICAgICAgYmpcbiAqIEBwYXJhbSAge0hlaWdodGZpZWxkfSAgICBzalxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgYWpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkhFSUdIVEZJRUxEXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlSGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiggY2lyY2xlQm9keSxjaXJjbGVTaGFwZSxjaXJjbGVQb3MsY2lyY2xlQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZCb2R5LGhmU2hhcGUsaGZQb3MsaGZBbmdsZSwganVzdFRlc3QsIHJhZGl1cyApe1xuICAgIHZhciBkYXRhID0gaGZTaGFwZS5kYXRhLFxuICAgICAgICByYWRpdXMgPSByYWRpdXMgfHwgY2lyY2xlU2hhcGUucmFkaXVzLFxuICAgICAgICB3ID0gaGZTaGFwZS5lbGVtZW50V2lkdGgsXG4gICAgICAgIGRpc3QgPSBjaXJjbGVIZWlnaHRmaWVsZF9kaXN0LFxuICAgICAgICBjYW5kaWRhdGUgPSBjaXJjbGVIZWlnaHRmaWVsZF9jYW5kaWRhdGUsXG4gICAgICAgIG1pbkNhbmRpZGF0ZSA9IGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZSxcbiAgICAgICAgbWluQ2FuZGlkYXRlTm9ybWFsID0gY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlTm9ybWFsLFxuICAgICAgICB3b3JsZE5vcm1hbCA9IGNpcmNsZUhlaWdodGZpZWxkX3dvcmxkTm9ybWFsLFxuICAgICAgICB2MCA9IGNpcmNsZUhlaWdodGZpZWxkX3YwLFxuICAgICAgICB2MSA9IGNpcmNsZUhlaWdodGZpZWxkX3YxO1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxuICAgIHZhciBpZHhBID0gTWF0aC5mbG9vciggKGNpcmNsZVBvc1swXSAtIHJhZGl1cyAtIGhmUG9zWzBdKSAvIHcgKSxcbiAgICAgICAgaWR4QiA9IE1hdGguY2VpbCggIChjaXJjbGVQb3NbMF0gKyByYWRpdXMgLSBoZlBvc1swXSkgLyB3ICk7XG5cbiAgICAvKmlmKGlkeEIgPCAwIHx8IGlkeEEgPj0gZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBqdXN0VGVzdCA/IGZhbHNlIDogMDsqL1xuXG4gICAgaWYoaWR4QSA8IDApe1xuICAgICAgICBpZHhBID0gMDtcbiAgICB9XG4gICAgaWYoaWR4QiA+PSBkYXRhLmxlbmd0aCl7XG4gICAgICAgIGlkeEIgPSBkYXRhLmxlbmd0aC0xO1xuICAgIH1cblxuICAgIC8vIEdldCBtYXggYW5kIG1pblxuICAgIHZhciBtYXggPSBkYXRhW2lkeEFdLFxuICAgICAgICBtaW4gPSBkYXRhW2lkeEJdO1xuICAgIGZvcih2YXIgaT1pZHhBOyBpPGlkeEI7IGkrKyl7XG4gICAgICAgIGlmKGRhdGFbaV0gPCBtaW4pe1xuICAgICAgICAgICAgbWluID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZihkYXRhW2ldID4gbWF4KXtcbiAgICAgICAgICAgIG1heCA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihjaXJjbGVQb3NbMV0tcmFkaXVzID4gbWF4KXtcbiAgICAgICAgcmV0dXJuIGp1c3RUZXN0ID8gZmFsc2UgOiAwO1xuICAgIH1cblxuICAgIC8qXG4gICAgaWYoY2lyY2xlUG9zWzFdK3JhZGl1cyA8IG1pbil7XG4gICAgICAgIC8vIEJlbG93IHRoZSBtaW5pbXVtIHBvaW50Li4uIFdlIGNhbiBqdXN0IGd1ZXNzLlxuICAgICAgICAvLyBUT0RPXG4gICAgfVxuICAgICovXG5cbiAgICAvLyAxLiBDaGVjayBzbyBjZW50ZXIgb2YgY2lyY2xlIGlzIG5vdCBpbnNpZGUgdGhlIGZpZWxkLiBJZiBpdCBpcywgdGhpcyB3b250IHdvcmsuLi5cbiAgICAvLyAyLiBGb3IgZWFjaCBlZGdlXG4gICAgLy8gMi4gMS4gR2V0IHBvaW50IG9uIGNpcmNsZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGVkZ2UgKHNjYWxlIG5vcm1hbCB3aXRoIC1yYWRpdXMpXG4gICAgLy8gMi4gMi4gQ2hlY2sgaWYgcG9pbnQgaXMgaW5zaWRlLlxuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBhbGwgZWRnZXMgZmlyc3RcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCBwb2ludHNcbiAgICAgICAgdmVjMi5zZXQodjAsICAgICBpKncsIGRhdGFbaV0gICk7XG4gICAgICAgIHZlYzIuc2V0KHYxLCAoaSsxKSp3LCBkYXRhW2krMV0pO1xuICAgICAgICB2ZWMyLmFkZCh2MCx2MCxoZlBvcyk7XG4gICAgICAgIHZlYzIuYWRkKHYxLHYxLGhmUG9zKTtcblxuICAgICAgICAvLyBHZXQgbm9ybWFsXG4gICAgICAgIHZlYzIuc3ViKHdvcmxkTm9ybWFsLCB2MSwgdjApO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwsIE1hdGguUEkvMik7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKHdvcmxkTm9ybWFsLHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAvLyBHZXQgcG9pbnQgb24gY2lyY2xlLCBjbG9zZXN0IHRvIHRoZSBlZGdlXG4gICAgICAgIHZlYzIuc2NhbGUoY2FuZGlkYXRlLHdvcmxkTm9ybWFsLC1yYWRpdXMpO1xuICAgICAgICB2ZWMyLmFkZChjYW5kaWRhdGUsY2FuZGlkYXRlLGNpcmNsZVBvcyk7XG5cbiAgICAgICAgLy8gRGlzdGFuY2UgZnJvbSB2MCB0byB0aGUgY2FuZGlkYXRlIHBvaW50XG4gICAgICAgIHZlYzIuc3ViKGRpc3QsY2FuZGlkYXRlLHYwKTtcblxuICAgICAgICAvLyBDaGVjayBpZiBpdCBpcyBpbiB0aGUgZWxlbWVudCBcInN0aWNrXCJcbiAgICAgICAgdmFyIGQgPSB2ZWMyLmRvdChkaXN0LHdvcmxkTm9ybWFsKTtcbiAgICAgICAgaWYoY2FuZGlkYXRlWzBdID49IHYwWzBdICYmIGNhbmRpZGF0ZVswXSA8IHYxWzBdICYmIGQgPD0gMCl7XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgY2FuZGlkYXRlIHBvaW50LCBwcm9qZWN0ZWQgdG8gdGhlIGVkZ2VcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoZGlzdCx3b3JsZE5vcm1hbCwtZCk7XG4gICAgICAgICAgICB2ZWMyLmFkZChtaW5DYW5kaWRhdGUsY2FuZGlkYXRlLGRpc3QpO1xuICAgICAgICAgICAgdmVjMi5jb3B5KG1pbkNhbmRpZGF0ZU5vcm1hbCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oaGZCb2R5LGNpcmNsZUJvZHksaGZTaGFwZSxjaXJjbGVTaGFwZSk7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbCBpcyBvdXQgb2YgdGhlIGhlaWdodGZpZWxkXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBtaW5DYW5kaWRhdGVOb3JtYWwpO1xuXG4gICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gaGVpZ2h0ZmllbGRcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRCLCAgYy5ub3JtYWxBLCAtcmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlUG9zKTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHZlYzIuY29weShjLmNvbnRhY3RQb2ludEEsIG1pbkNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB2ZWMyLnN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCggdGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBhbGwgdmVydGljZXNcbiAgICBmb3VuZCA9IGZhbHNlO1xuICAgIGlmKHJhZGl1cyA+IDApe1xuICAgICAgICBmb3IodmFyIGk9aWR4QTsgaTw9aWR4QjsgaSsrKXtcblxuICAgICAgICAgICAgLy8gR2V0IHBvaW50XG4gICAgICAgICAgICB2ZWMyLnNldCh2MCwgaSp3LCBkYXRhW2ldKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKHYwLHYwLGhmUG9zKTtcblxuICAgICAgICAgICAgdmVjMi5zdWIoZGlzdCwgY2lyY2xlUG9zLCB2MCk7XG5cbiAgICAgICAgICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA8IE1hdGgucG93KHJhZGl1cywgMikpe1xuXG4gICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGhmQm9keSxjaXJjbGVCb2R5LGhmU2hhcGUsY2lyY2xlU2hhcGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IG5vcm1hbCAtIG91dCBvZiBoZWlnaHRmaWVsZFxuICAgICAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIGRpc3QpO1xuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEIsIGMubm9ybWFsQSwgLXJhZGl1cyk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVQb3MpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCB2MCwgaGZQb3MpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZQb3MpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGZvdW5kKXtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG5cbn07XG5cbnZhciBjb252ZXhIZWlnaHRmaWVsZF92MCA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29udmV4SGVpZ2h0ZmllbGRfdjEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvbnZleEhlaWdodGZpZWxkX3RpbGVQb3MgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvbnZleEhlaWdodGZpZWxkX3RlbXBDb252ZXhTaGFwZSA9IG5ldyBDb252ZXgoW3ZlYzIuY3JlYXRlKCksdmVjMi5jcmVhdGUoKSx2ZWMyLmNyZWF0ZSgpLHZlYzIuY3JlYXRlKCldKTtcbi8qKlxuICogQG1ldGhvZCBjaXJjbGVIZWlnaHRmaWVsZFxuICogQHBhcmFtICB7Qm9keX0gICAgICAgICAgIGJpXG4gKiBAcGFyYW0gIHtDaXJjbGV9ICAgICAgICAgc2lcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICB4aVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgICAgIGJqXG4gKiBAcGFyYW0gIHtIZWlnaHRmaWVsZH0gICAgc2pcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICB4alxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgIGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5SRUNUQU5HTEUgfCBTaGFwZS5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLkhFSUdIVEZJRUxEXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4SGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiggY29udmV4Qm9keSxjb252ZXhTaGFwZSxjb252ZXhQb3MsY29udmV4QW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZCb2R5LGhmU2hhcGUsaGZQb3MsaGZBbmdsZSwganVzdFRlc3QgKXtcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuZGF0YSxcbiAgICAgICAgdyA9IGhmU2hhcGUuZWxlbWVudFdpZHRoLFxuICAgICAgICB2MCA9IGNvbnZleEhlaWdodGZpZWxkX3YwLFxuICAgICAgICB2MSA9IGNvbnZleEhlaWdodGZpZWxkX3YxLFxuICAgICAgICB0aWxlUG9zID0gY29udmV4SGVpZ2h0ZmllbGRfdGlsZVBvcyxcbiAgICAgICAgdGlsZUNvbnZleCA9IGNvbnZleEhlaWdodGZpZWxkX3RlbXBDb252ZXhTaGFwZTtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcbiAgICB2YXIgaWR4QSA9IE1hdGguZmxvb3IoIChjb252ZXhCb2R5LmFhYmIubG93ZXJCb3VuZFswXSAtIGhmUG9zWzBdKSAvIHcgKSxcbiAgICAgICAgaWR4QiA9IE1hdGguY2VpbCggIChjb252ZXhCb2R5LmFhYmIudXBwZXJCb3VuZFswXSAtIGhmUG9zWzBdKSAvIHcgKTtcblxuICAgIGlmKGlkeEEgPCAwKXtcbiAgICAgICAgaWR4QSA9IDA7XG4gICAgfVxuICAgIGlmKGlkeEIgPj0gZGF0YS5sZW5ndGgpe1xuICAgICAgICBpZHhCID0gZGF0YS5sZW5ndGgtMTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbWF4IGFuZCBtaW5cbiAgICB2YXIgbWF4ID0gZGF0YVtpZHhBXSxcbiAgICAgICAgbWluID0gZGF0YVtpZHhCXTtcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuICAgICAgICBpZihkYXRhW2ldIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYoZGF0YVtpXSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoY29udmV4Qm9keS5hYWJiLmxvd2VyQm91bmRbMV0gPiBtYXgpe1xuICAgICAgICByZXR1cm4ganVzdFRlc3QgPyBmYWxzZSA6IDA7XG4gICAgfVxuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgdmFyIG51bUNvbnRhY3RzID0gMDtcblxuICAgIC8vIExvb3Agb3ZlciBhbGwgZWRnZXNcbiAgICAvLyBUT0RPOiBJZiBwb3NzaWJsZSwgY29uc3RydWN0IGEgY29udmV4IGZyb20gc2V2ZXJhbCBkYXRhIHBvaW50cyAobmVlZCBvIGNoZWNrIGlmIHRoZSBwb2ludHMgbWFrZSBhIGNvbnZleCBzaGFwZSlcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCBwb2ludHNcbiAgICAgICAgdmVjMi5zZXQodjAsICAgICBpKncsIGRhdGFbaV0gICk7XG4gICAgICAgIHZlYzIuc2V0KHYxLCAoaSsxKSp3LCBkYXRhW2krMV0pO1xuICAgICAgICB2ZWMyLmFkZCh2MCx2MCxoZlBvcyk7XG4gICAgICAgIHZlYzIuYWRkKHYxLHYxLGhmUG9zKTtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBjb252ZXhcbiAgICAgICAgdmFyIHRpbGVIZWlnaHQgPSAxMDA7IC8vIHRvZG9cbiAgICAgICAgdmVjMi5zZXQodGlsZVBvcywgKHYxWzBdICsgdjBbMF0pKjAuNSwgKHYxWzFdICsgdjBbMV0gLSB0aWxlSGVpZ2h0KSowLjUpO1xuXG4gICAgICAgIHZlYzIuc3ViKHRpbGVDb252ZXgudmVydGljZXNbMF0sIHYxLCB0aWxlUG9zKTtcbiAgICAgICAgdmVjMi5zdWIodGlsZUNvbnZleC52ZXJ0aWNlc1sxXSwgdjAsIHRpbGVQb3MpO1xuICAgICAgICB2ZWMyLmNvcHkodGlsZUNvbnZleC52ZXJ0aWNlc1syXSwgdGlsZUNvbnZleC52ZXJ0aWNlc1sxXSk7XG4gICAgICAgIHZlYzIuY29weSh0aWxlQ29udmV4LnZlcnRpY2VzWzNdLCB0aWxlQ29udmV4LnZlcnRpY2VzWzBdKTtcbiAgICAgICAgdGlsZUNvbnZleC52ZXJ0aWNlc1syXVsxXSAtPSB0aWxlSGVpZ2h0O1xuICAgICAgICB0aWxlQ29udmV4LnZlcnRpY2VzWzNdWzFdIC09IHRpbGVIZWlnaHQ7XG5cbiAgICAgICAgLy8gRG8gY29udmV4IGNvbGxpc2lvblxuICAgICAgICBudW1Db250YWN0cyArPSB0aGlzLmNvbnZleENvbnZleCggICBjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4UG9zLCBjb252ZXhBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZCb2R5LCB0aWxlQ29udmV4LCB0aWxlUG9zLCAwLCBqdXN0VGVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTtcbn0se1wiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIyLFwiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjMsXCIuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvblwiOjI0LFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9vYmplY3RzL0JvZHlcIjozMixcIi4uL3NoYXBlcy9DaXJjbGVcIjozOCxcIi4uL3NoYXBlcy9Db252ZXhcIjozOSxcIi4uL3NoYXBlcy9SZWN0YW5nbGVcIjo0NCxcIi4uL3NoYXBlcy9TaGFwZVwiOjQ1LFwiLi4vdXRpbHMvVHVwbGVEaWN0aW9uYXJ5XCI6NDksXCIuLi91dGlscy9VdGlsc1wiOjUwfV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBSYXk7XG5cbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgUmF5Y2FzdFJlc3VsdCA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0Jyk7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcblxuLyoqXG4gKiBBIGxpbmUgd2l0aCBhIHN0YXJ0IGFuZCBlbmQgcG9pbnQgdGhhdCBpcyB1c2VkIHRvIGludGVyc2VjdCBzaGFwZXMuXG4gKiBAY2xhc3MgUmF5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmF5KG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gZnJvbVxuICAgICAqL1xuICAgIHRoaXMuZnJvbSA9IG9wdGlvbnMuZnJvbSA/IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLmZyb21bMF0sIG9wdGlvbnMuZnJvbVsxXSkgOiB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gdG9cbiAgICAgKi9cbiAgICB0aGlzLnRvID0gb3B0aW9ucy50byA/IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLnRvWzBdLCBvcHRpb25zLnRvWzFdKSA6IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IF9kaXJlY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLl9kaXJlY3Rpb24gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZWNpc2lvbiBvZiB0aGUgcmF5LiBVc2VkIHdoZW4gY2hlY2tpbmcgcGFyYWxsZWxpdHkgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBwcmVjaXNpb25cbiAgICAgKi9cbiAgICB0aGlzLnByZWNpc2lvbiA9IDAuMDAwMTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSBSYXkgdG8gdGFrZSAuY29sbGlzaW9uUmVzcG9uc2UgZmxhZ3MgaW50byBhY2NvdW50IG9uIGJvZGllcyBhbmQgc2hhcGVzLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY2hlY2tDb2xsaXNpb25SZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHJheSBza2lwcyBhbnkgaGl0cyB3aXRoIG5vcm1hbC5kb3QocmF5RGlyZWN0aW9uKSA8IDAuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBza2lwQmFja2ZhY2VzXG4gICAgICovXG4gICAgdGhpcy5za2lwQmFja2ZhY2VzID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY29sbGlzaW9uTWFza1xuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25NYXNrID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY29sbGlzaW9uR3JvdXBcbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uR3JvdXAgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnNlY3Rpb24gbW9kZS4gU2hvdWxkIGJlIFJheS5BTlksIFJheS5BTEwgb3IgUmF5LkNMT1NFU1QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vZGVcbiAgICAgKi9cbiAgICB0aGlzLm1vZGUgPSBSYXkuQU5ZO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCByZXN1bHQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gICAgICovXG4gICAgdGhpcy5yZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBiZSBzZXQgdG8gdHJ1ZSBkdXJpbmcgaW50ZXJzZWN0V29ybGQoKSBpZiB0aGUgcmF5IGhpdCBhbnl0aGluZy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGhhc0hpdFxuICAgICAqL1xuICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50LCB1c2VyLXByb3ZpZGVkIHJlc3VsdCBjYWxsYmFjay4gV2lsbCBiZSB1c2VkIGlmIG1vZGUgaXMgUmF5LkFMTC5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHRoaXMuY2FsbGJhY2sgPSBmdW5jdGlvbihyZXN1bHQpe307XG59XG5SYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmF5O1xuXG5SYXkuQ0xPU0VTVCA9IDE7XG5SYXkuQU5ZID0gMjtcblJheS5BTEwgPSA0O1xuXG52YXIgdG1wQUFCQiA9IG5ldyBBQUJCKCk7XG52YXIgdG1wQXJyYXkgPSBbXTtcblxuLyoqXG4gKiBEbyBpdGVyc2VjdGlvbiBhZ2FpbnN0IGFsbCBib2RpZXMgaW4gdGhlIGdpdmVuIFdvcmxkLlxuICogQG1ldGhvZCBpbnRlcnNlY3RXb3JsZFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHJheSBoaXQgYW55dGhpbmcsIG90aGVyd2lzZSBmYWxzZS5cbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RXb3JsZCA9IGZ1bmN0aW9uICh3b3JsZCwgb3B0aW9ucykge1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCBSYXkuQU5ZO1xuICAgIHRoaXMucmVzdWx0ID0gb3B0aW9ucy5yZXN1bHQgfHwgbmV3IFJheWNhc3RSZXN1bHQoKTtcbiAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSAhIW9wdGlvbnMuc2tpcEJhY2tmYWNlcztcbiAgICB0aGlzLmNvbGxpc2lvbk1hc2sgPSB0eXBlb2Yob3B0aW9ucy5jb2xsaXNpb25NYXNrKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmNvbGxpc2lvbk1hc2sgOiAtMTtcbiAgICB0aGlzLmNvbGxpc2lvbkdyb3VwID0gdHlwZW9mKG9wdGlvbnMuY29sbGlzaW9uR3JvdXApICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uR3JvdXAgOiAtMTtcbiAgICBpZihvcHRpb25zLmZyb20pe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5mcm9tLCBvcHRpb25zLmZyb20pO1xuICAgIH1cbiAgICBpZihvcHRpb25zLnRvKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMudG8sIG9wdGlvbnMudG8pO1xuICAgIH1cbiAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpe307XG4gICAgdGhpcy5oYXNIaXQgPSBmYWxzZTtcblxuICAgIHRoaXMucmVzdWx0LnJlc2V0KCk7XG4gICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCk7XG5cbiAgICB0aGlzLmdldEFBQkIodG1wQUFCQik7XG4gICAgdG1wQXJyYXkubGVuZ3RoID0gMDtcbiAgICB3b3JsZC5icm9hZHBoYXNlLmFhYmJRdWVyeSh3b3JsZCwgdG1wQUFCQiwgdG1wQXJyYXkpO1xuICAgIHRoaXMuaW50ZXJzZWN0Qm9kaWVzKHRtcEFycmF5KTtcblxuICAgIHJldHVybiB0aGlzLmhhc0hpdDtcbn07XG5cbnZhciB2MSA9IHZlYzIuY3JlYXRlKCksXG4gICAgdjIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG52YXIgaW50ZXJzZWN0Qm9keV93b3JsZFBvc2l0aW9uID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBTaG9vdCBhIHJheSBhdCBhIGJvZHksIGdldCBiYWNrIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXQuXG4gKiBAbWV0aG9kIGludGVyc2VjdEJvZHlcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZCAtIHNldCB0aGUgcmVzdWx0IHByb3BlcnR5IG9mIHRoZSBSYXkgaW5zdGVhZC5cbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb2R5ID0gZnVuY3Rpb24gKGJvZHksIHJlc3VsdCkge1xuXG4gICAgaWYocmVzdWx0KXtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpO1xuICAgIH1cbiAgICB2YXIgY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZTtcblxuICAgIGlmKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIWJvZHkuY29sbGlzaW9uUmVzcG9uc2Upe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYoKHRoaXMuY29sbGlzaW9uR3JvdXAgJiBib2R5LmNvbGxpc2lvbk1hc2spPT09MCB8fCAoYm9keS5jb2xsaXNpb25Hcm91cCAmIHRoaXMuY29sbGlzaW9uTWFzayk9PT0wKXtcbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vIH1cblxuICAgIHZhciB3b3JsZFBvc2l0aW9uID0gaW50ZXJzZWN0Qm9keV93b3JsZFBvc2l0aW9uO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIE4gPSBib2R5LnNoYXBlcy5sZW5ndGg7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgdmFyIHNoYXBlID0gYm9keS5zaGFwZXNbaV07XG5cbiAgICAgICAgaWYoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhc2hhcGUuY29sbGlzaW9uUmVzcG9uc2Upe1xuICAgICAgICAgICAgY29udGludWU7IC8vIFNraXBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB3b3JsZCBhbmdsZSBhbmQgcG9zaXRpb24gb2YgdGhlIHNoYXBlXG4gICAgICAgIHZlYzIuY29weSh3b3JsZFBvc2l0aW9uLCBib2R5LnNoYXBlT2Zmc2V0c1tpXSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9zaXRpb24sIHdvcmxkUG9zaXRpb24sIGJvZHkuYW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZCh3b3JsZFBvc2l0aW9uLCB3b3JsZFBvc2l0aW9uLCBib2R5LnBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHdvcmxkQW5nbGUgPSBib2R5LnNoYXBlQW5nbGVzW2ldICsgYm9keS5hbmdsZTtcblxuICAgICAgICB0aGlzLmludGVyc2VjdFNoYXBlKFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICB3b3JsZEFuZ2xlLFxuICAgICAgICAgICAgd29ybGRQb3NpdGlvbixcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgKTtcblxuICAgICAgICBpZih0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcCl7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RCb2RpZXNcbiAqIEBwYXJhbSB7QXJyYXl9IGJvZGllcyBBbiBhcnJheSBvZiBCb2R5IG9iamVjdHMuXG4gKiBAcGFyYW0ge1JheWNhc3RSZXN1bHR9IFtyZXN1bHRdIERlcHJlY2F0ZWRcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb2RpZXMgPSBmdW5jdGlvbiAoYm9kaWVzLCByZXN1bHQpIHtcbiAgICBpZihyZXN1bHQpe1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gYm9kaWVzLmxlbmd0aDsgIXRoaXMucmVzdWx0Ll9zaG91bGRTdG9wICYmIGkgPCBsOyBpICsrICkge1xuICAgICAgICB0aGlzLmludGVyc2VjdEJvZHkoYm9kaWVzW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIF9kaXJlY3Rpb24gdmVjdG9yLlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgX3VwZGF0ZURpcmVjdGlvblxuICovXG5SYXkucHJvdG90eXBlLl91cGRhdGVEaXJlY3Rpb24gPSBmdW5jdGlvbigpe1xuICAgIHZhciBkID0gdGhpcy5fZGlyZWN0aW9uO1xuICAgIHZlYzIuc3ViKGQsIHRoaXMudG8sIHRoaXMuZnJvbSk7IC8vIHRoaXMudG8udnN1Yih0aGlzLmZyb20sIHRoaXMuX2RpcmVjdGlvbik7XG4gICAgdmVjMi5ub3JtYWxpemUoZCwgZCk7IC8vIHRoaXMuX2RpcmVjdGlvbi5ub3JtYWxpemUoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RTaGFwZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAqIEBwYXJhbSB7YXJyYXl9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlLCBhbmdsZSwgcG9zaXRpb24sIGJvZHkpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuXG5cbiAgICAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZVxuICAgIHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbihmcm9tLCB0aGlzLl9kaXJlY3Rpb24sIHBvc2l0aW9uKTtcbiAgICBpZiAoIGRpc3RhbmNlID4gc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWV0aG9kID0gdGhpc1tzaGFwZS50eXBlXTtcbiAgICBpZihtZXRob2Qpe1xuICAgICAgICBtZXRob2QuY2FsbCh0aGlzLCBzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KTtcbiAgICB9XG59O1xuXG52YXIgdmVjdG9yID0gdmVjMi5jcmVhdGUoKTtcbnZhciBub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcblxudmFyIGEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGIgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGMgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG52YXIgdG1wUmF5Y2FzdFJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX2RpcmVjdGlvbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX3JheVN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RSZWN0YW5nbGVfd29ybGROb3JtYWxNaW4gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFJlY3RhbmdsZV93b3JsZE5vcm1hbE1heCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX2hpdFBvaW50V29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFJlY3RhbmdsZV9ib3hNaW4gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFJlY3RhbmdsZV9ib3hNYXggPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0UmVjdGFuZ2xlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXG4gKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RSZWN0YW5nbGUgPSBmdW5jdGlvbihzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KXtcbiAgICB2YXIgdG1pbiA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciB0bWF4ID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIHZhciBkaXJlY3Rpb24gPSBpbnRlcnNlY3RSZWN0YW5nbGVfZGlyZWN0aW9uO1xuICAgIHZhciByYXlTdGFydCA9IGludGVyc2VjdFJlY3RhbmdsZV9yYXlTdGFydDtcbiAgICB2YXIgd29ybGROb3JtYWxNaW4gPSBpbnRlcnNlY3RSZWN0YW5nbGVfd29ybGROb3JtYWxNaW47XG4gICAgdmFyIHdvcmxkTm9ybWFsTWF4ID0gaW50ZXJzZWN0UmVjdGFuZ2xlX3dvcmxkTm9ybWFsTWF4O1xuICAgIHZhciBoaXRQb2ludFdvcmxkID0gaW50ZXJzZWN0UmVjdGFuZ2xlX2hpdFBvaW50V29ybGQ7XG4gICAgdmFyIGJveE1pbiA9IGludGVyc2VjdFJlY3RhbmdsZV9ib3hNaW47XG4gICAgdmFyIGJveE1heCA9IGludGVyc2VjdFJlY3RhbmdsZV9ib3hNYXg7XG5cbiAgICB2ZWMyLnNldChib3hNaW4sIC1zaGFwZS53aWR0aCAqIDAuNSwgLXNoYXBlLmhlaWdodCAqIDAuNSk7XG4gICAgdmVjMi5zZXQoYm94TWF4LCBzaGFwZS53aWR0aCAqIDAuNSwgc2hhcGUuaGVpZ2h0ICogMC41KTtcblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgcmF5IGRpcmVjdGlvbiBhbmQgc3RhcnQgdG8gbG9jYWwgc3BhY2VcbiAgICB2ZWMyLnJvdGF0ZShkaXJlY3Rpb24sIHRoaXMuX2RpcmVjdGlvbiwgLWFuZ2xlKTtcbiAgICBib2R5LnRvTG9jYWxGcmFtZShyYXlTdGFydCwgdGhpcy5mcm9tKTtcblxuICAgIGlmIChkaXJlY3Rpb25bMF0gIT09IDApIHtcbiAgICAgICAgdmFyIHR4MSA9IChib3hNaW5bMF0gLSByYXlTdGFydFswXSkgLyBkaXJlY3Rpb25bMF07XG4gICAgICAgIHZhciB0eDIgPSAoYm94TWF4WzBdIC0gcmF5U3RhcnRbMF0pIC8gZGlyZWN0aW9uWzBdO1xuXG4gICAgICAgIHZhciB0bWluT2xkID0gdG1pbjtcbiAgICAgICAgdG1pbiA9IE1hdGgubWF4KHRtaW4sIE1hdGgubWluKHR4MSwgdHgyKSk7XG4gICAgICAgIGlmKHRtaW4gIT09IHRtaW5PbGQpe1xuICAgICAgICAgICAgdmVjMi5zZXQod29ybGROb3JtYWxNaW4sIHR4MSA+IHR4MiA/IDEgOiAtMSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1heE9sZCA9IHRtYXg7XG4gICAgICAgIHRtYXggPSBNYXRoLm1pbih0bWF4LCBNYXRoLm1heCh0eDEsIHR4MikpO1xuICAgICAgICBpZih0bWF4ICE9PSB0bWF4T2xkKXtcbiAgICAgICAgICAgIHZlYzIuc2V0KHdvcmxkTm9ybWFsTWF4LCB0eDEgPCB0eDIgPyAxIDogLTEsIDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvblsxXSAhPT0gMCkge1xuICAgICAgICB2YXIgdHkxID0gKGJveE1pblsxXSAtIHJheVN0YXJ0WzFdKSAvIGRpcmVjdGlvblsxXTtcbiAgICAgICAgdmFyIHR5MiA9IChib3hNYXhbMV0gLSByYXlTdGFydFsxXSkgLyBkaXJlY3Rpb25bMV07XG5cbiAgICAgICAgdmFyIHRtaW5PbGQgPSB0bWluO1xuICAgICAgICB0bWluID0gTWF0aC5tYXgodG1pbiwgTWF0aC5taW4odHkxLCB0eTIpKTtcbiAgICAgICAgaWYodG1pbiAhPT0gdG1pbk9sZCl7XG4gICAgICAgICAgICB2ZWMyLnNldCh3b3JsZE5vcm1hbE1pbiwgMCwgdHkxID4gdHkyID8gMSA6IC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bWF4T2xkID0gdG1heDtcbiAgICAgICAgdG1heCA9IE1hdGgubWluKHRtYXgsIE1hdGgubWF4KHR5MSwgdHkyKSk7XG4gICAgICAgIGlmKHRtYXggIT09IHRtYXhPbGQpe1xuICAgICAgICAgICAgdmVjMi5zZXQod29ybGROb3JtYWxNYXgsIDAsIHR5MSA8IHR5MiA/IDEgOiAtMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0bWF4ID49IHRtaW4pe1xuICAgICAgICAvLyBIaXQgcG9pbnRcbiAgICAgICAgdmVjMi5zZXQoXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgcmF5U3RhcnRbMF0gKyBkaXJlY3Rpb25bMF0gKiB0bWluLFxuICAgICAgICAgICAgcmF5U3RhcnRbMV0gKyBkaXJlY3Rpb25bMV0gKiB0bWluXG4gICAgICAgICk7XG5cbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWxNaW4sIHdvcmxkTm9ybWFsTWluLCBhbmdsZSk7XG5cbiAgICAgICAgYm9keS50b1dvcmxkRnJhbWUoaGl0UG9pbnRXb3JsZCwgaGl0UG9pbnRXb3JsZCk7XG5cbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24od29ybGROb3JtYWxNaW4sIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCAtMSk7XG4gICAgICAgIGlmKHRoaXMuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWxNYXgsIHdvcmxkTm9ybWFsTWF4LCBhbmdsZSk7XG5cbiAgICAgICAgLy8gSGl0IHBvaW50XG4gICAgICAgIHZlYzIuc2V0KFxuICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgIHJheVN0YXJ0WzBdICsgZGlyZWN0aW9uWzBdICogdG1heCxcbiAgICAgICAgICAgIHJheVN0YXJ0WzFdICsgZGlyZWN0aW9uWzFdICogdG1heFxuICAgICAgICApO1xuICAgICAgICBib2R5LnRvV29ybGRGcmFtZShoaXRQb2ludFdvcmxkLCBoaXRQb2ludFdvcmxkKTtcblxuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbih3b3JsZE5vcm1hbE1heCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIC0xKTtcbiAgICB9XG59O1xuUmF5LnByb3RvdHlwZVtTaGFwZS5SRUNUQU5HTEVdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RSZWN0YW5nbGU7XG5cbnZhciBpbnRlcnNlY3RQbGFuZV9wbGFuZVBvaW50VG9Gcm9tID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RQbGFuZV9kaXJfc2NhbGVkX3dpdGhfdCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UGxhbmVfaGl0UG9pbnRXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UGxhbmVfd29ybGROb3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBsYW5lX2xlbiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RQbGFuZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmUgPSBmdW5jdGlvbihzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb247XG5cbiAgICB2YXIgcGxhbmVQb2ludFRvRnJvbSA9IGludGVyc2VjdFBsYW5lX3BsYW5lUG9pbnRUb0Zyb207XG4gICAgdmFyIGRpcl9zY2FsZWRfd2l0aF90ID0gaW50ZXJzZWN0UGxhbmVfZGlyX3NjYWxlZF93aXRoX3Q7XG4gICAgdmFyIGhpdFBvaW50V29ybGQgPSBpbnRlcnNlY3RQbGFuZV9oaXRQb2ludFdvcmxkO1xuICAgIHZhciB3b3JsZE5vcm1hbCA9IGludGVyc2VjdFBsYW5lX3dvcmxkTm9ybWFsO1xuICAgIHZhciBsZW4gPSBpbnRlcnNlY3RQbGFuZV9sZW47XG5cbiAgICAvLyBHZXQgcGxhbmUgbm9ybWFsXG4gICAgdmVjMi5zZXQod29ybGROb3JtYWwsIDAsIDEpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCwgYW5nbGUpO1xuXG4gICAgdmVjMi5zdWIobGVuLCBmcm9tLCBwb3NpdGlvbik7IC8vZnJvbS52c3ViKHBvc2l0aW9uLCBsZW4pO1xuICAgIHZhciBwbGFuZVRvRnJvbSA9IHZlYzIuZG90KGxlbiwgd29ybGROb3JtYWwpOyAvLyBsZW4uZG90KHdvcmxkTm9ybWFsKTtcbiAgICB2ZWMyLnN1YihsZW4sIHRvLCBwb3NpdGlvbik7IC8vIHRvLnZzdWIocG9zaXRpb24sIGxlbik7XG4gICAgdmFyIHBsYW5lVG9UbyA9IHZlYzIuZG90KGxlbiwgd29ybGROb3JtYWwpOyAvLyBsZW4uZG90KHdvcmxkTm9ybWFsKTtcblxuICAgIGlmKHBsYW5lVG9Gcm9tICogcGxhbmVUb1RvID4gMCl7XG4gICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgYXJlIG9uIHRoZSBzYW1lIHNpZGUgb2YgdGhlIHBsYW5lLi4uIGJhaWwgb3V0XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZih2ZWMyLmRpc3RhbmNlKGZyb20sIHRvKSAvKiBmcm9tLmRpc3RhbmNlVG8odG8pICovIDwgcGxhbmVUb0Zyb20pe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5fZG90X2RpciA9IHZlYzIuZG90KHdvcmxkTm9ybWFsLCBkaXJlY3Rpb24pOyAvLyB3b3JsZE5vcm1hbC5kb3QoZGlyZWN0aW9uKTtcblxuICAgIC8vIGlmIChNYXRoLmFicyhuX2RvdF9kaXIpIDwgdGhpcy5wcmVjaXNpb24pIHtcbiAgICAvLyAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgLy8gICAgIHJldHVybjtcbiAgICAvLyB9XG5cbiAgICB2ZWMyLnN1YihwbGFuZVBvaW50VG9Gcm9tLCBmcm9tLCBwb3NpdGlvbik7IC8vIGZyb20udnN1Yihwb3NpdGlvbiwgcGxhbmVQb2ludFRvRnJvbSk7XG4gICAgdmFyIHQgPSAtdmVjMi5kb3Qod29ybGROb3JtYWwsIHBsYW5lUG9pbnRUb0Zyb20pIC8gbl9kb3RfZGlyOyAvLyAtIHdvcmxkTm9ybWFsLmRvdChwbGFuZVBvaW50VG9Gcm9tKSAvIG5fZG90X2RpcjtcbiAgICB2ZWMyLnNjYWxlKGRpcl9zY2FsZWRfd2l0aF90LCBkaXJlY3Rpb24sIHQpOyAvLyBkaXJlY3Rpb24uc2NhbGUodCwgZGlyX3NjYWxlZF93aXRoX3QpO1xuICAgIHZlYzIuYWRkKGhpdFBvaW50V29ybGQsIGZyb20sIGRpcl9zY2FsZWRfd2l0aF90KTsgLy8gZnJvbS52YWRkKGRpcl9zY2FsZWRfd2l0aF90LCBoaXRQb2ludFdvcmxkKTtcblxuICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgLTEpO1xufTtcblJheS5wcm90b3R5cGVbU2hhcGUuUExBTkVdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RQbGFuZTtcblxudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsID0gdmVjMi5jcmVhdGUoKTtcblJheS5wcm90b3R5cGUuaW50ZXJzZWN0Q2lyY2xlID0gZnVuY3Rpb24oc2hhcGUsIGFuZ2xlLCBwb3NpdGlvbiwgYm9keSl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb20sXG4gICAgICAgIHRvID0gdGhpcy50byxcbiAgICAgICAgciA9IHNoYXBlLnJhZGl1cztcblxuICAgIHZhciBhID0gTWF0aC5wb3codG9bMF0gLSBmcm9tWzBdLCAyKSArIE1hdGgucG93KHRvWzFdIC0gZnJvbVsxXSwgMik7XG4gICAgdmFyIGIgPSAyICogKCh0b1swXSAtIGZyb21bMF0pICogKGZyb21bMF0gLSBwb3NpdGlvblswXSkgKyAodG9bMV0gLSBmcm9tWzFdKSAqIChmcm9tWzFdIC0gcG9zaXRpb25bMV0pKTtcbiAgICB2YXIgYyA9IE1hdGgucG93KGZyb21bMF0gLSBwb3NpdGlvblswXSwgMikgKyBNYXRoLnBvdyhmcm9tWzFdIC0gcG9zaXRpb25bMV0sIDIpIC0gTWF0aC5wb3cociwgMik7XG5cbiAgICB2YXIgZGVsdGEgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBhICogYztcblxuICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQ7XG4gICAgdmFyIG5vcm1hbCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsO1xuXG4gICAgaWYoZGVsdGEgPCAwKXtcbiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgICAgIHJldHVybjtcblxuICAgIH0gZWxzZSBpZihkZWx0YSA9PT0gMCl7XG4gICAgICAgIC8vIHNpbmdsZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgdmVjMi5sZXJwKGludGVyc2VjdGlvblBvaW50LCBmcm9tLCB0bywgZGVsdGEpOyAvLyBmcm9tLmxlcnAodG8sIGRlbHRhLCBpbnRlcnNlY3Rpb25Qb2ludCk7XG5cbiAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcG9zaXRpb24pOyAvLyBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTsgLy9ub3JtYWwubm9ybWFsaXplKCk7XG5cbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgc2hhcGUsIGJvZHksIC0xKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkMSA9ICgtIGIgLSBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7XG4gICAgICAgIHZhciBkMiA9ICgtIGIgKyBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7XG5cbiAgICAgICAgdmVjMi5sZXJwKGludGVyc2VjdGlvblBvaW50LCBmcm9tLCB0bywgZDEpOyAvLyBmcm9tLmxlcnAodG8sIGQxLCBpbnRlcnNlY3Rpb25Qb2ludCk7XG5cbiAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcG9zaXRpb24pOyAvLyBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTsgLy9ub3JtYWwubm9ybWFsaXplKCk7XG5cbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgc2hhcGUsIGJvZHksIC0xKTtcblxuICAgICAgICBpZih0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2ZWMyLmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkMik7IC8vIGZyb20ubGVycCh0bywgZDIsIGludGVyc2VjdGlvblBvaW50KTtcblxuICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7IC8vIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpOyAvL25vcm1hbC5ub3JtYWxpemUoKTtcblxuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBzaGFwZSwgYm9keSwgLTEpO1xuICAgIH1cbn07XG5SYXkucHJvdG90eXBlW1NoYXBlLkNJUkNMRV0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdENpcmNsZTtcblxuLyoqXG4gKiBHZXQgdGhlIEFBQkIgb2YgdGhlIHJheS5cbiAqIEBtZXRob2QgZ2V0QUFCQlxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICovXG5SYXkucHJvdG90eXBlLmdldEFBQkIgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHZhciB0byA9IHRoaXMudG87XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgcmVzdWx0Lmxvd2VyQm91bmRbMF0gPSBNYXRoLm1pbih0b1swXSwgZnJvbVswXSk7XG4gICAgcmVzdWx0Lmxvd2VyQm91bmRbMV0gPSBNYXRoLm1pbih0b1sxXSwgZnJvbVsxXSk7XG4gICAgcmVzdWx0LnVwcGVyQm91bmRbMF0gPSBNYXRoLm1heCh0b1swXSwgZnJvbVswXSk7XG4gICAgcmVzdWx0LnVwcGVyQm91bmRbMV0gPSBNYXRoLm1heCh0b1sxXSwgZnJvbVsxXSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcmVwb3J0SW50ZXJzZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7YXJyYXl9IG5vcm1hbFxuICogQHBhcmFtICB7YXJyYXl9IGhpdFBvaW50V29ybGRcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgaW50ZXJzZWN0aW9ucyBzaG91bGQgY29udGludWVcbiAqL1xuUmF5LnByb3RvdHlwZS5yZXBvcnRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihub3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCBoaXRGYWNlSW5kZXgpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHZhciB0byA9IHRoaXMudG87XG4gICAgdmFyIGRpc3RhbmNlID0gdmVjMi5kaXN0YW5jZShmcm9tLCBoaXRQb2ludFdvcmxkKTsgLy8gZnJvbS5kaXN0YW5jZVRvKGhpdFBvaW50V29ybGQpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcblxuICAgIC8vIFNraXAgYmFjayBmYWNlcz9cbiAgICBpZih0aGlzLnNraXBCYWNrZmFjZXMgJiYgLyogbm9ybWFsLmRvdCh0aGlzLl9kaXJlY3Rpb24pICovIHZlYzIuZG90KG5vcm1hbCwgdGhpcy5fZGlyZWN0aW9uKSA+IDApe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzdWx0LmhpdEZhY2VJbmRleCA9IHR5cGVvZihoaXRGYWNlSW5kZXgpICE9PSAndW5kZWZpbmVkJyA/IGhpdEZhY2VJbmRleCA6IC0xO1xuXG4gICAgc3dpdGNoKHRoaXMubW9kZSl7XG4gICAgY2FzZSBSYXkuQUxMOlxuICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFJheS5DTE9TRVNUOlxuXG4gICAgICAgIC8vIFN0b3JlIGlmIGNsb3NlciB0aGFuIGN1cnJlbnQgY2xvc2VzdFxuICAgICAgICBpZihkaXN0YW5jZSA8IHJlc3VsdC5kaXN0YW5jZSB8fCAhcmVzdWx0Lmhhc0hpdCl7XG4gICAgICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBSYXkuQU5ZOlxuXG4gICAgICAgIC8vIFJlcG9ydCBhbmQgc3RvcC5cbiAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIG5vcm1hbCxcbiAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICApO1xuICAgICAgICByZXN1bHQuX3Nob3VsZFN0b3AgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG52YXIgdjAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGludGVyc2VjdCA9IHZlYzIuY3JlYXRlKCk7XG5mdW5jdGlvbiBkaXN0YW5jZUZyb21JbnRlcnNlY3Rpb24oZnJvbSwgZGlyZWN0aW9uLCBwb3NpdGlvbikge1xuXG4gICAgLy8gdjAgaXMgdmVjdG9yIGZyb20gZnJvbSB0byBwb3NpdGlvblxuICAgIHZlYzIuc3ViKHYwLCBwb3NpdGlvbiwgZnJvbSk7IC8vIHBvc2l0aW9uLnZzdWIoZnJvbSx2MCk7XG4gICAgdmFyIGRvdCA9IHZlYzIuZG90KHYwLCBkaXJlY3Rpb24pOyAvLyB2MC5kb3QoZGlyZWN0aW9uKTtcblxuICAgIC8vIGludGVyc2VjdCA9IGRpcmVjdGlvbipkb3QgKyBmcm9tXG4gICAgdmVjMi5zY2FsZShpbnRlcnNlY3QsIGRpcmVjdGlvbiwgZG90KTsgLy9kaXJlY3Rpb24ubXVsdChkb3QsaW50ZXJzZWN0KTtcbiAgICB2ZWMyLmFkZChpbnRlcnNlY3QsIGludGVyc2VjdCwgZnJvbSk7IC8vIGludGVyc2VjdC52YWRkKGZyb20sIGludGVyc2VjdCk7XG5cbiAgICB2YXIgZGlzdGFuY2UgPSB2ZWMyLmRpc3RhbmNlKHBvc2l0aW9uLCBpbnRlcnNlY3QpOyAvLyBwb3NpdGlvbi5kaXN0YW5jZVRvKGludGVyc2VjdCk7XG5cbiAgICByZXR1cm4gZGlzdGFuY2U7XG59XG5cblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjcsXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEzLFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NX1dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmF5Y2FzdFJlc3VsdDtcblxuLyoqXG4gKiBTdG9yYWdlIGZvciBSYXkgY2FzdGluZyBkYXRhLlxuICogQGNsYXNzIFJheWNhc3RSZXN1bHRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSYXljYXN0UmVzdWx0KCl7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7YXJyYXl9IHJheUZyb21Xb3JsZFxuXHQgKi9cblx0dGhpcy5yYXlGcm9tV29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge2FycmF5fSByYXlUb1dvcmxkXG5cdCAqL1xuXHR0aGlzLnJheVRvV29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge2FycmF5fSBoaXROb3JtYWxXb3JsZFxuXHQgKi9cblx0dGhpcy5oaXROb3JtYWxXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7YXJyYXl9IGhpdFBvaW50V29ybGRcblx0ICovXG5cdHRoaXMuaGl0UG9pbnRXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzSGl0XG5cdCAqL1xuXHR0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgaGl0IHNoYXBlLCBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge1NoYXBlfSBzaGFwZVxuXHQgKi9cblx0dGhpcy5zaGFwZSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBoaXQgYm9keSwgb3IgbnVsbC5cblx0ICogQHByb3BlcnR5IHtCb2R5fSBib2R5XG5cdCAqL1xuXHR0aGlzLmJvZHkgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBUaGUgaW5kZXggb2YgdGhlIGhpdCB0cmlhbmdsZSwgaWYgdGhlIGhpdCBzaGFwZSB3YXMgYSB0cmltZXNoLlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gaGl0RmFjZUluZGV4XG5cdCAqIEBkZWZhdWx0IC0xXG5cdCAqL1xuXHR0aGlzLmhpdEZhY2VJbmRleCA9IC0xO1xuXG5cdC8qKlxuXHQgKiBEaXN0YW5jZSB0byB0aGUgaGl0LiBXaWxsIGJlIHNldCB0byAtMSBpZiB0aGVyZSB3YXMgbm8gaGl0LlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gZGlzdGFuY2Vcblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuZGlzdGFuY2UgPSAtMTtcblxuXHQvKipcblx0ICogSWYgdGhlIHJheSBzaG91bGQgc3RvcCB0cmF2ZXJzaW5nIHRoZSBib2RpZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gX3Nob3VsZFN0b3Bcblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdHRoaXMuX3Nob3VsZFN0b3AgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXNldCBhbGwgcmVzdWx0IGRhdGEuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHR2ZWMyLnNldCh0aGlzLnJheUZyb21Xb3JsZCwgMCwgMCk7XG5cdHZlYzIuc2V0KHRoaXMucmF5VG9Xb3JsZCwgMCwgMCk7XG5cdHZlYzIuc2V0KHRoaXMuaGl0Tm9ybWFsV29ybGQsIDAsIDApO1xuXHR2ZWMyLnNldCh0aGlzLmhpdFBvaW50V29ybGQsIDAsIDApO1xuXHR0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblx0dGhpcy5ib2R5ID0gbnVsbDtcblx0dGhpcy5oaXRGYWNlSW5kZXggPSAtMTtcblx0dGhpcy5kaXN0YW5jZSA9IC0xO1xuXHR0aGlzLl9zaG91bGRTdG9wID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgYWJvcnRcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuXHR0aGlzLl9zaG91bGRTdG9wID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7YXJyYXl9IHJheUZyb21Xb3JsZFxuICogQHBhcmFtIHthcnJheX0gcmF5VG9Xb3JsZFxuICogQHBhcmFtIHthcnJheX0gaGl0Tm9ybWFsV29ybGRcbiAqIEBwYXJhbSB7YXJyYXl9IGhpdFBvaW50V29ybGRcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICovXG5SYXljYXN0UmVzdWx0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihcblx0cmF5RnJvbVdvcmxkLFxuXHRyYXlUb1dvcmxkLFxuXHRoaXROb3JtYWxXb3JsZCxcblx0aGl0UG9pbnRXb3JsZCxcblx0c2hhcGUsXG5cdGJvZHksXG5cdGRpc3RhbmNlXG4pe1xuXHR2ZWMyLmNvcHkodGhpcy5yYXlGcm9tV29ybGQsIHJheUZyb21Xb3JsZCk7XG5cdHZlYzIuY29weSh0aGlzLnJheVRvV29ybGQsIHJheVRvV29ybGQpO1xuXHR2ZWMyLmNvcHkodGhpcy5oaXROb3JtYWxXb3JsZCwgaGl0Tm9ybWFsV29ybGQpO1xuXHR2ZWMyLmNvcHkodGhpcy5oaXRQb2ludFdvcmxkLCBoaXRQb2ludFdvcmxkKTtcblx0dGhpcy5zaGFwZSA9IHNoYXBlO1xuXHR0aGlzLmJvZHkgPSBib2R5O1xuXHR0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG59O1xufSx7XCIuLi9tYXRoL3ZlYzJcIjozMX1dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICBCcm9hZHBoYXNlID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTQVBCcm9hZHBoYXNlO1xuXG4vKipcbiAqIFN3ZWVwIGFuZCBwcnVuZSBicm9hZHBoYXNlIGFsb25nIG9uZSBheGlzLlxuICpcbiAqIEBjbGFzcyBTQVBCcm9hZHBoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEJyb2FkcGhhc2VcbiAqL1xuZnVuY3Rpb24gU0FQQnJvYWRwaGFzZSgpe1xuICAgIEJyb2FkcGhhc2UuY2FsbCh0aGlzLEJyb2FkcGhhc2UuU0FQKTtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYm9kaWVzIGN1cnJlbnRseSBpbiB0aGUgYnJvYWRwaGFzZS5cbiAgICAgKiBAcHJvcGVydHkgYXhpc0xpc3RcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5heGlzTGlzdCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGF4aXMgdG8gc29ydCBhbG9uZy4gMCBtZWFucyB4LWF4aXMgYW5kIDEgeS1heGlzLiBJZiB5b3VyIGJvZGllcyBhcmUgbW9yZSBzcHJlYWQgb3V0IG92ZXIgdGhlIFggYXhpcywgc2V0IGF4aXNJbmRleCB0byAwLCBhbmQgeW91IHdpbGwgZ2FpbiBzb21lIHBlcmZvcm1hbmNlLlxuICAgICAqIEBwcm9wZXJ0eSBheGlzSW5kZXhcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYXhpc0luZGV4ID0gMDtcblxuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLl9hZGRCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB0aGF0LmF4aXNMaXN0LnB1c2goZS5ib2R5KTtcbiAgICB9O1xuXG4gICAgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gbGlzdFxuICAgICAgICB2YXIgaWR4ID0gdGhhdC5heGlzTGlzdC5pbmRleE9mKGUuYm9keSk7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgdGhhdC5heGlzTGlzdC5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU0FQQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHdvcmxkXG4gKiBAbWV0aG9kIHNldFdvcmxkXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICAvLyBDbGVhciB0aGUgb2xkIGF4aXMgYXJyYXlcbiAgICB0aGlzLmF4aXNMaXN0Lmxlbmd0aCA9IDA7XG5cbiAgICAvLyBBZGQgYWxsIGJvZGllcyBmcm9tIHRoZSBuZXcgd29ybGRcbiAgICBVdGlscy5hcHBlbmRBcnJheSh0aGlzLmF4aXNMaXN0LCB3b3JsZC5ib2RpZXMpO1xuXG4gICAgLy8gUmVtb3ZlIG9sZCBoYW5kbGVycywgaWYgYW55XG4gICAgd29ybGRcbiAgICAgICAgLm9mZihcImFkZEJvZHlcIix0aGlzLl9hZGRCb2R5SGFuZGxlcilcbiAgICAgICAgLm9mZihcInJlbW92ZUJvZHlcIix0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7XG5cbiAgICAvLyBBZGQgaGFuZGxlcnMgdG8gdXBkYXRlIHRoZSBsaXN0IG9mIGJvZGllcy5cbiAgICB3b3JsZC5vbihcImFkZEJvZHlcIix0aGlzLl9hZGRCb2R5SGFuZGxlcikub24oXCJyZW1vdmVCb2R5XCIsdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpO1xuXG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xufTtcblxuLyoqXG4gKiBTb3J0cyBib2RpZXMgYWxvbmcgYW4gYXhpcy5cbiAqIEBtZXRob2Qgc29ydEF4aXNMaXN0XG4gKiBAcGFyYW0ge0FycmF5fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5zb3J0QXhpc0xpc3QgPSBmdW5jdGlvbihhLCBheGlzSW5kZXgpe1xuICAgIGF4aXNJbmRleCA9IGF4aXNJbmRleHwwO1xuICAgIGZvcih2YXIgaT0xLGw9YS5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgIHZhciB2ID0gYVtpXTtcbiAgICAgICAgZm9yKHZhciBqPWkgLSAxO2o+PTA7ai0tKSB7XG4gICAgICAgICAgICBpZihhW2pdLmFhYmIubG93ZXJCb3VuZFtheGlzSW5kZXhdIDw9IHYuYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0pe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVtqKzFdID0gYVtqXTtcbiAgICAgICAgfVxuICAgICAgICBhW2orMV0gPSB2O1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNvcnRMaXN0ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCxcbiAgICBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcblxuICAgIC8vIFNvcnQgdGhlIGxpc3RzXG4gICAgU0FQQnJvYWRwaGFzZS5zb3J0QXhpc0xpc3QoYm9kaWVzLCBheGlzSW5kZXgpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbGxpZGluZyBwYWlyc1xuICogQG1ldGhvZCBnZXRDb2xsaXNpb25QYWlyc1xuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsXG4gICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0LFxuICAgICAgICBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcblxuICAgIHJlc3VsdC5sZW5ndGggPSAwO1xuXG4gICAgLy8gVXBkYXRlIGFsbCBBQUJCcyBpZiBuZWVkZWRcbiAgICB2YXIgbCA9IGJvZGllcy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGIgPSBib2RpZXNbbF07XG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGIudXBkYXRlQUFCQigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCB0aGUgbGlzdHNcbiAgICB0aGlzLnNvcnRMaXN0KCk7XG5cbiAgICAvLyBMb29rIHRocm91Z2ggdGhlIFggbGlzdFxuICAgIGZvcih2YXIgaT0wLCBOPWJvZGllcy5sZW5ndGh8MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcblxuICAgICAgICBmb3IodmFyIGo9aSsxOyBqPE47IGorKyl7XG4gICAgICAgICAgICB2YXIgYmogPSBib2RpZXNbal07XG5cbiAgICAgICAgICAgIC8vIEJvdW5kcyBvdmVybGFwP1xuICAgICAgICAgICAgdmFyIG92ZXJsYXBzID0gKGJqLmFhYmIubG93ZXJCb3VuZFtheGlzSW5kZXhdIDw9IGJpLmFhYmIudXBwZXJCb3VuZFtheGlzSW5kZXhdKTtcbiAgICAgICAgICAgIGlmKCFvdmVybGFwcyl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKEJyb2FkcGhhc2UuY2FuQ29sbGlkZShiaSxiaikgJiYgdGhpcy5ib3VuZGluZ1ZvbHVtZUNoZWNrKGJpLGJqKSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmksYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gYW4gQUFCQi5cbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICAgIHRoaXMuc29ydExpc3QoKTtcblxuICAgIHZhciBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcbiAgICB2YXIgYXhpcyA9ICd4JztcbiAgICBpZihheGlzSW5kZXggPT09IDEpeyBheGlzID0gJ3knOyB9XG4gICAgaWYoYXhpc0luZGV4ID09PSAyKXsgYXhpcyA9ICd6JzsgfVxuXG4gICAgdmFyIGF4aXNMaXN0ID0gdGhpcy5heGlzTGlzdDtcbiAgICB2YXIgbG93ZXIgPSBhYWJiLmxvd2VyQm91bmRbYXhpc107XG4gICAgdmFyIHVwcGVyID0gYWFiYi51cHBlckJvdW5kW2F4aXNdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBheGlzTGlzdC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYXhpc0xpc3RbaV07XG5cbiAgICAgICAgaWYoYi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgYi51cGRhdGVBQUJCKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihiLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbn0se1wiLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo4LFwiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gQ29uc3RyYWludDtcblxudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxuLyoqXG4gKiBCYXNlIGNvbnN0cmFpbnQgY2xhc3MuXG4gKlxuICogQGNsYXNzIENvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkPXRydWVdXG4gKi9cbmZ1bmN0aW9uIENvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB0eXBlLCBvcHRpb25zKXtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIGNvbnN0cmFpbnQuIE1heSBiZSBvbmUgb2YgQ29uc3RyYWludC5ESVNUQU5DRSwgQ29uc3RyYWludC5HRUFSLCBDb25zdHJhaW50LkxPQ0ssIENvbnN0cmFpbnQuUFJJU01BVElDIG9yIENvbnN0cmFpbnQuUkVWT0xVVEUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICBjb2xsaWRlQ29ubmVjdGVkIDogdHJ1ZSxcbiAgICAgICAgd2FrZVVwQm9kaWVzIDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEVxdWF0aW9ucyB0byBiZSBzb2x2ZWQgaW4gdGhpcyBjb25zdHJhaW50XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbnN0cmFpbnQuXG4gICAgICogQHByb3BlcnR5IGJvZHlBXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuXG4gICAgLyoqXG4gICAgICogU2Vjb25kIGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgY29uc3RyYWludC5cbiAgICAgKiBAcHJvcGVydHkgYm9keUJcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgY29ubmVjdGVkIGJvZGllcyB0byBjb2xsaWRlLlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaWRlQ29ubmVjdGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9IG9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZDtcblxuICAgIC8vIFdha2UgdXAgYm9kaWVzIHdoZW4gY29ubmVjdGVkXG4gICAgaWYob3B0aW9ucy53YWtlVXBCb2RpZXMpe1xuICAgICAgICBpZihib2R5QSl7XG4gICAgICAgICAgICBib2R5QS53YWtlVXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZihib2R5Qil7XG4gICAgICAgICAgICBib2R5Qi53YWtlVXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBjb25zdHJhaW50IHBhcmFtZXRlcnMgYmVmb3JlIHNvbHZlLlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXRob2QgdXBkYXRlKCkgbm90IGltcGxtZW1lbnRlZCBpbiB0aGlzIENvbnN0cmFpbnQgc3ViY2xhc3MhXCIpO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gRElTVEFOQ0VcbiAqL1xuQ29uc3RyYWludC5ESVNUQU5DRSA9IDE7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IEdFQVJcbiAqL1xuQ29uc3RyYWludC5HRUFSID0gMjtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gTE9DS1xuICovXG5Db25zdHJhaW50LkxPQ0sgPSAzO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBQUklTTUFUSUNcbiAqL1xuQ29uc3RyYWludC5QUklTTUFUSUMgPSA0O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSRVZPTFVURVxuICovXG5Db25zdHJhaW50LlJFVk9MVVRFID0gNTtcblxuLyoqXG4gKiBTZXQgc3RpZmZuZXNzIGZvciB0aGlzIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIHNldFN0aWZmbmVzc1xuICogQHBhcmFtIHtOdW1iZXJ9IHN0aWZmbmVzc1xuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS5zZXRTdGlmZm5lc3MgPSBmdW5jdGlvbihzdGlmZm5lc3Mpe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gZXFzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xuICAgICAgICBlcS5zdGlmZm5lc3MgPSBzdGlmZm5lc3M7XG4gICAgICAgIGVxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCByZWxheGF0aW9uIGZvciB0aGlzIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIHNldFJlbGF4YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByZWxheGF0aW9uXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnNldFJlbGF4YXRpb24gPSBmdW5jdGlvbihyZWxheGF0aW9uKXtcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGVxcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tpXTtcbiAgICAgICAgZXEucmVsYXhhdGlvbiA9IHJlbGF4YXRpb247XG4gICAgICAgIGVxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG59O1xuXG59LHtcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSwxNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpXG4sICAgRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZUNvbnN0cmFpbnQ7XG5cbi8qKlxuICogQ29uc3RyYWludCB0aGF0IHRyaWVzIHRvIGtlZXAgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGJvZGllcyBjb25zdGFudC5cbiAqXG4gKiBAY2xhc3MgRGlzdGFuY2VDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZV0gVGhlIGRpc3RhbmNlIHRvIGtlZXAgYmV0d2VlbiB0aGUgYW5jaG9yIHBvaW50cy4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm9kaWVzLlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubG9jYWxBbmNob3JBXSBUaGUgYW5jaG9yIHBvaW50IGZvciBib2R5QSwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBIGZyYW1lLiBEZWZhdWx0cyB0byBbMCwwXS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsQW5jaG9yQl0gVGhlIGFuY2hvciBwb2ludCBmb3IgYm9keUIsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QiBmcmFtZS4gRGVmYXVsdHMgdG8gWzAsMF0uXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubWF4Rm9yY2U9TnVtYmVyLk1BWF9WQUxVRV0gTWF4aW11bSBmb3JjZSB0byBhcHBseS5cbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIElmIGRpc3RhbmNlIGlzIG5vdCBnaXZlbiBhcyBhbiBvcHRpb24sIHRoZW4gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm9kaWVzIGlzIHVzZWQuXG4gKiAgICAgLy8gSW4gdGhpcyBleGFtcGxlLCB0aGUgYm9kaWVzIHdpbGwgYmUgY29uc3RyYWluZWQgdG8gaGF2ZSBhIGRpc3RhbmNlIG9mIDIgYmV0d2VlbiB0aGVpciBjZW50ZXJzLlxuICogICAgIHZhciBib2R5QSA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFstMSwgMF0gfSk7XG4gKiAgICAgdmFyIGJvZHlCID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWzEsIDBdIH0pO1xuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IERpc3RhbmNlQ29uc3RyYWludChib2R5QSwgYm9keUIpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xuICogICAgICAgICBkaXN0YW5jZTogMSwgICAgICAgICAgLy8gRGlzdGFuY2UgdG8ga2VlcCBiZXR3ZWVuIHRoZSBwb2ludHNcbiAqICAgICAgICAgbG9jYWxBbmNob3JBOiBbMSwgMF0sIC8vIFBvaW50IG9uIGJvZHlBXG4gKiAgICAgICAgIGxvY2FsQW5jaG9yQjogWy0xLCAwXSAvLyBQb2ludCBvbiBib2R5QlxuICogICAgIH0pO1xuICovXG5mdW5jdGlvbiBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsYm9keUIsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICBsb2NhbEFuY2hvckE6WzAsMF0sXG4gICAgICAgIGxvY2FsQW5jaG9yQjpbMCwwXVxuICAgIH0pO1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIsQ29uc3RyYWludC5ESVNUQU5DRSxvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIExvY2FsIGFuY2hvciBpbiBib2R5IEEuXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLmxvY2FsQW5jaG9yQVswXSwgb3B0aW9ucy5sb2NhbEFuY2hvckFbMV0pO1xuXG4gICAgLyoqXG4gICAgICogTG9jYWwgYW5jaG9yIGluIGJvZHkgQi5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JCID0gdmVjMi5mcm9tVmFsdWVzKG9wdGlvbnMubG9jYWxBbmNob3JCWzBdLCBvcHRpb25zLmxvY2FsQW5jaG9yQlsxXSk7XG5cbiAgICB2YXIgbG9jYWxBbmNob3JBID0gdGhpcy5sb2NhbEFuY2hvckE7XG4gICAgdmFyIGxvY2FsQW5jaG9yQiA9IHRoaXMubG9jYWxBbmNob3JCO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIHRvIGtlZXAuXG4gICAgICogQHByb3BlcnR5IGRpc3RhbmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRpc3RhbmNlID0gMDtcblxuICAgIGlmKHR5cGVvZihvcHRpb25zLmRpc3RhbmNlKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2UgdGhlIGN1cnJlbnQgd29ybGQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cbiAgICAgICAgdmFyIHdvcmxkQW5jaG9yQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgICAgICB3b3JsZEFuY2hvckIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICAgICAgciA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRBbmNob3JBLCBsb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRBbmNob3JCLCBsb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcblxuICAgICAgICB2ZWMyLmFkZChyLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRBbmNob3JCKTtcbiAgICAgICAgdmVjMi5zdWIociwgciwgd29ybGRBbmNob3JBKTtcbiAgICAgICAgdmVjMi5zdWIociwgciwgYm9keUEucG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSB2ZWMyLmxlbmd0aChyKTtcbiAgICB9XG5cbiAgICB2YXIgbWF4Rm9yY2U7XG4gICAgaWYodHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiApe1xuICAgICAgICBtYXhGb3JjZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWF4Rm9yY2UgPSBvcHRpb25zLm1heEZvcmNlO1xuICAgIH1cblxuICAgIHZhciBub3JtYWwgPSBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTsgLy8gSnVzdCBpbiB0aGUgbm9ybWFsIGRpcmVjdGlvblxuICAgIHRoaXMuZXF1YXRpb25zID0gWyBub3JtYWwgXTtcblxuICAgIC8qKlxuICAgICAqIE1heCBmb3JjZSB0byBhcHBseS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4Rm9yY2VcbiAgICAgKi9cbiAgICB0aGlzLm1heEZvcmNlID0gbWF4Rm9yY2U7XG5cbiAgICAvLyBnID0gKHhpIC0geGopLmRvdChuKVxuICAgIC8vIGRnL2R0ID0gKHZpIC0gdmopLmRvdChuKSA9IEcqVyA9IFtuIDAgLW4gMF0gKiBbdmkgd2kgdmogd2pdJ1xuXG4gICAgLy8gLi4uYW5kIGlmIHdlIHdlcmUgdG8gaW5jbHVkZSBvZmZzZXQgcG9pbnRzIChUT0RPIGZvciBub3cpOlxuICAgIC8vIGcgPVxuICAgIC8vICAgICAgKHhqICsgcmogLSB4aSAtIHJpKS5kb3QobikgLSBkaXN0YW5jZVxuICAgIC8vXG4gICAgLy8gZGcvZHQgPVxuICAgIC8vICAgICAgKHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaSkuZG90KG4pID1cbiAgICAvLyAgICAgIHsgdGVybSAyIGlzIG5lYXIgemVybyB9ID1cbiAgICAvLyAgICAgIFstbiAgIC1yaSB4IG4gICBuICAgcmogeCBuXSAqIFt2aSB3aSB2aiB3al0nID1cbiAgICAvLyAgICAgIEcgKiBXXG4gICAgLy9cbiAgICAvLyA9PiBHID0gWy1uIC1yaXhuIG4gcmp4bl1cblxuICAgIHZhciByID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgcmkgPSB2ZWMyLmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckFcbiAgICB2YXIgcmogPSB2ZWMyLmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgbm9ybWFsLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgICAgICB4aSA9IGJvZHlBLnBvc2l0aW9uLFxuICAgICAgICAgICAgeGogPSBib2R5Qi5wb3NpdGlvbjtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gbG9jYWwgYW5jaG9ycyB0byB3b3JsZFxuICAgICAgICB2ZWMyLnJvdGF0ZShyaSwgbG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHJqLCBsb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcblxuICAgICAgICB2ZWMyLmFkZChyLCB4aiwgcmopO1xuICAgICAgICB2ZWMyLnN1YihyLCByLCByaSk7XG4gICAgICAgIHZlYzIuc3ViKHIsIHIsIHhpKTtcblxuICAgICAgICAvL3ZlYzIuc3ViKHIsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB2ZWMyLmxlbmd0aChyKSAtIHRoYXQuZGlzdGFuY2U7XG4gICAgfTtcblxuICAgIC8vIE1ha2UgdGhlIGNvbnRhY3QgY29uc3RyYWludCBiaWxhdGVyYWxcbiAgICB0aGlzLnNldE1heEZvcmNlKG1heEZvcmNlKTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSB1cHBlciBsaW1pdCBpcyBlbmFibGVkIG9yIG5vdC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVwcGVyTGltaXRFbmFibGVkXG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGNvbnN0cmFpbnQgbGltaXQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHVwcGVyTGltaXRcbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXQgPSAxO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGxvd2VyIGxpbWl0IGlzIGVuYWJsZWQgb3Igbm90LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbG93ZXJMaW1pdEVuYWJsZWRcbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG93ZXIgY29uc3RyYWludCBsaW1pdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbG93ZXJMaW1pdFxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGNvbnN0cmFpbnQgcG9zaXRpb24uIFRoaXMgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcG9zaXRpb25cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcbn1cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpc3RhbmNlQ29uc3RyYWludDtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbnN0cmFpbnQgZXF1YXRpb25zLiBTaG91bGQgYmUgZG9uZSBpZiBhbnkgb2YgdGhlIGJvZGllcyBjaGFuZ2VkIHBvc2l0aW9uLCBiZWZvcmUgc29sdmluZy5cbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbnZhciBuID0gdmVjMi5jcmVhdGUoKTtcbnZhciByaSA9IHZlYzIuY3JlYXRlKCk7IC8vIHdvcmxkQW5jaG9yQVxudmFyIHJqID0gdmVjMi5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JCXG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlLFxuICAgICAgICB4aSA9IGJvZHlBLnBvc2l0aW9uLFxuICAgICAgICB4aiA9IGJvZHlCLnBvc2l0aW9uLFxuICAgICAgICBub3JtYWxFcXVhdGlvbiA9IHRoaXMuZXF1YXRpb25zWzBdLFxuICAgICAgICBHID0gbm9ybWFsLkc7XG5cbiAgICAvLyBUcmFuc2Zvcm0gbG9jYWwgYW5jaG9ycyB0byB3b3JsZFxuICAgIHZlYzIucm90YXRlKHJpLCB0aGlzLmxvY2FsQW5jaG9yQSwgYm9keUEuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHJqLCB0aGlzLmxvY2FsQW5jaG9yQiwgYm9keUIuYW5nbGUpO1xuXG4gICAgLy8gR2V0IHdvcmxkIGFuY2hvciBwb2ludHMgYW5kIG5vcm1hbFxuICAgIHZlYzIuYWRkKG4sIHhqLCByaik7XG4gICAgdmVjMi5zdWIobiwgbiwgcmkpO1xuICAgIHZlYzIuc3ViKG4sIG4sIHhpKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gdmVjMi5sZW5ndGgobik7XG5cbiAgICB2YXIgdmlvbGF0aW5nID0gZmFsc2U7XG4gICAgaWYodGhpcy51cHBlckxpbWl0RW5hYmxlZCl7XG4gICAgICAgIGlmKHRoaXMucG9zaXRpb24gPiB0aGlzLnVwcGVyTGltaXQpe1xuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWF4Rm9yY2UgPSAwO1xuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWluRm9yY2UgPSAtdGhpcy5tYXhGb3JjZTtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLnVwcGVyTGltaXQ7XG4gICAgICAgICAgICB2aW9sYXRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5sb3dlckxpbWl0RW5hYmxlZCl7XG4gICAgICAgIGlmKHRoaXMucG9zaXRpb24gPCB0aGlzLmxvd2VyTGltaXQpe1xuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWF4Rm9yY2UgPSB0aGlzLm1heEZvcmNlO1xuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWluRm9yY2UgPSAwO1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHRoaXMubG93ZXJMaW1pdDtcbiAgICAgICAgICAgIHZpb2xhdGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZigodGhpcy5sb3dlckxpbWl0RW5hYmxlZCB8fCB0aGlzLnVwcGVyTGltaXRFbmFibGVkKSAmJiAhdmlvbGF0aW5nKXtcbiAgICAgICAgLy8gTm8gY29uc3RyYWludCBuZWVkZWQuXG4gICAgICAgIG5vcm1hbEVxdWF0aW9uLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5vcm1hbEVxdWF0aW9uLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgdmVjMi5ub3JtYWxpemUobixuKTtcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIHZhciByaXhuID0gdmVjMi5jcm9zc0xlbmd0aChyaSwgbiksXG4gICAgICAgIHJqeG4gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJqLCBuKTtcblxuICAgIC8vIEcgPSBbLW4gLXJpeG4gbiByanhuXVxuICAgIEdbMF0gPSAtblswXTtcbiAgICBHWzFdID0gLW5bMV07XG4gICAgR1syXSA9IC1yaXhuO1xuICAgIEdbM10gPSBuWzBdO1xuICAgIEdbNF0gPSBuWzFdO1xuICAgIEdbNV0gPSByanhuO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCBmb3JjZSB0byBiZSB1c2VkXG4gKiBAbWV0aG9kIHNldE1heEZvcmNlXG4gKiBAcGFyYW0ge051bWJlcn0gZlxuICovXG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heEZvcmNlID0gZnVuY3Rpb24oZil7XG4gICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdO1xuICAgIG5vcm1hbC5taW5Gb3JjZSA9IC1mO1xuICAgIG5vcm1hbC5tYXhGb3JjZSA9ICBmO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1heCBmb3JjZVxuICogQG1ldGhvZCBnZXRNYXhGb3JjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLmdldE1heEZvcmNlID0gZnVuY3Rpb24oZil7XG4gICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdO1xuICAgIHJldHVybiBub3JtYWwubWF4Rm9yY2U7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjUwLFwiLi9Db25zdHJhaW50XCI6MTV9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpXG4sICAgRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKVxuLCAgIEFuZ2xlTG9ja0VxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0FuZ2xlTG9ja0VxdWF0aW9uJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR2VhckNvbnN0cmFpbnQ7XG5cbi8qKlxuICogQ29ubmVjdHMgdHdvIGJvZGllcyBhdCBnaXZlbiBvZmZzZXQgcG9pbnRzLCBsZXR0aW5nIHRoZW0gcm90YXRlIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIgYXJvdW5kIHRoaXMgcG9pbnQuXG4gKiBAY2xhc3MgR2VhckNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSAgICAgICAgICAgIGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9ICAgICAgICAgICAgYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICBbb3B0aW9ucy5hbmdsZT0wXSBSZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHRoZSBib2RpZXMuIFdpbGwgYmUgc2V0IHRvIHRoZSBjdXJyZW50IGFuZ2xlIGJldHdlZW4gdGhlIGJvZGllcyAodGhlIGdlYXIgcmF0aW8gaXMgYWNjb3VudGVkIGZvcikuXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgW29wdGlvbnMucmF0aW89MV0gR2VhciByYXRpby5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICBbb3B0aW9ucy5tYXhUb3JxdWVdIE1heGltdW0gdG9ycXVlIHRvIGFwcGx5LlxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICogQHRvZG8gQWJpbGl0eSB0byBzcGVjaWZ5IHdvcmxkIHBvaW50c1xuICovXG5mdW5jdGlvbiBHZWFyQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgQ29uc3RyYWludC5HRUFSLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBnZWFyIHJhdGlvLlxuICAgICAqIEBwcm9wZXJ0eSByYXRpb1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yYXRpbyA9IHR5cGVvZihvcHRpb25zLnJhdGlvKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmF0aW8gOiAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlbGF0aXZlIGFuZ2xlXG4gICAgICogQHByb3BlcnR5IGFuZ2xlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gdHlwZW9mKG9wdGlvbnMuYW5nbGUpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5hbmdsZSA6IGJvZHlCLmFuZ2xlIC0gdGhpcy5yYXRpbyAqIGJvZHlBLmFuZ2xlO1xuXG4gICAgLy8gU2VuZCBzYW1lIHBhcmFtZXRlcnMgdG8gdGhlIGVxdWF0aW9uXG4gICAgb3B0aW9ucy5hbmdsZSA9IHRoaXMuYW5nbGU7XG4gICAgb3B0aW9ucy5yYXRpbyA9IHRoaXMucmF0aW87XG5cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtcbiAgICAgICAgbmV3IEFuZ2xlTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpLFxuICAgIF07XG5cbiAgICAvLyBTZXQgbWF4IHRvcnF1ZVxuICAgIGlmKHR5cGVvZihvcHRpb25zLm1heFRvcnF1ZSkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgICB0aGlzLnNldE1heFRvcnF1ZShvcHRpb25zLm1heFRvcnF1ZSk7XG4gICAgfVxufVxuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlYXJDb25zdHJhaW50O1xuXG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZXEgPSB0aGlzLmVxdWF0aW9uc1swXTtcbiAgICBpZihlcS5yYXRpbyAhPT0gdGhpcy5yYXRpbyl7XG4gICAgICAgIGVxLnNldFJhdGlvKHRoaXMucmF0aW8pO1xuICAgIH1cbiAgICBlcS5hbmdsZSA9IHRoaXMuYW5nbGU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4IHRvcnF1ZSBmb3IgdGhlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIHNldE1heFRvcnF1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcnF1ZVxuICovXG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TWF4VG9ycXVlID0gZnVuY3Rpb24odG9ycXVlKXtcbiAgICB0aGlzLmVxdWF0aW9uc1swXS5zZXRNYXhUb3JxdWUodG9ycXVlKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXggdG9ycXVlIGZvciB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2QgZ2V0TWF4VG9ycXVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhUb3JxdWUgPSBmdW5jdGlvbih0b3JxdWUpe1xuICAgIHJldHVybiB0aGlzLmVxdWF0aW9uc1swXS5tYXhGb3JjZTtcbn07XG59LHtcIi4uL2VxdWF0aW9ucy9BbmdsZUxvY2tFcXVhdGlvblwiOjIxLFwiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjMsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vQ29uc3RyYWludFwiOjE1fV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0VxdWF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9ja0NvbnN0cmFpbnQ7XG5cbi8qKlxuICogTG9ja3MgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGJldHdlZW4gdHdvIGJvZGllcy5cbiAqXG4gKiBAY2xhc3MgTG9ja0NvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsT2Zmc2V0Ql0gVGhlIG9mZnNldCBvZiBib2R5QiBpbiBib2R5QSdzIGZyYW1lLiBJZiBub3QgZ2l2ZW4gdGhlIG9mZnNldCBpcyBjb21wdXRlZCBmcm9tIGN1cnJlbnQgcG9zaXRpb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvY2FsQW5nbGVCXSBUaGUgYW5nbGUgb2YgYm9keUIgaW4gYm9keUEncyBmcmFtZS4gSWYgbm90IGdpdmVuLCB0aGUgYW5nbGUgaXMgY29tcHV0ZWQgZnJvbSBjdXJyZW50IGFuZ2xlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZV1cbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqL1xuZnVuY3Rpb24gTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuTE9DSyxvcHRpb25zKTtcblxuICAgIHZhciBtYXhGb3JjZSA9ICggdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IE51bWJlci5NQVhfVkFMVUUgOiBvcHRpb25zLm1heEZvcmNlICk7XG5cbiAgICB2YXIgbG9jYWxBbmdsZUIgPSBvcHRpb25zLmxvY2FsQW5nbGVCIHx8IDA7XG5cbiAgICAvLyBVc2UgMyBlcXVhdGlvbnM6XG4gICAgLy8gZ3ggPSAgICh4aiAtIHhpIC0gbCkgKiB4aGF0ID0gMFxuICAgIC8vIGd5ID0gICAoeGogLSB4aSAtIGwpICogeWhhdCA9IDBcbiAgICAvLyBnciA9ICAgKHhpIC0geGogKyByKSAqIHRoYXQgPSAwXG4gICAgLy9cbiAgICAvLyAuLi53aGVyZTpcbiAgICAvLyAgIGwgaXMgdGhlIGxvY2FsT2Zmc2V0QiB2ZWN0b3Igcm90YXRlZCB0byB3b3JsZCBpbiBib2R5QSBmcmFtZVxuICAgIC8vICAgciBpcyB0aGUgc2FtZSB2ZWN0b3IgYnV0IHJldmVyc2VkIGFuZCByb3RhdGVkIGZyb20gYm9keUIgZnJhbWVcbiAgICAvLyAgIHhoYXQsIHloYXQgYXJlIHdvcmxkIGF4aXMgdmVjdG9yc1xuICAgIC8vICAgdGhhdCBpcyB0aGUgdGFuZ2VudCBvZiByXG4gICAgLy9cbiAgICAvLyBGb3IgdGhlIGZpcnN0IHR3byBjb25zdHJhaW50cywgd2UgZ2V0XG4gICAgLy8gRypXID0gKHZqIC0gdmkgLSBsZG90ICApICogeGhhdFxuICAgIC8vICAgICA9ICh2aiAtIHZpIC0gd2kgeCBsKSAqIHhoYXRcbiAgICAvL1xuICAgIC8vIFNpbmNlICh3aSB4IGwpICogeGhhdCA9IChsIHggeGhhdCkgKiB3aSwgd2UgZ2V0XG4gICAgLy8gRypXID0gWyAtMSAgIDAgICAoLWwgeCB4aGF0KSAgMSAgIDAgICAwXSAqIFt2aSB3aSB2aiB3al1cbiAgICAvL1xuICAgIC8vIFRoZSBsYXN0IGNvbnN0cmFpbnQgZ2l2ZXNcbiAgICAvLyBHVyA9ICh2aSAtIHZqICsgd2ogeCByKSAqIHRoYXRcbiAgICAvLyAgICA9IFsgIHRoYXQgICAwICAtdGhhdCAgKHIgeCB0KSBdXG5cbiAgICB2YXIgeCA9ICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICAgICAgeSA9ICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICAgICAgcm90ID0gICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcblxuICAgIHZhciBsID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgZyA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHRoYXQgPSB0aGlzO1xuICAgIHguY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUobCwgdGhhdC5sb2NhbE9mZnNldEIsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5zdWIoZywgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgbCk7XG4gICAgICAgIHJldHVybiBnWzBdO1xuICAgIH07XG4gICAgeS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZShsLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnN1YihnLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBsKTtcbiAgICAgICAgcmV0dXJuIGdbMV07XG4gICAgfTtcbiAgICB2YXIgciA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHJvdC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZShyLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUIuYW5nbGUgLSB0aGF0LmxvY2FsQW5nbGVCKTtcbiAgICAgICAgdmVjMi5zY2FsZShyLHIsLTEpO1xuICAgICAgICB2ZWMyLnN1YihnLGJvZHlBLnBvc2l0aW9uLGJvZHlCLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5hZGQoZyxnLHIpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh0LHIsLU1hdGguUEkvMik7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKHQsdCk7XG4gICAgICAgIHJldHVybiB2ZWMyLmRvdChnLHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbG9jYWxPZmZzZXRCXG4gICAgICovXG4gICAgdGhpcy5sb2NhbE9mZnNldEIgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIGlmKG9wdGlvbnMubG9jYWxPZmZzZXRCKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMubG9jYWxPZmZzZXRCLCBvcHRpb25zLmxvY2FsT2Zmc2V0Qik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IGZyb20gY3VycmVudCBwb3NpdGlvbnNcbiAgICAgICAgdmVjMi5zdWIodGhpcy5sb2NhbE9mZnNldEIsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIucm90YXRlKHRoaXMubG9jYWxPZmZzZXRCLCB0aGlzLmxvY2FsT2Zmc2V0QiwgLWJvZHlBLmFuZ2xlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IGFuZ2xlIG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxvY2FsQW5nbGVCXG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuZ2xlQiA9IDA7XG4gICAgaWYodHlwZW9mKG9wdGlvbnMubG9jYWxBbmdsZUIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMubG9jYWxBbmdsZUIgPSBvcHRpb25zLmxvY2FsQW5nbGVCO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnN0cnVjdFxuICAgICAgICB0aGlzLmxvY2FsQW5nbGVCID0gYm9keUIuYW5nbGUgLSBib2R5QS5hbmdsZTtcbiAgICB9XG5cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHgsIHksIHJvdCk7XG4gICAgdGhpcy5zZXRNYXhGb3JjZShtYXhGb3JjZSk7XG59XG5Mb2NrQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9ja0NvbnN0cmFpbnQ7XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGZvcmNlIHRvIGJlIGFwcGxpZWQuXG4gKiBAbWV0aG9kIHNldE1heEZvcmNlXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yY2VcbiAqL1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heEZvcmNlID0gZnVuY3Rpb24oZm9yY2Upe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmVxdWF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGVxc1tpXS5tYXhGb3JjZSA9ICBmb3JjZTtcbiAgICAgICAgZXFzW2ldLm1pbkZvcmNlID0gLWZvcmNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXggZm9yY2UuXG4gKiBAbWV0aG9kIGdldE1heEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZXF1YXRpb25zWzBdLm1heEZvcmNlO1xufTtcblxudmFyIGwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHIgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHhBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDEsMCk7XG52YXIgeUF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwxKTtcbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciB4ID0gICB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgeSA9ICAgdGhpcy5lcXVhdGlvbnNbMV0sXG4gICAgICAgIHJvdCA9IHRoaXMuZXF1YXRpb25zWzJdLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QjtcblxuICAgIHZlYzIucm90YXRlKGwsdGhpcy5sb2NhbE9mZnNldEIsYm9keUEuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHIsdGhpcy5sb2NhbE9mZnNldEIsYm9keUIuYW5nbGUgLSB0aGlzLmxvY2FsQW5nbGVCKTtcbiAgICB2ZWMyLnNjYWxlKHIsciwtMSk7XG5cbiAgICB2ZWMyLnJvdGF0ZSh0LHIsTWF0aC5QSS8yKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZSh0LHQpO1xuXG4gICAgeC5HWzBdID0gLTE7XG4gICAgeC5HWzFdID0gIDA7XG4gICAgeC5HWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgobCx4QXhpcyk7XG4gICAgeC5HWzNdID0gIDE7XG5cbiAgICB5LkdbMF0gPSAgMDtcbiAgICB5LkdbMV0gPSAtMTtcbiAgICB5LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChsLHlBeGlzKTtcbiAgICB5LkdbNF0gPSAgMTtcblxuICAgIHJvdC5HWzBdID0gIC10WzBdO1xuICAgIHJvdC5HWzFdID0gIC10WzFdO1xuICAgIHJvdC5HWzNdID0gIHRbMF07XG4gICAgcm90LkdbNF0gPSAgdFsxXTtcbiAgICByb3QuR1s1XSA9ICB2ZWMyLmNyb3NzTGVuZ3RoKHIsdCk7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0NvbnN0cmFpbnRcIjoxNX1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgUm90YXRpb25hbExvY2tFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpc21hdGljQ29uc3RyYWludDtcblxuLyoqXG4gKiBDb25zdHJhaW50IHRoYXQgb25seSBhbGxvd3MgYm9kaWVzIHRvIG1vdmUgYWxvbmcgYSBsaW5lLCByZWxhdGl2ZSB0byBlYWNoIG90aGVyLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cuaWZvcmNlMmQubmV0L2IyZHR1dC9qb2ludHMtcHJpc21hdGljXCI+dGhpcyB0dXRvcmlhbDwvYT4uXG4gKlxuICogQGNsYXNzIFByaXNtYXRpY0NvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSAgICBib2R5QVxuICogQHBhcmFtIHtCb2R5fSAgICBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSAgW29wdGlvbnMubWF4Rm9yY2VdICAgICAgICAgICAgICAgIE1heCBmb3JjZSB0byBiZSBhcHBsaWVkIGJ5IHRoZSBjb25zdHJhaW50XG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gICAgICAgICAgICBCb2R5IEEncyBhbmNob3IgcG9pbnQsIGRlZmluZWQgaW4gaXRzIG93biBsb2NhbCBmcmFtZS5cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxBbmNob3JCXSAgICAgICAgICAgIEJvZHkgQidzIGFuY2hvciBwb2ludCwgZGVmaW5lZCBpbiBpdHMgb3duIGxvY2FsIGZyYW1lLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbEF4aXNBXSAgICAgICAgICAgICAgQW4gYXhpcywgZGVmaW5lZCBpbiBib2R5IEEgZnJhbWUsIHRoYXQgYm9keSBCJ3MgYW5jaG9yIHBvaW50IG1heSBzbGlkZSBhbG9uZy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGlzYWJsZVJvdGF0aW9uYWxMb2NrXSAgIElmIHNldCB0byB0cnVlLCBib2R5QiB3aWxsIGJlIGZyZWUgdG8gcm90YXRlIGFyb3VuZCBpdHMgYW5jaG9yIHBvaW50LlxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy51cHBlckxpbWl0XVxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy5sb3dlckxpbWl0XVxuICogQHRvZG8gQWJpbGl0eSB0byBjcmVhdGUgdXNpbmcgb25seSBhIHBvaW50IGFuZCBhIHdvcmxkQXhpc1xuICovXG5mdW5jdGlvbiBQcmlzbWF0aWNDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIsQ29uc3RyYWludC5QUklTTUFUSUMsb3B0aW9ucyk7XG5cbiAgICAvLyBHZXQgYW5jaG9yc1xuICAgIHZhciBsb2NhbEFuY2hvckEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICAgICAgbG9jYWxBeGlzQSA9IHZlYzIuZnJvbVZhbHVlcygxLDApLFxuICAgICAgICBsb2NhbEFuY2hvckIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICBpZihvcHRpb25zLmxvY2FsQW5jaG9yQSl7IHZlYzIuY29weShsb2NhbEFuY2hvckEsIG9wdGlvbnMubG9jYWxBbmNob3JBKTsgfVxuICAgIGlmKG9wdGlvbnMubG9jYWxBeGlzQSl7IHZlYzIuY29weShsb2NhbEF4aXNBLCAgIG9wdGlvbnMubG9jYWxBeGlzQSk7IH1cbiAgICBpZihvcHRpb25zLmxvY2FsQW5jaG9yQil7IHZlYzIuY29weShsb2NhbEFuY2hvckIsIG9wdGlvbnMubG9jYWxBbmNob3JCKTsgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IGxvY2FsQW5jaG9yQTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSBsb2NhbEFuY2hvckI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBeGlzQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQXhpc0EgPSBsb2NhbEF4aXNBO1xuXG4gICAgLypcblxuICAgIFRoZSBjb25zdHJhaW50IHZpb2xhdGlvbiBmb3IgdGhlIGNvbW1vbiBheGlzIHBvaW50IGlzXG5cbiAgICAgICAgZyA9ICggeGogKyByaiAtIHhpIC0gcmkgKSAqIHQgICA6PSAgZ2cqdFxuXG4gICAgd2hlcmUgciBhcmUgYm9keS1sb2NhbCBhbmNob3IgcG9pbnRzLCBhbmQgdCBpcyBhIHRhbmdlbnQgdG8gdGhlIGNvbnN0cmFpbnQgYXhpcyBkZWZpbmVkIGluIGJvZHkgaSBmcmFtZS5cblxuICAgICAgICBnZG90ID0gICggdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpICkgKiB0ICsgKCB4aiArIHJqIC0geGkgLSByaSApICogKCB3aSB4IHQgKVxuXG4gICAgTm90ZSB0aGUgdXNlIG9mIHRoZSBjaGFpbiBydWxlLiBOb3cgd2UgaWRlbnRpZnkgdGhlIGphY29iaWFuXG5cbiAgICAgICAgRypXID0gWyAtdCAgICAgIC1yaSB4IHQgKyB0IHggZ2cgICAgIHQgICAgcmogeCB0IF0gKiBbdmkgd2kgdmogd2pdXG5cbiAgICBUaGUgcm90YXRpb25hbCBwYXJ0IGlzIGp1c3QgYSByb3RhdGlvbiBsb2NrLlxuXG4gICAgICovXG5cbiAgICB2YXIgbWF4Rm9yY2UgPSB0aGlzLm1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpIT09XCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubWF4Rm9yY2UgOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgLy8gVHJhbnNsYXRpb25hbCBwYXJ0XG4gICAgdmFyIHRyYW5zID0gbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7XG4gICAgdmFyIHJpID0gbmV3IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHJqID0gbmV3IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIGdnID0gbmV3IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHQgPSAgbmV3IHZlYzIuY3JlYXRlKCk7XG4gICAgdHJhbnMuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gZyA9ICggeGogKyByaiAtIHhpIC0gcmkgKSAqIHRcbiAgICAgICAgcmV0dXJuIHZlYzIuZG90KGdnLHQpO1xuICAgIH07XG4gICAgdHJhbnMudXBkYXRlSmFjb2JpYW4gPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgICAgIHhpID0gYm9keUEucG9zaXRpb24sXG4gICAgICAgICAgICB4aiA9IGJvZHlCLnBvc2l0aW9uO1xuICAgICAgICB2ZWMyLnJvdGF0ZShyaSxsb2NhbEFuY2hvckEsYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZShyaixsb2NhbEFuY2hvckIsYm9keUIuYW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZChnZyx4aixyaik7XG4gICAgICAgIHZlYzIuc3ViKGdnLGdnLHhpKTtcbiAgICAgICAgdmVjMi5zdWIoZ2csZ2cscmkpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh0LGxvY2FsQXhpc0EsYm9keUEuYW5nbGUrTWF0aC5QSS8yKTtcblxuICAgICAgICBHWzBdID0gLXRbMF07XG4gICAgICAgIEdbMV0gPSAtdFsxXTtcbiAgICAgICAgR1syXSA9IC12ZWMyLmNyb3NzTGVuZ3RoKHJpLHQpICsgdmVjMi5jcm9zc0xlbmd0aCh0LGdnKTtcbiAgICAgICAgR1szXSA9IHRbMF07XG4gICAgICAgIEdbNF0gPSB0WzFdO1xuICAgICAgICBHWzVdID0gdmVjMi5jcm9zc0xlbmd0aChyaix0KTtcbiAgICB9O1xuICAgIHRoaXMuZXF1YXRpb25zLnB1c2godHJhbnMpO1xuXG4gICAgLy8gUm90YXRpb25hbCBwYXJ0XG4gICAgaWYoIW9wdGlvbnMuZGlzYWJsZVJvdGF0aW9uYWxMb2NrKXtcbiAgICAgICAgdmFyIHJvdCA9IG5ldyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2gocm90KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgYW5jaG9yIEEgcmVsYXRpdmUgdG8gYW5jaG9yIEIsIGFsb25nIHRoZSBjb25zdHJhaW50IGF4aXMuXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcblxuICAgIC8vIElzIHRoaXMgb25lIHVzZWQgYXQgYWxsP1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIGxvd2VyIGxpbWl0LlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0RW5hYmxlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSB0eXBlb2Yob3B0aW9ucy5sb3dlckxpbWl0KSE9PVwidW5kZWZpbmVkXCIgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgdXBwZXIgbGltaXQuXG4gICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IHR5cGVvZihvcHRpb25zLnVwcGVyTGltaXQpIT09XCJ1bmRlZmluZWRcIiA/IHRydWUgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIExvd2VyIGNvbnN0cmFpbnQgbGltaXQuIFRoZSBjb25zdHJhaW50IHBvc2l0aW9uIGlzIGZvcmNlZCB0byBiZSBsYXJnZXIgdGhhbiB0aGlzIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXQgPSB0eXBlb2Yob3B0aW9ucy5sb3dlckxpbWl0KSE9PVwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmxvd2VyTGltaXQgOiAwO1xuXG4gICAgLyoqXG4gICAgICogVXBwZXIgY29uc3RyYWludCBsaW1pdC4gVGhlIGNvbnN0cmFpbnQgcG9zaXRpb24gaXMgZm9yY2VkIHRvIGJlIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckxpbWl0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXQgPSB0eXBlb2Yob3B0aW9ucy51cHBlckxpbWl0KSE9PVwidW5kZWZpbmVkXCIgPyBvcHRpb25zLnVwcGVyTGltaXQgOiAxO1xuXG4gICAgLy8gRXF1YXRpb25zIHVzZWQgZm9yIGxpbWl0c1xuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5Qik7XG4gICAgdGhpcy5sb3dlckxpbWl0RXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcblxuICAgIC8vIFNldCBtYXgvbWluIGZvcmNlc1xuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLm1pbkZvcmNlID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWluRm9yY2UgPSAwO1xuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLm1heEZvcmNlID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWF4Rm9yY2UgPSBtYXhGb3JjZTtcblxuICAgIC8qKlxuICAgICAqIEVxdWF0aW9uIHVzZWQgZm9yIHRoZSBtb3Rvci5cbiAgICAgKiBAcHJvcGVydHkgbW90b3JFcXVhdGlvblxuICAgICAqIEB0eXBlIHtFcXVhdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm1vdG9yRXF1YXRpb24gPSBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgbW90b3Igc3RhdGUuIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBtb3RvciB1c2luZyAuZW5hYmxlTW90b3JcbiAgICAgKiBAcHJvcGVydHkgbW90b3JFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGFyZ2V0IHNwZWVkIGZvciB0aGUgbW90b3IuXG4gICAgICogQHByb3BlcnR5IG1vdG9yU3BlZWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubW90b3JTcGVlZCA9IDA7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIG1vdG9yRXF1YXRpb24gPSB0aGlzLm1vdG9yRXF1YXRpb247XG4gICAgdmFyIG9sZCA9IG1vdG9yRXF1YXRpb24uY29tcHV0ZUdXO1xuICAgIG1vdG9yRXF1YXRpb24uY29tcHV0ZUdxID0gZnVuY3Rpb24oKXsgcmV0dXJuIDA7IH07XG4gICAgbW90b3JFcXVhdGlvbi5jb21wdXRlR1cgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgICAgIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgICAgIHZpID0gYmkudmVsb2NpdHksXG4gICAgICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxuICAgICAgICAgICAgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHksXG4gICAgICAgICAgICB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ211bHQoRyx2aSx3aSx2aix3aikgKyB0aGF0Lm1vdG9yU3BlZWQ7XG4gICAgfTtcbn1cblxuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcmlzbWF0aWNDb25zdHJhaW50O1xuXG52YXIgd29ybGRBeGlzQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgd29ybGRBbmNob3JBID0gdmVjMi5jcmVhdGUoKSxcbiAgICB3b3JsZEFuY2hvckIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIG9yaWVudGVkQW5jaG9yQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgb3JpZW50ZWRBbmNob3JCID0gdmVjMi5jcmVhdGUoKSxcbiAgICB0bXAgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY29uc3RyYWludCBlcXVhdGlvbnMuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgYm9kaWVzIGNoYW5nZWQgcG9zaXRpb24sIGJlZm9yZSBzb2x2aW5nLlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnMsXG4gICAgICAgIHRyYW5zID0gZXFzWzBdLFxuICAgICAgICB1cHBlckxpbWl0ID0gdGhpcy51cHBlckxpbWl0LFxuICAgICAgICBsb3dlckxpbWl0ID0gdGhpcy5sb3dlckxpbWl0LFxuICAgICAgICB1cHBlckxpbWl0RXF1YXRpb24gPSB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbixcbiAgICAgICAgbG93ZXJMaW1pdEVxdWF0aW9uID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb24sXG4gICAgICAgIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICBsb2NhbEF4aXNBID0gdGhpcy5sb2NhbEF4aXNBLFxuICAgICAgICBsb2NhbEFuY2hvckEgPSB0aGlzLmxvY2FsQW5jaG9yQSxcbiAgICAgICAgbG9jYWxBbmNob3JCID0gdGhpcy5sb2NhbEFuY2hvckI7XG5cbiAgICB0cmFucy51cGRhdGVKYWNvYmlhbigpO1xuXG4gICAgLy8gVHJhbnNmb3JtIGxvY2FsIHRoaW5ncyB0byB3b3JsZFxuICAgIHZlYzIucm90YXRlKHdvcmxkQXhpc0EsICAgICAgbG9jYWxBeGlzQSwgICAgICBib2R5QS5hbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUob3JpZW50ZWRBbmNob3JBLCBsb2NhbEFuY2hvckEsICAgIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLmFkZCh3b3JsZEFuY2hvckEsICAgICAgIG9yaWVudGVkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgIHZlYzIucm90YXRlKG9yaWVudGVkQW5jaG9yQiwgbG9jYWxBbmNob3JCLCAgICBib2R5Qi5hbmdsZSk7XG4gICAgdmVjMi5hZGQod29ybGRBbmNob3JCLCAgICAgICBvcmllbnRlZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcblxuICAgIHZhciByZWxQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gPSB2ZWMyLmRvdCh3b3JsZEFuY2hvckIsd29ybGRBeGlzQSkgLSB2ZWMyLmRvdCh3b3JsZEFuY2hvckEsd29ybGRBeGlzQSk7XG5cbiAgICAvLyBNb3RvclxuICAgIGlmKHRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgLy8gRyA9IFsgYSAgICAgYSB4IHJpICAgLWEgICAtYSB4IHJqIF1cbiAgICAgICAgdmFyIEcgPSB0aGlzLm1vdG9yRXF1YXRpb24uRztcbiAgICAgICAgR1swXSA9IHdvcmxkQXhpc0FbMF07XG4gICAgICAgIEdbMV0gPSB3b3JsZEF4aXNBWzFdO1xuICAgICAgICBHWzJdID0gdmVjMi5jcm9zc0xlbmd0aCh3b3JsZEF4aXNBLG9yaWVudGVkQW5jaG9yQik7XG4gICAgICAgIEdbM10gPSAtd29ybGRBeGlzQVswXTtcbiAgICAgICAgR1s0XSA9IC13b3JsZEF4aXNBWzFdO1xuICAgICAgICBHWzVdID0gLXZlYzIuY3Jvc3NMZW5ndGgod29ybGRBeGlzQSxvcmllbnRlZEFuY2hvckEpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICAgIExpbWl0cyBzdHJhdGVneTpcbiAgICAgICAgQWRkIGNvbnRhY3QgZXF1YXRpb24sIHdpdGggbm9ybWFsIGFsb25nIHRoZSBjb25zdHJhaW50IGF4aXMuXG4gICAgICAgIG1pbi9tYXhGb3JjZSBpcyBzZXQgc28gdGhlIGNvbnN0cmFpbnQgaXMgcmVwdWxzaXZlIGluIHRoZSBjb3JyZWN0IGRpcmVjdGlvbi5cbiAgICAgICAgU29tZSBvZmZzZXQgaXMgYWRkZWQgdG8gZWl0aGVyIGVxdWF0aW9uLmNvbnRhY3RQb2ludEEgb3IgLmNvbnRhY3RQb2ludEIgdG8gZ2V0IHRoZSBjb3JyZWN0IHVwcGVyL2xvd2VyIGxpbWl0LlxuXG4gICAgICAgICAgICAgICAgIF5cbiAgICAgICAgICAgICAgICAgfFxuICAgICAgdXBwZXJMaW1pdCB4XG4gICAgICAgICAgICAgICAgIHwgICAgLS0tLS0tXG4gICAgICAgICBhbmNob3JCIHg8LS0tfCAgQiB8XG4gICAgICAgICAgICAgICAgIHwgICAgfCAgICB8XG4gICAgICAgIC0tLS0tLSAgIHwgICAgLS0tLS0tXG4gICAgICAgIHwgICAgfCAgIHxcbiAgICAgICAgfCAgQSB8LS0+eCBhbmNob3JBXG4gICAgICAgIC0tLS0tLSAgIHxcbiAgICAgICAgICAgICAgICAgeCBsb3dlckxpbWl0XG4gICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICBheGlzXG4gICAgICovXG5cblxuICAgIGlmKHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgJiYgcmVsUG9zaXRpb24gPiB1cHBlckxpbWl0KXtcbiAgICAgICAgLy8gVXBkYXRlIGNvbnRhY3QgY29uc3RyYWludCBub3JtYWwsIGV0Y1xuICAgICAgICB2ZWMyLnNjYWxlKHVwcGVyTGltaXRFcXVhdGlvbi5ub3JtYWxBLCB3b3JsZEF4aXNBLCAtMSk7XG4gICAgICAgIHZlYzIuc3ViKHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLCB3b3JsZEFuY2hvckEsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIodXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIHdvcmxkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnNjYWxlKHRtcCx3b3JsZEF4aXNBLHVwcGVyTGltaXQpO1xuICAgICAgICB2ZWMyLmFkZCh1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSx1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSx0bXApO1xuICAgICAgICBpZihlcXMuaW5kZXhPZih1cHBlckxpbWl0RXF1YXRpb24pID09PSAtMSl7XG4gICAgICAgICAgICBlcXMucHVzaCh1cHBlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmxvd2VyTGltaXRFbmFibGVkICYmIHJlbFBvc2l0aW9uIDwgbG93ZXJMaW1pdCl7XG4gICAgICAgIC8vIFVwZGF0ZSBjb250YWN0IGNvbnN0cmFpbnQgbm9ybWFsLCBldGNcbiAgICAgICAgdmVjMi5zY2FsZShsb3dlckxpbWl0RXF1YXRpb24ubm9ybWFsQSwgd29ybGRBeGlzQSwgMSk7XG4gICAgICAgIHZlYzIuc3ViKGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLCB3b3JsZEFuY2hvckEsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIobG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIHdvcmxkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnNjYWxlKHRtcCx3b3JsZEF4aXNBLGxvd2VyTGltaXQpO1xuICAgICAgICB2ZWMyLnN1Yihsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qixsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qix0bXApO1xuICAgICAgICBpZihlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pID09PSAtMSl7XG4gICAgICAgICAgICBlcXMucHVzaChsb3dlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IGVxcy5pbmRleE9mKGxvd2VyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0aGUgbW90b3JcbiAqIEBtZXRob2QgZW5hYmxlTW90b3JcbiAqL1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuZW5hYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIHRoZSByb3RhdGlvbmFsIG1vdG9yXG4gKiBAbWV0aG9kIGRpc2FibGVNb3RvclxuICovXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5kaXNhYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIGlmKCF0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5lcXVhdGlvbnMuc3BsaWNlKGksMSk7XG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb25zdHJhaW50IGxpbWl0cy5cbiAqIEBtZXRob2Qgc2V0TGltaXRzXG4gKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgTG93ZXIgbGltaXQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVXBwZXIgbGltaXQuXG4gKi9cblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLnNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcbiAgICBpZih0eXBlb2YobG93ZXIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdCA9IGxvd2VyO1xuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZih1cHBlcikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xuICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuXG59LHtcIi4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoyMixcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxMb2NrRXF1YXRpb25cIjoyNSxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9Db25zdHJhaW50XCI6MTV9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpXG4sICAgRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKVxuLCAgIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uJylcbiwgICBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxMb2NrRXF1YXRpb24nKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZXZvbHV0ZUNvbnN0cmFpbnQ7XG5cbnZhciB3b3JsZFBpdm90QSA9IHZlYzIuY3JlYXRlKCksXG4gICAgd29ybGRQaXZvdEIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHhBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDEsMCksXG4gICAgeUF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwxKSxcbiAgICBnID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBDb25uZWN0cyB0d28gYm9kaWVzIGF0IGdpdmVuIG9mZnNldCBwb2ludHMsIGxldHRpbmcgdGhlbSByb3RhdGUgcmVsYXRpdmUgdG8gZWFjaCBvdGhlciBhcm91bmQgdGhpcyBwb2ludC5cbiAqIEBjbGFzcyBSZXZvbHV0ZUNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSAgICBib2R5QVxuICogQHBhcmFtIHtCb2R5fSAgICBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMud29ybGRQaXZvdF0gQSBwaXZvdCBwb2ludCBnaXZlbiBpbiB3b3JsZCBjb29yZGluYXRlcy4gSWYgc3BlY2lmaWVkLCBsb2NhbFBpdm90QSBhbmQgbG9jYWxQaXZvdEIgYXJlIGF1dG9tYXRpY2FsbHkgY29tcHV0ZWQgZnJvbSB0aGlzIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbFBpdm90QV0gVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyBvZiBib2R5QSB3aGljaCBib2R5QSBpcyBjb25zdHJhaW5lZCB0by5cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxQaXZvdEJdIFNlZSBsb2NhbFBpdm90QS5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgW29wdGlvbnMubWF4Rm9yY2VdIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgcmV2b2x1dGUgY29uc3RyYWludCBiZXR3ZWVuIHR3byBib2RpZXMgd2l0aCBwaXZvdCBwb2ludCBpbiBiZXR3ZWVuIHRoZW0uXG4gKiAgICAgdmFyIGJvZHlBID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWy0xLCAwXSB9KTtcbiAqICAgICB2YXIgYm9keUIgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbMSwgMF0gfSk7XG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgUmV2b2x1dGVDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xuICogICAgICAgICB3b3JsZFBpdm90OiBbMCwgMF1cbiAqICAgICB9KTtcbiAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuICpcbiAqICAgICAvLyBVc2luZyBib2R5LWxvY2FsIHBpdm90IHBvaW50cywgdGhlIGNvbnN0cmFpbnQgY291bGQgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGxpa2UgdGhpczpcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBSZXZvbHV0ZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XG4gKiAgICAgICAgIGxvY2FsUGl2b3RBOiBbMSwgMF0sXG4gKiAgICAgICAgIGxvY2FsUGl2b3RCOiBbLTEsIDBdXG4gKiAgICAgfSk7XG4gKi9cbmZ1bmN0aW9uIFJldm9sdXRlQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuUkVWT0xVVEUsb3B0aW9ucyk7XG5cbiAgICB2YXIgbWF4Rm9yY2UgPSB0aGlzLm1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5tYXhGb3JjZSA6IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBwaXZvdEFcbiAgICAgKi9cbiAgICB0aGlzLnBpdm90QSA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBwaXZvdEJcbiAgICAgKi9cbiAgICB0aGlzLnBpdm90QiA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICBpZihvcHRpb25zLndvcmxkUGl2b3Qpe1xuICAgICAgICAvLyBDb21wdXRlIHBpdm90QSBhbmQgcGl2b3RCXG4gICAgICAgIHZlYzIuc3ViKHRoaXMucGl2b3RBLCBvcHRpb25zLndvcmxkUGl2b3QsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIodGhpcy5waXZvdEIsIG9wdGlvbnMud29ybGRQaXZvdCwgYm9keUIucG9zaXRpb24pO1xuICAgICAgICAvLyBSb3RhdGUgdG8gbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgICAgdmVjMi5yb3RhdGUodGhpcy5waXZvdEEsIHRoaXMucGl2b3RBLCAtYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh0aGlzLnBpdm90QiwgdGhpcy5waXZvdEIsIC1ib2R5Qi5hbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gR2V0IHBpdm90QSBhbmQgcGl2b3RCXG4gICAgICAgIHZlYzIuY29weSh0aGlzLnBpdm90QSwgb3B0aW9ucy5sb2NhbFBpdm90QSk7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLnBpdm90Qiwgb3B0aW9ucy5sb2NhbFBpdm90Qik7XG4gICAgfVxuXG4gICAgLy8gRXF1YXRpb25zIHRvIGJlIGZlZCB0byB0aGUgc29sdmVyXG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zID0gW1xuICAgICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICAgICAgbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSksXG4gICAgXTtcblxuICAgIHZhciB4ID0gZXFzWzBdO1xuICAgIHZhciB5ID0gZXFzWzFdO1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIHguY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEEsIHRoYXQucGl2b3RBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RCLCB0aGF0LnBpdm90QiwgYm9keUIuYW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZChnLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRQaXZvdEIpO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIHdvcmxkUGl2b3RBKTtcbiAgICAgICAgcmV0dXJuIHZlYzIuZG90KGcseEF4aXMpO1xuICAgIH07XG5cbiAgICB5LmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RBLCB0aGF0LnBpdm90QSwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QiwgdGhhdC5waXZvdEIsIGJvZHlCLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQoZywgYm9keUIucG9zaXRpb24sIHdvcmxkUGl2b3RCKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCB3b3JsZFBpdm90QSk7XG4gICAgICAgIHJldHVybiB2ZWMyLmRvdChnLHlBeGlzKTtcbiAgICB9O1xuXG4gICAgeS5taW5Gb3JjZSA9IHgubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG4gICAgeS5tYXhGb3JjZSA9IHgubWF4Rm9yY2UgPSAgbWF4Rm9yY2U7XG5cbiAgICB0aGlzLm1vdG9yRXF1YXRpb24gPSBuZXcgUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24oYm9keUEsYm9keUIpO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1vdG9yIGlzIGVuYWJsZWQuIFVzZSAuZW5hYmxlTW90b3IoKSB0byBlbmFibGUgdGhlIGNvbnN0cmFpbnQgbW90b3IuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBtb3RvckVuYWJsZWRcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cmFpbnQgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IGFuZ2xlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSBsb3dlciBsaW1pdFxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0RW5hYmxlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSB1cHBlciBsaW1pdFxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckxpbWl0RW5hYmxlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb3dlciBsaW1pdCBvbiB0aGUgY29uc3RyYWludCBhbmdsZS5cbiAgICAgKiBAcHJvcGVydHkgbG93ZXJMaW1pdFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXBwZXIgbGltaXQgb24gdGhlIGNvbnN0cmFpbnQgYW5nbGUuXG4gICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXQgPSAwO1xuXG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24gPSBuZXcgUm90YXRpb25hbExvY2tFcXVhdGlvbihib2R5QSxib2R5Qik7XG4gICAgdGhpcy5sb3dlckxpbWl0RXF1YXRpb24gPSBuZXcgUm90YXRpb25hbExvY2tFcXVhdGlvbihib2R5QSxib2R5Qik7XG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24ubWluRm9yY2UgPSAwO1xuICAgIHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uLm1heEZvcmNlID0gMDtcbn1cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJldm9sdXRlQ29uc3RyYWludDtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbnN0cmFpbnQgYW5nbGUgbGltaXRzLlxuICogQG1ldGhvZCBzZXRMaW1pdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBMb3dlciBhbmdsZSBsaW1pdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBVcHBlciBhbmdsZSBsaW1pdC5cbiAqL1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5zZXRMaW1pdHMgPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyKSB7XG4gICAgaWYodHlwZW9mKGxvd2VyKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXI7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZih0eXBlb2YodXBwZXIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xuICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9keUEgPSAgdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSAgdGhpcy5ib2R5QixcbiAgICAgICAgcGl2b3RBID0gdGhpcy5waXZvdEEsXG4gICAgICAgIHBpdm90QiA9IHRoaXMucGl2b3RCLFxuICAgICAgICBlcXMgPSAgICB0aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgbm9ybWFsID0gZXFzWzBdLFxuICAgICAgICB0YW5nZW50PSBlcXNbMV0sXG4gICAgICAgIHggPSBlcXNbMF0sXG4gICAgICAgIHkgPSBlcXNbMV0sXG4gICAgICAgIHVwcGVyTGltaXQgPSB0aGlzLnVwcGVyTGltaXQsXG4gICAgICAgIGxvd2VyTGltaXQgPSB0aGlzLmxvd2VyTGltaXQsXG4gICAgICAgIHVwcGVyTGltaXRFcXVhdGlvbiA9IHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLFxuICAgICAgICBsb3dlckxpbWl0RXF1YXRpb24gPSB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbjtcblxuICAgIHZhciByZWxBbmdsZSA9IHRoaXMuYW5nbGUgPSBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlO1xuXG4gICAgaWYodGhpcy51cHBlckxpbWl0RW5hYmxlZCAmJiByZWxBbmdsZSA+IHVwcGVyTGltaXQpe1xuICAgICAgICB1cHBlckxpbWl0RXF1YXRpb24uYW5nbGUgPSB1cHBlckxpbWl0O1xuICAgICAgICBpZihlcXMuaW5kZXhPZih1cHBlckxpbWl0RXF1YXRpb24pID09PSAtMSl7XG4gICAgICAgICAgICBlcXMucHVzaCh1cHBlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmxvd2VyTGltaXRFbmFibGVkICYmIHJlbEFuZ2xlIDwgbG93ZXJMaW1pdCl7XG4gICAgICAgIGxvd2VyTGltaXRFcXVhdGlvbi5hbmdsZSA9IGxvd2VyTGltaXQ7XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKGxvd2VyTGltaXRFcXVhdGlvbikgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKGxvd2VyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG5cbiAgICBUaGUgY29uc3RyYWludCB2aW9sYXRpb24gaXNcblxuICAgICAgICBnID0geGogKyByaiAtIHhpIC0gcmlcblxuICAgIC4uLndoZXJlIHhpIGFuZCB4aiBhcmUgdGhlIGJvZHkgcG9zaXRpb25zIGFuZCByaSBhbmQgcmogd29ybGQtb3JpZW50ZWQgb2Zmc2V0IHZlY3RvcnMuIERpZmZlcmVudGlhdGU6XG5cbiAgICAgICAgZ2RvdCA9IHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaVxuXG4gICAgV2Ugc3BsaXQgdGhpcyBpbnRvIHggYW5kIHkgZGlyZWN0aW9ucy4gKGxldCB4IGFuZCB5IGJlIHVuaXQgdmVjdG9ycyBhbG9uZyB0aGUgcmVzcGVjdGl2ZSBheGVzKVxuXG4gICAgICAgIGdkb3QgKiB4ID0gKCB2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmkgKSAqIHhcbiAgICAgICAgICAgICAgICAgPSAoIHZqKnggKyAod2ogeCByaikqeCAtdmkqeCAtKHdpIHggcmkpKnhcbiAgICAgICAgICAgICAgICAgPSAoIHZqKnggKyAocmogeCB4KSp3aiAtdmkqeCAtKHJpIHggeCkqd2lcbiAgICAgICAgICAgICAgICAgPSBbIC14ICAgLShyaSB4IHgpICAgeCAgIChyaiB4IHgpXSAqIFt2aSB3aSB2aiB3al1cbiAgICAgICAgICAgICAgICAgPSBHKldcblxuICAgIC4uLmFuZCBzaW1pbGFyIGZvciB5LiBXZSBoYXZlIHRoZW4gaWRlbnRpZmllZCB0aGUgamFjb2JpYW4gZW50cmllcyBmb3IgeCBhbmQgeSBkaXJlY3Rpb25zOlxuXG4gICAgICAgIEd4ID0gWyB4ICAgKHJqIHggeCkgICAteCAgIC0ocmkgeCB4KV1cbiAgICAgICAgR3kgPSBbIHkgICAocmogeCB5KSAgIC15ICAgLShyaSB4IHkpXVxuXG4gICAgICovXG5cbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QSwgcGl2b3RBLCBib2R5QS5hbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEIsIHBpdm90QiwgYm9keUIuYW5nbGUpO1xuXG4gICAgLy8gdG9kbzogdGhlc2UgYXJlIGEgYml0IHNwYXJzZS4gV2UgY291bGQgc2F2ZSBzb21lIGNvbXB1dGF0aW9ucyBvbiBtYWtpbmcgY3VzdG9tIGVxLmNvbXB1dGVHVyBmdW5jdGlvbnMsIGV0Y1xuXG4gICAgeC5HWzBdID0gLTE7XG4gICAgeC5HWzFdID0gIDA7XG4gICAgeC5HWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgod29ybGRQaXZvdEEseEF4aXMpO1xuICAgIHguR1szXSA9ICAxO1xuICAgIHguR1s0XSA9ICAwO1xuICAgIHguR1s1XSA9ICB2ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RCLHhBeGlzKTtcblxuICAgIHkuR1swXSA9ICAwO1xuICAgIHkuR1sxXSA9IC0xO1xuICAgIHkuR1syXSA9IC12ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RBLHlBeGlzKTtcbiAgICB5LkdbM10gPSAgMDtcbiAgICB5LkdbNF0gPSAgMTtcbiAgICB5LkdbNV0gPSAgdmVjMi5jcm9zc0xlbmd0aCh3b3JsZFBpdm90Qix5QXhpcyk7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0aGUgcm90YXRpb25hbCBtb3RvclxuICogQG1ldGhvZCBlbmFibGVNb3RvclxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLmVuYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaCh0aGlzLm1vdG9yRXF1YXRpb24pO1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRGlzYWJsZSB0aGUgcm90YXRpb25hbCBtb3RvclxuICogQG1ldGhvZCBkaXNhYmxlTW90b3JcbiAqL1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5kaXNhYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIGlmKCF0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5lcXVhdGlvbnMuc3BsaWNlKGksMSk7XG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIG1vdG9yIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kIG1vdG9ySXNFbmFibGVkXG4gKiBAZGVwcmVjYXRlZCB1c2UgcHJvcGVydHkgbW90b3JFbmFibGVkIGluc3RlYWQuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLm1vdG9ySXNFbmFibGVkID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gISF0aGlzLm1vdG9yRW5hYmxlZDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzcGVlZCBvZiB0aGUgcm90YXRpb25hbCBjb25zdHJhaW50IG1vdG9yXG4gKiBAbWV0aG9kIHNldE1vdG9yU3BlZWRcbiAqIEBwYXJhbSAge051bWJlcn0gc3BlZWRcbiAqL1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNb3RvclNwZWVkID0gZnVuY3Rpb24oc3BlZWQpe1xuICAgIGlmKCF0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5lcXVhdGlvbnNbaV0ucmVsYXRpdmVWZWxvY2l0eSA9IHNwZWVkO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNwZWVkIG9mIHRoZSByb3RhdGlvbmFsIGNvbnN0cmFpbnQgbW90b3JcbiAqIEBtZXRob2QgZ2V0TW90b3JTcGVlZFxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCBzcGVlZCwgb3IgZmFsc2UgaWYgdGhlIG1vdG9yIGlzIG5vdCBlbmFibGVkLlxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLmdldE1vdG9yU3BlZWQgPSBmdW5jdGlvbigpe1xuICAgIGlmKCF0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubW90b3JFcXVhdGlvbi5yZWxhdGl2ZVZlbG9jaXR5O1xufTtcblxufSx7XCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMyxcIi4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uXCI6MjUsXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb25cIjoyNixcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9Db25zdHJhaW50XCI6MTV9XSwyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKFwiLi9FcXVhdGlvblwiKSxcbiAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQW5nbGVMb2NrRXF1YXRpb247XG5cbi8qKlxuICogTG9ja3MgdGhlIHJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdHdvIGJvZGllcy4gVGhlIGNvbnN0cmFpbnQgdHJpZXMgdG8ga2VlcCB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0d28gdmVjdG9ycywgbG9jYWwgaW4gZWFjaCBib2R5LCB0byB6ZXJvLiBUaGUgbG9jYWwgYW5nbGUgaW4gYm9keSBpIGlzIGEgcGFyYW1ldGVyLlxuICpcbiAqIEBjbGFzcyBBbmdsZUxvY2tFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXSBBbmdsZSB0byBhZGQgdG8gdGhlIGxvY2FsIHZlY3RvciBpbiBib2R5IEEuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmF0aW9dIEdlYXIgcmF0aW9cbiAqL1xuZnVuY3Rpb24gQW5nbGVMb2NrRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsYm9keUEsYm9keUIsLU51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGUgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBnZWFyIHJhdGlvLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByYXRpb1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSBzZXRSYXRpb1xuICAgICAqL1xuICAgIHRoaXMucmF0aW8gPSB0eXBlb2Yob3B0aW9ucy5yYXRpbyk9PT1cIm51bWJlclwiID8gb3B0aW9ucy5yYXRpbyA6IDE7XG5cbiAgICB0aGlzLnNldFJhdGlvKHRoaXMucmF0aW8pO1xufVxuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbmdsZUxvY2tFcXVhdGlvbjtcblxuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMucmF0aW8gKiB0aGlzLmJvZHlBLmFuZ2xlIC0gdGhpcy5ib2R5Qi5hbmdsZSArIHRoaXMuYW5nbGU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZ2VhciByYXRpbyBmb3IgdGhpcyBlcXVhdGlvblxuICogQG1ldGhvZCBzZXRSYXRpb1xuICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXG4gKi9cbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5zZXRSYXRpbyA9IGZ1bmN0aW9uKHJhdGlvKXtcbiAgICB2YXIgRyA9IHRoaXMuRztcbiAgICBHWzJdID0gIHJhdGlvO1xuICAgIEdbNV0gPSAtMTtcbiAgICB0aGlzLnJhdGlvID0gcmF0aW87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4IGZvcmNlIGZvciB0aGUgZXF1YXRpb24uXG4gKiBAbWV0aG9kIHNldE1heFRvcnF1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcnF1ZVxuICovXG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUuc2V0TWF4VG9ycXVlID0gZnVuY3Rpb24odG9ycXVlKXtcbiAgICB0aGlzLm1heEZvcmNlID0gIHRvcnF1ZTtcbiAgICB0aGlzLm1pbkZvcmNlID0gLXRvcnF1ZTtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0VxdWF0aW9uXCI6MjN9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKFwiLi9FcXVhdGlvblwiKSxcbiAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdEVxdWF0aW9uO1xuXG4vKipcbiAqIE5vbi1wZW5ldHJhdGlvbiBjb25zdHJhaW50IGVxdWF0aW9uLiBUcmllcyB0byBtYWtlIHRoZSBjb250YWN0UG9pbnRBIGFuZCBjb250YWN0UG9pbnRCIHZlY3RvcnMgY29pbmNpZGUsIHdoaWxlIGtlZXBpbmcgdGhlIGFwcGxpZWQgZm9yY2UgcmVwdWxzaXZlLlxuICpcbiAqIEBjbGFzcyBDb250YWN0RXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqL1xuZnVuY3Rpb24gQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIDAsIE51bWJlci5NQVhfVkFMVUUpO1xuXG4gICAgLyoqXG4gICAgICogVmVjdG9yIGZyb20gYm9keSBpIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBjb250YWN0IHBvaW50LlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFBvaW50QSA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdGhpcy5wZW5ldHJhdGlvblZlYyA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgZnJvbSBib2R5IEEgY2VudGVyIG9mIG1hc3MgdG8gdGhlIGNvbnRhY3QgcG9pbnQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRCID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBub3JtYWwgdmVjdG9yLCBwb2ludGluZyBvdXQgb2YgYm9keSBpXG4gICAgICogQHByb3BlcnR5IG5vcm1hbEFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ub3JtYWxBID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN0aXR1dGlvbiB0byB1c2UgKDA9bm8gYm91bmNpbmVzcywgMT1tYXggYm91bmNpbmVzcykuXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIHRydWUgaWYgdGhpcyBpcyB0aGUgZmlyc3QgaW1wYWN0IGJldHdlZW4gdGhlIGJvZGllcyAobm90IHBlcnNpc3RhbnQgY29udGFjdCkuXG4gICAgICogQHByb3BlcnR5IGZpcnN0SW1wYWN0XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5maXJzdEltcGFjdCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlIGluIGJvZHkgaSB0aGF0IHRyaWdnZXJlZCB0aGlzIGNvbnRhY3QuXG4gICAgICogQHByb3BlcnR5IHNoYXBlQVxuICAgICAqIEB0eXBlIHtTaGFwZX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBqIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY29udGFjdC5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVCXG4gICAgICogQHR5cGUge1NoYXBlfVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVCID0gbnVsbDtcbn1cbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250YWN0RXF1YXRpb247XG5Db250YWN0RXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oYSxiLGgpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgcmkgPSB0aGlzLmNvbnRhY3RQb2ludEEsXG4gICAgICAgIHJqID0gdGhpcy5jb250YWN0UG9pbnRCLFxuICAgICAgICB4aSA9IGJpLnBvc2l0aW9uLFxuICAgICAgICB4aiA9IGJqLnBvc2l0aW9uO1xuXG4gICAgdmFyIHBlbmV0cmF0aW9uVmVjID0gdGhpcy5wZW5ldHJhdGlvblZlYyxcbiAgICAgICAgbiA9IHRoaXMubm9ybWFsQSxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIHZhciByaXhuID0gdmVjMi5jcm9zc0xlbmd0aChyaSxuKSxcbiAgICAgICAgcmp4biA9IHZlYzIuY3Jvc3NMZW5ndGgocmosbik7XG5cbiAgICAvLyBHID0gWy1uIC1yaXhuIG4gcmp4bl1cbiAgICBHWzBdID0gLW5bMF07XG4gICAgR1sxXSA9IC1uWzFdO1xuICAgIEdbMl0gPSAtcml4bjtcbiAgICBHWzNdID0gblswXTtcbiAgICBHWzRdID0gblsxXTtcbiAgICBHWzVdID0gcmp4bjtcblxuICAgIC8vIENhbGN1bGF0ZSBxID0geGorcmogLSh4aStyaSkgaS5lLiB0aGUgcGVuZXRyYXRpb24gdmVjdG9yXG4gICAgdmVjMi5hZGQocGVuZXRyYXRpb25WZWMseGoscmopO1xuICAgIHZlYzIuc3ViKHBlbmV0cmF0aW9uVmVjLHBlbmV0cmF0aW9uVmVjLHhpKTtcbiAgICB2ZWMyLnN1YihwZW5ldHJhdGlvblZlYyxwZW5ldHJhdGlvblZlYyxyaSk7XG5cbiAgICAvLyBDb21wdXRlIGl0ZXJhdGlvblxuICAgIHZhciBHVywgR3E7XG4gICAgaWYodGhpcy5maXJzdEltcGFjdCAmJiB0aGlzLnJlc3RpdHV0aW9uICE9PSAwKXtcbiAgICAgICAgR3EgPSAwO1xuICAgICAgICBHVyA9ICgxL2IpKigxK3RoaXMucmVzdGl0dXRpb24pICogdGhpcy5jb21wdXRlR1coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBHcSA9IHZlYzIuZG90KG4scGVuZXRyYXRpb25WZWMpICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICB9XG5cbiAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICB2YXIgQiA9IC0gR3EgKiBhIC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9FcXVhdGlvblwiOjIzfV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBFcXVhdGlvbjtcblxudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKSxcbiAgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyksXG4gICAgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNvbnN0cmFpbnQgZXF1YXRpb25zLlxuICogQGNsYXNzIEVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUEgRmlyc3QgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBlcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QiBTZWNvbmQgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBlcXVhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG1pbkZvcmNlIE1pbmltdW0gZm9yY2UgdG8gYXBwbHkuIERlZmF1bHQ6IC1OdW1iZXIuTUFYX1ZBTFVFXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4Rm9yY2UgTWF4aW11bSBmb3JjZSB0byBhcHBseS4gRGVmYXVsdDogTnVtYmVyLk1BWF9WQUxVRVxuICovXG5mdW5jdGlvbiBFcXVhdGlvbihib2R5QSwgYm9keUIsIG1pbkZvcmNlLCBtYXhGb3JjZSl7XG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGZvcmNlIHRvIGFwcGx5IHdoZW4gc29sdmluZy5cbiAgICAgKiBAcHJvcGVydHkgbWluRm9yY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluRm9yY2UgPSB0eXBlb2YobWluRm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IC1OdW1iZXIuTUFYX1ZBTFVFIDogbWluRm9yY2U7XG5cbiAgICAvKipcbiAgICAgKiBNYXggZm9yY2UgdG8gYXBwbHkgd2hlbiBzb2x2aW5nLlxuICAgICAqIEBwcm9wZXJ0eSBtYXhGb3JjZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhGb3JjZSA9IHR5cGVvZihtYXhGb3JjZSk9PT1cInVuZGVmaW5lZFwiID8gTnVtYmVyLk1BWF9WQUxVRSA6IG1heEZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb25zdHJhaW50XG4gICAgICogQHByb3BlcnR5IGJvZHlBXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuXG4gICAgLyoqXG4gICAgICogU2Vjb25kIGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgY29uc3RyYWludFxuICAgICAqIEBwcm9wZXJ0eSBib2R5QlxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGlmZm5lc3Mgb2YgdGhpcyBlcXVhdGlvbi4gVHlwaWNhbGx5IGNob3NlbiB0byBhIGxhcmdlIG51bWJlciAofjFlNyksIGJ1dCBjYW4gYmUgY2hvc2VuIHNvbWV3aGF0IGZyZWVseSB0byBnZXQgYSBzdGFibGUgc2ltdWxhdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiB0aW1lIHN0ZXBzIG5lZWRlZCB0byBzdGFiaWxpemUgdGhlIGNvbnN0cmFpbnQgZXF1YXRpb24uIFR5cGljYWxseSBiZXR3ZWVuIDMgYW5kIDUgdGltZSBzdGVwcy5cbiAgICAgKiBAcHJvcGVydHkgcmVsYXhhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZWxheGF0aW9uID0gRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEphY29iaWFuIGVudHJ5IG9mIHRoaXMgZXF1YXRpb24uIDYgbnVtYmVycywgMyBwZXIgYm9keSAoeCx5LGFuZ2xlKS5cbiAgICAgKiBAcHJvcGVydHkgR1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLkcgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSg2KTtcbiAgICBmb3IodmFyIGk9MDsgaTw2OyBpKyspe1xuICAgICAgICB0aGlzLkdbaV09MDtcbiAgICB9XG5cbiAgICB0aGlzLm9mZnNldCA9IDA7XG5cbiAgICB0aGlzLmEgPSAwO1xuICAgIHRoaXMuYiA9IDA7XG4gICAgdGhpcy5lcHNpbG9uID0gMDtcbiAgICB0aGlzLnRpbWVTdGVwID0gMS82MDtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBzdGlmZm5lc3Mgb3IgcmVsYXhhdGlvbiB3YXMgY2hhbmdlZC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG5lZWRzVXBkYXRlXG4gICAgICovXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0aW5nIGNvbnN0cmFpbnQgbXVsdGlwbGllciBmcm9tIHRoZSBsYXN0IHNvbHZlLiBUaGlzIGlzIG1vc3RseSBlcXVpdmFsZW50IHRvIHRoZSBmb3JjZSBwcm9kdWNlZCBieSB0aGUgY29uc3RyYWludC5cbiAgICAgKiBAcHJvcGVydHkgbXVsdGlwbGllclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tdWx0aXBsaWVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHZlbG9jaXR5LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZWxhdGl2ZVZlbG9jaXR5XG4gICAgICovXG4gICAgdGhpcy5yZWxhdGl2ZVZlbG9jaXR5ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBlcXVhdGlvbiBpcyBlbmFibGVkIG9yIG5vdC4gSWYgdHJ1ZSwgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgc29sdmVyLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG59XG5FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcXVhdGlvbjtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdGlmZm5lc3Mgd2hlbiBjcmVhdGluZyBhIG5ldyBFcXVhdGlvbi5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBERUZBVUxUX1NUSUZGTkVTU1xuICogQGRlZmF1bHQgMWU2XG4gKi9cbkVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTID0gMWU2O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHJlbGF4YXRpb24gd2hlbiBjcmVhdGluZyBhIG5ldyBFcXVhdGlvbi5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBERUZBVUxUX1JFTEFYQVRJT05cbiAqIEBkZWZhdWx0IDRcbiAqL1xuRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OID0gNDtcblxuLyoqXG4gKiBDb21wdXRlIFNQT09LIHBhcmFtZXRlcnMgLmEsIC5iIGFuZCAuZXBzaWxvbiBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFyYW1ldGVycy4gU2VlIGVxdWF0aW9ucyA5LCAxMCBhbmQgMTEgaW4gdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyLzVEVjA1OC9WVDA5L2xlY3R1cmVzL3Nwb29rbm90ZXMucGRmXCI+U1BPT0sgbm90ZXM8L2E+LlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcyxcbiAgICAgICAgZCA9IHRoaXMucmVsYXhhdGlvbixcbiAgICAgICAgaCA9IHRoaXMudGltZVN0ZXA7XG5cbiAgICB0aGlzLmEgPSA0LjAgLyAoaCAqICgxICsgNCAqIGQpKTtcbiAgICB0aGlzLmIgPSAoNC4wICogZCkgLyAoMSArIDQgKiBkKTtcbiAgICB0aGlzLmVwc2lsb24gPSA0LjAgLyAoaCAqIGggKiBrICogKDEgKyA0ICogZCkpO1xuXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSBhIGphY29iaWFuIGVudHJ5IHdpdGggY29ycmVzcG9uZGluZyBwb3NpdGlvbnMgb3IgdmVsb2NpdGllc1xuICogQG1ldGhvZCBnbXVsdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuZ211bHQgPSBmdW5jdGlvbihHLHZpLHdpLHZqLHdqKXtcbiAgICByZXR1cm4gIEdbMF0gKiB2aVswXSArXG4gICAgICAgICAgICBHWzFdICogdmlbMV0gK1xuICAgICAgICAgICAgR1syXSAqIHdpICtcbiAgICAgICAgICAgIEdbM10gKiB2alswXSArXG4gICAgICAgICAgICBHWzRdICogdmpbMV0gK1xuICAgICAgICAgICAgR1s1XSAqIHdqO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUkhTIG9mIHRoZSBTUE9PSyBlcXVhdGlvblxuICogQG1ldGhvZCBjb21wdXRlQlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICB2YXIgR3EgPSB0aGlzLmNvbXB1dGVHcSgpO1xuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIHJldHVybiAtIEdxICogYSAtIEdXICogYiAtIEdpTWYqaDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgR1xcKnEsIHdoZXJlIHEgYXJlIHRoZSBnZW5lcmFsaXplZCBib2R5IGNvb3JkaW5hdGVzXG4gKiBAbWV0aG9kIGNvbXB1dGVHcVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52YXIgcWkgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHFqID0gdmVjMi5jcmVhdGUoKTtcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgeGkgPSBiaS5wb3NpdGlvbixcbiAgICAgICAgeGogPSBiai5wb3NpdGlvbixcbiAgICAgICAgYWkgPSBiaS5hbmdsZSxcbiAgICAgICAgYWogPSBiai5hbmdsZTtcblxuICAgIHJldHVybiB0aGlzLmdtdWx0KEcsIHFpLCBhaSwgcWosIGFqKSArIHRoaXMub2Zmc2V0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqVywgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllc1xuICogQG1ldGhvZCBjb21wdXRlR1dcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHVyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEcgPSB0aGlzLkcsXG4gICAgICAgIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICB2aSA9IGJpLnZlbG9jaXR5LFxuICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxuICAgICAgICB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgd2ogPSBiai5hbmd1bGFyVmVsb2NpdHk7XG4gICAgcmV0dXJuIHRoaXMuZ211bHQoRyx2aSx3aSx2aix3aikgKyB0aGlzLnJlbGF0aXZlVmVsb2NpdHk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCpXbGFtYmRhLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzXG4gKiBAbWV0aG9kIGNvbXB1dGVHV2xhbWJkYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdXbGFtYmRhID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHZpID0gYmkudmxhbWJkYSxcbiAgICAgICAgdmogPSBiai52bGFtYmRhLFxuICAgICAgICB3aSA9IGJpLndsYW1iZGEsXG4gICAgICAgIHdqID0gYmoud2xhbWJkYTtcbiAgICByZXR1cm4gdGhpcy5nbXVsdChHLHZpLHdpLHZqLHdqKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgR1xcKmludihNKVxcKmYsIHdoZXJlIE0gaXMgdGhlIG1hc3MgbWF0cml4IHdpdGggZGlhZ29uYWwgYmxvY2tzIGZvciBlYWNoIGJvZHksIGFuZCBmIGFyZSB0aGUgZm9yY2VzIG9uIHRoZSBib2RpZXMuXG4gKiBAbWV0aG9kIGNvbXB1dGVHaU1mXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZhciBpTWZpID0gdmVjMi5jcmVhdGUoKSxcbiAgICBpTWZqID0gdmVjMi5jcmVhdGUoKTtcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNZiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICBmaSA9IGJpLmZvcmNlLFxuICAgICAgICB0aSA9IGJpLmFuZ3VsYXJGb3JjZSxcbiAgICAgICAgZmogPSBiai5mb3JjZSxcbiAgICAgICAgdGogPSBiai5hbmd1bGFyRm9yY2UsXG4gICAgICAgIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52SWkgPSBiaS5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIGludklqID0gYmouaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBHID0gdGhpcy5HO1xuXG4gICAgdmVjMi5zY2FsZShpTWZpLCBmaSxpbnZNYXNzaSk7XG4gICAgdmVjMi5zY2FsZShpTWZqLCBmaixpbnZNYXNzaik7XG5cbiAgICByZXR1cm4gdGhpcy5nbXVsdChHLGlNZmksdGkqaW52SWksaU1maix0aippbnZJaik7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCppbnYoTSlcXCpHJ1xuICogQG1ldGhvZCBjb21wdXRlR2lNR3RcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1HdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBpbnZJaiA9IGJqLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIHJldHVybiAgR1swXSAqIEdbMF0gKiBpbnZNYXNzaSArXG4gICAgICAgICAgICBHWzFdICogR1sxXSAqIGludk1hc3NpICtcbiAgICAgICAgICAgIEdbMl0gKiBHWzJdICogICAgaW52SWkgK1xuICAgICAgICAgICAgR1szXSAqIEdbM10gKiBpbnZNYXNzaiArXG4gICAgICAgICAgICBHWzRdICogR1s0XSAqIGludk1hc3NqICtcbiAgICAgICAgICAgIEdbNV0gKiBHWzVdICogICAgaW52SWo7XG59O1xuXG52YXIgYWRkVG9XbGFtYmRhX3RlbXAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9HaSA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX0dqID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfcmkgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9yaiA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX01kaWFnID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBBZGQgY29uc3RyYWludCB2ZWxvY2l0eSB0byB0aGUgYm9kaWVzLlxuICogQG1ldGhvZCBhZGRUb1dsYW1iZGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YWxhbWJkYVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuYWRkVG9XbGFtYmRhID0gZnVuY3Rpb24oZGVsdGFsYW1iZGEpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgdGVtcCA9IGFkZFRvV2xhbWJkYV90ZW1wLFxuICAgICAgICBHaSA9IGFkZFRvV2xhbWJkYV9HaSxcbiAgICAgICAgR2ogPSBhZGRUb1dsYW1iZGFfR2osXG4gICAgICAgIHJpID0gYWRkVG9XbGFtYmRhX3JpLFxuICAgICAgICByaiA9IGFkZFRvV2xhbWJkYV9yaixcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZJaSA9IGJpLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIE1kaWFnID0gYWRkVG9XbGFtYmRhX01kaWFnLFxuICAgICAgICBHID0gdGhpcy5HO1xuXG4gICAgR2lbMF0gPSBHWzBdO1xuICAgIEdpWzFdID0gR1sxXTtcbiAgICBHalswXSA9IEdbM107XG4gICAgR2pbMV0gPSBHWzRdO1xuXG4gICAgLy8gQWRkIHRvIGxpbmVhciB2ZWxvY2l0eVxuICAgIC8vIHZfbGFtYmRhICs9IGludihNKSAqIGRlbHRhX2xhbWJhICogR1xuICAgIHZlYzIuc2NhbGUodGVtcCwgR2ksIGludk1hc3NpKmRlbHRhbGFtYmRhKTtcbiAgICB2ZWMyLmFkZCggYmkudmxhbWJkYSwgYmkudmxhbWJkYSwgdGVtcCk7XG4gICAgLy8gVGhpcyBpbXB1bHNlIGlzIGluIHRoZSBvZmZzZXQgZnJhbWVcbiAgICAvLyBBbHNvIGFkZCBjb250cmlidXRpb24gdG8gYW5ndWxhclxuICAgIC8vYmkud2xhbWJkYSAtPSB2ZWMyLmNyb3NzTGVuZ3RoKHRlbXAscmkpO1xuICAgIGJpLndsYW1iZGEgKz0gaW52SWkgKiBHWzJdICogZGVsdGFsYW1iZGE7XG5cblxuICAgIHZlYzIuc2NhbGUodGVtcCwgR2osIGludk1hc3NqKmRlbHRhbGFtYmRhKTtcbiAgICB2ZWMyLmFkZCggYmoudmxhbWJkYSwgYmoudmxhbWJkYSwgdGVtcCk7XG4gICAgLy9iai53bGFtYmRhIC09IHZlYzIuY3Jvc3NMZW5ndGgodGVtcCxyaik7XG4gICAgYmoud2xhbWJkYSArPSBpbnZJaiAqIEdbNV0gKiBkZWx0YWxhbWJkYTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgZGVub21pbmF0b3IgcGFydCBvZiB0aGUgU1BPT0sgZXF1YXRpb246IEMgPSBHXFwqaW52KE0pXFwqRycgKyBlcHNcbiAqIEBtZXRob2QgY29tcHV0ZUludkNcbiAqIEBwYXJhbSAge051bWJlcn0gZXBzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlSW52QyA9IGZ1bmN0aW9uKGVwcyl7XG4gICAgcmV0dXJuIDEuMCAvICh0aGlzLmNvbXB1dGVHaU1HdCgpICsgZXBzKTtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9vYmplY3RzL0JvZHlcIjozMixcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgRXF1YXRpb24gPSBfZGVyZXFfKCcuL0VxdWF0aW9uJylcbiwgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnJpY3Rpb25FcXVhdGlvbjtcblxuLyoqXG4gKiBDb25zdHJhaW5zIHRoZSBzbGlwcGluZyBpbiBhIGNvbnRhY3QgYWxvbmcgYSB0YW5nZW50XG4gKlxuICogQGNsYXNzIEZyaWN0aW9uRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IHNsaXBGb3JjZVxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqL1xuZnVuY3Rpb24gRnJpY3Rpb25FcXVhdGlvbihib2R5QSwgYm9keUIsIHNsaXBGb3JjZSl7XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1zbGlwRm9yY2UsIHNsaXBGb3JjZSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSB2ZWN0b3IgZnJvbSBjZW50ZXIgb2YgYm9keSBBIHRvIHRoZSBjb250YWN0IHBvaW50LCB3b3JsZCBvcmllbnRlZC5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RQb2ludEEgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgdmVjdG9yIGZyb20gY2VudGVyIG9mIGJvZHkgQiB0byB0aGUgY29udGFjdCBwb2ludCwgd29ybGQgb3JpZW50ZWQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRCID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFRhbmdlbnQgdmVjdG9yIHRoYXQgdGhlIGZyaWN0aW9uIGZvcmNlIHdpbGwgYWN0IGFsb25nLiBXb3JsZCBvcmllbnRlZC5cbiAgICAgKiBAcHJvcGVydHkgdFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogQSBDb250YWN0RXF1YXRpb24gY29ubmVjdGVkIHRvIHRoaXMgZnJpY3Rpb24uIFRoZSBjb250YWN0IGVxdWF0aW9ucyBjYW4gYmUgdXNlZCB0byByZXNjYWxlIHRoZSBtYXggZm9yY2UgZm9yIHRoZSBmcmljdGlvbi4gSWYgbW9yZSB0aGFuIG9uZSBjb250YWN0IGVxdWF0aW9uIGlzIGdpdmVuLCB0aGVuIHRoZSBtYXggZm9yY2UgY2FuIGJlIHNldCB0byB0aGUgYXZlcmFnZS5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdEVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtDb250YWN0RXF1YXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnJpY3Rpb24uXG4gICAgICogQHByb3BlcnR5IHNoYXBlQVxuICAgICAqIEB0eXBlIHtTaGFwZX1cbiAgICAgKiBAdG9kbyBOZWVkZWQ/IFRoZSBzaGFwZSBjYW4gYmUgbG9va2VkIHVwIHZpYSBjb250YWN0RXF1YXRpb24uc2hhcGVBLi4uXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlIGluIGJvZHkgaiB0aGF0IHRyaWdnZXJlZCB0aGlzIGZyaWN0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUJcbiAgICAgKiBAdHlwZSB7U2hhcGV9XG4gICAgICogQHRvZG8gTmVlZGVkPyBUaGUgc2hhcGUgY2FuIGJlIGxvb2tlZCB1cCB2aWEgY29udGFjdEVxdWF0aW9uLnNoYXBlQi4uLlxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVCID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmljdGlvbiBjb2VmZmljaWVudCB0byB1c2UuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uQ29lZmZpY2llbnRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25Db2VmZmljaWVudCA9IDAuMztcbn1cbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZyaWN0aW9uRXF1YXRpb247XG5cbi8qKlxuICogU2V0IHRoZSBzbGlwcGluZyBjb25kaXRpb24gZm9yIHRoZSBjb25zdHJhaW50LiBUaGUgZnJpY3Rpb24gZm9yY2UgY2Fubm90IGJlXG4gKiBsYXJnZXIgdGhhbiB0aGlzIHZhbHVlLlxuICogQG1ldGhvZCBzZXRTbGlwRm9yY2VcbiAqIEBwYXJhbSAge051bWJlcn0gc2xpcEZvcmNlXG4gKi9cbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLnNldFNsaXBGb3JjZSA9IGZ1bmN0aW9uKHNsaXBGb3JjZSl7XG4gICAgdGhpcy5tYXhGb3JjZSA9IHNsaXBGb3JjZTtcbiAgICB0aGlzLm1pbkZvcmNlID0gLXNsaXBGb3JjZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXggZm9yY2UgZm9yIHRoZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBnZXRTbGlwRm9yY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuZ2V0U2xpcEZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5tYXhGb3JjZTtcbn07XG5cbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oYSxiLGgpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgcmkgPSB0aGlzLmNvbnRhY3RQb2ludEEsXG4gICAgICAgIHJqID0gdGhpcy5jb250YWN0UG9pbnRCLFxuICAgICAgICB0ID0gdGhpcy50LFxuICAgICAgICBHID0gdGhpcy5HO1xuXG4gICAgLy8gRyA9IFstdCAtcml4dCB0IHJqeHRdXG4gICAgLy8gQW5kIHJlbWVtYmVyLCB0aGlzIGlzIGEgcHVyZSB2ZWxvY2l0eSBjb25zdHJhaW50LCBnIGlzIGFsd2F5cyB6ZXJvIVxuICAgIEdbMF0gPSAtdFswXTtcbiAgICBHWzFdID0gLXRbMV07XG4gICAgR1syXSA9IC12ZWMyLmNyb3NzTGVuZ3RoKHJpLHQpO1xuICAgIEdbM10gPSB0WzBdO1xuICAgIEdbNF0gPSB0WzFdO1xuICAgIEdbNV0gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJqLHQpO1xuXG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKSxcbiAgICAgICAgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcblxuICAgIHZhciBCID0gLyogLSBnICogYSAgKi8gLSBHVyAqIGIgLSBoKkdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjUwLFwiLi9FcXVhdGlvblwiOjIzfV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEVxdWF0aW9uID0gX2RlcmVxXyhcIi4vRXF1YXRpb25cIiksXG4gICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxMb2NrRXF1YXRpb247XG5cbi8qKlxuICogTG9ja3MgdGhlIHJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdHdvIGJvZGllcy4gVGhlIGNvbnN0cmFpbnQgdHJpZXMgdG8ga2VlcCB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0d28gdmVjdG9ycywgbG9jYWwgaW4gZWFjaCBib2R5LCB0byB6ZXJvLiBUaGUgbG9jYWwgYW5nbGUgaW4gYm9keSBpIGlzIGEgcGFyYW1ldGVyLlxuICpcbiAqIEBjbGFzcyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5nbGVdIEFuZ2xlIHRvIGFkZCB0byB0aGUgbG9jYWwgdmVjdG9yIGluIGJvZHlBLlxuICovXG5mdW5jdGlvbiBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmFuZ2xlIHx8IDA7XG5cbiAgICB2YXIgRyA9IHRoaXMuRztcbiAgICBHWzJdID0gIDE7XG4gICAgR1s1XSA9IC0xO1xufVxuUm90YXRpb25hbExvY2tFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcblJvdGF0aW9uYWxMb2NrRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbExvY2tFcXVhdGlvbjtcblxudmFyIHdvcmxkVmVjdG9yQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgd29ybGRWZWN0b3JCID0gdmVjMi5jcmVhdGUoKSxcbiAgICB4QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygxLDApLFxuICAgIHlBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDAsMSk7XG5Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgIHZlYzIucm90YXRlKHdvcmxkVmVjdG9yQSx4QXhpcyx0aGlzLmJvZHlBLmFuZ2xlK3RoaXMuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkVmVjdG9yQix5QXhpcyx0aGlzLmJvZHlCLmFuZ2xlKTtcbiAgICByZXR1cm4gdmVjMi5kb3Qod29ybGRWZWN0b3JBLHdvcmxkVmVjdG9yQik7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9FcXVhdGlvblwiOjIzfV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEVxdWF0aW9uID0gX2RlcmVxXyhcIi4vRXF1YXRpb25cIiksXG4gICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uO1xuXG4vKipcbiAqIFN5bmNzIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdHdvIGJvZGllcywgb3Igc2V0cyBhIHJlbGF0aXZlIHZlbG9jaXR5IChtb3RvcikuXG4gKlxuICogQGNsYXNzIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbmZ1bmN0aW9uIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB0aGlzLnJlbGF0aXZlVmVsb2NpdHkgPSAxO1xuICAgIHRoaXMucmF0aW8gPSAxO1xufVxuUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbjtcblJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgRyA9IHRoaXMuRztcbiAgICBHWzJdID0gLTE7XG4gICAgR1s1XSA9IHRoaXMucmF0aW87XG5cbiAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xuICAgIHZhciBCID0gLSBHVyAqIGIgLSBoKkdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0VxdWF0aW9uXCI6MjN9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIG9iamVjdHMgdGhhdCBkaXNwYXRjaGVzIGV2ZW50cy5cbiAqIEBjbGFzcyBFdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24gKCkge307XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBFdmVudEVtaXR0ZXIsXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAbWV0aG9kIG9uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIsIGNvbnRleHQgKSB7XG4gICAgICAgIGxpc3RlbmVyLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBldmVudCBsaXN0ZW5lciBpcyBhZGRlZFxuICAgICAqIEBtZXRob2QgaGFzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXM6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICBpZihsaXN0ZW5lcil7XG4gICAgICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKTtcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0uc3BsaWNlKCBpbmRleCwgMSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbWl0IGFuIGV2ZW50LlxuICAgICAqIEBtZXRob2QgZW1pdFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50LnR5cGVcbiAgICAgKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICB2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuICAgICAgICBpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBcnJheVsgaSBdO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoIGxpc3RlbmVyLmNvbnRleHQsIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxufSx7fV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIE1hdGVyaWFsID0gX2RlcmVxXygnLi9NYXRlcmlhbCcpO1xudmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0VxdWF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdE1hdGVyaWFsO1xuXG4vKipcbiAqIERlZmluZXMgd2hhdCBoYXBwZW5zIHdoZW4gdHdvIG1hdGVyaWFscyBtZWV0LCBzdWNoIGFzIHdoYXQgZnJpY3Rpb24gY29lZmZpY2llbnQgdG8gdXNlLiBZb3UgY2FuIGFsc28gc2V0IG90aGVyIHRoaW5ncyBzdWNoIGFzIHJlc3RpdHV0aW9uLCBzdXJmYWNlIHZlbG9jaXR5IGFuZCBjb25zdHJhaW50IHBhcmFtZXRlcnMuXG4gKiBAY2xhc3MgQ29udGFjdE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQVxuICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxCXG4gKiBAcGFyYW0ge09iamVjdH0gICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLmZyaWN0aW9uPTAuM10gICAgICAgRnJpY3Rpb24gY29lZmZpY2llbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5yZXN0aXR1dGlvbj0wXSAgICAgIFJlc3RpdHV0aW9uIGNvZWZmaWNpZW50IGFrYSBcImJvdW5jaW5lc3NcIi5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnN0aWZmbmVzc10gICAgICAgICAgQ29udGFjdEVxdWF0aW9uIHN0aWZmbmVzcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnJlbGF4YXRpb25dICAgICAgICAgQ29udGFjdEVxdWF0aW9uIHJlbGF4YXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5mcmljdGlvblN0aWZmbmVzc10gIEZyaWN0aW9uRXF1YXRpb24gc3RpZmZuZXNzLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuZnJpY3Rpb25SZWxheGF0aW9uXSBGcmljdGlvbkVxdWF0aW9uIHJlbGF4YXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5zdXJmYWNlVmVsb2NpdHk9MF0gIFN1cmZhY2UgdmVsb2NpdHkuXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIENvbnRhY3RNYXRlcmlhbChtYXRlcmlhbEEsIG1hdGVyaWFsQiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZighKG1hdGVyaWFsQSBpbnN0YW5jZW9mIE1hdGVyaWFsKSB8fCAhKG1hdGVyaWFsQiBpbnN0YW5jZW9mIE1hdGVyaWFsKSl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IHR3byBhcmd1bWVudHMgbXVzdCBiZSBNYXRlcmlhbCBpbnN0YW5jZXMuXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250YWN0IG1hdGVyaWFsIGlkZW50aWZpZXJcbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBtYXRlcmlhbCBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb250YWN0IG1hdGVyaWFsXG4gICAgICogQHByb3BlcnR5IG1hdGVyaWFsQVxuICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsQSA9IG1hdGVyaWFsQTtcblxuICAgIC8qKlxuICAgICAqIFNlY29uZCBtYXRlcmlhbCBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb250YWN0IG1hdGVyaWFsXG4gICAgICogQHByb3BlcnR5IG1hdGVyaWFsQlxuICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsQiA9IG1hdGVyaWFsQjtcblxuICAgIC8qKlxuICAgICAqIEZyaWN0aW9uIHRvIHVzZSBpbiB0aGUgY29udGFjdCBvZiB0aGVzZSB0d28gbWF0ZXJpYWxzXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uICAgID0gIHR5cGVvZihvcHRpb25zLmZyaWN0aW9uKSAgICAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMuZnJpY3Rpb24pICAgIDogMC4zO1xuXG4gICAgLyoqXG4gICAgICogUmVzdGl0dXRpb24gdG8gdXNlIGluIHRoZSBjb250YWN0IG9mIHRoZXNlIHR3byBtYXRlcmlhbHNcbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSAgdHlwZW9mKG9wdGlvbnMucmVzdGl0dXRpb24pICE9PSBcInVuZGVmaW5lZFwiID8gICBOdW1iZXIob3B0aW9ucy5yZXN0aXR1dGlvbikgOiAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHJlc3VsdGluZyBDb250YWN0RXF1YXRpb24gdGhhdCB0aGlzIENvbnRhY3RNYXRlcmlhbCBnZW5lcmF0ZVxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gICAgICAgICAgICB0eXBlb2Yob3B0aW9ucy5zdGlmZm5lc3MpICAgICAgICAgICAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMuc3RpZmZuZXNzKSAgIDogRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBSZWxheGF0aW9uIG9mIHRoZSByZXN1bHRpbmcgQ29udGFjdEVxdWF0aW9uIHRoYXQgdGhpcyBDb250YWN0TWF0ZXJpYWwgZ2VuZXJhdGVcbiAgICAgKiBAcHJvcGVydHkgcmVsYXhhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZWxheGF0aW9uID0gICAgICAgICAgIHR5cGVvZihvcHRpb25zLnJlbGF4YXRpb24pICAgICAgICAgICE9PSBcInVuZGVmaW5lZFwiID8gICBOdW1iZXIob3B0aW9ucy5yZWxheGF0aW9uKSAgOiBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHJlc3VsdGluZyBGcmljdGlvbkVxdWF0aW9uIHRoYXQgdGhpcyBDb250YWN0TWF0ZXJpYWwgZ2VuZXJhdGVcbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25TdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25TdGlmZm5lc3MgPSAgICB0eXBlb2Yob3B0aW9ucy5mcmljdGlvblN0aWZmbmVzcykgICAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMuZnJpY3Rpb25TdGlmZm5lc3MpICAgOiBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFJlbGF4YXRpb24gb2YgdGhlIHJlc3VsdGluZyBGcmljdGlvbkVxdWF0aW9uIHRoYXQgdGhpcyBDb250YWN0TWF0ZXJpYWwgZ2VuZXJhdGVcbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25SZWxheGF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uUmVsYXhhdGlvbiA9ICAgdHlwZW9mKG9wdGlvbnMuZnJpY3Rpb25SZWxheGF0aW9uKSAgIT09IFwidW5kZWZpbmVkXCIgPyAgIE51bWJlcihvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbikgIDogRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBhZGQgc3VyZmFjZSB2ZWxvY2l0eSB0byB0aGlzIG1hdGVyaWFsLiBJZiBib2R5QSByZXN0cyBvbiB0b3AgaWYgYm9keUIsIGFuZCB0aGUgc3VyZmFjZSB2ZWxvY2l0eSBpcyBwb3NpdGl2ZSwgYm9keUEgd2lsbCBzbGlkZSB0byB0aGUgcmlnaHQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN1cmZhY2VWZWxvY2l0eVxuICAgICAqL1xuICAgIHRoaXMuc3VyZmFjZVZlbG9jaXR5ID0gdHlwZW9mKG9wdGlvbnMuc3VyZmFjZVZlbG9jaXR5KSAgICAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMuc3VyZmFjZVZlbG9jaXR5KSAgICA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBPZmZzZXQgdG8gYmUgc2V0IG9uIENvbnRhY3RFcXVhdGlvbnMuIEEgcG9zaXRpdmUgdmFsdWUgd2lsbCBtYWtlIHRoZSBib2RpZXMgcGVuZXRyYXRlIG1vcmUgaW50byBlYWNoIG90aGVyLiBDYW4gYmUgdXNlZnVsIGluIHNjZW5lcyB3aGVyZSBjb250YWN0cyBuZWVkIHRvIGJlIG1vcmUgcGVyc2lzdGVudCwgZm9yIGV4YW1wbGUgd2hlbiBzdGFja2luZy4gQWthIFwiY3VyZSBmb3IgbmVydm91cyBjb250YWN0c1wiLlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0U2tpblNpemVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFNraW5TaXplID0gMC4wMDU7XG59XG5cbkNvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xuXG59LHtcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi9NYXRlcmlhbFwiOjI5fV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBNYXRlcmlhbDtcblxuLyoqXG4gKiBEZWZpbmVzIGEgcGh5c2ljcyBtYXRlcmlhbC5cbiAqIEBjbGFzcyBNYXRlcmlhbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgTWF0ZXJpYWwgaWRlbnRpZmllclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICovXG5mdW5jdGlvbiBNYXRlcmlhbChpZCl7XG4gICAgLyoqXG4gICAgICogVGhlIG1hdGVyaWFsIGlkZW50aWZpZXJcbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBpZCB8fCBNYXRlcmlhbC5pZENvdW50ZXIrKztcbn1cblxuTWF0ZXJpYWwuaWRDb3VudGVyID0gMDtcblxufSx7fV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG4gICAgLypcbiAgICAgICAgUG9seUsgbGlicmFyeVxuICAgICAgICB1cmw6IGh0dHA6Ly9wb2x5ay5pdmFuay5uZXRcbiAgICAgICAgUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2VuY2UuXG5cbiAgICAgICAgQ29weXJpZ2h0IChjKSAyMDEyIEl2YW4gS3Vja2lyXG5cbiAgICAgICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICAgICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAgICAgICAgZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gICAgICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICAgICAgICBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAgICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAgICAgICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgY29uZGl0aW9uczpcblxuICAgICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgICAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgICAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAgICAgICAgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICAgICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAgICAgICAgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gICAgICAgIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICAgICAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gICAgICAgIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAgICAqL1xuXG4gICAgdmFyIFBvbHlLID0ge307XG5cbiAgICAvKlxuICAgICAgICBJcyBQb2x5Z29uIHNlbGYtaW50ZXJzZWN0aW5nP1xuXG4gICAgICAgIE8obl4yKVxuICAgICovXG4gICAgLypcbiAgICBQb2x5Sy5Jc1NpbXBsZSA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xuICAgICAgICBpZihuPDQpIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgYTEgPSBuZXcgUG9seUsuX1AoKSwgYTIgPSBuZXcgUG9seUsuX1AoKTtcbiAgICAgICAgdmFyIGIxID0gbmV3IFBvbHlLLl9QKCksIGIyID0gbmV3IFBvbHlLLl9QKCk7XG4gICAgICAgIHZhciBjID0gbmV3IFBvbHlLLl9QKCk7XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBhMS54ID0gcFsyKmkgIF07XG4gICAgICAgICAgICBhMS55ID0gcFsyKmkrMV07XG4gICAgICAgICAgICBpZihpPT1uLTEpICB7IGEyLnggPSBwWzAgICAgXTsgIGEyLnkgPSBwWzEgICAgXTsgfVxuICAgICAgICAgICAgZWxzZSAgICAgICAgeyBhMi54ID0gcFsyKmkrMl07ICBhMi55ID0gcFsyKmkrM107IH1cblxuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8bjsgaisrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKGktaikgPCAyKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZihqPT1uLTEgJiYgaT09MCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYoaT09bi0xICYmIGo9PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgYjEueCA9IHBbMipqICBdO1xuICAgICAgICAgICAgICAgIGIxLnkgPSBwWzIqaisxXTtcbiAgICAgICAgICAgICAgICBpZihqPT1uLTEpICB7IGIyLnggPSBwWzAgICAgXTsgIGIyLnkgPSBwWzEgICAgXTsgfVxuICAgICAgICAgICAgICAgIGVsc2UgICAgICAgIHsgYjIueCA9IHBbMipqKzJdOyAgYjIueSA9IHBbMipqKzNdOyB9XG5cbiAgICAgICAgICAgICAgICBpZihQb2x5Sy5fR2V0TGluZUludGVyc2VjdGlvbihhMSxhMixiMSxiMixjKSAhPSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgUG9seUsuSXNDb252ZXggPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgaWYocC5sZW5ndGg8NikgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSA0O1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxuICAgICAgICAgICAgaWYoIVBvbHlLLl9jb252ZXgocFtpXSwgcFtpKzFdLCBwW2krMl0sIHBbaSszXSwgcFtpKzRdLCBwW2krNV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmKCFQb2x5Sy5fY29udmV4KHBbbCAgXSwgcFtsKzFdLCBwW2wrMl0sIHBbbCszXSwgcFswXSwgcFsxXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYoIVBvbHlLLl9jb252ZXgocFtsKzJdLCBwW2wrM10sIHBbMCAgXSwgcFsxICBdLCBwWzJdLCBwWzNdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgKi9cbiAgICBQb2x5Sy5HZXRBcmVhID0gZnVuY3Rpb24ocClcbiAgICB7XG4gICAgICAgIGlmKHAubGVuZ3RoIDw2KSByZXR1cm4gMDtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxuICAgICAgICAgICAgc3VtICs9IChwW2krMl0tcFtpXSkgKiAocFtpKzFdK3BbaSszXSk7XG4gICAgICAgIHN1bSArPSAocFswXS1wW2xdKSAqIChwW2wrMV0rcFsxXSk7XG4gICAgICAgIHJldHVybiAtIHN1bSAqIDAuNTtcbiAgICB9XG4gICAgLypcbiAgICBQb2x5Sy5HZXRBQUJCID0gZnVuY3Rpb24ocClcbiAgICB7XG4gICAgICAgIHZhciBtaW54ID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtaW55ID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXh4ID0gLW1pbng7XG4gICAgICAgIHZhciBtYXh5ID0gLW1pbnk7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHAubGVuZ3RoOyBpKz0yKVxuICAgICAgICB7XG4gICAgICAgICAgICBtaW54ID0gTWF0aC5taW4obWlueCwgcFtpICBdKTtcbiAgICAgICAgICAgIG1heHggPSBNYXRoLm1heChtYXh4LCBwW2kgIF0pO1xuICAgICAgICAgICAgbWlueSA9IE1hdGgubWluKG1pbnksIHBbaSsxXSk7XG4gICAgICAgICAgICBtYXh5ID0gTWF0aC5tYXgobWF4eSwgcFtpKzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3g6bWlueCwgeTptaW55LCB3aWR0aDptYXh4LW1pbngsIGhlaWdodDptYXh5LW1pbnl9O1xuICAgIH1cbiAgICAqL1xuXG4gICAgUG9seUsuVHJpYW5ndWxhdGUgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgdmFyIG4gPSBwLmxlbmd0aD4+MTtcbiAgICAgICAgaWYobjwzKSByZXR1cm4gW107XG4gICAgICAgIHZhciB0Z3MgPSBbXTtcbiAgICAgICAgdmFyIGF2bCA9IFtdO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspIGF2bC5wdXNoKGkpO1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGFsID0gbjtcbiAgICAgICAgd2hpbGUoYWwgPiAzKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaTAgPSBhdmxbKGkrMCklYWxdO1xuICAgICAgICAgICAgdmFyIGkxID0gYXZsWyhpKzEpJWFsXTtcbiAgICAgICAgICAgIHZhciBpMiA9IGF2bFsoaSsyKSVhbF07XG5cbiAgICAgICAgICAgIHZhciBheCA9IHBbMippMF0sICBheSA9IHBbMippMCsxXTtcbiAgICAgICAgICAgIHZhciBieCA9IHBbMippMV0sICBieSA9IHBbMippMSsxXTtcbiAgICAgICAgICAgIHZhciBjeCA9IHBbMippMl0sICBjeSA9IHBbMippMisxXTtcblxuICAgICAgICAgICAgdmFyIGVhckZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBpZihQb2x5Sy5fY29udmV4KGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVhckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGo9MDsgajxhbDsgaisrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpID0gYXZsW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZih2aT09aTAgfHwgdmk9PWkxIHx8IHZpPT1pMikgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmKFBvbHlLLl9Qb2ludEluVHJpYW5nbGUocFsyKnZpXSwgcFsyKnZpKzFdLCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KSkge2VhckZvdW5kID0gZmFsc2U7IGJyZWFrO31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihlYXJGb3VuZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0Z3MucHVzaChpMCwgaTEsIGkyKTtcbiAgICAgICAgICAgICAgICBhdmwuc3BsaWNlKChpKzEpJWFsLCAxKTtcbiAgICAgICAgICAgICAgICBhbC0tO1xuICAgICAgICAgICAgICAgIGk9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGkrKyA+IDMqYWwpIGJyZWFrOyAgICAgIC8vIG5vIGNvbnZleCBhbmdsZXMgOihcbiAgICAgICAgfVxuICAgICAgICB0Z3MucHVzaChhdmxbMF0sIGF2bFsxXSwgYXZsWzJdKTtcbiAgICAgICAgcmV0dXJuIHRncztcbiAgICB9XG4gICAgLypcbiAgICBQb2x5Sy5Db250YWluc1BvaW50ID0gZnVuY3Rpb24ocCwgcHgsIHB5KVxuICAgIHtcbiAgICAgICAgdmFyIG4gPSBwLmxlbmd0aD4+MTtcbiAgICAgICAgdmFyIGF4LCBheSwgYnggPSBwWzIqbi0yXS1weCwgYnkgPSBwWzIqbi0xXS1weTtcbiAgICAgICAgdmFyIGRlcHRoID0gMDtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBheCA9IGJ4OyAgYXkgPSBieTtcbiAgICAgICAgICAgIGJ4ID0gcFsyKmkgIF0gLSBweDtcbiAgICAgICAgICAgIGJ5ID0gcFsyKmkrMV0gLSBweTtcbiAgICAgICAgICAgIGlmKGF5PCAwICYmIGJ5PCAwKSBjb250aW51ZTsgICAgLy8gYm90aCBcInVwXCIgb3IgYm90aCBcImRvbndcIlxuICAgICAgICAgICAgaWYoYXk+PTAgJiYgYnk+PTApIGNvbnRpbnVlOyAgICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG9ud1wiXG4gICAgICAgICAgICBpZihheDwgMCAmJiBieDwgMCkgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBseCA9IGF4ICsgKGJ4LWF4KSooLWF5KS8oYnktYXkpO1xuICAgICAgICAgICAgaWYobHg+MCkgZGVwdGgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGRlcHRoICYgMSkgPT0gMTtcbiAgICB9XG5cbiAgICBQb2x5Sy5TbGljZSA9IGZ1bmN0aW9uKHAsIGF4LCBheSwgYngsIGJ5KVxuICAgIHtcbiAgICAgICAgaWYoUG9seUsuQ29udGFpbnNQb2ludChwLCBheCwgYXkpIHx8IFBvbHlLLkNvbnRhaW5zUG9pbnQocCwgYngsIGJ5KSkgcmV0dXJuIFtwLnNsaWNlKDApXTtcblxuICAgICAgICB2YXIgYSA9IG5ldyBQb2x5Sy5fUChheCwgYXkpO1xuICAgICAgICB2YXIgYiA9IG5ldyBQb2x5Sy5fUChieCwgYnkpO1xuICAgICAgICB2YXIgaXNjcyA9IFtdOyAgLy8gaW50ZXJzZWN0aW9uc1xuICAgICAgICB2YXIgcHMgPSBbXTsgICAgLy8gcG9pbnRzXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHAubGVuZ3RoOyBpKz0yKSBwcy5wdXNoKG5ldyBQb2x5Sy5fUChwW2ldLCBwW2krMV0pKTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxwcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGlzYyA9IG5ldyBQb2x5Sy5fUCgwLDApO1xuICAgICAgICAgICAgaXNjID0gUG9seUsuX0dldExpbmVJbnRlcnNlY3Rpb24oYSwgYiwgcHNbaV0sIHBzWyhpKzEpJXBzLmxlbmd0aF0sIGlzYyk7XG5cbiAgICAgICAgICAgIGlmKGlzYylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpc2MuZmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaXNjcy5wdXNoKGlzYyk7XG4gICAgICAgICAgICAgICAgcHMuc3BsaWNlKGkrMSwwLGlzYyk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGlzY3MubGVuZ3RoID09IDApIHJldHVybiBbcC5zbGljZSgwKV07XG4gICAgICAgIHZhciBjb21wID0gZnVuY3Rpb24odSx2KSB7cmV0dXJuIFBvbHlLLl9QLmRpc3QoYSx1KSAtIFBvbHlLLl9QLmRpc3QoYSx2KTsgfVxuICAgICAgICBpc2NzLnNvcnQoY29tcCk7XG5cbiAgICAgICAgdmFyIHBncyA9IFtdO1xuICAgICAgICB2YXIgZGlyID0gMDtcbiAgICAgICAgd2hpbGUoaXNjcy5sZW5ndGggPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbiA9IHBzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpMCA9IGlzY3NbMF07XG4gICAgICAgICAgICB2YXIgaTEgPSBpc2NzWzFdO1xuICAgICAgICAgICAgdmFyIGluZDAgPSBwcy5pbmRleE9mKGkwKTtcbiAgICAgICAgICAgIHZhciBpbmQxID0gcHMuaW5kZXhPZihpMSk7XG4gICAgICAgICAgICB2YXIgc29sdmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmKFBvbHlLLl9maXJzdFdpdGhGbGFnKHBzLCBpbmQwKSA9PSBpbmQxKSBzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGkwID0gaXNjc1sxXTtcbiAgICAgICAgICAgICAgICBpMSA9IGlzY3NbMF07XG4gICAgICAgICAgICAgICAgaW5kMCA9IHBzLmluZGV4T2YoaTApO1xuICAgICAgICAgICAgICAgIGluZDEgPSBwcy5pbmRleE9mKGkxKTtcbiAgICAgICAgICAgICAgICBpZihQb2x5Sy5fZmlyc3RXaXRoRmxhZyhwcywgaW5kMCkgPT0gaW5kMSkgc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHNvbHZlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkaXItLTtcbiAgICAgICAgICAgICAgICB2YXIgcGduID0gUG9seUsuX2dldFBvaW50cyhwcywgaW5kMCwgaW5kMSk7XG4gICAgICAgICAgICAgICAgcGdzLnB1c2gocGduKTtcbiAgICAgICAgICAgICAgICBwcyA9IFBvbHlLLl9nZXRQb2ludHMocHMsIGluZDEsIGluZDApO1xuICAgICAgICAgICAgICAgIGkwLmZsYWcgPSBpMS5mbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaXNjcy5zcGxpY2UoMCwyKTtcbiAgICAgICAgICAgICAgICBpZihpc2NzLmxlbmd0aCA9PSAwKSBwZ3MucHVzaChwcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgZGlyKys7IGlzY3MucmV2ZXJzZSgpOyB9XG4gICAgICAgICAgICBpZihkaXI+MSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxwZ3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwZyA9IHBnc1tpXTtcbiAgICAgICAgICAgIHZhciBucGcgPSBbXTtcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHBnLmxlbmd0aDsgaisrKSBucGcucHVzaChwZ1tqXS54LCBwZ1tqXS55KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5wZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBQb2x5Sy5SYXljYXN0ID0gZnVuY3Rpb24ocCwgeCwgeSwgZHgsIGR5LCBpc2MpXG4gICAge1xuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgICAgICAgdmFyIHRwID0gUG9seUsuX3RwO1xuICAgICAgICB2YXIgYTEgPSB0cFswXSwgYTIgPSB0cFsxXSxcbiAgICAgICAgYjEgPSB0cFsyXSwgYjIgPSB0cFszXSwgYyA9IHRwWzRdO1xuICAgICAgICBhMS54ID0geDsgYTEueSA9IHk7XG4gICAgICAgIGEyLnggPSB4K2R4OyBhMi55ID0geStkeTtcblxuICAgICAgICBpZihpc2M9PW51bGwpIGlzYyA9IHtkaXN0OjAsIGVkZ2U6MCwgbm9ybTp7eDowLCB5OjB9LCByZWZsOnt4OjAsIHk6MH19O1xuICAgICAgICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGIxLnggPSBwW2kgIF07ICBiMS55ID0gcFtpKzFdO1xuICAgICAgICAgICAgYjIueCA9IHBbaSsyXTsgIGIyLnkgPSBwW2krM107XG4gICAgICAgICAgICB2YXIgbmlzYyA9IFBvbHlLLl9SYXlMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKTtcbiAgICAgICAgICAgIGlmKG5pc2MpIFBvbHlLLl91cGRhdGVJU0MoZHgsIGR5LCBhMSwgYjEsIGIyLCBjLCBpLzIsIGlzYyk7XG4gICAgICAgIH1cbiAgICAgICAgYjEueCA9IGIyLng7ICBiMS55ID0gYjIueTtcbiAgICAgICAgYjIueCA9IHBbMF07ICBiMi55ID0gcFsxXTtcbiAgICAgICAgdmFyIG5pc2MgPSBQb2x5Sy5fUmF5TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYyk7XG4gICAgICAgIGlmKG5pc2MpIFBvbHlLLl91cGRhdGVJU0MoZHgsIGR5LCBhMSwgYjEsIGIyLCBjLCBwLmxlbmd0aC8yLCBpc2MpO1xuXG4gICAgICAgIHJldHVybiAoaXNjLmRpc3QgIT0gSW5maW5pdHkpID8gaXNjIDogbnVsbDtcbiAgICB9XG5cbiAgICBQb2x5Sy5DbG9zZXN0RWRnZSA9IGZ1bmN0aW9uKHAsIHgsIHksIGlzYylcbiAgICB7XG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICAgICAgICB2YXIgdHAgPSBQb2x5Sy5fdHA7XG4gICAgICAgIHZhciBhMSA9IHRwWzBdLFxuICAgICAgICBiMSA9IHRwWzJdLCBiMiA9IHRwWzNdLCBjID0gdHBbNF07XG4gICAgICAgIGExLnggPSB4OyBhMS55ID0geTtcblxuICAgICAgICBpZihpc2M9PW51bGwpIGlzYyA9IHtkaXN0OjAsIGVkZ2U6MCwgcG9pbnQ6e3g6MCwgeTowfSwgbm9ybTp7eDowLCB5OjB9fTtcbiAgICAgICAgaXNjLmRpc3QgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxuICAgICAgICB7XG4gICAgICAgICAgICBiMS54ID0gcFtpICBdOyAgYjEueSA9IHBbaSsxXTtcbiAgICAgICAgICAgIGIyLnggPSBwW2krMl07ICBiMi55ID0gcFtpKzNdO1xuICAgICAgICAgICAgUG9seUsuX3BvaW50TGluZURpc3QoYTEsIGIxLCBiMiwgaT4+MSwgaXNjKTtcbiAgICAgICAgfVxuICAgICAgICBiMS54ID0gYjIueDsgIGIxLnkgPSBiMi55O1xuICAgICAgICBiMi54ID0gcFswXTsgIGIyLnkgPSBwWzFdO1xuICAgICAgICBQb2x5Sy5fcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBsPj4xLCBpc2MpO1xuXG4gICAgICAgIHZhciBpZHN0ID0gMS9pc2MuZGlzdDtcbiAgICAgICAgaXNjLm5vcm0ueCA9ICh4LWlzYy5wb2ludC54KSppZHN0O1xuICAgICAgICBpc2Mubm9ybS55ID0gKHktaXNjLnBvaW50LnkpKmlkc3Q7XG4gICAgICAgIHJldHVybiBpc2M7XG4gICAgfVxuXG4gICAgUG9seUsuX3BvaW50TGluZURpc3QgPSBmdW5jdGlvbihwLCBhLCBiLCBlZGdlLCBpc2MpXG4gICAge1xuICAgICAgICB2YXIgeCA9IHAueCwgeSA9IHAueSwgeDEgPSBhLngsIHkxID0gYS55LCB4MiA9IGIueCwgeTIgPSBiLnk7XG5cbiAgICAgICAgdmFyIEEgPSB4IC0geDE7XG4gICAgICAgIHZhciBCID0geSAtIHkxO1xuICAgICAgICB2YXIgQyA9IHgyIC0geDE7XG4gICAgICAgIHZhciBEID0geTIgLSB5MTtcblxuICAgICAgICB2YXIgZG90ID0gQSAqIEMgKyBCICogRDtcbiAgICAgICAgdmFyIGxlbl9zcSA9IEMgKiBDICsgRCAqIEQ7XG4gICAgICAgIHZhciBwYXJhbSA9IGRvdCAvIGxlbl9zcTtcblxuICAgICAgICB2YXIgeHgsIHl5O1xuXG4gICAgICAgIGlmIChwYXJhbSA8IDAgfHwgKHgxID09IHgyICYmIHkxID09IHkyKSkge1xuICAgICAgICAgICAgeHggPSB4MTtcbiAgICAgICAgICAgIHl5ID0geTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW0gPiAxKSB7XG4gICAgICAgICAgICB4eCA9IHgyO1xuICAgICAgICAgICAgeXkgPSB5MjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHh4ID0geDEgKyBwYXJhbSAqIEM7XG4gICAgICAgICAgICB5eSA9IHkxICsgcGFyYW0gKiBEO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR4ID0geCAtIHh4O1xuICAgICAgICB2YXIgZHkgPSB5IC0geXk7XG4gICAgICAgIHZhciBkc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBpZihkc3Q8aXNjLmRpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlzYy5kaXN0ID0gZHN0O1xuICAgICAgICAgICAgaXNjLmVkZ2UgPSBlZGdlO1xuICAgICAgICAgICAgaXNjLnBvaW50LnggPSB4eDtcbiAgICAgICAgICAgIGlzYy5wb2ludC55ID0geXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBQb2x5Sy5fdXBkYXRlSVNDID0gZnVuY3Rpb24oZHgsIGR5LCBhMSwgYjEsIGIyLCBjLCBlZGdlLCBpc2MpXG4gICAge1xuICAgICAgICB2YXIgbnJsID0gUG9seUsuX1AuZGlzdChhMSwgYyk7XG4gICAgICAgIGlmKG5ybDxpc2MuZGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGlibCA9IDEvUG9seUsuX1AuZGlzdChiMSwgYjIpO1xuICAgICAgICAgICAgdmFyIG54ID0gLShiMi55LWIxLnkpKmlibDtcbiAgICAgICAgICAgIHZhciBueSA9ICAoYjIueC1iMS54KSppYmw7XG4gICAgICAgICAgICB2YXIgZGRvdCA9IDIqKGR4Km54K2R5Km55KTtcbiAgICAgICAgICAgIGlzYy5kaXN0ID0gbnJsO1xuICAgICAgICAgICAgaXNjLm5vcm0ueCA9IG54O1xuICAgICAgICAgICAgaXNjLm5vcm0ueSA9IG55O1xuICAgICAgICAgICAgaXNjLnJlZmwueCA9IC1kZG90Km54K2R4O1xuICAgICAgICAgICAgaXNjLnJlZmwueSA9IC1kZG90Km55K2R5O1xuICAgICAgICAgICAgaXNjLmVkZ2UgPSBlZGdlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgUG9seUsuX2dldFBvaW50cyA9IGZ1bmN0aW9uKHBzLCBpbmQwLCBpbmQxKVxuICAgIHtcbiAgICAgICAgdmFyIG4gPSBwcy5sZW5ndGg7XG4gICAgICAgIHZhciBucHMgPSBbXTtcbiAgICAgICAgaWYoaW5kMTxpbmQwKSBpbmQxICs9IG47XG4gICAgICAgIGZvcih2YXIgaT1pbmQwOyBpPD0gaW5kMTsgaSsrKSBucHMucHVzaChwc1tpJW5dKTtcbiAgICAgICAgcmV0dXJuIG5wcztcbiAgICB9XG5cbiAgICBQb2x5Sy5fZmlyc3RXaXRoRmxhZyA9IGZ1bmN0aW9uKHBzLCBpbmQpXG4gICAge1xuICAgICAgICB2YXIgbiA9IHBzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUodHJ1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaW5kID0gKGluZCsxKSVuO1xuICAgICAgICAgICAgaWYocHNbaW5kXS5mbGFnKSByZXR1cm4gaW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgICovXG4gICAgUG9seUsuX1BvaW50SW5UcmlhbmdsZSA9IGZ1bmN0aW9uKHB4LCBweSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSlcbiAgICB7XG4gICAgICAgIHZhciB2MHggPSBjeC1heDtcbiAgICAgICAgdmFyIHYweSA9IGN5LWF5O1xuICAgICAgICB2YXIgdjF4ID0gYngtYXg7XG4gICAgICAgIHZhciB2MXkgPSBieS1heTtcbiAgICAgICAgdmFyIHYyeCA9IHB4LWF4O1xuICAgICAgICB2YXIgdjJ5ID0gcHktYXk7XG5cbiAgICAgICAgdmFyIGRvdDAwID0gdjB4KnYweCt2MHkqdjB5O1xuICAgICAgICB2YXIgZG90MDEgPSB2MHgqdjF4K3YweSp2MXk7XG4gICAgICAgIHZhciBkb3QwMiA9IHYweCp2MngrdjB5KnYyeTtcbiAgICAgICAgdmFyIGRvdDExID0gdjF4KnYxeCt2MXkqdjF5O1xuICAgICAgICB2YXIgZG90MTIgPSB2MXgqdjJ4K3YxeSp2Mnk7XG5cbiAgICAgICAgdmFyIGludkRlbm9tID0gMSAvIChkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSk7XG4gICAgICAgIHZhciB1ID0gKGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyKSAqIGludkRlbm9tO1xuICAgICAgICB2YXIgdiA9IChkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMikgKiBpbnZEZW5vbTtcblxuICAgICAgICAvLyBDaGVjayBpZiBwb2ludCBpcyBpbiB0cmlhbmdsZVxuICAgICAgICByZXR1cm4gKHUgPj0gMCkgJiYgKHYgPj0gMCkgJiYgKHUgKyB2IDwgMSk7XG4gICAgfVxuICAgIC8qXG4gICAgUG9seUsuX1JheUxpbmVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhMSwgYTIsIGIxLCBiMiwgYylcbiAgICB7XG4gICAgICAgIHZhciBkYXggPSAoYTEueC1hMi54KSwgZGJ4ID0gKGIxLngtYjIueCk7XG4gICAgICAgIHZhciBkYXkgPSAoYTEueS1hMi55KSwgZGJ5ID0gKGIxLnktYjIueSk7XG5cbiAgICAgICAgdmFyIERlbiA9IGRheCpkYnkgLSBkYXkqZGJ4O1xuICAgICAgICBpZiAoRGVuID09IDApIHJldHVybiBudWxsOyAgLy8gcGFyYWxsZWxcblxuICAgICAgICB2YXIgQSA9IChhMS54ICogYTIueSAtIGExLnkgKiBhMi54KTtcbiAgICAgICAgdmFyIEIgPSAoYjEueCAqIGIyLnkgLSBiMS55ICogYjIueCk7XG5cbiAgICAgICAgdmFyIEkgPSBjO1xuICAgICAgICB2YXIgaURlbiA9IDEvRGVuO1xuICAgICAgICBJLnggPSAoIEEqZGJ4IC0gZGF4KkIgKSAqIGlEZW47XG4gICAgICAgIEkueSA9ICggQSpkYnkgLSBkYXkqQiApICogaURlbjtcblxuICAgICAgICBpZighUG9seUsuX0luUmVjdChJLCBiMSwgYjIpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYoKGRheT4wICYmIEkueT5hMS55KSB8fCAoZGF5PDAgJiYgSS55PGExLnkpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYoKGRheD4wICYmIEkueD5hMS54KSB8fCAoZGF4PDAgJiYgSS54PGExLngpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIEk7XG4gICAgfVxuXG4gICAgUG9seUsuX0dldExpbmVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhMSwgYTIsIGIxLCBiMiwgYylcbiAgICB7XG4gICAgICAgIHZhciBkYXggPSAoYTEueC1hMi54KSwgZGJ4ID0gKGIxLngtYjIueCk7XG4gICAgICAgIHZhciBkYXkgPSAoYTEueS1hMi55KSwgZGJ5ID0gKGIxLnktYjIueSk7XG5cbiAgICAgICAgdmFyIERlbiA9IGRheCpkYnkgLSBkYXkqZGJ4O1xuICAgICAgICBpZiAoRGVuID09IDApIHJldHVybiBudWxsOyAgLy8gcGFyYWxsZWxcblxuICAgICAgICB2YXIgQSA9IChhMS54ICogYTIueSAtIGExLnkgKiBhMi54KTtcbiAgICAgICAgdmFyIEIgPSAoYjEueCAqIGIyLnkgLSBiMS55ICogYjIueCk7XG5cbiAgICAgICAgdmFyIEkgPSBjO1xuICAgICAgICBJLnggPSAoIEEqZGJ4IC0gZGF4KkIgKSAvIERlbjtcbiAgICAgICAgSS55ID0gKCBBKmRieSAtIGRheSpCICkgLyBEZW47XG5cbiAgICAgICAgaWYoUG9seUsuX0luUmVjdChJLCBhMSwgYTIpICYmIFBvbHlLLl9JblJlY3QoSSwgYjEsIGIyKSkgcmV0dXJuIEk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIFBvbHlLLl9JblJlY3QgPSBmdW5jdGlvbihhLCBiLCBjKVxuICAgIHtcbiAgICAgICAgaWYgIChiLnggPT0gYy54KSByZXR1cm4gKGEueT49TWF0aC5taW4oYi55LCBjLnkpICYmIGEueTw9TWF0aC5tYXgoYi55LCBjLnkpKTtcbiAgICAgICAgaWYgIChiLnkgPT0gYy55KSByZXR1cm4gKGEueD49TWF0aC5taW4oYi54LCBjLngpICYmIGEueDw9TWF0aC5tYXgoYi54LCBjLngpKTtcblxuICAgICAgICBpZihhLnggPj0gTWF0aC5taW4oYi54LCBjLngpICYmIGEueCA8PSBNYXRoLm1heChiLngsIGMueClcbiAgICAgICAgJiYgYS55ID49IE1hdGgubWluKGIueSwgYy55KSAmJiBhLnkgPD0gTWF0aC5tYXgoYi55LCBjLnkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAqL1xuICAgIFBvbHlLLl9jb252ZXggPSBmdW5jdGlvbihheCwgYXksIGJ4LCBieSwgY3gsIGN5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIChheS1ieSkqKGN4LWJ4KSArIChieC1heCkqKGN5LWJ5KSA+PSAwO1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLl9QID0gZnVuY3Rpb24oeCx5KVxuICAgIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy5mbGFnID0gZmFsc2U7XG4gICAgfVxuICAgIFBvbHlLLl9QLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHJldHVybiBcIlBvaW50IFtcIit0aGlzLngrXCIsIFwiK3RoaXMueStcIl1cIjtcbiAgICB9XG4gICAgUG9seUsuX1AuZGlzdCA9IGZ1bmN0aW9uKGEsYilcbiAgICB7XG4gICAgICAgIHZhciBkeCA9IGIueC1hLng7XG4gICAgICAgIHZhciBkeSA9IGIueS1hLnk7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG4gICAgfVxuXG4gICAgUG9seUsuX3RwID0gW107XG4gICAgZm9yKHZhciBpPTA7IGk8MTA7IGkrKykgUG9seUsuX3RwLnB1c2gobmV3IFBvbHlLLl9QKDAsMCkpO1xuICAgICAgICAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlLO1xuXG59LHt9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBUaGUgdmVjMiBvYmplY3QgZnJvbSBnbE1hdHJpeCwgd2l0aCBzb21lIGV4dGVuc2lvbnMgYW5kIHNvbWUgcmVtb3ZlZCBtZXRob2RzLiBTZWUgaHR0cDovL2dsbWF0cml4Lm5ldC5cbiAqIEBjbGFzcyB2ZWMyXG4gKi9cblxudmFyIHZlYzIgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG4vKipcbiAqIE1ha2UgYSBjcm9zcyBwcm9kdWN0IGFuZCBvbmx5IHJldHVybiB0aGUgeiBjb21wb25lbnRcbiAqIEBtZXRob2QgY3Jvc3NMZW5ndGhcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52ZWMyLmNyb3NzTGVuZ3RoID0gZnVuY3Rpb24oYSxiKXtcbiAgICByZXR1cm4gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbn07XG5cbi8qKlxuICogQ3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIGEgdmVjdG9yIGFuZCB0aGUgWiBjb21wb25lbnQgb2YgYSB2ZWN0b3JcbiAqIEBtZXRob2QgY3Jvc3NWWlxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IHZlY1xuICogQHBhcmFtICB7TnVtYmVyfSB6Y29tcFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52ZWMyLmNyb3NzVlogPSBmdW5jdGlvbihvdXQsIHZlYywgemNvbXApe1xuICAgIHZlYzIucm90YXRlKG91dCx2ZWMsLU1hdGguUEkvMik7Ly8gUm90YXRlIGFjY29yZGluZyB0byB0aGUgcmlnaHQgaGFuZCBydWxlXG4gICAgdmVjMi5zY2FsZShvdXQsb3V0LHpjb21wKTsgICAgICAvLyBTY2FsZSB3aXRoIHpcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcm9zcyBwcm9kdWN0IGJldHdlZW4gYSB2ZWN0b3IgYW5kIHRoZSBaIGNvbXBvbmVudCBvZiBhIHZlY3RvclxuICogQG1ldGhvZCBjcm9zc1pWXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHpjb21wXG4gKiBAcGFyYW0gIHtBcnJheX0gdmVjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZlYzIuY3Jvc3NaViA9IGZ1bmN0aW9uKG91dCwgemNvbXAsIHZlYyl7XG4gICAgdmVjMi5yb3RhdGUob3V0LHZlYyxNYXRoLlBJLzIpOyAvLyBSb3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByaWdodCBoYW5kIHJ1bGVcbiAgICB2ZWMyLnNjYWxlKG91dCxvdXQsemNvbXApOyAgICAgIC8vIFNjYWxlIHdpdGggelxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSBhbiBhbmdsZVxuICogQG1ldGhvZCByb3RhdGVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbnZlYzIucm90YXRlID0gZnVuY3Rpb24ob3V0LGEsYW5nbGUpe1xuICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBzID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgeCA9IGFbMF0sXG4gICAgICAgICAgICB5ID0gYVsxXTtcbiAgICAgICAgb3V0WzBdID0gYyp4IC1zKnk7XG4gICAgICAgIG91dFsxXSA9IHMqeCArYyp5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMV07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgOTAgZGVncmVlcyBjbG9ja3dpc2VcbiAqIEBtZXRob2Qgcm90YXRlOTBjd1xuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xudmVjMi5yb3RhdGU5MGN3ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdO1xuICAgIHZhciB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSB5O1xuICAgIG91dFsxXSA9IC14O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBwb2ludCBwb3NpdGlvbiB0byBsb2NhbCBmcmFtZS5cbiAqIEBtZXRob2QgdG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRQb2ludFxuICogQHBhcmFtICB7QXJyYXl9IGZyYW1lUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxuICovXG52ZWMyLnRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uKG91dCwgd29ybGRQb2ludCwgZnJhbWVQb3NpdGlvbiwgZnJhbWVBbmdsZSl7XG4gICAgdmVjMi5jb3B5KG91dCwgd29ybGRQb2ludCk7XG4gICAgdmVjMi5zdWIob3V0LCBvdXQsIGZyYW1lUG9zaXRpb24pO1xuICAgIHZlYzIucm90YXRlKG91dCwgb3V0LCAtZnJhbWVBbmdsZSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHBvaW50IHBvc2l0aW9uIHRvIGdsb2JhbCBmcmFtZS5cbiAqIEBtZXRob2QgdG9HbG9iYWxGcmFtZVxuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IGxvY2FsUG9pbnRcbiAqIEBwYXJhbSAge0FycmF5fSBmcmFtZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGZyYW1lQW5nbGVcbiAqL1xudmVjMi50b0dsb2JhbEZyYW1lID0gZnVuY3Rpb24ob3V0LCBsb2NhbFBvaW50LCBmcmFtZVBvc2l0aW9uLCBmcmFtZUFuZ2xlKXtcbiAgICB2ZWMyLmNvcHkob3V0LCBsb2NhbFBvaW50KTtcbiAgICB2ZWMyLnJvdGF0ZShvdXQsIG91dCwgZnJhbWVBbmdsZSk7XG4gICAgdmVjMi5hZGQob3V0LCBvdXQsIGZyYW1lUG9zaXRpb24pO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIGNlbnRyb2lkIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB2ZWN0b3JzIGEsYixjLiBTZWUgaHR0cDovL2Vhc3ljYWxjdWxhdGlvbi5jb20vYW5hbHl0aWNhbC9sZWFybi1jZW50cm9pZC5waHBcbiAqIEBtZXRob2QgY2VudHJvaWRcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEByZXR1cm4gIHtBcnJheX0gVGhlIG91dCBvYmplY3RcbiAqL1xudmVjMi5jZW50cm9pZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gICAgdmVjMi5hZGQob3V0LCBhLCBiKTtcbiAgICB2ZWMyLmFkZChvdXQsIG91dCwgYyk7XG4gICAgdmVjMi5zY2FsZShvdXQsIG91dCwgMS8zKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNyZWF0ZVxuICogQHJldHVybiB7QXJyYXl9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybiB7QXJyYXl9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tVmFsdWVzXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBvdXQgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBzdWJ0cmFjdFxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuc3VidHJhY3RcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3ViXG4gKi9cbnZlYzIuc3ViID0gdmVjMi5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbXVsdGlwbHlcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLm11bHRpcGx5XG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG11bFxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRpdmlkZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLmRpdmlkZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXZcbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzY2FsZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRpc3RhbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5kaXN0YW5jZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXN0XG4gKi9cbnZlYzIuZGlzdCA9IHZlYzIuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHNxdWFyZWREaXN0YW5jZVxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLnNxdWFyZWREaXN0YW5jZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXJEaXN0XG4gKi9cbnZlYzIuc3FyRGlzdCA9IHZlYzIuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbGVuZ3RoXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIubGVuZ3RoXG4gKiBAbWV0aG9kIGxlblxuICogQHN0YXRpY1xuICovXG52ZWMyLmxlbiA9IHZlYzIubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXVhcmVkTGVuZ3RoXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm4ge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMyLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuc3F1YXJlZExlbmd0aFxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXJMZW5cbiAqL1xudmVjMi5zcXJMZW4gPSB2ZWMyLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbmVnYXRlXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZG90XG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzIuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzdHJcbiAqIEBwYXJhbSB7QXJyYXl9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcpJztcbn07XG5cbnZlYzIubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbn0se1wiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBkZWNvbXAgPSBfZGVyZXFfKCdwb2x5LWRlY29tcCcpXG4sICAgQ29udmV4ID0gX2RlcmVxXygnLi4vc2hhcGVzL0NvbnZleCcpXG4sICAgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJylcbiwgICBFdmVudEVtaXR0ZXIgPSBfZGVyZXFfKCcuLi9ldmVudHMvRXZlbnRFbWl0dGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQm9keTtcblxuLyoqXG4gKiBBIHJpZ2lkIGJvZHkuIEhhcyBnb3QgYSBjZW50ZXIgb2YgbWFzcywgcG9zaXRpb24sIHZlbG9jaXR5IGFuZCBhIG51bWJlciBvZlxuICogc2hhcGVzIHRoYXQgYXJlIHVzZWQgZm9yIGNvbGxpc2lvbnMuXG4gKlxuICogQGNsYXNzIEJvZHlcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgIFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5tYXNzPTBdICAgIEEgbnVtYmVyID49IDAuIElmIHplcm8sIHRoZSAudHlwZSB3aWxsIGJlIHNldCB0byBCb2R5LlNUQVRJQy5cbiAqIEBwYXJhbSB7QXJyYXl9ICAgICAgICAgICAgICAgW29wdGlvbnMucG9zaXRpb25dXG4gKiBAcGFyYW0ge0FycmF5fSAgICAgICAgICAgICAgIFtvcHRpb25zLnZlbG9jaXR5XVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5hbmdsZT0wXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5hbmd1bGFyVmVsb2NpdHk9MF1cbiAqIEBwYXJhbSB7QXJyYXl9ICAgICAgICAgICAgICAgW29wdGlvbnMuZm9yY2VdXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgIFtvcHRpb25zLmFuZ3VsYXJGb3JjZT0wXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5maXhlZFJvdGF0aW9uPWZhbHNlXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5jY2RTcGVlZFRocmVzaG9sZD0tMV1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMuY2NkSXRlcmF0aW9ucz0xMF1cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAvLyBDcmVhdGUgYSB0eXBpY2FsIGR5bmFtaWMgYm9keVxuICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoe1xuICogICAgICAgICBtYXNzOiAxLFxuICogICAgICAgICBwb3NpdGlvbjogWzAsIDBdLFxuICogICAgICAgICBhbmdsZTogMCxcbiAqICAgICAgICAgdmVsb2NpdHk6IFswLCAwXSxcbiAqICAgICAgICAgYW5ndWxhclZlbG9jaXR5OiAwXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIEFkZCBhIGNpcmN1bGFyIHNoYXBlIHRvIHRoZSBib2R5XG4gKiAgICAgYm9keS5hZGRTaGFwZShuZXcgQ2lyY2xlKDEpKTtcbiAqXG4gKiAgICAgLy8gQWRkIHRoZSBib2R5IHRvIHRoZSB3b3JsZFxuICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSk7XG4gKi9cbmZ1bmN0aW9uIEJvZHkob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBib2R5IGlkZW50aWZ5ZXJcbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSArK0JvZHkuX2lkQ291bnRlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZCB0aGF0IHRoaXMgYm9keSBpcyBhZGRlZCB0by4gVGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gTlVMTCBpZiB0aGUgYm9keSBpcyBub3QgYWRkZWQgdG8gYW55IHdvcmxkLlxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxuICAgICAqIEB0eXBlIHtXb3JsZH1cbiAgICAgKi9cbiAgICB0aGlzLndvcmxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZXMgb2YgdGhlIGJvZHkuIFRoZSBsb2NhbCB0cmFuc2Zvcm0gb2YgdGhlIHNoYXBlIGluIC5zaGFwZXNbaV0gaXNcbiAgICAgKiBkZWZpbmVkIGJ5IC5zaGFwZU9mZnNldHNbaV0gYW5kIC5zaGFwZUFuZ2xlc1tpXS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zaGFwZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbCBzaGFwZSBvZmZzZXRzLCByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcy4gVGhpcyBpcyBhblxuICAgICAqIGFycmF5IG9mIEFycmF5LlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZU9mZnNldHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zaGFwZU9mZnNldHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBib2R5LWxvY2FsIHNoYXBlIGFuZ2xlIHRyYW5zZm9ybXMuIFRoaXMgaXMgYW4gYXJyYXkgb2YgbnVtYmVycyAoYW5nbGVzKS5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVBbmdsZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zaGFwZUFuZ2xlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hc3Mgb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IG1hc3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWFzcyA9IG9wdGlvbnMubWFzcyB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2UgbWFzcyBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgaW52TWFzc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbnZNYXNzID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmVydGlhIG9mIHRoZSBib2R5IGFyb3VuZCB0aGUgWiBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSBpbmVydGlhXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmluZXJ0aWEgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2UgaW5lcnRpYSBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgaW52SW5lcnRpYVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbnZJbmVydGlhID0gMDtcblxuICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcbiAgICB0aGlzLmludkluZXJ0aWFTb2x2ZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBmaXggdGhlIHJvdGF0aW9uIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBmaXhlZFJvdGF0aW9uXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5maXhlZFJvdGF0aW9uID0gISFvcHRpb25zLmZpeGVkUm90YXRpb247XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGJvZHlcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuICAgIGlmKG9wdGlvbnMucG9zaXRpb24pe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5wb3NpdGlvbiwgb3B0aW9ucy5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVycG9sYXRlZCBwb3NpdGlvbiBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgaW50ZXJwb2xhdGVkUG9zaXRpb25cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5pbnRlcnBvbGF0ZWRQb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVycG9sYXRlZCBhbmdsZSBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgaW50ZXJwb2xhdGVkQW5nbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJwb2xhdGVkQW5nbGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIHBvc2l0aW9uIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBwcmV2aW91c1Bvc2l0aW9uXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIGFuZ2xlIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBwcmV2aW91c0FuZ2xlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzQW5nbGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlbG9jaXR5IG9mIHRoZSBib2R5XG4gICAgICogQHByb3BlcnR5IHZlbG9jaXR5XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICBpZihvcHRpb25zLnZlbG9jaXR5KXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMudmVsb2NpdHksIG9wdGlvbnMudmVsb2NpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cmFpbnQgdmVsb2NpdHkgdGhhdCB3YXMgYWRkZWQgdG8gdGhlIGJvZHkgZHVyaW5nIHRoZSBsYXN0IHN0ZXAuXG4gICAgICogQHByb3BlcnR5IHZsYW1iZGFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52bGFtYmRhID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGNvbnN0cmFpbnQgdmVsb2NpdHkgdGhhdCB3YXMgYWRkZWQgdG8gdGhlIGJvZHkgZHVyaW5nIGxhc3Qgc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgd2xhbWJkYVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLndsYW1iZGEgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ2xlIG9mIHRoZSBib2R5LCBpbiByYWRpYW5zLlxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gVGhlIGFuZ2xlIHByb3BlcnR5IGlzIG5vdCBub3JtYWxpemVkIHRvIHRoZSBpbnRlcnZhbCAwIHRvIDIqcGksIGl0IGNhbiBiZSBhbnkgdmFsdWUuXG4gICAgICogICAgIC8vIElmIHlvdSBuZWVkIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyKnBpLCB1c2UgdGhlIGZvbGxvd2luZyBmdW5jdGlvbiB0byBub3JtYWxpemUgaXQuXG4gICAgICogICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUFuZ2xlKGFuZ2xlKXtcbiAgICAgKiAgICAgICAgIGFuZ2xlID0gYW5nbGUgJSAoMipNYXRoLlBJKTtcbiAgICAgKiAgICAgICAgIGlmKGFuZ2xlIDwgMCl7XG4gICAgICogICAgICAgICAgICAgYW5nbGUgKz0gKDIqTWF0aC5QSSk7XG4gICAgICogICAgICAgICB9XG4gICAgICogICAgICAgICByZXR1cm4gYW5nbGU7XG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZHksIGluIHJhZGlhbnMgcGVyIHNlY29uZC5cbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclZlbG9jaXR5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9yY2UgYWN0aW5nIG9uIHRoZSBib2R5LiBTaW5jZSB0aGUgYm9keSBmb3JjZSAoYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvYW5ndWxhckZvcmNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319KSB3aWxsIGJlIHplcm9lZCBhZnRlciBlYWNoIHN0ZXAsIHNvIHlvdSBuZWVkIHRvIHNldCB0aGUgZm9yY2UgYmVmb3JlIGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgZm9yY2VcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBUaGlzIHByb2R1Y2VzIGEgZm9yY2VmaWVsZCBvZiAxIE5ld3RvbiBpbiB0aGUgcG9zaXRpdmUgeCBkaXJlY3Rpb24uXG4gICAgICogICAgIGZvcih2YXIgaT0wOyBpPG51bVN0ZXBzOyBpKyspe1xuICAgICAqICAgICAgICAgYm9keS5mb3JjZVswXSA9IDE7XG4gICAgICogICAgICAgICB3b3JsZC5zdGVwKDEvNjApO1xuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBUaGlzIHdpbGwgYXBwbHkgYSByb3RhdGlvbmFsIGZvcmNlIG9uIHRoZSBib2R5XG4gICAgICogICAgIGZvcih2YXIgaT0wOyBpPG51bVN0ZXBzOyBpKyspe1xuICAgICAqICAgICAgICAgYm9keS5hbmd1bGFyRm9yY2UgPSAtMztcbiAgICAgKiAgICAgICAgIHdvcmxkLnN0ZXAoMS82MCk7XG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICB0aGlzLmZvcmNlID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zLmZvcmNlKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMuZm9yY2UsIG9wdGlvbnMuZm9yY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmd1bGFyIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2VlIHt7I2Nyb3NzTGluayBcIkJvZHkvZm9yY2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJGb3JjZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyRm9yY2UgPSBvcHRpb25zLmFuZ3VsYXJGb3JjZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpbmVhciBkYW1waW5nIGFjdGluZyBvbiB0aGUgYm9keSBpbiB0aGUgdmVsb2NpdHkgZGlyZWN0aW9uLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHByb3BlcnR5IGRhbXBpbmdcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMVxuICAgICAqL1xuICAgIHRoaXMuZGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmRhbXBpbmcpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5kYW1waW5nIDogMC4xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ3VsYXIgZm9yY2UgYWN0aW5nIG9uIHRoZSBib2R5LiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJEYW1waW5nXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjFcbiAgICAgKi9cbiAgICB0aGlzLmFuZ3VsYXJEYW1waW5nID0gdHlwZW9mKG9wdGlvbnMuYW5ndWxhckRhbXBpbmcpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5hbmd1bGFyRGFtcGluZyA6IDAuMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIG1vdGlvbiB0aGlzIGJvZHkgaGFzLiBTaG91bGQgYmUgb25lIG9mOiB7eyNjcm9zc0xpbmsgXCJCb2R5L1NUQVRJQzpwcm9wZXJ0eVwifX1Cb2R5LlNUQVRJQ3t7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJCb2R5L0RZTkFNSUM6cHJvcGVydHlcIn19Qm9keS5EWU5BTUlDe3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvS0lORU1BVElDOnByb3BlcnR5XCJ9fUJvZHkuS0lORU1BVElDe3svY3Jvc3NMaW5rfX0uXG4gICAgICpcbiAgICAgKiAqIFN0YXRpYyBib2RpZXMgZG8gbm90IG1vdmUsIGFuZCB0aGV5IGRvIG5vdCByZXNwb25kIHRvIGZvcmNlcyBvciBjb2xsaXNpb24uXG4gICAgICogKiBEeW5hbWljIGJvZGllcyBib2R5IGNhbiBtb3ZlIGFuZCByZXNwb25kIHRvIGNvbGxpc2lvbnMgYW5kIGZvcmNlcy5cbiAgICAgKiAqIEtpbmVtYXRpYyBib2RpZXMgb25seSBtb3ZlcyBhY2NvcmRpbmcgdG8gaXRzIC52ZWxvY2l0eSwgYW5kIGRvZXMgbm90IHJlc3BvbmQgdG8gY29sbGlzaW9ucyBvciBmb3JjZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEJvZGllcyBhcmUgc3RhdGljIGJ5IGRlZmF1bHQuIFN0YXRpYyBib2RpZXMgd2lsbCBuZXZlciBtb3ZlLlxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkudHlwZSA9PSBCb2R5LlNUQVRJQyk7IC8vIHRydWVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEJ5IHNldHRpbmcgdGhlIG1hc3Mgb2YgYSBib2R5IHRvIGEgbm9uemVybyBudW1iZXIsIHRoZSBib2R5XG4gICAgICogICAgIC8vIHdpbGwgYmVjb21lIGR5bmFtaWMgYW5kIHdpbGwgbW92ZSBhbmQgaW50ZXJhY3Qgd2l0aCBvdGhlciBib2RpZXMuXG4gICAgICogICAgIHZhciBkeW5hbWljQm9keSA9IG5ldyBCb2R5KHtcbiAgICAgKiAgICAgICAgIG1hc3MgOiAxXG4gICAgICogICAgIH0pO1xuICAgICAqICAgICBjb25zb2xlLmxvZyhkeW5hbWljQm9keS50eXBlID09IEJvZHkuRFlOQU1JQyk7IC8vIHRydWVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEtpbmVtYXRpYyBib2RpZXMgd2lsbCBvbmx5IG1vdmUgaWYgeW91IGNoYW5nZSB0aGVpciB2ZWxvY2l0eS5cbiAgICAgKiAgICAgdmFyIGtpbmVtYXRpY0JvZHkgPSBuZXcgQm9keSh7XG4gICAgICogICAgICAgICB0eXBlOiBCb2R5LktJTkVNQVRJQyAvLyBUeXBlIGNhbiBiZSBzZXQgdmlhIHRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiAgICAgfSk7XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gQm9keS5TVEFUSUM7XG5cbiAgICBpZih0eXBlb2Yob3B0aW9ucy50eXBlKSAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgfSBlbHNlIGlmKCFvcHRpb25zLm1hc3Mpe1xuICAgICAgICB0aGlzLnR5cGUgPSBCb2R5LlNUQVRJQztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnR5cGUgPSBCb2R5LkRZTkFNSUM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQm91bmRpbmcgY2lyY2xlIHJhZGl1cy5cbiAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQm91bmRpbmcgYm94IG9mIHRoaXMgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYWFiYlxuICAgICAqIEB0eXBlIHtBQUJCfVxuICAgICAqL1xuICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIEFBQkIgbmVlZHMgdXBkYXRlLiBVcGRhdGUgaXQgd2l0aCB7eyNjcm9zc0xpbmsgXCJCb2R5L3VwZGF0ZUFBQkI6bWV0aG9kXCJ9fS51cGRhdGVBQUJCKCl7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgYWFiYk5lZWRzVXBkYXRlXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHNlZSB1cGRhdGVBQUJCXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBGb3JjZSB1cGRhdGUgdGhlIEFBQkJcbiAgICAgKiAgICAgYm9keS5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAqICAgICBib2R5LnVwZGF0ZUFBQkIoKTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5hYWJiTmVlZHNVcGRhdGUpOyAvLyBmYWxzZVxuICAgICAqL1xuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBib2R5IHdpbGwgYXV0b21hdGljYWxseSBmYWxsIHRvIHNsZWVwLiBOb3RlIHRoYXQgeW91IG5lZWQgdG8gZW5hYmxlIHNsZWVwaW5nIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJXb3JsZFwifX17ey9jcm9zc0xpbmt9fSBiZWZvcmUgYW55dGhpbmcgd2lsbCBoYXBwZW4uXG4gICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hbGxvd1NsZWVwID0gdHJ1ZTtcblxuICAgIHRoaXMud2FudHNUb1NsZWVwID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBPbmUgb2Yge3sjY3Jvc3NMaW5rIFwiQm9keS9BV0FLRTpwcm9wZXJ0eVwifX1Cb2R5LkFXQUtFe3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkJvZHkvU0xFRVBZOnByb3BlcnR5XCJ9fUJvZHkuU0xFRVBZe3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvU0xFRVBJTkc6cHJvcGVydHlcIn19Qm9keS5TTEVFUElOR3t7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogVGhlIGJvZHkgaXMgaW5pdGlhbGx5IEJvZHkuQVdBS0UuIElmIGl0cyB2ZWxvY2l0eSBub3JtIGlzIGJlbG93IC5zbGVlcFNwZWVkTGltaXQsIHRoZSBzbGVlcFN0YXRlIHdpbGwgYmVjb21lIEJvZHkuU0xFRVBZLiBJZiB0aGUgYm9keSBjb250aW51ZXMgdG8gYmUgQm9keS5TTEVFUFkgZm9yIC5zbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCB3aWxsIGZhbGwgYXNsZWVwIChCb2R5LlNMRUVQWSkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc2xlZXBTdGF0ZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgQm9keS5BV0FLRVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuQVdBS0U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc3BlZWQgKHRoZSBub3JtIG9mIHRoZSB2ZWxvY2l0eSkgaXMgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUsIHRoZSBib2R5IGlzIGNvbnNpZGVyZWQgc2xlZXB5LlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFNwZWVkTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMlxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBTcGVlZExpbWl0ID0gMC4yO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGJvZHkgaGFzIGJlZW4gc2xlZXB5IGZvciB0aGlzIHNsZWVwVGltZUxpbWl0IHNlY29uZHMsIGl0IGlzIGNvbnNpZGVyZWQgc2xlZXBpbmcuXG4gICAgICogQHByb3BlcnR5IHNsZWVwVGltZUxpbWl0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5zbGVlcFRpbWVMaW1pdCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBHcmF2aXR5IHNjYWxpbmcgZmFjdG9yLiBJZiB5b3Ugd2FudCB0aGUgYm9keSB0byBpZ25vcmUgZ3Jhdml0eSwgc2V0IHRoaXMgdG8gemVyby4gSWYgeW91IHdhbnQgdG8gcmV2ZXJzZSBncmF2aXR5LCBzZXQgaXQgdG8gLTEuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGdyYXZpdHlTY2FsZVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICB0aGlzLmdyYXZpdHlTY2FsZSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuIFRoYXQgbWVhbnMgdGhhdCB0aGlzIGJvZHkgd2lsbCBtb3ZlIHRocm91Z2ggb3RoZXIgYm9kaWVzLCBidXQgaXQgd2lsbCBzdGlsbCB0cmlnZ2VyIGNvbnRhY3QgZXZlbnRzLCBldGMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjb2xsaXNpb25SZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSG93IGxvbmcgdGhlIGJvZHkgaGFzIGJlZW4gc2xlZXBpbmcuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGlkbGVUaW1lXG4gICAgICovXG4gICAgdGhpcy5pZGxlVGltZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCB0aW1lIHdoZW4gdGhlIGJvZHkgd2VudCB0byBTTEVFUFkgc3RhdGUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpbWVMYXN0U2xlZXB5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gMDtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBib2R5IHNwZWVkIGV4Y2VlZHMgdGhpcyB0aHJlc2hvbGQsIENDRCAoY29udGludW91cyBjb2xsaXNpb24gZGV0ZWN0aW9uKSB3aWxsIGJlIGVuYWJsZWQuIFNldCBpdCB0byBhIG5lZ2F0aXZlIG51bWJlciB0byBkaXNhYmxlIENDRCBjb21wbGV0ZWx5IGZvciB0aGlzIGJvZHkuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNjZFNwZWVkVGhyZXNob2xkXG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cbiAgICB0aGlzLmNjZFNwZWVkVGhyZXNob2xkID0gb3B0aW9ucy5jY2RTcGVlZFRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jY2RTcGVlZFRocmVzaG9sZCA6IC0xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiBzZWFyY2hpbmcgZm9yIHRoZSB0aW1lIG9mIGltcGFjdCBkdXJpbmcgQ0NELiBBIGxhcmdlciBudW1iZXIgd2lsbCBhc3N1cmUgdGhhdCB0aGVyZSdzIGEgc21hbGwgcGVuZXRyYXRpb24gb24gQ0NEIGNvbGxpc2lvbiwgYnV0IGEgc21hbGwgbnVtYmVyIHdpbGwgZ2l2ZSBtb3JlIHBlcmZvcm1hbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjY2RJdGVyYXRpb25zXG4gICAgICogQGRlZmF1bHQgMTBcbiAgICAgKi9cbiAgICB0aGlzLmNjZEl0ZXJhdGlvbnMgPSBvcHRpb25zLmNjZEl0ZXJhdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2NkSXRlcmF0aW9ucyA6IDEwO1xuXG4gICAgdGhpcy5jb25jYXZlUGF0aCA9IG51bGw7XG5cbiAgICB0aGlzLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XG5cbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG59XG5Cb2R5LnByb3RvdHlwZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbkJvZHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm9keTtcblxuQm9keS5faWRDb3VudGVyID0gMDtcblxuQm9keS5wcm90b3R5cGUudXBkYXRlU29sdmVNYXNzUHJvcGVydGllcyA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7XG4gICAgICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IHRoaXMuaW52TWFzcztcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSB0aGlzLmludkluZXJ0aWE7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRvdGFsIGRlbnNpdHkgb2YgdGhlIGJvZHlcbiAqIEBtZXRob2Qgc2V0RGVuc2l0eVxuICovXG5Cb2R5LnByb3RvdHlwZS5zZXREZW5zaXR5ID0gZnVuY3Rpb24oZGVuc2l0eSkge1xuICAgIHZhciB0b3RhbEFyZWEgPSB0aGlzLmdldEFyZWEoKTtcbiAgICB0aGlzLm1hc3MgPSB0b3RhbEFyZWEgKiBkZW5zaXR5O1xuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0b3RhbCBhcmVhIG9mIGFsbCBzaGFwZXMgaW4gdGhlIGJvZHlcbiAqIEBtZXRob2QgZ2V0QXJlYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvdGFsQXJlYSA9IDA7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB0b3RhbEFyZWEgKz0gdGhpcy5zaGFwZXNbaV0uYXJlYTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsQXJlYTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBBQUJCIGZyb20gdGhlIGJvZHkuIFRoZSBBQUJCIGlzIHVwZGF0ZWQgaWYgbmVjZXNzYXJ5LlxuICogQG1ldGhvZCBnZXRBQUJCXG4gKi9cbkJvZHkucHJvdG90eXBlLmdldEFBQkIgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgdGhpcy51cGRhdGVBQUJCKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFhYmI7XG59O1xuXG52YXIgc2hhcGVBQUJCID0gbmV3IEFBQkIoKSxcbiAgICB0bXAgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIEFBQkIgb2YgdGhlIEJvZHlcbiAqIEBtZXRob2QgdXBkYXRlQUFCQlxuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVBQUJCID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0cyxcbiAgICAgICAgc2hhcGVBbmdsZXMgPSB0aGlzLnNoYXBlQW5nbGVzLFxuICAgICAgICBOID0gc2hhcGVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gdG1wLFxuICAgICAgICBib2R5QW5nbGUgPSB0aGlzLmFuZ2xlO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sXG4gICAgICAgICAgICBhbmdsZSA9IHNoYXBlQW5nbGVzW2ldICsgYm9keUFuZ2xlO1xuXG4gICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBvZmZzZXRcbiAgICAgICAgdmVjMi5yb3RhdGUob2Zmc2V0LCBzaGFwZU9mZnNldHNbaV0sIGJvZHlBbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKG9mZnNldCwgb2Zmc2V0LCB0aGlzLnBvc2l0aW9uKTtcblxuICAgICAgICAvLyBHZXQgc2hhcGUgQUFCQlxuICAgICAgICBzaGFwZS5jb21wdXRlQUFCQihzaGFwZUFBQkIsIG9mZnNldCwgYW5nbGUpO1xuXG4gICAgICAgIGlmKGk9PT0wKXtcbiAgICAgICAgICAgIHRoaXMuYWFiYi5jb3B5KHNoYXBlQUFCQik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFhYmIuZXh0ZW5kKHNoYXBlQUFCQik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgYm9keS4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBzaGFwZXNcbiAqIGFyZSBjaGFuZ2VkLlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0cyxcbiAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgIHJhZGl1cyA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXSxcbiAgICAgICAgICAgIG9mZnNldCA9IHZlYzIubGVuZ3RoKHNoYXBlT2Zmc2V0c1tpXSksXG4gICAgICAgICAgICByID0gc2hhcGUuYm91bmRpbmdSYWRpdXM7XG4gICAgICAgIGlmKG9mZnNldCArIHIgPiByYWRpdXMpe1xuICAgICAgICAgICAgcmFkaXVzID0gb2Zmc2V0ICsgcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSByYWRpdXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIHNoYXBlIHRvIHRoZSBib2R5LiBZb3UgY2FuIHBhc3MgYSBsb2NhbCB0cmFuc2Zvcm0gd2hlbiBhZGRpbmcgYSBzaGFwZSxcbiAqIHNvIHRoYXQgdGhlIHNoYXBlIGdldHMgYW4gb2Zmc2V0IGFuZCBhbmdsZSByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcy5cbiAqIFdpbGwgYXV0b21hdGljYWxseSB1cGRhdGUgdGhlIG1hc3MgcHJvcGVydGllcyBhbmQgYm91bmRpbmcgcmFkaXVzLlxuICpcbiAqIEBtZXRob2QgYWRkU2hhcGVcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgICAgICAgICAgc2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBbb2Zmc2V0XSBMb2NhbCBib2R5IG9mZnNldCBvZiB0aGUgc2hhcGUuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgICAgIFthbmdsZV0gIExvY2FsIGJvZHkgYW5nbGUuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCksXG4gKiAgICAgICAgIHNoYXBlID0gbmV3IENpcmNsZSgpO1xuICpcbiAqICAgICAvLyBBZGQgdGhlIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIGluIHRoZSBjZW50ZXJcbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlKTtcbiAqXG4gKiAgICAgLy8gQWRkIGFub3RoZXIgc2hhcGUgdG8gdGhlIGJvZHksIHBvc2l0aW9uZWQgMSB1bml0IGxlbmd0aCBmcm9tIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzIGFsb25nIHRoZSBsb2NhbCB4LWF4aXMuXG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSxbMSwwXSk7XG4gKlxuICogICAgIC8vIEFkZCBhbm90aGVyIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIDEgdW5pdCBsZW5ndGggZnJvbSB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcyBhbG9uZyB0aGUgbG9jYWwgeS1heGlzLCBhbmQgcm90YXRlZCA5MCBkZWdyZWVzIENDVy5cbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlLFswLDFdLE1hdGguUEkvMik7XG4gKi9cbkJvZHkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24oc2hhcGUsb2Zmc2V0LGFuZ2xlKXtcbiAgICBhbmdsZSA9IGFuZ2xlIHx8IDAuMDtcblxuICAgIC8vIENvcHkgdGhlIG9mZnNldCB2ZWN0b3JcbiAgICBpZihvZmZzZXQpe1xuICAgICAgICBvZmZzZXQgPSB2ZWMyLmZyb21WYWx1ZXMob2Zmc2V0WzBdLG9mZnNldFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGFwZXMgICAgICAucHVzaChzaGFwZSk7XG4gICAgdGhpcy5zaGFwZU9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgIHRoaXMuc2hhcGVBbmdsZXMgLnB1c2goYW5nbGUpO1xuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHNoYXBlXG4gKiBAbWV0aG9kIHJlbW92ZVNoYXBlXG4gKiBAcGFyYW0gIHtTaGFwZX0gIHNoYXBlXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICBUcnVlIGlmIHRoZSBzaGFwZSB3YXMgZm91bmQgYW5kIHJlbW92ZWQsIGVsc2UgZmFsc2UuXG4gKi9cbkJvZHkucHJvdG90eXBlLnJlbW92ZVNoYXBlID0gZnVuY3Rpb24oc2hhcGUpe1xuICAgIHZhciBpZHggPSB0aGlzLnNoYXBlcy5pbmRleE9mKHNoYXBlKTtcblxuICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICB0aGlzLnNoYXBlcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB0aGlzLnNoYXBlT2Zmc2V0cy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB0aGlzLnNoYXBlQW5nbGVzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyAuaW5lcnRpYSwgLmludk1hc3MsIC5pbnZJbmVydGlhIGZvciB0aGlzIEJvZHkuIFNob3VsZCBiZSBjYWxsZWQgd2hlblxuICogY2hhbmdpbmcgdGhlIHN0cnVjdHVyZSBvciBtYXNzIG9mIHRoZSBCb2R5LlxuICpcbiAqIEBtZXRob2QgdXBkYXRlTWFzc1Byb3BlcnRpZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIGJvZHkubWFzcyArPSAxO1xuICogICAgIGJvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlTWFzc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMudHlwZSA9PT0gQm9keS5TVEFUSUMgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG5cbiAgICAgICAgdGhpcy5tYXNzID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdGhpcy5pbnZNYXNzID0gMDtcbiAgICAgICAgdGhpcy5pbmVydGlhID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhID0gMDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgICAgICBtID0gdGhpcy5tYXNzIC8gTixcbiAgICAgICAgICAgIEkgPSAwO1xuXG4gICAgICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8TjsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHIyID0gdmVjMi5zcXVhcmVkTGVuZ3RoKHRoaXMuc2hhcGVPZmZzZXRzW2ldKSxcbiAgICAgICAgICAgICAgICAgICAgSWNtID0gc2hhcGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYShtKTtcbiAgICAgICAgICAgICAgICBJICs9IEljbSArIG0qcjI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZXJ0aWEgPSBJO1xuICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhID0gST4wID8gMS9JIDogMDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmVydGlhID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZlcnNlIG1hc3MgcHJvcGVydGllcyBhcmUgZWFzeVxuICAgICAgICB0aGlzLmludk1hc3MgPSAxL3RoaXMubWFzczsvLyA+IDAgPyAxL3RoaXMubWFzcyA6IDA7XG4gICAgfVxufTtcblxudmFyIEJvZHlfYXBwbHlGb3JjZV9yID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBBcHBseSBmb3JjZSB0byBhIHdvcmxkIHBvaW50LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIFJpZ2lkQm9keSBzdXJmYWNlLiBBcHBseWluZyBmb3JjZSB0aGlzIHdheSB3aWxsIGFkZCB0byBCb2R5LmZvcmNlIGFuZCBCb2R5LmFuZ3VsYXJGb3JjZS5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICogQHBhcmFtIHtBcnJheX0gZm9yY2UgVGhlIGZvcmNlIHRvIGFkZC5cbiAqIEBwYXJhbSB7QXJyYXl9IHdvcmxkUG9pbnQgQSB3b3JsZCBwb2ludCB0byBhcHBseSB0aGUgZm9yY2Ugb24uXG4gKi9cbkJvZHkucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbihmb3JjZSx3b3JsZFBvaW50KXtcbiAgICAvLyBDb21wdXRlIHBvaW50IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBib2R5IGNlbnRlclxuICAgIHZhciByID0gQm9keV9hcHBseUZvcmNlX3I7XG4gICAgdmVjMi5zdWIocix3b3JsZFBvaW50LHRoaXMucG9zaXRpb24pO1xuXG4gICAgLy8gQWRkIGxpbmVhciBmb3JjZVxuICAgIHZlYzIuYWRkKHRoaXMuZm9yY2UsdGhpcy5mb3JjZSxmb3JjZSk7XG5cbiAgICAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgZm9yY2VcbiAgICB2YXIgcm90Rm9yY2UgPSB2ZWMyLmNyb3NzTGVuZ3RoKHIsZm9yY2UpO1xuXG4gICAgLy8gQWRkIHJvdGF0aW9uYWwgZm9yY2VcbiAgICB0aGlzLmFuZ3VsYXJGb3JjZSArPSByb3RGb3JjZTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgd29ybGQgcG9pbnQgdG8gbG9jYWwgYm9keSBmcmFtZS5cbiAqIEBtZXRob2QgdG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0ICAgICAgICAgIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpblxuICogQHBhcmFtICB7QXJyYXl9IHdvcmxkUG9pbnQgICBUaGUgaW5wdXQgd29ybGQgdmVjdG9yXG4gKi9cbkJvZHkucHJvdG90eXBlLnRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uKG91dCwgd29ybGRQb2ludCl7XG4gICAgdmVjMi50b0xvY2FsRnJhbWUob3V0LCB3b3JsZFBvaW50LCB0aGlzLnBvc2l0aW9uLCB0aGlzLmFuZ2xlKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgbG9jYWwgcG9pbnQgdG8gd29ybGQgZnJhbWUuXG4gKiBAbWV0aG9kIHRvV29ybGRGcmFtZVxuICogQHBhcmFtICB7QXJyYXl9IG91dCAgICAgICAgICBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cbiAqIEBwYXJhbSAge0FycmF5fSBsb2NhbFBvaW50ICAgVGhlIGlucHV0IGxvY2FsIHZlY3RvclxuICovXG5Cb2R5LnByb3RvdHlwZS50b1dvcmxkRnJhbWUgPSBmdW5jdGlvbihvdXQsIGxvY2FsUG9pbnQpe1xuICAgIHZlYzIudG9HbG9iYWxGcmFtZShvdXQsIGxvY2FsUG9pbnQsIHRoaXMucG9zaXRpb24sIHRoaXMuYW5nbGUpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHBvbHlnb24gc2hhcGUgcGF0aCwgYW5kIGFzc2VtYmxlcyBjb252ZXggc2hhcGVzIGZyb20gdGhhdCBhbmQgcHV0cyB0aGVtIGF0IHByb3BlciBvZmZzZXQgcG9pbnRzLlxuICogQG1ldGhvZCBmcm9tUG9seWdvblxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiAyZCB2ZWN0b3JzLCBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dIHRoYXQgcmVzZW1ibGVzIGEgY29uY2F2ZSBvciBjb252ZXggcG9seWdvbi4gVGhlIHNoYXBlIG11c3QgYmUgc2ltcGxlIGFuZCB3aXRob3V0IGhvbGVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcHRpbWFsRGVjb21wPWZhbHNlXSAgIFNldCB0byB0cnVlIGlmIHlvdSBuZWVkIG9wdGltYWwgZGVjb21wb3NpdGlvbi4gV2FybmluZzogdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1vcmUgdGhhbiAxMCB2ZXJ0aWNlcy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFNpbXBsZUNoZWNrPWZhbHNlXSBTZXQgdG8gdHJ1ZSBpZiB5b3UgYWxyZWFkeSBrbm93IHRoYXQgdGhlIHBhdGggaXMgbm90IGludGVyc2VjdGluZyBpdHNlbGYuXG4gKiBAcGFyYW0ge0Jvb2xlYW58TnVtYmVyfSBbb3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHM9ZmFsc2VdIFNldCB0byBhIG51bWJlciAoYW5nbGUgdGhyZXNob2xkIHZhbHVlKSB0byByZW1vdmUgY29sbGluZWFyIHBvaW50cywgb3IgZmFsc2UgdG8ga2VlcCBhbGwgcG9pbnRzLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLCBlbHNlIGZhbHNlLlxuICovXG5Cb2R5LnByb3RvdHlwZS5mcm9tUG9seWdvbiA9IGZ1bmN0aW9uKHBhdGgsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBSZW1vdmUgYWxsIHNoYXBlc1xuICAgIGZvcih2YXIgaT10aGlzLnNoYXBlcy5sZW5ndGg7IGk+PTA7IC0taSl7XG4gICAgICAgIHRoaXMucmVtb3ZlU2hhcGUodGhpcy5zaGFwZXNbaV0pO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IGRlY29tcC5Qb2x5Z29uKCk7XG4gICAgcC52ZXJ0aWNlcyA9IHBhdGg7XG5cbiAgICAvLyBNYWtlIGl0IGNvdW50ZXItY2xvY2t3aXNlXG4gICAgcC5tYWtlQ0NXKCk7XG5cbiAgICBpZih0eXBlb2Yob3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHMpID09PSBcIm51bWJlclwiKXtcbiAgICAgICAgcC5yZW1vdmVDb2xsaW5lYXJQb2ludHMob3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHMpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFueSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyB0aGUgcGF0aCBpdHNlbGZcbiAgICBpZih0eXBlb2Yob3B0aW9ucy5za2lwU2ltcGxlQ2hlY2spID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgaWYoIXAuaXNTaW1wbGUoKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTYXZlIHRoaXMgcGF0aCBmb3IgbGF0ZXJcbiAgICB0aGlzLmNvbmNhdmVQYXRoID0gcC52ZXJ0aWNlcy5zbGljZSgwKTtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmNvbmNhdmVQYXRoLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSBbMCwwXTtcbiAgICAgICAgdmVjMi5jb3B5KHYsdGhpcy5jb25jYXZlUGF0aFtpXSk7XG4gICAgICAgIHRoaXMuY29uY2F2ZVBhdGhbaV0gPSB2O1xuICAgIH1cblxuICAgIC8vIFNsb3cgb3IgZmFzdCBkZWNvbXA/XG4gICAgdmFyIGNvbnZleGVzO1xuICAgIGlmKG9wdGlvbnMub3B0aW1hbERlY29tcCl7XG4gICAgICAgIGNvbnZleGVzID0gcC5kZWNvbXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb252ZXhlcyA9IHAucXVpY2tEZWNvbXAoKTtcbiAgICB9XG5cbiAgICB2YXIgY20gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLy8gQWRkIGNvbnZleGVzXG4gICAgZm9yKHZhciBpPTA7IGkhPT1jb252ZXhlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIC8vIENyZWF0ZSBjb252ZXhcbiAgICAgICAgdmFyIGMgPSBuZXcgQ29udmV4KGNvbnZleGVzW2ldLnZlcnRpY2VzKTtcblxuICAgICAgICAvLyBNb3ZlIGFsbCB2ZXJ0aWNlcyBzbyBpdHMgY2VudGVyIG9mIG1hc3MgaXMgaW4gdGhlIGxvY2FsIGNlbnRlciBvZiB0aGUgY29udmV4XG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09Yy52ZXJ0aWNlcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICB2YXIgdiA9IGMudmVydGljZXNbal07XG4gICAgICAgICAgICB2ZWMyLnN1Yih2LHYsYy5jZW50ZXJPZk1hc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVjMi5zY2FsZShjbSxjLmNlbnRlck9mTWFzcywxKTtcbiAgICAgICAgYy51cGRhdGVUcmlhbmdsZXMoKTtcbiAgICAgICAgYy51cGRhdGVDZW50ZXJPZk1hc3MoKTtcbiAgICAgICAgYy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgc2hhcGVcbiAgICAgICAgdGhpcy5hZGRTaGFwZShjLGNtKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkanVzdENlbnRlck9mTWFzcygpO1xuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIGFkanVzdENlbnRlck9mTWFzc190bXAzID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDQgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBNb3ZlcyB0aGUgc2hhcGUgb2Zmc2V0cyBzbyB0aGVpciBjZW50ZXIgb2YgbWFzcyBiZWNvbWVzIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzLlxuICogQG1ldGhvZCBhZGp1c3RDZW50ZXJPZk1hc3NcbiAqL1xuQm9keS5wcm90b3R5cGUuYWRqdXN0Q2VudGVyT2ZNYXNzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgb2Zmc2V0X3RpbWVzX2FyZWEgPSBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMixcbiAgICAgICAgc3VtID0gICAgICAgICAgICAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMyxcbiAgICAgICAgY20gPSAgICAgICAgICAgICAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wNCxcbiAgICAgICAgdG90YWxBcmVhID0gICAgICAgICAwO1xuICAgIHZlYzIuc2V0KHN1bSwwLDApO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT10aGlzLnNoYXBlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzID0gdGhpcy5zaGFwZXNbaV0sXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNoYXBlT2Zmc2V0c1tpXTtcbiAgICAgICAgdmVjMi5zY2FsZShvZmZzZXRfdGltZXNfYXJlYSxvZmZzZXQscy5hcmVhKTtcbiAgICAgICAgdmVjMi5hZGQoc3VtLHN1bSxvZmZzZXRfdGltZXNfYXJlYSk7XG4gICAgICAgIHRvdGFsQXJlYSArPSBzLmFyZWE7XG4gICAgfVxuXG4gICAgdmVjMi5zY2FsZShjbSxzdW0sMS90b3RhbEFyZWEpO1xuXG4gICAgLy8gTm93IG1vdmUgYWxsIHNoYXBlc1xuICAgIGZvcih2YXIgaT0wOyBpIT09dGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2hhcGVzW2ldLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5zaGFwZU9mZnNldHNbaV07XG5cbiAgICAgICAgLy8gT2Zmc2V0IG1heSBiZSB1bmRlZmluZWQuIEZpeCB0aGF0LlxuICAgICAgICBpZighb2Zmc2V0KXtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2hhcGVPZmZzZXRzW2ldID0gdmVjMi5jcmVhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzIuc3ViKG9mZnNldCxvZmZzZXQsY20pO1xuICAgIH1cblxuICAgIC8vIE1vdmUgdGhlIGJvZHkgcG9zaXRpb24gdG9vXG4gICAgdmVjMi5hZGQodGhpcy5wb3NpdGlvbix0aGlzLnBvc2l0aW9uLGNtKTtcblxuICAgIC8vIEFuZCBjb25jYXZlIHBhdGhcbiAgICBmb3IodmFyIGk9MDsgdGhpcy5jb25jYXZlUGF0aCAmJiBpPHRoaXMuY29uY2F2ZVBhdGgubGVuZ3RoOyBpKyspe1xuICAgICAgICB2ZWMyLnN1Yih0aGlzLmNvbmNhdmVQYXRoW2ldLCB0aGlzLmNvbmNhdmVQYXRoW2ldLCBjbSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZm9yY2Ugb24gdGhlIGJvZHkgdG8gemVyby5cbiAqIEBtZXRob2Qgc2V0WmVyb0ZvcmNlXG4gKi9cbkJvZHkucHJvdG90eXBlLnNldFplcm9Gb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmVjMi5zZXQodGhpcy5mb3JjZSwwLjAsMC4wKTtcbiAgICB0aGlzLmFuZ3VsYXJGb3JjZSA9IDAuMDtcbn07XG5cbkJvZHkucHJvdG90eXBlLnJlc2V0Q29uc3RyYWludFZlbG9jaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgIHZsYW1iZGEgPSBiLnZsYW1iZGE7XG4gICAgdmVjMi5zZXQodmxhbWJkYSwwLDApO1xuICAgIGIud2xhbWJkYSA9IDA7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5hZGRDb25zdHJhaW50VmVsb2NpdHkgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgdiA9IGIudmVsb2NpdHk7XG4gICAgdmVjMi5hZGQoIHYsIHYsIGIudmxhbWJkYSk7XG4gICAgYi5hbmd1bGFyVmVsb2NpdHkgKz0gYi53bGFtYmRhO1xufTtcblxuLyoqXG4gKiBBcHBseSBkYW1waW5nLCBzZWUgPGEgaHJlZj1cImh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9idWxsZXQvaXNzdWVzL2RldGFpbD9pZD03NFwiPnRoaXM8L2E+IGZvciBkZXRhaWxzLlxuICogQG1ldGhvZCBhcHBseURhbXBpbmdcbiAqIEBwYXJhbSAge251bWJlcn0gZHQgQ3VycmVudCB0aW1lIHN0ZXBcbiAqL1xuQm9keS5wcm90b3R5cGUuYXBwbHlEYW1waW5nID0gZnVuY3Rpb24oZHQpe1xuICAgIGlmKHRoaXMudHlwZSA9PT0gQm9keS5EWU5BTUlDKXsgLy8gT25seSBmb3IgZHluYW1pYyBib2RpZXNcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlbG9jaXR5O1xuICAgICAgICB2ZWMyLnNjYWxlKHYsIHYsIE1hdGgucG93KDEuMCAtIHRoaXMuZGFtcGluZyxkdCkpO1xuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqPSBNYXRoLnBvdygxLjAgLSB0aGlzLmFuZ3VsYXJEYW1waW5nLGR0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFdha2UgdGhlIGJvZHkgdXAuIE5vcm1hbGx5IHlvdSBzaG91bGQgbm90IG5lZWQgdGhpcywgYXMgdGhlIGJvZHkgaXMgYXV0b21hdGljYWxseSBhd29rZW4gYXQgZXZlbnRzIHN1Y2ggYXMgY29sbGlzaW9ucy5cbiAqIFNldHMgdGhlIHNsZWVwU3RhdGUgdG8ge3sjY3Jvc3NMaW5rIFwiQm9keS9BV0FLRTpwcm9wZXJ0eVwifX1Cb2R5LkFXQUtFe3svY3Jvc3NMaW5rfX0gYW5kIGVtaXRzIHRoZSB3YWtlVXAgZXZlbnQgaWYgdGhlIGJvZHkgd2Fzbid0IGF3YWtlIGJlZm9yZS5cbiAqIEBtZXRob2Qgd2FrZVVwXG4gKi9cbkJvZHkucHJvdG90eXBlLndha2VVcCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHMgPSB0aGlzLnNsZWVwU3RhdGU7XG4gICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcbiAgICB0aGlzLmlkbGVUaW1lID0gMDtcbiAgICBpZihzICE9PSBCb2R5LkFXQUtFKXtcbiAgICAgICAgdGhpcy5lbWl0KEJvZHkud2FrZVVwRXZlbnQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRm9yY2UgYm9keSBzbGVlcFxuICogQG1ldGhvZCBzbGVlcFxuICovXG5Cb2R5LnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUElORztcbiAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IDA7XG4gICAgdGhpcy5hbmd1bGFyRm9yY2UgPSAwO1xuICAgIHZlYzIuc2V0KHRoaXMudmVsb2NpdHksMCwwKTtcbiAgICB2ZWMyLnNldCh0aGlzLmZvcmNlLDAsMCk7XG4gICAgdGhpcy5lbWl0KEJvZHkuc2xlZXBFdmVudCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBldmVyeSB0aW1lc3RlcCB0byB1cGRhdGUgaW50ZXJuYWwgc2xlZXAgdGltZXIgYW5kIGNoYW5nZSBzbGVlcCBzdGF0ZSBpZiBuZWVkZWQuXG4gKiBAbWV0aG9kIHNsZWVwVGlja1xuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgVGhlIHdvcmxkIHRpbWUgaW4gc2Vjb25kc1xuICogQHBhcmFtIHtib29sZWFufSBkb250U2xlZXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdFxuICovXG5Cb2R5LnByb3RvdHlwZS5zbGVlcFRpY2sgPSBmdW5jdGlvbih0aW1lLCBkb250U2xlZXAsIGR0KXtcbiAgICBpZighdGhpcy5hbGxvd1NsZWVwIHx8IHRoaXMudHlwZSA9PT0gQm9keS5TTEVFUElORyl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndhbnRzVG9TbGVlcCA9IGZhbHNlO1xuXG4gICAgdmFyIHNsZWVwU3RhdGUgPSB0aGlzLnNsZWVwU3RhdGUsXG4gICAgICAgIHNwZWVkU3F1YXJlZCA9IHZlYzIuc3F1YXJlZExlbmd0aCh0aGlzLnZlbG9jaXR5KSArIE1hdGgucG93KHRoaXMuYW5ndWxhclZlbG9jaXR5LDIpLFxuICAgICAgICBzcGVlZExpbWl0U3F1YXJlZCA9IE1hdGgucG93KHRoaXMuc2xlZXBTcGVlZExpbWl0LDIpO1xuXG4gICAgLy8gQWRkIHRvIGlkbGUgdGltZVxuICAgIGlmKHNwZWVkU3F1YXJlZCA+PSBzcGVlZExpbWl0U3F1YXJlZCl7XG4gICAgICAgIHRoaXMuaWRsZVRpbWUgPSAwO1xuICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LkFXQUtFO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaWRsZVRpbWUgKz0gZHQ7XG4gICAgICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuU0xFRVBZO1xuICAgIH1cbiAgICBpZih0aGlzLmlkbGVUaW1lID4gdGhpcy5zbGVlcFRpbWVMaW1pdCl7XG4gICAgICAgIGlmKCFkb250U2xlZXApe1xuICAgICAgICAgICAgdGhpcy5zbGVlcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53YW50c1RvU2xlZXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICBpZihzbGVlcFN0YXRlPT09Qm9keS5BV0FLRSAmJiBzcGVlZFNxdWFyZWQgPCBzcGVlZExpbWl0U3F1YXJlZCl7XG4gICAgICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuU0xFRVBZOyAvLyBTbGVlcHlcbiAgICAgICAgdGhpcy50aW1lTGFzdFNsZWVweSA9IHRpbWU7XG4gICAgICAgIHRoaXMuZW1pdChCb2R5LnNsZWVweUV2ZW50KTtcbiAgICB9IGVsc2UgaWYoc2xlZXBTdGF0ZT09PUJvZHkuU0xFRVBZICYmIHNwZWVkU3F1YXJlZCA+PSBzcGVlZExpbWl0U3F1YXJlZCl7XG4gICAgICAgIHRoaXMud2FrZVVwKCk7IC8vIFdha2UgdXBcbiAgICB9IGVsc2UgaWYoc2xlZXBTdGF0ZT09PUJvZHkuU0xFRVBZICYmICh0aW1lIC0gdGhpcy50aW1lTGFzdFNsZWVweSApID4gdGhpcy5zbGVlcFRpbWVMaW1pdCl7XG4gICAgICAgIHRoaXMud2FudHNUb1NsZWVwID0gdHJ1ZTtcbiAgICAgICAgaWYoIWRvbnRTbGVlcCl7XG4gICAgICAgICAgICB0aGlzLnNsZWVwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKi9cbn07XG5cbkJvZHkucHJvdG90eXBlLmdldFZlbG9jaXR5RnJvbVBvc2l0aW9uID0gZnVuY3Rpb24oc3RvcmUsIHRpbWVTdGVwKXtcbiAgICBzdG9yZSA9IHN0b3JlIHx8IHZlYzIuY3JlYXRlKCk7XG4gICAgdmVjMi5zdWIoc3RvcmUsIHRoaXMucG9zaXRpb24sIHRoaXMucHJldmlvdXNQb3NpdGlvbik7XG4gICAgdmVjMi5zY2FsZShzdG9yZSwgc3RvcmUsIDEvdGltZVN0ZXApO1xuICAgIHJldHVybiBzdG9yZTtcbn07XG5cbkJvZHkucHJvdG90eXBlLmdldEFuZ3VsYXJWZWxvY2l0eUZyb21Qb3NpdGlvbiA9IGZ1bmN0aW9uKHRpbWVTdGVwKXtcbiAgICByZXR1cm4gKHRoaXMuYW5nbGUgLSB0aGlzLnByZXZpb3VzQW5nbGUpIC8gdGltZVN0ZXA7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBib2R5IGlzIG92ZXJsYXBwaW5nIGFub3RoZXIgYm9keS4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG9ubHkgd29ya3MgaWYgdGhlIGJvZHkgd2FzIGFkZGVkIHRvIGEgV29ybGQgYW5kIGlmIGF0IGxlYXN0IG9uZSBzdGVwIHdhcyB0YWtlbi5cbiAqIEBtZXRob2Qgb3ZlcmxhcHNcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkJvZHkucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24oYm9keSl7XG4gICAgcmV0dXJuIHRoaXMud29ybGQub3ZlcmxhcEtlZXBlci5ib2RpZXNBcmVPdmVybGFwcGluZyh0aGlzLCBib2R5KTtcbn07XG5cbnZhciBpbnRlZ3JhdGVfZmhNaW52ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlZ3JhdGVfdmVsb2R0ID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBNb3ZlIHRoZSBib2R5IGZvcndhcmQgaW4gdGltZSBnaXZlbiBpdHMgY3VycmVudCB2ZWxvY2l0eS5cbiAqIEBtZXRob2QgaW50ZWdyYXRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGR0XG4gKi9cbkJvZHkucHJvdG90eXBlLmludGVncmF0ZSA9IGZ1bmN0aW9uKGR0KXtcbiAgICB2YXIgbWludiA9IHRoaXMuaW52TWFzcyxcbiAgICAgICAgZiA9IHRoaXMuZm9yY2UsXG4gICAgICAgIHBvcyA9IHRoaXMucG9zaXRpb24sXG4gICAgICAgIHZlbG8gPSB0aGlzLnZlbG9jaXR5O1xuXG4gICAgLy8gU2F2ZSBvbGQgcG9zaXRpb25cbiAgICB2ZWMyLmNvcHkodGhpcy5wcmV2aW91c1Bvc2l0aW9uLCB0aGlzLnBvc2l0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzQW5nbGUgPSB0aGlzLmFuZ2xlO1xuXG4gICAgLy8gVmVsb2NpdHkgdXBkYXRlXG4gICAgaWYoIXRoaXMuZml4ZWRSb3RhdGlvbil7XG4gICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMuYW5ndWxhckZvcmNlICogdGhpcy5pbnZJbmVydGlhICogZHQ7XG4gICAgfVxuICAgIHZlYzIuc2NhbGUoaW50ZWdyYXRlX2ZoTWludiwgZiwgZHQgKiBtaW52KTtcbiAgICB2ZWMyLmFkZCh2ZWxvLCBpbnRlZ3JhdGVfZmhNaW52LCB2ZWxvKTtcblxuICAgIC8vIENDRFxuICAgIGlmKCF0aGlzLmludGVncmF0ZVRvVGltZU9mSW1wYWN0KGR0KSl7XG5cbiAgICAgICAgLy8gUmVndWxhciBwb3NpdGlvbiB1cGRhdGVcbiAgICAgICAgdmVjMi5zY2FsZShpbnRlZ3JhdGVfdmVsb2R0LCB2ZWxvLCBkdCk7XG4gICAgICAgIHZlYzIuYWRkKHBvcywgcG9zLCBpbnRlZ3JhdGVfdmVsb2R0KTtcbiAgICAgICAgaWYoIXRoaXMuZml4ZWRSb3RhdGlvbil7XG4gICAgICAgICAgICB0aGlzLmFuZ2xlICs9IHRoaXMuYW5ndWxhclZlbG9jaXR5ICogZHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG59O1xuXG52YXIgZGlyZWN0aW9uID0gdmVjMi5jcmVhdGUoKTtcbnZhciBlbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHN0YXJ0VG9FbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJlbWVtYmVyUG9zaXRpb24gPSB2ZWMyLmNyZWF0ZSgpO1xuQm9keS5wcm90b3R5cGUuaW50ZWdyYXRlVG9UaW1lT2ZJbXBhY3QgPSBmdW5jdGlvbihkdCl7XG5cbiAgICBpZih0aGlzLmNjZFNwZWVkVGhyZXNob2xkIDwgMCB8fCB2ZWMyLnNxdWFyZWRMZW5ndGgodGhpcy52ZWxvY2l0eSkgPCBNYXRoLnBvdyh0aGlzLmNjZFNwZWVkVGhyZXNob2xkLCAyKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2ZWMyLm5vcm1hbGl6ZShkaXJlY3Rpb24sIHRoaXMudmVsb2NpdHkpO1xuXG4gICAgdmVjMi5zY2FsZShlbmQsIHRoaXMudmVsb2NpdHksIGR0KTtcbiAgICB2ZWMyLmFkZChlbmQsIGVuZCwgdGhpcy5wb3NpdGlvbik7XG5cbiAgICB2ZWMyLnN1YihzdGFydFRvRW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xuICAgIHZhciBzdGFydFRvRW5kQW5nbGUgPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xuICAgIHZhciBsZW4gPSB2ZWMyLmxlbmd0aChzdGFydFRvRW5kKTtcblxuICAgIHZhciB0aW1lT2ZJbXBhY3QgPSAxO1xuXG4gICAgdmFyIGhpdDtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy53b3JsZC5yYXljYXN0QWxsKHRoaXMucG9zaXRpb24sIGVuZCwge30sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYocmVzdWx0LmJvZHkgPT09IHRoYXQpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhpdCA9IHJlc3VsdC5ib2R5O1xuICAgICAgICB2ZWMyLmNvcHkoZW5kLCByZXN1bHQuaGl0UG9pbnRXb3JsZCk7XG4gICAgICAgIHZlYzIuc3ViKHN0YXJ0VG9FbmQsIHJlc3VsdC5oaXRQb2ludFdvcmxkLCB0aGF0LnBvc2l0aW9uKTtcbiAgICAgICAgdGltZU9mSW1wYWN0ID0gdmVjMi5sZW5ndGgoc3RhcnRUb0VuZCkgLyBsZW47XG4gICAgICAgIHJlc3VsdC5hYm9ydCgpO1xuICAgIH0pO1xuXG4gICAgaWYoIWhpdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcmVtZW1iZXJBbmdsZSA9IHRoaXMuYW5nbGU7XG4gICAgdmVjMi5jb3B5KHJlbWVtYmVyUG9zaXRpb24sIHRoaXMucG9zaXRpb24pO1xuXG4gICAgLy8gR290IGEgc3RhcnQgYW5kIGVuZCBwb2ludC4gQXBwcm94aW1hdGUgdGltZSBvZiBpbXBhY3QgdXNpbmcgYmluYXJ5IHNlYXJjaFxuICAgIHZhciBpdGVyID0gMDtcbiAgICB2YXIgdG1pbiA9IDA7XG4gICAgdmFyIHRtaWQgPSAwO1xuICAgIHZhciB0bWF4ID0gdGltZU9mSW1wYWN0O1xuICAgIHdoaWxlICh0bWF4ID49IHRtaW4gJiYgaXRlciA8IHRoaXMuY2NkSXRlcmF0aW9ucykge1xuICAgICAgICBpdGVyKys7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBtaWRwb2ludFxuICAgICAgICB0bWlkID0gKHRtYXggLSB0bWluKSAvIDI7XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgYm9keSB0byB0aGF0IHBvaW50XG4gICAgICAgIHZlYzIuc2NhbGUoaW50ZWdyYXRlX3ZlbG9kdCwgc3RhcnRUb0VuZCwgdGltZU9mSW1wYWN0KTtcbiAgICAgICAgdmVjMi5hZGQodGhpcy5wb3NpdGlvbiwgcmVtZW1iZXJQb3NpdGlvbiwgaW50ZWdyYXRlX3ZlbG9kdCk7XG4gICAgICAgIHRoaXMuYW5nbGUgPSByZW1lbWJlckFuZ2xlICsgc3RhcnRUb0VuZEFuZ2xlICogdGltZU9mSW1wYWN0O1xuICAgICAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcblxuICAgICAgICAvLyBjaGVjayBvdmVybGFwXG4gICAgICAgIHZhciBvdmVybGFwcyA9IHRoaXMuYWFiYi5vdmVybGFwcyhoaXQuYWFiYikgJiYgdGhpcy53b3JsZC5uYXJyb3dwaGFzZS5ib2RpZXNPdmVybGFwKHRoaXMsIGhpdCk7XG5cbiAgICAgICAgaWYgKG92ZXJsYXBzKSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2UgbWluIHRvIHNlYXJjaCB1cHBlciBpbnRlcnZhbFxuICAgICAgICAgICAgdG1pbiA9IHRtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2UgbWF4IHRvIHNlYXJjaCBsb3dlciBpbnRlcnZhbFxuICAgICAgICAgICAgdG1heCA9IHRtaWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lT2ZJbXBhY3QgPSB0bWlkO1xuXG4gICAgdmVjMi5jb3B5KHRoaXMucG9zaXRpb24sIHJlbWVtYmVyUG9zaXRpb24pO1xuICAgIHRoaXMuYW5nbGUgPSByZW1lbWJlckFuZ2xlO1xuXG4gICAgLy8gbW92ZSB0byBUT0lcbiAgICB2ZWMyLnNjYWxlKGludGVncmF0ZV92ZWxvZHQsIHN0YXJ0VG9FbmQsIHRpbWVPZkltcGFjdCk7XG4gICAgdmVjMi5hZGQodGhpcy5wb3NpdGlvbiwgdGhpcy5wb3NpdGlvbiwgaW50ZWdyYXRlX3ZlbG9kdCk7XG4gICAgaWYoIXRoaXMuZml4ZWRSb3RhdGlvbil7XG4gICAgICAgIHRoaXMuYW5nbGUgKz0gc3RhcnRUb0VuZEFuZ2xlICogdGltZU9mSW1wYWN0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAZXZlbnQgc2xlZXB5XG4gKi9cbkJvZHkuc2xlZXB5RXZlbnQgPSB7XG4gICAgdHlwZTogXCJzbGVlcHlcIlxufTtcblxuLyoqXG4gKiBAZXZlbnQgc2xlZXBcbiAqL1xuQm9keS5zbGVlcEV2ZW50ID0ge1xuICAgIHR5cGU6IFwic2xlZXBcIlxufTtcblxuLyoqXG4gKiBAZXZlbnQgd2FrZXVwXG4gKi9cbkJvZHkud2FrZVVwRXZlbnQgPSB7XG4gICAgdHlwZTogXCJ3YWtldXBcIlxufTtcblxuLyoqXG4gKiBEeW5hbWljIGJvZHkuXG4gKiBAcHJvcGVydHkgRFlOQU1JQ1xuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuQm9keS5EWU5BTUlDID0gMTtcblxuLyoqXG4gKiBTdGF0aWMgYm9keS5cbiAqIEBwcm9wZXJ0eSBTVEFUSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuU1RBVElDID0gMjtcblxuLyoqXG4gKiBLaW5lbWF0aWMgYm9keS5cbiAqIEBwcm9wZXJ0eSBLSU5FTUFUSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuS0lORU1BVElDID0gNDtcblxuLyoqXG4gKiBAcHJvcGVydHkgQVdBS0VcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuQVdBS0UgPSAwO1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBTTEVFUFlcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuU0xFRVBZID0gMTtcblxuLyoqXG4gKiBAcHJvcGVydHkgU0xFRVBJTkdcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuU0xFRVBJTkcgPSAyO1xuXG5cbn0se1wiLi4vY29sbGlzaW9uL0FBQkJcIjo3LFwiLi4vZXZlbnRzL0V2ZW50RW1pdHRlclwiOjI3LFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9zaGFwZXMvQ29udmV4XCI6MzksXCJwb2x5LWRlY29tcFwiOjV9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xudmFyIFNwcmluZyA9IF9kZXJlcV8oJy4vU3ByaW5nJyk7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhclNwcmluZztcblxuLyoqXG4gKiBBIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzLlxuICpcbiAqIFRoZSBTcHJpbmcgZXhwbGljaXRseSBhZGRzIGZvcmNlIGFuZCBhbmd1bGFyRm9yY2UgdG8gdGhlIGJvZGllcy5cbiAqXG4gKiBAY2xhc3MgTGluZWFyU3ByaW5nXG4gKiBAZXh0ZW5kcyBTcHJpbmdcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc3RMZW5ndGhdICAgQSBudW1iZXIgPiAwLiBEZWZhdWx0IGlzIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gdGhlIHdvcmxkIGFuY2hvciBwb2ludHMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzPTEwMF0gIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gICAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBPdmVycmlkZXMgdGhlIG9wdGlvbiBcImxvY2FsQW5jaG9yQVwiIGlmIGdpdmVuLlxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQl1cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckFdICAgV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gbG9jYWwgYm9keSBjb29yZGluYXRlcy4gRGVmYXVsdHMgdG8gdGhlIGJvZHkgY2VudGVyLlxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsQW5jaG9yQl1cbiAqL1xuZnVuY3Rpb24gTGluZWFyU3ByaW5nKGJvZHlBLGJvZHlCLG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgU3ByaW5nLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEFuY2hvciBmb3IgYm9keUEgaW4gbG9jYWwgYm9keUEgY29vcmRpbmF0ZXMuXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QiBpbiBsb2NhbCBib2R5QiBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JCID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICBpZihvcHRpb25zLmxvY2FsQW5jaG9yQSl7IHZlYzIuY29weSh0aGlzLmxvY2FsQW5jaG9yQSwgb3B0aW9ucy5sb2NhbEFuY2hvckEpOyB9XG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckIpeyB2ZWMyLmNvcHkodGhpcy5sb2NhbEFuY2hvckIsIG9wdGlvbnMubG9jYWxBbmNob3JCKTsgfVxuICAgIGlmKG9wdGlvbnMud29ybGRBbmNob3JBKXsgdGhpcy5zZXRXb3JsZEFuY2hvckEob3B0aW9ucy53b3JsZEFuY2hvckEpOyB9XG4gICAgaWYob3B0aW9ucy53b3JsZEFuY2hvckIpeyB0aGlzLnNldFdvcmxkQW5jaG9yQihvcHRpb25zLndvcmxkQW5jaG9yQik7IH1cblxuICAgIHZhciB3b3JsZEFuY2hvckEgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHZhciB3b3JsZEFuY2hvckIgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHRoaXMuZ2V0V29ybGRBbmNob3JBKHdvcmxkQW5jaG9yQSk7XG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKTtcbiAgICB2YXIgd29ybGREaXN0YW5jZSA9IHZlYzIuZGlzdGFuY2Uod29ybGRBbmNob3JBLCB3b3JsZEFuY2hvckIpO1xuXG4gICAgLyoqXG4gICAgICogUmVzdCBsZW5ndGggb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgcmVzdExlbmd0aFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN0TGVuZ3RoID0gdHlwZW9mKG9wdGlvbnMucmVzdExlbmd0aCkgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLnJlc3RMZW5ndGggOiB3b3JsZERpc3RhbmNlO1xufVxuTGluZWFyU3ByaW5nLnByb3RvdHlwZSA9IG5ldyBTcHJpbmcoKTtcbkxpbmVhclNwcmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lYXJTcHJpbmc7XG5cbi8qKlxuICogU2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCB1c2luZyB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2Qgc2V0V29ybGRBbmNob3JBXG4gKiBAcGFyYW0ge0FycmF5fSB3b3JsZEFuY2hvckFcbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckEgPSBmdW5jdGlvbih3b3JsZEFuY2hvckEpe1xuICAgIHRoaXMuYm9keUEudG9Mb2NhbEZyYW1lKHRoaXMubG9jYWxBbmNob3JBLCB3b3JsZEFuY2hvckEpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEIsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBzZXRXb3JsZEFuY2hvckJcbiAqIEBwYXJhbSB7QXJyYXl9IHdvcmxkQW5jaG9yQlxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLnNldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uKHdvcmxkQW5jaG9yQil7XG4gICAgdGhpcy5ib2R5Qi50b0xvY2FsRnJhbWUodGhpcy5sb2NhbEFuY2hvckIsIHdvcmxkQW5jaG9yQik7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIGdldFdvcmxkQW5jaG9yQVxuICogQHBhcmFtIHtBcnJheX0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5nZXRXb3JsZEFuY2hvckEgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMuYm9keUEudG9Xb3JsZEZyYW1lKHJlc3VsdCwgdGhpcy5sb2NhbEFuY2hvckEpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEIsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBnZXRXb3JsZEFuY2hvckJcbiAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXG4gKi9cbkxpbmVhclNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JCID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLmJvZHlCLnRvV29ybGRGcmFtZShyZXN1bHQsIHRoaXMubG9jYWxBbmNob3JCKTtcbn07XG5cbnZhciBhcHBseUZvcmNlX3IgPSAgICAgICAgICAgICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3JfdW5pdCA9ICAgICAgICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3UgPSAgICAgICAgICAgICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX2YgPSAgICAgICAgICAgICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSA9ICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQiA9ICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3JpID0gICAgICAgICAgICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3JqID0gICAgICAgICAgICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3RtcCA9ICAgICAgICAgICAgdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxuICogQG1ldGhvZCBhcHBseUZvcmNlXG4gKi9cbkxpbmVhclNwcmluZy5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcyxcbiAgICAgICAgZCA9IHRoaXMuZGFtcGluZyxcbiAgICAgICAgbCA9IHRoaXMucmVzdExlbmd0aCxcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHIgPSBhcHBseUZvcmNlX3IsXG4gICAgICAgIHJfdW5pdCA9IGFwcGx5Rm9yY2Vfcl91bml0LFxuICAgICAgICB1ID0gYXBwbHlGb3JjZV91LFxuICAgICAgICBmID0gYXBwbHlGb3JjZV9mLFxuICAgICAgICB0bXAgPSBhcHBseUZvcmNlX3RtcDtcblxuICAgIHZhciB3b3JsZEFuY2hvckEgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSxcbiAgICAgICAgd29ybGRBbmNob3JCID0gYXBwbHlGb3JjZV93b3JsZEFuY2hvckIsXG4gICAgICAgIHJpID0gYXBwbHlGb3JjZV9yaSxcbiAgICAgICAgcmogPSBhcHBseUZvcmNlX3JqO1xuXG4gICAgLy8gR2V0IHdvcmxkIGFuY2hvcnNcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpO1xuICAgIHRoaXMuZ2V0V29ybGRBbmNob3JCKHdvcmxkQW5jaG9yQik7XG5cbiAgICAvLyBHZXQgb2Zmc2V0IHBvaW50c1xuICAgIHZlYzIuc3ViKHJpLCB3b3JsZEFuY2hvckEsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICB2ZWMyLnN1Yihyaiwgd29ybGRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XG5cbiAgICAvLyBDb21wdXRlIGRpc3RhbmNlIHZlY3RvciBiZXR3ZWVuIHdvcmxkIGFuY2hvciBwb2ludHNcbiAgICB2ZWMyLnN1YihyLCB3b3JsZEFuY2hvckIsIHdvcmxkQW5jaG9yQSk7XG4gICAgdmFyIHJsZW4gPSB2ZWMyLmxlbihyKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShyX3VuaXQscik7XG5cbiAgICAvL2NvbnNvbGUubG9nKHJsZW4pXG4gICAgLy9jb25zb2xlLmxvZyhcIkFcIix2ZWMyLnN0cih3b3JsZEFuY2hvckEpLFwiQlwiLHZlYzIuc3RyKHdvcmxkQW5jaG9yQikpXG5cbiAgICAvLyBDb21wdXRlIHJlbGF0aXZlIHZlbG9jaXR5IG9mIHRoZSBhbmNob3IgcG9pbnRzLCB1XG4gICAgdmVjMi5zdWIodSwgYm9keUIudmVsb2NpdHksIGJvZHlBLnZlbG9jaXR5KTtcbiAgICB2ZWMyLmNyb3NzWlYodG1wLCBib2R5Qi5hbmd1bGFyVmVsb2NpdHksIHJqKTtcbiAgICB2ZWMyLmFkZCh1LCB1LCB0bXApO1xuICAgIHZlYzIuY3Jvc3NaVih0bXAsIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSwgcmkpO1xuICAgIHZlYzIuc3ViKHUsIHUsIHRtcCk7XG5cbiAgICAvLyBGID0gLSBrICogKCB4IC0gTCApIC0gRCAqICggdSApXG4gICAgdmVjMi5zY2FsZShmLCByX3VuaXQsIC1rKihybGVuLWwpIC0gZCp2ZWMyLmRvdCh1LHJfdW5pdCkpO1xuXG4gICAgLy8gQWRkIGZvcmNlcyB0byBib2RpZXNcbiAgICB2ZWMyLnN1YiggYm9keUEuZm9yY2UsIGJvZHlBLmZvcmNlLCBmKTtcbiAgICB2ZWMyLmFkZCggYm9keUIuZm9yY2UsIGJvZHlCLmZvcmNlLCBmKTtcblxuICAgIC8vIEFuZ3VsYXIgZm9yY2VcbiAgICB2YXIgcmlfeF9mID0gdmVjMi5jcm9zc0xlbmd0aChyaSwgZik7XG4gICAgdmFyIHJqX3hfZiA9IHZlYzIuY3Jvc3NMZW5ndGgocmosIGYpO1xuICAgIGJvZHlBLmFuZ3VsYXJGb3JjZSAtPSByaV94X2Y7XG4gICAgYm9keUIuYW5ndWxhckZvcmNlICs9IHJqX3hfZjtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjUwLFwiLi9TcHJpbmdcIjozNX1dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgU3ByaW5nID0gX2RlcmVxXygnLi9TcHJpbmcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsU3ByaW5nO1xuXG4vKipcbiAqIEEgcm90YXRpb25hbCBzcHJpbmcsIGNvbm5lY3RpbmcgdHdvIGJvZGllcyByb3RhdGlvbi4gVGhpcyBzcHJpbmcgZXhwbGljaXRseSBhZGRzIGFuZ3VsYXJGb3JjZSAodG9ycXVlKSB0byB0aGUgYm9kaWVzLlxuICpcbiAqIFRoZSBzcHJpbmcgY2FuIGJlIGNvbWJpbmVkIHdpdGggYSB7eyNjcm9zc0xpbmsgXCJSZXZvbHV0ZUNvbnN0cmFpbnRcIn19e3svY3Jvc3NMaW5rfX0gdG8gbWFrZSwgZm9yIGV4YW1wbGUsIGEgbW91c2UgdHJhcC5cbiAqXG4gKiBAY2xhc3MgUm90YXRpb25hbFNwcmluZ1xuICogQGV4dGVuZHMgU3ByaW5nXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXN0QW5nbGVdIFRoZSByZWxhdGl2ZSBhbmdsZSBvZiBib2RpZXMgYXQgd2hpY2ggdGhlIHNwcmluZyBpcyBhdCByZXN0LiBJZiBub3QgZ2l2ZW4sIGl0J3Mgc2V0IHRvIHRoZSBjdXJyZW50IHJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdGhlIGJvZGllcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGlmZm5lc3M9MTAwXSBTcHJpbmcgY29uc3RhbnQgKHNlZSBIb29rZXMgTGF3KS4gQSBudW1iZXIgPj0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nPTFdIEEgbnVtYmVyID49IDAuXG4gKi9cbmZ1bmN0aW9uIFJvdGF0aW9uYWxTcHJpbmcoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIFNwcmluZy5jYWxsKHRoaXMsIGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXN0IGFuZ2xlIG9mIHRoZSBzcHJpbmcuXG4gICAgICogQHByb3BlcnR5IHJlc3RBbmdsZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN0QW5nbGUgPSB0eXBlb2Yob3B0aW9ucy5yZXN0QW5nbGUpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5yZXN0QW5nbGUgOiBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlO1xufVxuUm90YXRpb25hbFNwcmluZy5wcm90b3R5cGUgPSBuZXcgU3ByaW5nKCk7XG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxTcHJpbmc7XG5cbi8qKlxuICogQXBwbHkgdGhlIHNwcmluZyBmb3JjZSB0byB0aGUgY29ubmVjdGVkIGJvZGllcy5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICovXG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5kYW1waW5nLFxuICAgICAgICBsID0gdGhpcy5yZXN0QW5nbGUsXG4gICAgICAgIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICB4ID0gYm9keUIuYW5nbGUgLSBib2R5QS5hbmdsZSxcbiAgICAgICAgdSA9IGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSAtIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eTtcblxuICAgIHZhciB0b3JxdWUgPSAtIGsgKiAoeCAtIGwpIC0gZCAqIHUgKiAwO1xuXG4gICAgYm9keUEuYW5ndWxhckZvcmNlIC09IHRvcnF1ZTtcbiAgICBib2R5Qi5hbmd1bGFyRm9yY2UgKz0gdG9ycXVlO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vU3ByaW5nXCI6MzV9XSwzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpbmc7XG5cbi8qKlxuICogQSBzcHJpbmcsIGNvbm5lY3RpbmcgdHdvIGJvZGllcy4gVGhlIFNwcmluZyBleHBsaWNpdGx5IGFkZHMgZm9yY2UgYW5kIGFuZ3VsYXJGb3JjZSB0byB0aGUgYm9kaWVzIGFuZCBkb2VzIHRoZXJlZm9yZSBub3QgcHV0IGxvYWQgb24gdGhlIGNvbnN0cmFpbnQgc29sdmVyLlxuICpcbiAqIEBjbGFzcyBTcHJpbmdcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdICBTcHJpbmcgY29uc3RhbnQgKHNlZSBIb29rZXMgTGF3KS4gQSBudW1iZXIgPj0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nPTFdICAgICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMVxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiBsb2NhbCBib2R5IGNvb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB0aGUgYm9keSBjZW50ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy4gT3ZlcnJpZGVzIHRoZSBvcHRpb24gXCJsb2NhbEFuY2hvckFcIiBpZiBnaXZlbi5cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckJdXG4gKi9cbmZ1bmN0aW9uIFNwcmluZyhib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcbiAgICAgICAgc3RpZmZuZXNzOiAxMDAsXG4gICAgICAgIGRhbXBpbmc6IDEsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9IG9wdGlvbnMuc3RpZmZuZXNzO1xuXG4gICAgLyoqXG4gICAgICogRGFtcGluZyBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSBkYW1waW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRhbXBpbmcgPSBvcHRpb25zLmRhbXBpbmc7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBjb25uZWN0ZWQgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgY29ubmVjdGVkIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xufVxuXG4vKipcbiAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqL1xuU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzXG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIEV4cG9ydCBwMiBjbGFzc2VzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBQUJCIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL0FBQkInKSxcbiAgICBBbmdsZUxvY2tFcXVhdGlvbiA6ICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0FuZ2xlTG9ja0VxdWF0aW9uJyksXG4gICAgQm9keSA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvQm9keScpLFxuICAgIEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIENhcHN1bGUgOiAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ2Fwc3VsZScpLFxuICAgIENpcmNsZSA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ2lyY2xlJyksXG4gICAgQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKSxcbiAgICBDb250YWN0RXF1YXRpb24gOiAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpLFxuICAgIENvbnRhY3RNYXRlcmlhbCA6ICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWwnKSxcbiAgICBDb252ZXggOiAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0NvbnZleCcpLFxuICAgIERpc3RhbmNlQ29uc3RyYWludCA6ICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnQnKSxcbiAgICBFcXVhdGlvbiA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0VxdWF0aW9uJyksXG4gICAgRXZlbnRFbWl0dGVyIDogICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2V2ZW50cy9FdmVudEVtaXR0ZXInKSxcbiAgICBGcmljdGlvbkVxdWF0aW9uIDogICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKSxcbiAgICBHZWFyQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvR2VhckNvbnN0cmFpbnQnKSxcbiAgICBHcmlkQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL0dyaWRCcm9hZHBoYXNlJyksXG4gICAgR1NTb2x2ZXIgOiAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NvbHZlci9HU1NvbHZlcicpLFxuICAgIEhlaWdodGZpZWxkIDogICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvSGVpZ2h0ZmllbGQnKSxcbiAgICBMaW5lIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0xpbmUnKSxcbiAgICBMb2NrQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvTG9ja0NvbnN0cmFpbnQnKSxcbiAgICBNYXRlcmlhbCA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vbWF0ZXJpYWwvTWF0ZXJpYWwnKSxcbiAgICBOYXJyb3dwaGFzZSA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL05hcnJvd3BoYXNlJyksXG4gICAgTmFpdmVCcm9hZHBoYXNlIDogICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UnKSxcbiAgICBQYXJ0aWNsZSA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL1BhcnRpY2xlJyksXG4gICAgUGxhbmUgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9QbGFuZScpLFxuICAgIFJldm9sdXRlQ29uc3RyYWludCA6ICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9SZXZvbHV0ZUNvbnN0cmFpbnQnKSxcbiAgICBQcmlzbWF0aWNDb25zdHJhaW50IDogICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvUHJpc21hdGljQ29uc3RyYWludCcpLFxuICAgIFJheSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vUmF5JyksXG4gICAgUmF5Y2FzdFJlc3VsdCA6ICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0JyksXG4gICAgUmVjdGFuZ2xlIDogICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9SZWN0YW5nbGUnKSxcbiAgICBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiA6ICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uJyksXG4gICAgU0FQQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlJyksXG4gICAgU2hhcGUgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9TaGFwZScpLFxuICAgIFNvbHZlciA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zb2x2ZXIvU29sdmVyJyksXG4gICAgU3ByaW5nIDogICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvU3ByaW5nJyksXG4gICAgTGluZWFyU3ByaW5nIDogICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvTGluZWFyU3ByaW5nJyksXG4gICAgUm90YXRpb25hbFNwcmluZyA6ICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvUm90YXRpb25hbFNwcmluZycpLFxuICAgIFV0aWxzIDogICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi91dGlscy9VdGlscycpLFxuICAgIFdvcmxkIDogICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi93b3JsZC9Xb3JsZCcpLFxuICAgIHZlYzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRoL3ZlYzInKSxcbiAgICB2ZXJzaW9uIDogICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24sXG59O1xuXG59LHtcIi4uL3BhY2thZ2UuanNvblwiOjYsXCIuL2NvbGxpc2lvbi9BQUJCXCI6NyxcIi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo4LFwiLi9jb2xsaXNpb24vR3JpZEJyb2FkcGhhc2VcIjo5LFwiLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlXCI6MTAsXCIuL2NvbGxpc2lvbi9OYXJyb3dwaGFzZVwiOjExLFwiLi9jb2xsaXNpb24vUmF5XCI6MTIsXCIuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0XCI6MTMsXCIuL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlXCI6MTQsXCIuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnRcIjoxNSxcIi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50XCI6MTYsXCIuL2NvbnN0cmFpbnRzL0dlYXJDb25zdHJhaW50XCI6MTcsXCIuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50XCI6MTgsXCIuL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnRcIjoxOSxcIi4vY29uc3RyYWludHMvUmV2b2x1dGVDb25zdHJhaW50XCI6MjAsXCIuL2VxdWF0aW9ucy9BbmdsZUxvY2tFcXVhdGlvblwiOjIxLFwiLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MjIsXCIuL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvblwiOjI0LFwiLi9lcXVhdGlvbnMvUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb25cIjoyNixcIi4vZXZlbnRzL0V2ZW50RW1pdHRlclwiOjI3LFwiLi9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWxcIjoyOCxcIi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjoyOSxcIi4vbWF0aC92ZWMyXCI6MzEsXCIuL29iamVjdHMvQm9keVwiOjMyLFwiLi9vYmplY3RzL0xpbmVhclNwcmluZ1wiOjMzLFwiLi9vYmplY3RzL1JvdGF0aW9uYWxTcHJpbmdcIjozNCxcIi4vb2JqZWN0cy9TcHJpbmdcIjozNSxcIi4vc2hhcGVzL0NhcHN1bGVcIjozNyxcIi4vc2hhcGVzL0NpcmNsZVwiOjM4LFwiLi9zaGFwZXMvQ29udmV4XCI6MzksXCIuL3NoYXBlcy9IZWlnaHRmaWVsZFwiOjQwLFwiLi9zaGFwZXMvTGluZVwiOjQxLFwiLi9zaGFwZXMvUGFydGljbGVcIjo0MixcIi4vc2hhcGVzL1BsYW5lXCI6NDMsXCIuL3NoYXBlcy9SZWN0YW5nbGVcIjo0NCxcIi4vc2hhcGVzL1NoYXBlXCI6NDUsXCIuL3NvbHZlci9HU1NvbHZlclwiOjQ2LFwiLi9zb2x2ZXIvU29sdmVyXCI6NDcsXCIuL3V0aWxzL1V0aWxzXCI6NTAsXCIuL3dvcmxkL1dvcmxkXCI6NTR9XSwzNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2Fwc3VsZTtcblxuLyoqXG4gKiBDYXBzdWxlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIENhcHN1bGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGVuZ3RoPTFdIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBlbmQgcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1cz0xXSBSYWRpdXMgb2YgdGhlIGNhcHN1bGVcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHJhZGl1cyA9IDE7XG4gKiAgICAgdmFyIGxlbmd0aCA9IDI7XG4gKiAgICAgdmFyIGNhcHN1bGVTaGFwZSA9IG5ldyBDYXBzdWxlKGxlbmd0aCwgcmFkaXVzKTtcbiAqICAgICBib2R5LmFkZFNoYXBlKGNhcHN1bGVTaGFwZSk7XG4gKi9cbmZ1bmN0aW9uIENhcHN1bGUobGVuZ3RoLCByYWRpdXMpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGVuZCBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxlbmd0aFxuICAgICAqL1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoIHx8IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmFkaXVzIG9mIHRoZSBjYXBzdWxlLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzLFNoYXBlLkNBUFNVTEUpO1xufVxuQ2Fwc3VsZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkNhcHN1bGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2Fwc3VsZTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtYXNzIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBDYXBzdWxlLlxuICogQG1ldGhvZCBjb25wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEB0b2RvXG4gKi9cbkNhcHN1bGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIHJlY3RhbmdsZVxuICAgIHZhciByID0gdGhpcy5yYWRpdXMsXG4gICAgICAgIHcgPSB0aGlzLmxlbmd0aCArIHIsIC8vIDIqciBpcyB0b28gbXVjaCwgMCBpcyB0b28gbGl0dGxlXG4gICAgICAgIGggPSByKjI7XG4gICAgcmV0dXJuIG1hc3MgKiAoaCpoICsgdyp3KSAvIDEyO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKi9cbkNhcHN1bGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5yYWRpdXMgKyB0aGlzLmxlbmd0aC8yO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZUFyZWFcbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5hcmVhID0gTWF0aC5QSSAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKyB0aGlzLnJhZGl1cyAqIDIgKiB0aGlzLmxlbmd0aDtcbn07XG5cbnZhciByID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzO1xuXG4gICAgLy8gQ29tcHV0ZSBjZW50ZXIgcG9zaXRpb24gb2Ygb25lIG9mIHRoZSB0aGUgY2lyY2xlcywgd29ybGQgb3JpZW50ZWQsIGJ1dCB3aXRoIGxvY2FsIG9mZnNldFxuICAgIHZlYzIuc2V0KHIsdGhpcy5sZW5ndGggLyAyLDApO1xuICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUocixyLGFuZ2xlKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYm91bmRzXG4gICAgdmVjMi5zZXQob3V0LnVwcGVyQm91bmQsICBNYXRoLm1heChyWzBdK3JhZGl1cywgLXJbMF0rcmFkaXVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHJbMV0rcmFkaXVzLCAtclsxXStyYWRpdXMpKTtcbiAgICB2ZWMyLnNldChvdXQubG93ZXJCb3VuZCwgIE1hdGgubWluKHJbMF0tcmFkaXVzLCAtclswXS1yYWRpdXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oclsxXS1yYWRpdXMsIC1yWzFdLXJhZGl1cykpO1xuXG4gICAgLy8gQWRkIG9mZnNldFxuICAgIHZlYzIuYWRkKG91dC5sb3dlckJvdW5kLCBvdXQubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgIHZlYzIuYWRkKG91dC51cHBlckJvdW5kLCBvdXQudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vU2hhcGVcIjo0NX1dLDM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlO1xuXG4vKipcbiAqIENpcmNsZSBzaGFwZSBjbGFzcy5cbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzPTFdIFRoZSByYWRpdXMgb2YgdGhpcyBjaXJjbGVcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciByYWRpdXMgPSAxO1xuICogICAgIHZhciBjaXJjbGVTaGFwZSA9IG5ldyBDaXJjbGUocmFkaXVzKTtcbiAqICAgICBib2R5LmFkZFNoYXBlKGNpcmNsZVNoYXBlKTtcbiAqL1xuZnVuY3Rpb24gQ2lyY2xlKHJhZGl1cyl7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXG4gICAgICogQHByb3BlcnR5IHJhZGl1c1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXMgfHwgMTtcblxuICAgIFNoYXBlLmNhbGwodGhpcyxTaGFwZS5DSVJDTEUpO1xufVxuQ2lyY2xlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuQ2lyY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENpcmNsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5DaXJjbGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xuICAgIHJldHVybiBtYXNzICogciAqIHIgLyAyO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkNpcmNsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSB0aGlzLnJhZGl1cztcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVBcmVhXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkNpcmNsZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5hcmVhID0gTWF0aC5QSSAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5DaXJjbGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciByID0gdGhpcy5yYWRpdXM7XG4gICAgdmVjMi5zZXQob3V0LnVwcGVyQm91bmQsICByLCAgcik7XG4gICAgdmVjMi5zZXQob3V0Lmxvd2VyQm91bmQsIC1yLCAtcik7XG4gICAgaWYocG9zaXRpb24pe1xuICAgICAgICB2ZWMyLmFkZChvdXQubG93ZXJCb3VuZCwgb3V0Lmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5hZGQob3V0LnVwcGVyQm91bmQsIG91dC51cHBlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgfVxufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vU2hhcGVcIjo0NX1dLDM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIHBvbHlrID0gX2RlcmVxXygnLi4vbWF0aC9wb2x5aycpXG4sICAgZGVjb21wID0gX2RlcmVxXygncG9seS1kZWNvbXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb252ZXg7XG5cbi8qKlxuICogQ29udmV4IHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIENvbnZleFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgQW4gYXJyYXkgb2YgdmVydGljZXMgdGhhdCBzcGFuIHRoaXMgc2hhcGUuIFZlcnRpY2VzIGFyZSBnaXZlbiBpbiBjb3VudGVyLWNsb2Nrd2lzZSAoQ0NXKSBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXhlc10gQW4gYXJyYXkgb2YgdW5pdCBsZW5ndGggdmVjdG9ycywgcmVwcmVzZW50aW5nIHRoZSBzeW1tZXRyeSBheGVzIGluIHRoZSBjb252ZXguXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIENyZWF0ZSBhIGJveFxuICogICAgIHZhciB2ZXJ0aWNlcyA9IFtbLTEsLTFdLCBbMSwtMV0sIFsxLDFdLCBbLTEsMV1dO1xuICogICAgIHZhciBjb252ZXhTaGFwZSA9IG5ldyBDb252ZXgodmVydGljZXMpO1xuICogICAgIGJvZHkuYWRkU2hhcGUoY29udmV4U2hhcGUpO1xuICovXG5mdW5jdGlvbiBDb252ZXgodmVydGljZXMsIGF4ZXMpe1xuXG4gICAgLyoqXG4gICAgICogVmVydGljZXMgZGVmaW5lZCBpbiB0aGUgbG9jYWwgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IHZlcnRpY2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEF4ZXMgZGVmaW5lZCBpbiB0aGUgbG9jYWwgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IGF4ZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5heGVzID0gW107XG5cbiAgICAvLyBDb3B5IHRoZSB2ZXJ0c1xuICAgIGZvcih2YXIgaT0wOyBpPHZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICB2ZWMyLmNvcHkodix2ZXJ0aWNlc1tpXSk7XG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaCh2KTtcbiAgICB9XG5cbiAgICBpZihheGVzKXtcbiAgICAgICAgLy8gQ29weSB0aGUgYXhlc1xuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgdmVjMi5jb3B5KGF4aXMsIGF4ZXNbaV0pO1xuICAgICAgICAgICAgdGhpcy5heGVzLnB1c2goYXhpcyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYXhlcyBmcm9tIHRoZSB2ZXJ0ZXggZGF0YVxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgLy8gR2V0IHRoZSB3b3JsZCBlZGdlXG4gICAgICAgICAgICB2YXIgd29ybGRQb2ludDAgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIHZhciB3b3JsZFBvaW50MSA9IHZlcnRpY2VzWyhpKzEpICUgdmVydGljZXMubGVuZ3RoXTtcblxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG4gICAgICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MCk7XG5cbiAgICAgICAgICAgIC8vIEdldCBub3JtYWwgLSBqdXN0IHJvdGF0ZSA5MCBkZWdyZWVzIHNpbmNlIHZlcnRpY2VzIGFyZSBnaXZlbiBpbiBDQ1dcbiAgICAgICAgICAgIHZlYzIucm90YXRlOTBjdyhub3JtYWwsIG5vcm1hbCk7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsIG5vcm1hbCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXhlcy5wdXNoKG5vcm1hbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2VudGVyIG9mIG1hc3Mgb2YgdGhlIENvbnZleFxuICAgICAqIEBwcm9wZXJ0eSBjZW50ZXJPZk1hc3NcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jZW50ZXJPZk1hc3MgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFRyaWFuZ3VsYXRlZCB2ZXJzaW9uIG9mIHRoaXMgY29udmV4LiBUaGUgc3RydWN0dXJlIGlzIEFycmF5IG9mIDMtQXJyYXlzLCBhbmQgZWFjaCBzdWJhcnJheSBjb250YWlucyAzIGludGVnZXJzLCByZWZlcmVuY2luZyB0aGUgdmVydGljZXMuXG4gICAgICogQHByb3BlcnR5IHRyaWFuZ2xlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYodGhpcy52ZXJ0aWNlcy5sZW5ndGgpe1xuICAgICAgICB0aGlzLnVwZGF0ZVRyaWFuZ2xlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNlbnRlck9mTWFzcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBib3VuZGluZyByYWRpdXMgb2YgdGhlIGNvbnZleFxuICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG5cbiAgICBTaGFwZS5jYWxsKHRoaXMsIFNoYXBlLkNPTlZFWCk7XG5cbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVBcmVhKCk7XG4gICAgaWYodGhpcy5hcmVhIDwgMCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnZleCB2ZXJ0aWNlcyBtdXN0IGJlIGdpdmVuIGluIGNvbnRlci1jbG9ja3dpc2Ugd2luZGluZy5cIik7XG4gICAgfVxufVxuQ29udmV4LnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuQ29udmV4LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnZleDtcblxudmFyIHRtcFZlYzEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHRtcFZlYzIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFByb2plY3QgYSBDb252ZXggb250byBhIHdvcmxkLW9yaWVudGVkIGF4aXNcbiAqIEBtZXRob2QgcHJvamVjdE9udG9BeGlzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb2Zmc2V0XG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxBeGlzXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XG4gKi9cbkNvbnZleC5wcm90b3R5cGUucHJvamVjdE9udG9Mb2NhbEF4aXMgPSBmdW5jdGlvbihsb2NhbEF4aXMsIHJlc3VsdCl7XG4gICAgdmFyIG1heD1udWxsLFxuICAgICAgICBtaW49bnVsbCxcbiAgICAgICAgdixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGxvY2FsQXhpcyA9IHRtcFZlYzE7XG5cbiAgICAvLyBHZXQgcHJvamVjdGVkIHBvc2l0aW9uIG9mIGFsbCB2ZXJ0aWNlc1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmFsdWUgPSB2ZWMyLmRvdCh2LCBsb2NhbEF4aXMpO1xuICAgICAgICBpZihtYXggPT09IG51bGwgfHwgdmFsdWUgPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYobWluID09PSBudWxsIHx8IHZhbHVlIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYobWluID4gbWF4KXtcbiAgICAgICAgdmFyIHQgPSBtaW47XG4gICAgICAgIG1pbiA9IG1heDtcbiAgICAgICAgbWF4ID0gdDtcbiAgICB9XG5cbiAgICB2ZWMyLnNldChyZXN1bHQsIG1pbiwgbWF4KTtcbn07XG5cbkNvbnZleC5wcm90b3R5cGUucHJvamVjdE9udG9Xb3JsZEF4aXMgPSBmdW5jdGlvbihsb2NhbEF4aXMsIHNoYXBlT2Zmc2V0LCBzaGFwZUFuZ2xlLCByZXN1bHQpe1xuICAgIHZhciB3b3JsZEF4aXMgPSB0bXBWZWMyO1xuXG4gICAgdGhpcy5wcm9qZWN0T250b0xvY2FsQXhpcyhsb2NhbEF4aXMsIHJlc3VsdCk7XG5cbiAgICAvLyBQcm9qZWN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keSBvbnRvIHRoZSBheGlzIC0gbmVlZCB0byBhZGQgdGhpcyB0byB0aGUgcmVzdWx0XG4gICAgaWYoc2hhcGVBbmdsZSAhPT0gMCl7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkQXhpcywgbG9jYWxBeGlzLCBzaGFwZUFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3b3JsZEF4aXMgPSBsb2NhbEF4aXM7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB2ZWMyLmRvdChzaGFwZU9mZnNldCwgd29ybGRBeGlzKTtcblxuICAgIHZlYzIuc2V0KHJlc3VsdCwgcmVzdWx0WzBdICsgb2Zmc2V0LCByZXN1bHRbMV0gKyBvZmZzZXQpO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLnRyaWFuZ2xlcyBwcm9wZXJ0eVxuICogQG1ldGhvZCB1cGRhdGVUcmlhbmdsZXNcbiAqL1xuQ29udmV4LnByb3RvdHlwZS51cGRhdGVUcmlhbmdsZXMgPSBmdW5jdGlvbigpe1xuXG4gICAgdGhpcy50cmlhbmdsZXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJld3JpdGUgb24gcG9seWsgbm90YXRpb24sIGFycmF5IG9mIG51bWJlcnNcbiAgICB2YXIgcG9seWtWZXJ0cyA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHRoaXMudmVydGljZXNbaV07XG4gICAgICAgIHBvbHlrVmVydHMucHVzaCh2WzBdLHZbMV0pO1xuICAgIH1cblxuICAgIC8vIFRyaWFuZ3VsYXRlXG4gICAgdmFyIHRyaWFuZ2xlcyA9IHBvbHlrLlRyaWFuZ3VsYXRlKHBvbHlrVmVydHMpO1xuXG4gICAgLy8gTG9vcCBvdmVyIGFsbCB0cmlhbmdsZXMsIGFkZCB0aGVpciBpbmVydGlhIGNvbnRyaWJ1dGlvbnMgdG8gSVxuICAgIGZvcih2YXIgaT0wOyBpPHRyaWFuZ2xlcy5sZW5ndGg7IGkrPTMpe1xuICAgICAgICB2YXIgaWQxID0gdHJpYW5nbGVzW2ldLFxuICAgICAgICAgICAgaWQyID0gdHJpYW5nbGVzW2krMV0sXG4gICAgICAgICAgICBpZDMgPSB0cmlhbmdsZXNbaSsyXTtcblxuICAgICAgICAvLyBBZGQgdG8gdHJpYW5nbGVzXG4gICAgICAgIHRoaXMudHJpYW5nbGVzLnB1c2goW2lkMSxpZDIsaWQzXSk7XG4gICAgfVxufTtcblxudmFyIHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZCA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkX3RpbWVzX21hc3MgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19hID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfYiA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2MgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19hYyA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2NhID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfY2IgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19uID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIC5jZW50ZXJPZk1hc3MgcHJvcGVydHkuXG4gKiBAbWV0aG9kIHVwZGF0ZUNlbnRlck9mTWFzc1xuICovXG5Db252ZXgucHJvdG90eXBlLnVwZGF0ZUNlbnRlck9mTWFzcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRyaWFuZ2xlcyA9IHRoaXMudHJpYW5nbGVzLFxuICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIGNtID0gdGhpcy5jZW50ZXJPZk1hc3MsXG4gICAgICAgIGNlbnRyb2lkID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkLFxuICAgICAgICBuID0gdXBkYXRlQ2VudGVyT2ZNYXNzX24sXG4gICAgICAgIGEgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYSxcbiAgICAgICAgYiA9IHVwZGF0ZUNlbnRlck9mTWFzc19iLFxuICAgICAgICBjID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2MsXG4gICAgICAgIGFjID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2FjLFxuICAgICAgICBjYSA9IHVwZGF0ZUNlbnRlck9mTWFzc19jYSxcbiAgICAgICAgY2IgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2IsXG4gICAgICAgIGNlbnRyb2lkX3RpbWVzX21hc3MgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWRfdGltZXNfbWFzcztcblxuICAgIHZlYzIuc2V0KGNtLDAsMCk7XG4gICAgdmFyIHRvdGFsQXJlYSA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PXRyaWFuZ2xlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB0ID0gdHJpYW5nbGVzW2ldLFxuICAgICAgICAgICAgYSA9IHZlcnRzW3RbMF1dLFxuICAgICAgICAgICAgYiA9IHZlcnRzW3RbMV1dLFxuICAgICAgICAgICAgYyA9IHZlcnRzW3RbMl1dO1xuXG4gICAgICAgIHZlYzIuY2VudHJvaWQoY2VudHJvaWQsYSxiLGMpO1xuXG4gICAgICAgIC8vIEdldCBtYXNzIGZvciB0aGUgdHJpYW5nbGUgKGRlbnNpdHk9MSBpbiB0aGlzIGNhc2UpXG4gICAgICAgIC8vIGh0dHA6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy84MDE5OC9hcmVhLW9mLXRyaWFuZ2xlLXZpYS12ZWN0b3JzXG4gICAgICAgIHZhciBtID0gQ29udmV4LnRyaWFuZ2xlQXJlYShhLGIsYyk7XG4gICAgICAgIHRvdGFsQXJlYSArPSBtO1xuXG4gICAgICAgIC8vIEFkZCB0byBjZW50ZXIgb2YgbWFzc1xuICAgICAgICB2ZWMyLnNjYWxlKGNlbnRyb2lkX3RpbWVzX21hc3MsIGNlbnRyb2lkLCBtKTtcbiAgICAgICAgdmVjMi5hZGQoY20sIGNtLCBjZW50cm9pZF90aW1lc19tYXNzKTtcbiAgICB9XG5cbiAgICB2ZWMyLnNjYWxlKGNtLGNtLDEvdG90YWxBcmVhKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbWFzcyBtb21lbnQgb2YgaW5lcnRpYSBvZiB0aGUgQ29udmV4LlxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBzZWUgaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC90b3BpYy8zNDI4MjItbW9tZW50LW9mLWluZXJ0aWEtb2YtYS1wb2x5Z29uLTJkL1xuICovXG5Db252ZXgucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICB2YXIgZGVub20gPSAwLjAsXG4gICAgICAgIG51bWVyID0gMC4wLFxuICAgICAgICBOID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBqID0gTi0xLCBpID0gMDsgaSA8IE47IGogPSBpLCBpICsrKXtcbiAgICAgICAgdmFyIHAwID0gdGhpcy52ZXJ0aWNlc1tqXTtcbiAgICAgICAgdmFyIHAxID0gdGhpcy52ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmFyIGEgPSBNYXRoLmFicyh2ZWMyLmNyb3NzTGVuZ3RoKHAwLHAxKSk7XG4gICAgICAgIHZhciBiID0gdmVjMi5kb3QocDEscDEpICsgdmVjMi5kb3QocDEscDApICsgdmVjMi5kb3QocDAscDApO1xuICAgICAgICBkZW5vbSArPSBhICogYjtcbiAgICAgICAgbnVtZXIgKz0gYTtcbiAgICB9XG4gICAgcmV0dXJuIChtYXNzIC8gNi4wKSAqIChkZW5vbSAvIG51bWVyKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgLmJvdW5kaW5nUmFkaXVzIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKi9cbkNvbnZleC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIHIyID0gMDtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgbDIgPSB2ZWMyLnNxdWFyZWRMZW5ndGgodmVydHNbaV0pO1xuICAgICAgICBpZihsMiA+IHIyKXtcbiAgICAgICAgICAgIHIyID0gbDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTWF0aC5zcXJ0KHIyKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhcmVhIG9mIHRoZSB0cmlhbmdsZSBzcGFubmVkIGJ5IHRoZSB0aHJlZSBwb2ludHMgYSwgYiwgYy4gVGhlIGFyZWEgaXMgcG9zaXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIsIG90aGVyd2lzZSBuZWdhdGl2ZS5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgdHJpYW5nbGVBcmVhXG4gKiBAcGFyYW0ge0FycmF5fSBhXG4gKiBAcGFyYW0ge0FycmF5fSBiXG4gKiBAcGFyYW0ge0FycmF5fSBjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkNvbnZleC50cmlhbmdsZUFyZWEgPSBmdW5jdGlvbihhLGIsYyl7XG4gICAgcmV0dXJuICgoKGJbMF0gLSBhWzBdKSooY1sxXSAtIGFbMV0pKS0oKGNbMF0gLSBhWzBdKSooYlsxXSAtIGFbMV0pKSkgKiAwLjU7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLmFyZWFcbiAqIEBtZXRob2QgdXBkYXRlQXJlYVxuICovXG5Db252ZXgucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMudXBkYXRlVHJpYW5nbGVzKCk7XG4gICAgdGhpcy5hcmVhID0gMDtcblxuICAgIHZhciB0cmlhbmdsZXMgPSB0aGlzLnRyaWFuZ2xlcyxcbiAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIGZvcih2YXIgaT0wOyBpIT09dHJpYW5nbGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHQgPSB0cmlhbmdsZXNbaV0sXG4gICAgICAgICAgICBhID0gdmVydHNbdFswXV0sXG4gICAgICAgICAgICBiID0gdmVydHNbdFsxXV0sXG4gICAgICAgICAgICBjID0gdmVydHNbdFsyXV07XG5cbiAgICAgICAgLy8gR2V0IG1hc3MgZm9yIHRoZSB0cmlhbmdsZSAoZGVuc2l0eT0xIGluIHRoaXMgY2FzZSlcbiAgICAgICAgdmFyIG0gPSBDb252ZXgudHJpYW5nbGVBcmVhKGEsYixjKTtcbiAgICAgICAgdGhpcy5hcmVhICs9IG07XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dFxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5Db252ZXgucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIG91dC5zZXRGcm9tUG9pbnRzKHRoaXMudmVydGljZXMsIHBvc2l0aW9uLCBhbmdsZSwgMCk7XG59O1xuXG59LHtcIi4uL21hdGgvcG9seWtcIjozMCxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9TaGFwZVwiOjQ1LFwicG9seS1kZWNvbXBcIjo1fV0sNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSGVpZ2h0ZmllbGQ7XG5cbi8qKlxuICogSGVpZ2h0ZmllbGQgc2hhcGUgY2xhc3MuIEhlaWdodCBkYXRhIGlzIGdpdmVuIGFzIGFuIGFycmF5LiBUaGVzZSBkYXRhIHBvaW50cyBhcmUgc3ByZWFkIG91dCBldmVubHkgd2l0aCBhIGRpc3RhbmNlIFwiZWxlbWVudFdpZHRoXCIuXG4gKiBAY2xhc3MgSGVpZ2h0ZmllbGRcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgQW4gYXJyYXkgb2YgWSB2YWx1ZXMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY29uc3RydWN0IHRoZSB0ZXJyYWluLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5WYWx1ZV0gTWluaW11bSB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludHMgaW4gdGhlIGRhdGEgYXJyYXkuIFdpbGwgYmUgY29tcHV0ZWQgYXV0b21hdGljYWxseSBpZiBub3QgZ2l2ZW4uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4VmFsdWVdIE1heGltdW0gdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWxlbWVudFdpZHRoPTAuMV0gV29ybGQgc3BhY2luZyBiZXR3ZWVuIHRoZSBkYXRhIHBvaW50cyBpbiBYIGRpcmVjdGlvbi5cbiAqIEB0b2RvIFNob3VsZCBiZSBwb3NzaWJsZSB0byB1c2UgYWxvbmcgYWxsIGF4ZXMsIG5vdCBqdXN0IHlcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIEdlbmVyYXRlIHNvbWUgaGVpZ2h0IGRhdGEgKHktdmFsdWVzKS5cbiAqICAgICB2YXIgZGF0YSA9IFtdO1xuICogICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxMDAwOyBpKyspe1xuICogICAgICAgICB2YXIgeSA9IDAuNSAqIE1hdGguY29zKDAuMiAqIGkpO1xuICogICAgICAgICBkYXRhLnB1c2goeSk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBDcmVhdGUgdGhlIGhlaWdodGZpZWxkIHNoYXBlXG4gKiAgICAgdmFyIGhlaWdodGZpZWxkU2hhcGUgPSBuZXcgSGVpZ2h0ZmllbGQoZGF0YSwge1xuICogICAgICAgICBlbGVtZW50V2lkdGg6IDEgLy8gRGlzdGFuY2UgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb25cbiAqICAgICB9KTtcbiAqICAgICB2YXIgaGVpZ2h0ZmllbGRCb2R5ID0gbmV3IEJvZHkoKTtcbiAqICAgICBoZWlnaHRmaWVsZEJvZHkuYWRkU2hhcGUoaGVpZ2h0ZmllbGRTaGFwZSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShoZWlnaHRmaWVsZEJvZHkpO1xuICovXG5mdW5jdGlvbiBIZWlnaHRmaWVsZChkYXRhLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBtYXhWYWx1ZSA6IG51bGwsXG4gICAgICAgIG1pblZhbHVlIDogbnVsbCxcbiAgICAgICAgZWxlbWVudFdpZHRoIDogMC4xXG4gICAgfSk7XG5cbiAgICBpZihvcHRpb25zLm1pblZhbHVlID09PSBudWxsIHx8IG9wdGlvbnMubWF4VmFsdWUgPT09IG51bGwpe1xuICAgICAgICBvcHRpb25zLm1heFZhbHVlID0gZGF0YVswXTtcbiAgICAgICAgb3B0aW9ucy5taW5WYWx1ZSA9IGRhdGFbMF07XG4gICAgICAgIGZvcih2YXIgaT0wOyBpICE9PSBkYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciB2ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIGlmKHYgPiBvcHRpb25zLm1heFZhbHVlKXtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1heFZhbHVlID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHYgPCBvcHRpb25zLm1pblZhbHVlKXtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1pblZhbHVlID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIG51bWJlcnMsIG9yIGhlaWdodCB2YWx1ZXMsIHRoYXQgYXJlIHNwcmVhZCBvdXQgYWxvbmcgdGhlIHggYXhpcy5cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBkYXRhXG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgIC8qKlxuICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgZGF0YVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhWYWx1ZVxuICAgICAqL1xuICAgIHRoaXMubWF4VmFsdWUgPSBvcHRpb25zLm1heFZhbHVlO1xuXG4gICAgLyoqXG4gICAgICogTWF4IHZhbHVlIG9mIHRoZSBkYXRhXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblZhbHVlXG4gICAgICovXG4gICAgdGhpcy5taW5WYWx1ZSA9IG9wdGlvbnMubWluVmFsdWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgZWFjaCBlbGVtZW50XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVsZW1lbnRXaWR0aFxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudFdpZHRoID0gb3B0aW9ucy5lbGVtZW50V2lkdGg7XG5cbiAgICBTaGFwZS5jYWxsKHRoaXMsU2hhcGUuSEVJR0hURklFTEQpO1xufVxuSGVpZ2h0ZmllbGQucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIZWlnaHRmaWVsZDtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgYXJlYSA9IDA7XG4gICAgZm9yKHZhciBpPTA7IGk8ZGF0YS5sZW5ndGgtMTsgaSsrKXtcbiAgICAgICAgYXJlYSArPSAoZGF0YVtpXStkYXRhW2krMV0pIC8gMiAqIHRoaXMuZWxlbWVudFdpZHRoO1xuICAgIH1cbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIC8vIFVzZSB0aGUgbWF4IGRhdGEgcmVjdGFuZ2xlXG4gICAgb3V0LnVwcGVyQm91bmRbMF0gPSB0aGlzLmVsZW1lbnRXaWR0aCAqIHRoaXMuZGF0YS5sZW5ndGggKyBwb3NpdGlvblswXTtcbiAgICBvdXQudXBwZXJCb3VuZFsxXSA9IHRoaXMubWF4VmFsdWUgKyBwb3NpdGlvblsxXTtcbiAgICBvdXQubG93ZXJCb3VuZFswXSA9IHBvc2l0aW9uWzBdO1xuICAgIG91dC5sb3dlckJvdW5kWzFdID0gLU51bWJlci5NQVhfVkFMVUU7IC8vIEluZmluaXR5XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1MCxcIi4vU2hhcGVcIjo0NX1dLDQxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKipcbiAqIExpbmUgc2hhcGUgY2xhc3MuIFRoZSBsaW5lIHNoYXBlIGlzIGFsb25nIHRoZSB4IGRpcmVjdGlvbiwgYW5kIHN0cmV0Y2hlcyBmcm9tIFstbGVuZ3RoLzIsIDBdIHRvIFtsZW5ndGgvMiwwXS5cbiAqIEBjbGFzcyBMaW5lXG4gKiBAcGFyYW0ge051bWJlcn0gW2xlbmd0aD0xXSBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBsaW5lXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExpbmUobGVuZ3RoKXtcblxuICAgIC8qKlxuICAgICAqIExlbmd0aCBvZiB0aGlzIGxpbmVcbiAgICAgKiBAcHJvcGVydHkgbGVuZ3RoXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aCB8fCAxO1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzLFNoYXBlLkxJTkUpO1xufVxuTGluZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkxpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZTtcblxuTGluZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiBtYXNzICogTWF0aC5wb3codGhpcy5sZW5ndGgsMikgLyAxMjtcbn07XG5cbkxpbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5sZW5ndGgvMjtcbn07XG5cbnZhciBwb2ludHMgPSBbdmVjMi5jcmVhdGUoKSx2ZWMyLmNyZWF0ZSgpXTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuTGluZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIGwyID0gdGhpcy5sZW5ndGggLyAyO1xuICAgIHZlYzIuc2V0KHBvaW50c1swXSwgLWwyLCAgMCk7XG4gICAgdmVjMi5zZXQocG9pbnRzWzFdLCAgbDIsICAwKTtcbiAgICBvdXQuc2V0RnJvbVBvaW50cyhwb2ludHMscG9zaXRpb24sYW5nbGUsMCk7XG59O1xuXG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL1NoYXBlXCI6NDV9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGU7XG5cbi8qKlxuICogUGFydGljbGUgc2hhcGUgY2xhc3MuXG4gKiBAY2xhc3MgUGFydGljbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqL1xuZnVuY3Rpb24gUGFydGljbGUoKXtcbiAgICBTaGFwZS5jYWxsKHRoaXMsU2hhcGUuUEFSVElDTEUpO1xufVxuUGFydGljbGUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5QYXJ0aWNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJ0aWNsZTtcblxuUGFydGljbGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICByZXR1cm4gMDsgLy8gQ2FuJ3Qgcm90YXRlIGEgcGFydGljbGVcbn07XG5cblBhcnRpY2xlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2ZWMyLmNvcHkob3V0Lmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcbiAgICB2ZWMyLmNvcHkob3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL1NoYXBlXCI6NDV9XSw0MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSAgX2RlcmVxXygnLi9TaGFwZScpXG4sICAgIHZlYzIgPSAgX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYW5lO1xuXG4vKipcbiAqIFBsYW5lIHNoYXBlIGNsYXNzLiBUaGUgcGxhbmUgaXMgZmFjaW5nIGluIHRoZSBZIGRpcmVjdGlvbi5cbiAqIEBjbGFzcyBQbGFuZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQbGFuZSgpe1xuICAgIFNoYXBlLmNhbGwodGhpcyxTaGFwZS5QTEFORSk7XG59XG5QbGFuZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblBsYW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lO1xuXG4vKipcbiAqIENvbXB1dGUgbW9tZW50IG9mIGluZXJ0aWFcbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICovXG5QbGFuZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiAwOyAvLyBQbGFuZSBpcyBpbmZpbml0ZS4gVGhlIGluZXJ0aWEgc2hvdWxkIHRoZXJlZm9yZSBiZSBpbmZpbnR5IGJ1dCBieSBjb252ZW50aW9uIHdlIHNldCAwIGhlcmVcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXNcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuUGxhbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuUGxhbmUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBhID0gMCxcbiAgICAgICAgc2V0ID0gdmVjMi5zZXQ7XG4gICAgaWYodHlwZW9mKGFuZ2xlKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICAgIGEgPSBhbmdsZSAlICgyKk1hdGguUEkpO1xuICAgIH1cblxuICAgIGlmKGEgPT09IDApe1xuICAgICAgICAvLyB5IGdvZXMgZnJvbSAtaW5mIHRvIDBcbiAgICAgICAgc2V0KG91dC5sb3dlckJvdW5kLCAtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICBzZXQob3V0LnVwcGVyQm91bmQsICBOdW1iZXIuTUFYX1ZBTFVFLCAgMCk7XG4gICAgfSBlbHNlIGlmKGEgPT09IE1hdGguUEkgLyAyKXtcbiAgICAgICAgLy8geCBnb2VzIGZyb20gMCB0byBpbmZcbiAgICAgICAgc2V0KG91dC5sb3dlckJvdW5kLCAwLCAtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHNldChvdXQudXBwZXJCb3VuZCwgICAgICBOdW1iZXIuTUFYX1ZBTFVFLCAgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgfSBlbHNlIGlmKGEgPT09IE1hdGguUEkpe1xuICAgICAgICAvLyB5IGdvZXMgZnJvbSAwIHRvIGluZlxuICAgICAgICBzZXQob3V0Lmxvd2VyQm91bmQsIC1OdW1iZXIuTUFYX1ZBTFVFLCAwKTtcbiAgICAgICAgc2V0KG91dC51cHBlckJvdW5kLCAgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgfSBlbHNlIGlmKGEgPT09IDMqTWF0aC5QSS8yKXtcbiAgICAgICAgLy8geCBnb2VzIGZyb20gLWluZiB0byAwXG4gICAgICAgIHNldChvdXQubG93ZXJCb3VuZCwgLU51bWJlci5NQVhfVkFMVUUsICAgICAtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHNldChvdXQudXBwZXJCb3VuZCwgIDAsICBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXQgbWF4IGJvdW5kc1xuICAgICAgICBzZXQob3V0Lmxvd2VyQm91bmQsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHNldChvdXQudXBwZXJCb3VuZCwgIE51bWJlci5NQVhfVkFMVUUsICBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB9XG5cbiAgICB2ZWMyLmFkZChvdXQubG93ZXJCb3VuZCwgb3V0Lmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcbiAgICB2ZWMyLmFkZChvdXQudXBwZXJCb3VuZCwgb3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcbn07XG5cblBsYW5lLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmFyZWEgPSBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1MCxcIi4vU2hhcGVcIjo0NX1dLDQ0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgIENvbnZleCA9IF9kZXJlcV8oJy4vQ29udmV4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlO1xuXG4vKipcbiAqIFJlY3RhbmdsZSBzaGFwZSBjbGFzcy5cbiAqIEBjbGFzcyBSZWN0YW5nbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0xXSBXaWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MV0gSGVpZ2h0XG4gKiBAZXh0ZW5kcyBDb252ZXhcbiAqL1xuZnVuY3Rpb24gUmVjdGFuZ2xlKHdpZHRoLCBoZWlnaHQpe1xuXG4gICAgLyoqXG4gICAgICogVG90YWwgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDE7XG5cbiAgICAvKipcbiAgICAgKiBUb3RhbCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG5cbiAgICB2YXIgdmVydHMgPSBbICAgdmVjMi5mcm9tVmFsdWVzKC13aWR0aC8yLCAtaGVpZ2h0LzIpLFxuICAgICAgICAgICAgICAgICAgICB2ZWMyLmZyb21WYWx1ZXMoIHdpZHRoLzIsIC1oZWlnaHQvMiksXG4gICAgICAgICAgICAgICAgICAgIHZlYzIuZnJvbVZhbHVlcyggd2lkdGgvMiwgIGhlaWdodC8yKSxcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5mcm9tVmFsdWVzKC13aWR0aC8yLCAgaGVpZ2h0LzIpXTtcbiAgICB2YXIgYXhlcyA9IFt2ZWMyLmZyb21WYWx1ZXMoMSwgMCksIHZlYzIuZnJvbVZhbHVlcygwLCAxKV07XG5cbiAgICBDb252ZXguY2FsbCh0aGlzLCB2ZXJ0cywgYXhlcyk7XG5cbiAgICB0aGlzLnR5cGUgPSBTaGFwZS5SRUNUQU5HTEU7XG59XG5SZWN0YW5nbGUucHJvdG90eXBlID0gbmV3IENvbnZleChbXSk7XG5SZWN0YW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjdGFuZ2xlO1xuXG4vKipcbiAqIENvbXB1dGUgbW9tZW50IG9mIGluZXJ0aWFcbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblJlY3RhbmdsZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHZhciB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgIHJldHVybiBtYXNzICogKGgqaCArIHcqdykgLyAxMjtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXNcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuUmVjdGFuZ2xlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoLFxuICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IE1hdGguc3FydCh3KncgKyBoKmgpIC8gMjtcbn07XG5cbnZhciBjb3JuZXIxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb3JuZXIyID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb3JuZXIzID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb3JuZXI0ID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuUmVjdGFuZ2xlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICBvdXQuc2V0RnJvbVBvaW50cyh0aGlzLnZlcnRpY2VzLHBvc2l0aW9uLGFuZ2xlLDApO1xufTtcblxuUmVjdGFuZ2xlLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmFyZWEgPSB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG59O1xuXG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0NvbnZleFwiOjM5LFwiLi9TaGFwZVwiOjQ1fV0sNDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBTaGFwZTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBzaGFwZXMuXG4gKiBAY2xhc3MgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVcbiAqL1xuZnVuY3Rpb24gU2hhcGUodHlwZSl7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgc2hhcGUuIE9uZSBvZjpcbiAgICAgKlxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvQ0lSQ0xFOnByb3BlcnR5XCJ9fVNoYXBlLkNJUkNMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9QQVJUSUNMRTpwcm9wZXJ0eVwifX1TaGFwZS5QQVJUSUNMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9QTEFORTpwcm9wZXJ0eVwifX1TaGFwZS5QTEFORXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9DT05WRVg6cHJvcGVydHlcIn19U2hhcGUuQ09OVkVYe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0xJTkU6cHJvcGVydHlcIn19U2hhcGUuTElORXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9SRUNUQU5HTEU6cHJvcGVydHlcIn19U2hhcGUuUkVDVEFOR0xFe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0NBUFNVTEU6cHJvcGVydHlcIn19U2hhcGUuQ0FQU1VMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9IRUlHSFRGSUVMRDpwcm9wZXJ0eVwifX1TaGFwZS5IRUlHSFRGSUVMRHt7L2Nyb3NzTGlua319XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBTaGFwZSBvYmplY3QgaWRlbnRpZmllci5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBTaGFwZS5pZENvdW50ZXIrKztcblxuICAgIC8qKlxuICAgICAqIEJvdW5kaW5nIGNpcmNsZSByYWRpdXMgb2YgdGhpcyBzaGFwZVxuICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBDb2xsaXNpb24gZ3JvdXAgdGhhdCB0aGlzIHNoYXBlIGJlbG9uZ3MgdG8gKGJpdCBtYXNrKS4gU2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3LmF1cmVsaWVucmlib24uY29tL2Jsb2cvMjAxMS8wNy9ib3gyZC10dXRvcmlhbC1jb2xsaXNpb24tZmlsdGVyaW5nL1wiPnRoaXMgdHV0b3JpYWw8L2E+LlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25Hcm91cFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gU2V0dXAgYml0cyBmb3IgZWFjaCBhdmFpbGFibGUgZ3JvdXBcbiAgICAgKiAgICAgdmFyIFBMQVlFUiA9IE1hdGgucG93KDIsMCksXG4gICAgICogICAgICAgICBFTkVNWSA9ICBNYXRoLnBvdygyLDEpLFxuICAgICAqICAgICAgICAgR1JPVU5EID0gTWF0aC5wb3coMiwyKVxuICAgICAqXG4gICAgICogICAgIC8vIFB1dCBzaGFwZXMgaW50byB0aGVpciBncm91cHNcbiAgICAgKiAgICAgcGxheWVyMVNoYXBlLmNvbGxpc2lvbkdyb3VwID0gUExBWUVSO1xuICAgICAqICAgICBwbGF5ZXIyU2hhcGUuY29sbGlzaW9uR3JvdXAgPSBQTEFZRVI7XG4gICAgICogICAgIGVuZW15U2hhcGUgIC5jb2xsaXNpb25Hcm91cCA9IEVORU1ZO1xuICAgICAqICAgICBncm91bmRTaGFwZSAuY29sbGlzaW9uR3JvdXAgPSBHUk9VTkQ7XG4gICAgICpcbiAgICAgKiAgICAgLy8gQXNzaWduIGdyb3VwcyB0aGF0IGVhY2ggc2hhcGUgY29sbGlkZSB3aXRoLlxuICAgICAqICAgICAvLyBOb3RlIHRoYXQgdGhlIHBsYXllcnMgY2FuIGNvbGxpZGUgd2l0aCBncm91bmQgYW5kIGVuZW1pZXMsIGJ1dCBub3Qgd2l0aCBvdGhlciBwbGF5ZXJzLlxuICAgICAqICAgICBwbGF5ZXIxU2hhcGUuY29sbGlzaW9uTWFzayA9IEVORU1ZIHwgR1JPVU5EO1xuICAgICAqICAgICBwbGF5ZXIyU2hhcGUuY29sbGlzaW9uTWFzayA9IEVORU1ZIHwgR1JPVU5EO1xuICAgICAqICAgICBlbmVteVNoYXBlICAuY29sbGlzaW9uTWFzayA9IFBMQVlFUiB8IEdST1VORDtcbiAgICAgKiAgICAgZ3JvdW5kU2hhcGUgLmNvbGxpc2lvbk1hc2sgPSBQTEFZRVIgfCBFTkVNWTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEhvdyBjb2xsaXNpb24gY2hlY2sgaXMgZG9uZVxuICAgICAqICAgICBpZihzaGFwZUEuY29sbGlzaW9uR3JvdXAgJiBzaGFwZUIuY29sbGlzaW9uTWFzaykhPTAgJiYgKHNoYXBlQi5jb2xsaXNpb25Hcm91cCAmIHNoYXBlQS5jb2xsaXNpb25NYXNrKSE9MCl7XG4gICAgICogICAgICAgICAvLyBUaGUgc2hhcGVzIHdpbGwgY29sbGlkZVxuICAgICAqICAgICB9XG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuIFRoYXQgbWVhbnMgdGhhdCB0aGlzIHNoYXBlIHdpbGwgbW92ZSB0aHJvdWdoIG90aGVyIGJvZHkgc2hhcGVzLCBidXQgaXQgd2lsbCBzdGlsbCB0cmlnZ2VyIGNvbnRhY3QgZXZlbnRzLCBldGMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjb2xsaXNpb25SZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQ29sbGlzaW9uIG1hc2sgb2YgdGhpcyBzaGFwZS4gU2VlIC5jb2xsaXNpb25Hcm91cC5cbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uTWFza1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25NYXNrID0gIDE7XG4gICAgaWYodHlwZSl7XG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXRlcmlhbCB0byB1c2UgaW4gY29sbGlzaW9ucyBmb3IgdGhpcyBTaGFwZS4gSWYgdGhpcyBpcyBzZXQgdG8gbnVsbCwgdGhlIHdvcmxkIHdpbGwgdXNlIGRlZmF1bHQgbWF0ZXJpYWwgcHJvcGVydGllcyBpbnN0ZWFkLlxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbFxuICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFyZWEgb2YgdGhpcyBzaGFwZS5cbiAgICAgKiBAcHJvcGVydHkgYXJlYVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hcmVhID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoaXMgc2hhcGUgdG8gYmUgYSBzZW5zb3IuIEEgc2Vuc29yIGRvZXMgbm90IGdlbmVyYXRlIGNvbnRhY3RzLCBidXQgaXQgc3RpbGwgcmVwb3J0cyBjb250YWN0IGV2ZW50cy4gVGhpcyBpcyBnb29kIGlmIHlvdSB3YW50IHRvIGtub3cgaWYgYSBzaGFwZSBpcyBvdmVybGFwcGluZyBhbm90aGVyIHNoYXBlLCB3aXRob3V0IHRoZW0gZ2VuZXJhdGluZyBjb250YWN0cy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNlbnNvclxuICAgICAqL1xuICAgIHRoaXMuc2Vuc29yID0gZmFsc2U7XG5cbiAgICB0aGlzLnVwZGF0ZUFyZWEoKTtcbn1cblxuU2hhcGUuaWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQ0lSQ0xFXG4gKi9cblNoYXBlLkNJUkNMRSA9ICAgICAgMTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gUEFSVElDTEVcbiAqL1xuU2hhcGUuUEFSVElDTEUgPSAgICAyO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBQTEFORVxuICovXG5TaGFwZS5QTEFORSA9ICAgICAgIDQ7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IENPTlZFWFxuICovXG5TaGFwZS5DT05WRVggPSAgICAgIDg7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IExJTkVcbiAqL1xuU2hhcGUuTElORSA9ICAgICAgICAxNjtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gUkVDVEFOR0xFXG4gKi9cblNoYXBlLlJFQ1RBTkdMRSA9ICAgMzI7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IENBUFNVTEVcbiAqL1xuU2hhcGUuQ0FQU1VMRSA9ICAgICA2NDtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gSEVJR0hURklFTERcbiAqL1xuU2hhcGUuSEVJR0hURklFTEQgPSAxMjg7XG5cbi8qKlxuICogU2hvdWxkIHJldHVybiB0aGUgbW9tZW50IG9mIGluZXJ0aWEgYXJvdW5kIHRoZSBaIGF4aXMgb2YgdGhlIGJvZHkgZ2l2ZW4gdGhlIHRvdGFsIG1hc3MuIFNlZSA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVwiPldpa2lwZWRpYSdzIGxpc3Qgb2YgbW9tZW50cyBvZiBpbmVydGlhPC9hPi5cbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IElmIHRoZSBpbmVydGlhIGlzIGluZmluaXR5IG9yIGlmIHRoZSBvYmplY3Qgc2ltcGx5IGlzbid0IHBvc3NpYmxlIHRvIHJvdGF0ZSwgcmV0dXJuIDAuXG4gKi9cblNoYXBlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBTaGFwZS4uLlwiKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRpbmcgY2lyY2xlIHJhZGl1cyBvZiB0aGlzIHNoYXBlLlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5TaGFwZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNoYXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIFNoYXBlLi4uXCIpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIC5hcmVhIHByb3BlcnR5IG9mIHRoZSBzaGFwZS5cbiAqIEBtZXRob2QgdXBkYXRlQXJlYVxuICovXG5TaGFwZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgaW4gYWxsIHN1YmNsYXNzZXNcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgd29ybGQgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCAoQUFCQikgb2YgdGhpcyBzaGFwZS5cbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgaW4gZWFjaCBzdWJjbGFzc1xufTtcblxufSx7fV0sNDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFNvbHZlciA9IF9kZXJlcV8oJy4vU29sdmVyJylcbiwgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHU1NvbHZlcjtcblxuLyoqXG4gKiBJdGVyYXRpdmUgR2F1c3MtU2VpZGVsIGNvbnN0cmFpbnQgZXF1YXRpb24gc29sdmVyLlxuICpcbiAqIEBjbGFzcyBHU1NvbHZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTb2x2ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pdGVyYXRpb25zPTEwXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvbGVyYW5jZT0wXVxuICovXG5mdW5jdGlvbiBHU1NvbHZlcihvcHRpb25zKXtcbiAgICBTb2x2ZXIuY2FsbCh0aGlzLG9wdGlvbnMsU29sdmVyLkdTKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBkbyB3aGVuIHNvbHZpbmcuIE1vcmUgZ2l2ZXMgYmV0dGVyIHJlc3VsdHMsIGJ1dCBpcyBtb3JlIGV4cGVuc2l2ZS5cbiAgICAgKiBAcHJvcGVydHkgaXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pdGVyYXRpb25zID0gb3B0aW9ucy5pdGVyYXRpb25zIHx8IDEwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVycm9yIHRvbGVyYW5jZSwgcGVyIGNvbnN0cmFpbnQuIElmIHRoZSB0b3RhbCBlcnJvciBpcyBiZWxvdyB0aGlzIGxpbWl0LCB0aGUgc29sdmVyIHdpbGwgc3RvcCBpdGVyYXRpbmcuIFNldCB0byB6ZXJvIGZvciBhcyBnb29kIHNvbHV0aW9uIGFzIHBvc3NpYmxlLCBidXQgdG8gc29tZXRoaW5nIGxhcmdlciB0aGFuIHplcm8gdG8gbWFrZSBjb21wdXRhdGlvbnMgZmFzdGVyLlxuICAgICAqIEBwcm9wZXJ0eSB0b2xlcmFuY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9sZXJhbmNlID0gb3B0aW9ucy50b2xlcmFuY2UgfHwgMWUtMTA7XG5cbiAgICB0aGlzLmFycmF5U3RlcCA9IDMwO1xuICAgIHRoaXMubGFtYmRhID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUodGhpcy5hcnJheVN0ZXApO1xuICAgIHRoaXMuQnMgPSAgICAgbmV3IFV0aWxzLkFSUkFZX1RZUEUodGhpcy5hcnJheVN0ZXApO1xuICAgIHRoaXMuaW52Q3MgPSAgbmV3IFV0aWxzLkFSUkFZX1RZUEUodGhpcy5hcnJheVN0ZXApO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gc2V0IGFsbCByaWdodCBoYW5kIHNpZGUgdGVybXMgdG8gemVybyB3aGVuIHNvbHZpbmcuIENhbiBiZSBoYW5keSBmb3IgYSBmZXcgYXBwbGljYXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB1c2VaZXJvUkhTXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51c2VaZXJvUkhTID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgdGhhdCBhcmUgZG9uZSB0byBhcHByb3hpbWF0ZSBub3JtYWwgZm9yY2VzLiBXaGVuIHRoZXNlIGl0ZXJhdGlvbnMgYXJlIGRvbmUsIGZyaWN0aW9uIGZvcmNlIHdpbGwgYmUgY29tcHV0ZWQgZnJvbSB0aGUgY29udGFjdCBub3JtYWwgZm9yY2VzLiBUaGVzZSBmcmljdGlvbiBmb3JjZXMgd2lsbCBvdmVycmlkZSBhbnkgb3RoZXIgZnJpY3Rpb24gZm9yY2VzIHNldCBmcm9tIHRoZSBXb3JsZCBmb3IgZXhhbXBsZS5cbiAgICAgKiBUaGUgc29sdmVyIHdpbGwgdXNlIGxlc3MgaXRlcmF0aW9ucyBpZiB0aGUgc29sdXRpb24gaXMgYmVsb3cgdGhlIC50b2xlcmFuY2UuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uSXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRoYXQgd2VyZSBtYWRlIGR1cmluZyB0aGUgbGFzdCBzb2x2ZS4gSWYgLnRvbGVyYW5jZSBpcyB6ZXJvLCB0aGlzIHZhbHVlIHdpbGwgYWx3YXlzIGJlIGVxdWFsIHRvIC5pdGVyYXRpb25zLCBidXQgaWYgLnRvbGVyYW5jZSBpcyBsYXJnZXIgdGhhbiB6ZXJvLCBhbmQgdGhlIHNvbHZlciBjYW4gcXVpdCBlYXJseSwgdGhlbiB0aGlzIG51bWJlciB3aWxsIGJlIHNvbWV3aGVyZSBiZXR3ZWVuIDEgYW5kIC5pdGVyYXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB1c2VkSXRlcmF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMudXNlZEl0ZXJhdGlvbnMgPSAwO1xufVxuR1NTb2x2ZXIucHJvdG90eXBlID0gbmV3IFNvbHZlcigpO1xuR1NTb2x2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR1NTb2x2ZXI7XG5cbmZ1bmN0aW9uIHNldEFycmF5WmVybyhhcnJheSl7XG4gICAgdmFyIGwgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgYXJyYXlbbF0gPSArMC4wO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTb2x2ZSB0aGUgc3lzdGVtIG9mIGVxdWF0aW9uc1xuICogQG1ldGhvZCBzb2x2ZVxuICogQHBhcmFtICB7TnVtYmVyfSAgaCAgICAgICBUaW1lIHN0ZXBcbiAqIEBwYXJhbSAge1dvcmxkfSAgIHdvcmxkICAgIFdvcmxkIHRvIHNvbHZlXG4gKi9cbkdTU29sdmVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKGgsIHdvcmxkKXtcblxuICAgIHRoaXMuc29ydEVxdWF0aW9ucygpO1xuXG4gICAgdmFyIGl0ZXIgPSAwLFxuICAgICAgICBtYXhJdGVyID0gdGhpcy5pdGVyYXRpb25zLFxuICAgICAgICBtYXhGcmljdGlvbkl0ZXIgPSB0aGlzLmZyaWN0aW9uSXRlcmF0aW9ucyxcbiAgICAgICAgZXF1YXRpb25zID0gdGhpcy5lcXVhdGlvbnMsXG4gICAgICAgIE5lcSA9IGVxdWF0aW9ucy5sZW5ndGgsXG4gICAgICAgIHRvbFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnRvbGVyYW5jZSpOZXEsIDIpLFxuICAgICAgICBib2RpZXMgPSB3b3JsZC5ib2RpZXMsXG4gICAgICAgIE5ib2RpZXMgPSB3b3JsZC5ib2RpZXMubGVuZ3RoLFxuICAgICAgICBhZGQgPSB2ZWMyLmFkZCxcbiAgICAgICAgc2V0ID0gdmVjMi5zZXQsXG4gICAgICAgIHVzZVplcm9SSFMgPSB0aGlzLnVzZVplcm9SSFMsXG4gICAgICAgIGxhbWJkYSA9IHRoaXMubGFtYmRhO1xuXG4gICAgdGhpcy51c2VkSXRlcmF0aW9ucyA9IDA7XG5cbiAgICBpZihOZXEpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHNvbHZlIG1hc3NcbiAgICAgICAgICAgIGIudXBkYXRlU29sdmVNYXNzUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpbmdzIHRoYXQgZG9lcyBub3QgY2hhbmdlIGR1cmluZyBpdGVyYXRpb24gY2FuIGJlIGNvbXB1dGVkIG9uY2VcbiAgICBpZihsYW1iZGEubGVuZ3RoIDwgTmVxKXtcbiAgICAgICAgbGFtYmRhID0gdGhpcy5sYW1iZGEgPSAgbmV3IFV0aWxzLkFSUkFZX1RZUEUoTmVxICsgdGhpcy5hcnJheVN0ZXApO1xuICAgICAgICB0aGlzLkJzID0gICAgICAgICAgICAgICBuZXcgVXRpbHMuQVJSQVlfVFlQRShOZXEgKyB0aGlzLmFycmF5U3RlcCk7XG4gICAgICAgIHRoaXMuaW52Q3MgPSAgICAgICAgICAgIG5ldyBVdGlscy5BUlJBWV9UWVBFKE5lcSArIHRoaXMuYXJyYXlTdGVwKTtcbiAgICB9XG4gICAgc2V0QXJyYXlaZXJvKGxhbWJkYSk7XG4gICAgdmFyIGludkNzID0gdGhpcy5pbnZDcyxcbiAgICAgICAgQnMgPSB0aGlzLkJzLFxuICAgICAgICBsYW1iZGEgPSB0aGlzLmxhbWJkYTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09ZXF1YXRpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBlcXVhdGlvbnNbaV07XG4gICAgICAgIGlmKGMudGltZVN0ZXAgIT09IGggfHwgYy5uZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBjLnRpbWVTdGVwID0gaDtcbiAgICAgICAgICAgIGMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgQnNbaV0gPSAgICAgYy5jb21wdXRlQihjLmEsYy5iLGgpO1xuICAgICAgICBpbnZDc1tpXSA9ICBjLmNvbXB1dGVJbnZDKGMuZXBzaWxvbik7XG4gICAgfVxuXG4gICAgdmFyIHEsIEIsIGMsIGRlbHRhbGFtYmRhVG90LGksajtcblxuICAgIGlmKE5lcSAhPT0gMCl7XG5cbiAgICAgICAgZm9yKGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgLy8gUmVzZXQgdmxhbWJkYVxuICAgICAgICAgICAgYi5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobWF4RnJpY3Rpb25JdGVyKXtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBjb250YWN0IGVxdWF0aW9ucyB0byBnZXQgbm9ybWFsIGZvcmNlc1xuICAgICAgICAgICAgZm9yKGl0ZXI9MDsgaXRlciE9PW1heEZyaWN0aW9uSXRlcjsgaXRlcisrKXtcblxuICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHRvdGFsIGVycm9yIGZvciBlYWNoIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDtcblxuICAgICAgICAgICAgICAgIGZvcihqPTA7IGohPT1OZXE7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBlcXVhdGlvbnNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhbGFtYmRhID0gR1NTb2x2ZXIuaXRlcmF0ZUVxdWF0aW9uKGosYyxjLmVwc2lsb24sQnMsaW52Q3MsbGFtYmRhLHVzZVplcm9SSFMsaCxpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgKz0gTWF0aC5hYnMoZGVsdGFsYW1iZGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudXNlZEl0ZXJhdGlvbnMrKztcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0b3RhbCBlcnJvciBpcyBzbWFsbCBlbm91Z2ggLSBzdG9wIGl0ZXJhdGVcbiAgICAgICAgICAgICAgICBpZihkZWx0YWxhbWJkYVRvdCpkZWx0YWxhbWJkYVRvdCA8PSB0b2xTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBHU1NvbHZlci51cGRhdGVNdWx0aXBsaWVycyhlcXVhdGlvbnMsIGxhbWJkYSwgMS9oKTtcblxuICAgICAgICAgICAgLy8gU2V0IGNvbXB1dGVkIGZyaWN0aW9uIGZvcmNlXG4gICAgICAgICAgICBmb3Ioaj0wOyBqIT09TmVxOyBqKyspe1xuICAgICAgICAgICAgICAgIHZhciBlcSA9IGVxdWF0aW9uc1tqXTtcbiAgICAgICAgICAgICAgICBpZihlcSBpbnN0YW5jZW9mIEZyaWN0aW9uRXF1YXRpb24pe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrPTA7IGshPT1lcS5jb250YWN0RXF1YXRpb25zLmxlbmd0aDsgaysrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgKz0gZXEuY29udGFjdEVxdWF0aW9uc1trXS5tdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGYgKj0gZXEuZnJpY3Rpb25Db2VmZmljaWVudCAvIGVxLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBlcS5tYXhGb3JjZSA9ICBmO1xuICAgICAgICAgICAgICAgICAgICBlcS5taW5Gb3JjZSA9IC1mO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZXF1YXRpb25zXG4gICAgICAgIGZvcihpdGVyPTA7IGl0ZXIhPT1tYXhJdGVyOyBpdGVyKyspe1xuXG4gICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uXG4gICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDtcblxuICAgICAgICAgICAgZm9yKGo9MDsgaiE9PU5lcTsgaisrKXtcbiAgICAgICAgICAgICAgICBjID0gZXF1YXRpb25zW2pdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhbGFtYmRhID0gR1NTb2x2ZXIuaXRlcmF0ZUVxdWF0aW9uKGosYyxjLmVwc2lsb24sQnMsaW52Q3MsbGFtYmRhLHVzZVplcm9SSFMsaCxpdGVyKTtcbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBNYXRoLmFicyhkZWx0YWxhbWJkYSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXNlZEl0ZXJhdGlvbnMrKztcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxuICAgICAgICAgICAgaWYoZGVsdGFsYW1iZGFUb3QqZGVsdGFsYW1iZGFUb3QgPD0gdG9sU3F1YXJlZCl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgcmVzdWx0IHRvIHZlbG9jaXR5XG4gICAgICAgIGZvcihpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLmFkZENvbnN0cmFpbnRWZWxvY2l0eSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgR1NTb2x2ZXIudXBkYXRlTXVsdGlwbGllcnMoZXF1YXRpb25zLCBsYW1iZGEsIDEvaCk7XG4gICAgfVxufTtcblxuLy8gU2V0cyB0aGUgLm11bHRpcGxpZXIgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvblxuR1NTb2x2ZXIudXBkYXRlTXVsdGlwbGllcnMgPSBmdW5jdGlvbihlcXVhdGlvbnMsIGxhbWJkYSwgaW52RHQpe1xuICAgIC8vIFNldCB0aGUgLm11bHRpcGxpZXIgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvblxuICAgIHZhciBsID0gZXF1YXRpb25zLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICBlcXVhdGlvbnNbbF0ubXVsdGlwbGllciA9IGxhbWJkYVtsXSAqIGludkR0O1xuICAgIH1cbn07XG5cbkdTU29sdmVyLml0ZXJhdGVFcXVhdGlvbiA9IGZ1bmN0aW9uKGosZXEsZXBzLEJzLGludkNzLGxhbWJkYSx1c2VaZXJvUkhTLGR0LGl0ZXIpe1xuICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXG4gICAgdmFyIEIgPSBCc1tqXSxcbiAgICAgICAgaW52QyA9IGludkNzW2pdLFxuICAgICAgICBsYW1iZGFqID0gbGFtYmRhW2pdLFxuICAgICAgICBHV2xhbWJkYSA9IGVxLmNvbXB1dGVHV2xhbWJkYSgpO1xuXG4gICAgdmFyIG1heEZvcmNlID0gZXEubWF4Rm9yY2UsXG4gICAgICAgIG1pbkZvcmNlID0gZXEubWluRm9yY2U7XG5cbiAgICBpZih1c2VaZXJvUkhTKXtcbiAgICAgICAgQiA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhbGFtYmRhID0gaW52QyAqICggQiAtIEdXbGFtYmRhIC0gZXBzICogbGFtYmRhaiApO1xuXG4gICAgLy8gQ2xhbXAgaWYgd2UgYXJlIG5vdCB3aXRoaW4gdGhlIG1pbi9tYXggaW50ZXJ2YWxcbiAgICB2YXIgbGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhID0gbGFtYmRhaiArIGRlbHRhbGFtYmRhO1xuICAgIGlmKGxhbWJkYWpfcGx1c19kZWx0YWxhbWJkYSA8IG1pbkZvcmNlKmR0KXtcbiAgICAgICAgZGVsdGFsYW1iZGEgPSBtaW5Gb3JjZSpkdCAtIGxhbWJkYWo7XG4gICAgfSBlbHNlIGlmKGxhbWJkYWpfcGx1c19kZWx0YWxhbWJkYSA+IG1heEZvcmNlKmR0KXtcbiAgICAgICAgZGVsdGFsYW1iZGEgPSBtYXhGb3JjZSpkdCAtIGxhbWJkYWo7XG4gICAgfVxuICAgIGxhbWJkYVtqXSArPSBkZWx0YWxhbWJkYTtcbiAgICBlcS5hZGRUb1dsYW1iZGEoZGVsdGFsYW1iZGEpO1xuXG4gICAgcmV0dXJuIGRlbHRhbGFtYmRhO1xufTtcblxufSx7XCIuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvblwiOjI0LFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjUwLFwiLi9Tb2x2ZXJcIjo0N31dLDQ3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICBFdmVudEVtaXR0ZXIgPSBfZGVyZXFfKCcuLi9ldmVudHMvRXZlbnRFbWl0dGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU29sdmVyO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNvbnN0cmFpbnQgc29sdmVycy5cbiAqIEBjbGFzcyBTb2x2ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmZ1bmN0aW9uIFNvbHZlcihvcHRpb25zLHR5cGUpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBlcXVhdGlvbnMgaW4gdGhlIHNvbHZlci5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBzb3J0IGFsbCBlcXVhdGlvbnMgYmVmb3JlIGVhY2ggc29sdmUuXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uU29ydEZ1bmN0aW9uXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufGJvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvblNvcnRGdW5jdGlvbiA9IG9wdGlvbnMuZXF1YXRpb25Tb3J0RnVuY3Rpb24gfHwgZmFsc2U7XG59XG5Tb2x2ZXIucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuU29sdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbHZlcjtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW1wbGVtZW50ZWQgaW4gZWFjaCBzdWJjbGFzc1xuICogQG1ldGhvZCBzb2x2ZVxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cblNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihkdCx3b3JsZCl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU29sdmVyLnNvbHZlIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzIVwiKTtcbn07XG5cbnZhciBtb2NrV29ybGQgPSB7Ym9kaWVzOltdfTtcblxuLyoqXG4gKiBTb2x2ZXMgYWxsIGNvbnN0cmFpbnRzIGluIGFuIGlzbGFuZC5cbiAqIEBtZXRob2Qgc29sdmVJc2xhbmRcbiAqIEBwYXJhbSAge051bWJlcn0gZHRcbiAqIEBwYXJhbSAge0lzbGFuZH0gaXNsYW5kXG4gKi9cblNvbHZlci5wcm90b3R5cGUuc29sdmVJc2xhbmQgPSBmdW5jdGlvbihkdCxpc2xhbmQpe1xuXG4gICAgdGhpcy5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcblxuICAgIGlmKGlzbGFuZC5lcXVhdGlvbnMubGVuZ3RoKXtcbiAgICAgICAgLy8gQWRkIGVxdWF0aW9ucyB0byBzb2x2ZXJcbiAgICAgICAgdGhpcy5hZGRFcXVhdGlvbnMoaXNsYW5kLmVxdWF0aW9ucyk7XG4gICAgICAgIG1vY2tXb3JsZC5ib2RpZXMubGVuZ3RoID0gMDtcbiAgICAgICAgaXNsYW5kLmdldEJvZGllcyhtb2NrV29ybGQuYm9kaWVzKTtcblxuICAgICAgICAvLyBTb2x2ZVxuICAgICAgICBpZihtb2NrV29ybGQuYm9kaWVzLmxlbmd0aCl7XG4gICAgICAgICAgICB0aGlzLnNvbHZlKGR0LG1vY2tXb3JsZCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFNvcnQgYWxsIGVxdWF0aW9ucyB1c2luZyB0aGUgLmVxdWF0aW9uU29ydEZ1bmN0aW9uLiBTaG91bGQgYmUgY2FsbGVkIGJ5IHN1YmNsYXNzZXMgYmVmb3JlIHNvbHZpbmcuXG4gKiBAbWV0aG9kIHNvcnRFcXVhdGlvbnNcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5zb3J0RXF1YXRpb25zID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLmVxdWF0aW9uU29ydEZ1bmN0aW9uKXtcbiAgICAgICAgdGhpcy5lcXVhdGlvbnMuc29ydCh0aGlzLmVxdWF0aW9uU29ydEZ1bmN0aW9uKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhbiBlcXVhdGlvbiB0byBiZSBzb2x2ZWQuXG4gKlxuICogQG1ldGhvZCBhZGRFcXVhdGlvblxuICogQHBhcmFtIHtFcXVhdGlvbn0gZXFcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5hZGRFcXVhdGlvbiA9IGZ1bmN0aW9uKGVxKXtcbiAgICBpZihlcS5lbmFibGVkKXtcbiAgICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChlcSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgZXF1YXRpb25zLiBTYW1lIGFzIC5hZGRFcXVhdGlvbiwgYnV0IHRoaXMgdGltZSB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkgb2YgRXF1YXRpb25zXG4gKlxuICogQG1ldGhvZCBhZGRFcXVhdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVxc1xuICovXG5Tb2x2ZXIucHJvdG90eXBlLmFkZEVxdWF0aW9ucyA9IGZ1bmN0aW9uKGVxcyl7XG4gICAgLy9VdGlscy5hcHBlbmRBcnJheSh0aGlzLmVxdWF0aW9ucyxlcXMpO1xuICAgIGZvcih2YXIgaT0wLCBOPWVxcy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBlcXNbaV07XG4gICAgICAgIGlmKGVxLmVuYWJsZWQpe1xuICAgICAgICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChlcSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBlcXVhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUVxdWF0aW9uXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICovXG5Tb2x2ZXIucHJvdG90eXBlLnJlbW92ZUVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xuICAgIHZhciBpID0gdGhpcy5lcXVhdGlvbnMuaW5kZXhPZihlcSk7XG4gICAgaWYoaSAhPT0gLTEpe1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgY3VycmVudGx5IGFkZGVkIGVxdWF0aW9ucy5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUFsbEVxdWF0aW9uc1xuICovXG5Tb2x2ZXIucHJvdG90eXBlLnJlbW92ZUFsbEVxdWF0aW9ucyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lcXVhdGlvbnMubGVuZ3RoPTA7XG59O1xuXG5Tb2x2ZXIuR1MgPSAxO1xuU29sdmVyLklTTEFORCA9IDI7XG5cbn0se1wiLi4vZXZlbnRzL0V2ZW50RW1pdHRlclwiOjI3LFwiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDQ4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBUdXBsZURpY3Rpb25hcnkgPSBfZGVyZXFfKCcuL1R1cGxlRGljdGlvbmFyeScpO1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXBLZWVwZXI7XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2Ygb3ZlcmxhcHMgaW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHRoZSBsYXN0IHN0ZXAgc3RhdGUuXG4gKiBAY2xhc3MgT3ZlcmxhcEtlZXBlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE92ZXJsYXBLZWVwZXIoKSB7XG4gICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZSA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuICAgIHRoaXMucmVjb3JkUG9vbCA9IFtdO1xuICAgIHRoaXMudG1wRGljdCA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcbiAgICB0aGlzLnRtcEFycmF5MSA9IFtdO1xufVxuXG4vKipcbiAqIFRpY2tzIG9uZSBzdGVwIGZvcndhcmQgaW4gdGltZS4gVGhpcyB3aWxsIG1vdmUgdGhlIGN1cnJlbnQgb3ZlcmxhcCBzdGF0ZSB0byB0aGUgXCJvbGRcIiBvdmVybGFwIHN0YXRlLCBhbmQgY3JlYXRlIGEgbmV3IG9uZSBhcyBjdXJyZW50LlxuICogQG1ldGhvZCB0aWNrXG4gKi9cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGFzdCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuXG4gICAgLy8gU2F2ZSBvbGQgb2JqZWN0cyBpbnRvIHBvb2xcbiAgICB2YXIgbCA9IGxhc3Qua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGxhc3Qua2V5c1tsXTtcbiAgICAgICAgdmFyIGxhc3RPYmplY3QgPSBsYXN0LmdldEJ5S2V5KGtleSk7XG4gICAgICAgIHZhciBjdXJyZW50T2JqZWN0ID0gY3VycmVudC5nZXRCeUtleShrZXkpO1xuICAgICAgICBpZihsYXN0T2JqZWN0ICYmICFjdXJyZW50T2JqZWN0KXtcbiAgICAgICAgICAgIC8vIFRoZSByZWNvcmQgaXMgb25seSB1c2VkIGluIHRoZSBcImxhc3RcIiBkaWN0LCBhbmQgd2lsbCBiZSByZW1vdmVkLiBXZSBtaWdodCBhcyB3ZWxsIHBvb2wgaXQuXG4gICAgICAgICAgICB0aGlzLnJlY29yZFBvb2wucHVzaChsYXN0T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFyIGxhc3Qgb2JqZWN0XG4gICAgbGFzdC5yZXNldCgpO1xuXG4gICAgLy8gVHJhbnNmZXIgZnJvbSBuZXcgb2JqZWN0IHRvIG9sZFxuICAgIGxhc3QuY29weShjdXJyZW50KTtcblxuICAgIC8vIENsZWFyIGN1cnJlbnQgb2JqZWN0XG4gICAgY3VycmVudC5yZXNldCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldE92ZXJsYXBwaW5nXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtCb2R5fSBzaGFwZUJcbiAqL1xuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuc2V0T3ZlcmxhcHBpbmcgPSBmdW5jdGlvbihib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKSB7XG4gICAgdmFyIGxhc3QgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcblxuICAgIC8vIFN0b3JlIGN1cnJlbnQgY29udGFjdCBzdGF0ZVxuICAgIGlmKCFjdXJyZW50LmdldChzaGFwZUEuaWQsIHNoYXBlQi5pZCkpe1xuXG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZih0aGlzLnJlY29yZFBvb2wubGVuZ3RoKXtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLnJlY29yZFBvb2wucG9wKCk7XG4gICAgICAgICAgICBkYXRhLnNldChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgT3ZlcmxhcEtlZXBlclJlY29yZChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQuc2V0KHNoYXBlQS5pZCwgc2hhcGVCLmlkLCBkYXRhKTtcbiAgICB9XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXROZXdPdmVybGFwcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGlmZih0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlLCB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlLCByZXN1bHQpO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RW5kT3ZlcmxhcHMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHJldHVybiB0aGlzLmdldERpZmYodGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZSwgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZSwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBib2RpZXMgYXJlIGN1cnJlbnRseSBvdmVybGFwcGluZy5cbiAqIEBtZXRob2QgYm9kaWVzQXJlT3ZlcmxhcHBpbmdcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuYm9kaWVzQXJlT3ZlcmxhcHBpbmcgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcbiAgICB2YXIgbCA9IGN1cnJlbnQua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGN1cnJlbnQua2V5c1tsXTtcbiAgICAgICAgdmFyIGRhdGEgPSBjdXJyZW50LmRhdGFba2V5XTtcbiAgICAgICAgaWYoKGRhdGEuYm9keUEgPT09IGJvZHlBICYmIGRhdGEuYm9keUIgPT09IGJvZHlCKSB8fCBkYXRhLmJvZHlBID09PSBib2R5QiAmJiBkYXRhLmJvZHlCID09PSBib2R5QSl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXREaWZmID0gZnVuY3Rpb24oZGljdEEsIGRpY3RCLCByZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgW107XG4gICAgdmFyIGxhc3QgPSBkaWN0QTtcbiAgICB2YXIgY3VycmVudCA9IGRpY3RCO1xuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgbCA9IGN1cnJlbnQua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGN1cnJlbnQua2V5c1tsXTtcbiAgICAgICAgdmFyIGRhdGEgPSBjdXJyZW50LmRhdGFba2V5XTtcblxuICAgICAgICBpZighZGF0YSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSAnK2tleSsnIGhhZCBubyBkYXRhIScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3REYXRhID0gbGFzdC5kYXRhW2tleV07XG4gICAgICAgIGlmKCFsYXN0RGF0YSl7XG4gICAgICAgICAgICAvLyBOb3Qgb3ZlcmxhcHBpbmcgaW4gbGFzdCBzdGF0ZSwgYnV0IGluIGN1cnJlbnQuXG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5pc05ld092ZXJsYXAgPSBmdW5jdGlvbihzaGFwZUEsIHNoYXBlQil7XG4gICAgdmFyIGlkQSA9IHNoYXBlQS5pZHwwLFxuICAgICAgICBpZEIgPSBzaGFwZUIuaWR8MDtcbiAgICB2YXIgbGFzdCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuICAgIC8vIE5vdCBpbiBsYXN0IGJ1dCBpbiBuZXdcbiAgICByZXR1cm4gISEhbGFzdC5nZXQoaWRBLCBpZEIpICYmICEhY3VycmVudC5nZXQoaWRBLCBpZEIpO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0TmV3Qm9keU92ZXJsYXBzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLnRtcEFycmF5MS5sZW5ndGggPSAwO1xuICAgIHZhciBvdmVybGFwcyA9IHRoaXMuZ2V0TmV3T3ZlcmxhcHModGhpcy50bXBBcnJheTEpO1xuICAgIHJldHVybiB0aGlzLmdldEJvZHlEaWZmKG92ZXJsYXBzLCByZXN1bHQpO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RW5kQm9keU92ZXJsYXBzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLnRtcEFycmF5MS5sZW5ndGggPSAwO1xuICAgIHZhciBvdmVybGFwcyA9IHRoaXMuZ2V0RW5kT3ZlcmxhcHModGhpcy50bXBBcnJheTEpO1xuICAgIHJldHVybiB0aGlzLmdldEJvZHlEaWZmKG92ZXJsYXBzLCByZXN1bHQpO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0Qm9keURpZmYgPSBmdW5jdGlvbihvdmVybGFwcywgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG4gICAgdmFyIGFjY3VtdWxhdG9yID0gdGhpcy50bXBEaWN0O1xuXG4gICAgdmFyIGwgPSBvdmVybGFwcy5sZW5ndGg7XG5cbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIgZGF0YSA9IG92ZXJsYXBzW2xdO1xuXG4gICAgICAgIC8vIFNpbmNlIHdlIHVzZSBib2R5IGlkJ3MgZm9yIHRoZSBhY2N1bXVsYXRvciwgdGhlc2Ugd2lsbCBiZSBhIHN1YnNldCBvZiB0aGUgb3JpZ2luYWwgb25lXG4gICAgICAgIGFjY3VtdWxhdG9yLnNldChkYXRhLmJvZHlBLmlkfDAsIGRhdGEuYm9keUIuaWR8MCwgZGF0YSk7XG4gICAgfVxuXG4gICAgbCA9IGFjY3VtdWxhdG9yLmtleXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBkYXRhID0gYWNjdW11bGF0b3IuZ2V0QnlLZXkoYWNjdW11bGF0b3Iua2V5c1tsXSk7XG4gICAgICAgIGlmKGRhdGEpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGF0YS5ib2R5QSwgZGF0YS5ib2R5Qik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY2N1bXVsYXRvci5yZXNldCgpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogT3ZlcmxhcCBkYXRhIGNvbnRhaW5lciBmb3IgdGhlIE92ZXJsYXBLZWVwZXJcbiAqIEBjbGFzcyBPdmVybGFwS2VlcGVyUmVjb3JkXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gKi9cbmZ1bmN0aW9uIE92ZXJsYXBLZWVwZXJSZWNvcmQoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQil7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVBXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUEgPSBzaGFwZUE7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVCXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUIgPSBzaGFwZUI7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5QVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlCXG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xufVxuXG4vKipcbiAqIFNldCB0aGUgZGF0YSBmb3IgdGhlIHJlY29yZFxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gKi9cbk92ZXJsYXBLZWVwZXJSZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpe1xuICAgIE92ZXJsYXBLZWVwZXJSZWNvcmQuY2FsbCh0aGlzLCBib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbn07XG5cbn0se1wiLi9UdXBsZURpY3Rpb25hcnlcIjo0OSxcIi4vVXRpbHNcIjo1MH1dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4vVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUdXBsZURpY3Rpb25hcnk7XG5cbi8qKlxuICogQGNsYXNzIFR1cGxlRGljdGlvbmFyeVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFR1cGxlRGljdGlvbmFyeSgpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHN0b3JhZ2VcbiAgICAgKiBAcHJvcGVydHkgZGF0YVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0ge307XG5cbiAgICAvKipcbiAgICAgKiBLZXlzIHRoYXQgYXJlIGN1cnJlbnRseSB1c2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGtleXNcbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSBbXTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBnaXZlbiB0d28gaW50ZWdlcnNcbiAqIEBtZXRob2QgZ2V0S2V5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSAge251bWJlcn0galxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uKGlkMSwgaWQyKSB7XG4gICAgaWQxID0gaWQxfDA7XG4gICAgaWQyID0gaWQyfDA7XG5cbiAgICBpZiAoIChpZDF8MCkgPT09IChpZDJ8MCkgKXtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIHZhbGlkIGZvciB2YWx1ZXMgPCAyXjE2XG4gICAgcmV0dXJuICgoaWQxfDApID4gKGlkMnwwKSA/XG4gICAgICAgIChpZDEgPDwgMTYpIHwgKGlkMiAmIDB4RkZGRikgOlxuICAgICAgICAoaWQyIDw8IDE2KSB8IChpZDEgJiAweEZGRkYpKXwwXG4gICAgICAgIDtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRCeUtleVxuICogQHBhcmFtICB7TnVtYmVyfSBrZXlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRCeUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGtleSA9IGtleXwwO1xuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSwgaikge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5nZXRLZXkoaSwgaildO1xufTtcblxuLyoqXG4gKiBTZXQgYSB2YWx1ZS5cbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaiwgdmFsdWUpIHtcbiAgICBpZighdmFsdWUpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhIVwiKTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoaSwgaik7XG5cbiAgICAvLyBDaGVjayBpZiBrZXkgYWxyZWFkeSBleGlzdHNcbiAgICBpZighdGhpcy5kYXRhW2tleV0pe1xuICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YVtrZXldID0gdmFsdWU7XG5cbiAgICByZXR1cm4ga2V5O1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGRhdGEuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAga2V5cyA9IHRoaXMua2V5cztcblxuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhW2tleXNbbF1dO1xuICAgIH1cblxuICAgIGtleXMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogQ29weSBhbm90aGVyIFR1cGxlRGljdGlvbmFyeS4gTm90ZSB0aGF0IGFsbCBkYXRhIGluIHRoaXMgZGljdGlvbmFyeSB3aWxsIGJlIHJlbW92ZWQuXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7VHVwbGVEaWN0aW9uYXJ5fSBkaWN0IFRoZSBUdXBsZURpY3Rpb25hcnkgdG8gY29weSBpbnRvIHRoaXMgb25lLlxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihkaWN0KSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIFV0aWxzLmFwcGVuZEFycmF5KHRoaXMua2V5cywgZGljdC5rZXlzKTtcbiAgICB2YXIgbCA9IGRpY3Qua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGRpY3Qua2V5c1tsXTtcbiAgICAgICAgdGhpcy5kYXRhW2tleV0gPSBkaWN0LmRhdGFba2V5XTtcbiAgICB9XG59O1xuXG59LHtcIi4vVXRpbHNcIjo1MH1dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGdsb2JhbCBQMl9BUlJBWV9UWVBFICovXG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG5cbi8qKlxuICogTWlzYyB1dGlsaXR5IGZ1bmN0aW9uc1xuICogQGNsYXNzIFV0aWxzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRpbHMoKXt9XG5cbi8qKlxuICogQXBwZW5kIHRoZSB2YWx1ZXMgaW4gYXJyYXkgYiB0byB0aGUgYXJyYXkgYS4gU2VlIDxhIGhyZWY9XCJodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNzQxMjYvaG93LXRvLWFwcGVuZC1hbi1hcnJheS10by1hbi1leGlzdGluZy1qYXZhc2NyaXB0LWFycmF5LzEzNzQxMzEjMTM3NDEzMVwiPnRoaXM8L2E+IGZvciBhbiBleHBsYW5hdGlvbi5cbiAqIEBtZXRob2QgYXBwZW5kQXJyYXlcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICovXG5VdGlscy5hcHBlbmRBcnJheSA9IGZ1bmN0aW9uKGEsYil7XG4gICAgaWYgKGIubGVuZ3RoIDwgMTUwMDAwKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYi5sZW5ndGg7IGkgIT09IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBhLnB1c2goYltpXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEdhcmJhZ2UgZnJlZSBBcnJheS5zcGxpY2UoKS4gRG9lcyBub3QgYWxsb2NhdGUgYSBuZXcgYXJyYXkuXG4gKiBAbWV0aG9kIHNwbGljZVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGhvd21hbnlcbiAqL1xuVXRpbHMuc3BsaWNlID0gZnVuY3Rpb24oYXJyYXksaW5kZXgsaG93bWFueSl7XG4gICAgaG93bWFueSA9IGhvd21hbnkgfHwgMTtcbiAgICBmb3IgKHZhciBpPWluZGV4LCBsZW49YXJyYXkubGVuZ3RoLWhvd21hbnk7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIGhvd21hbnldO1xuICAgIH1cbiAgICBhcnJheS5sZW5ndGggPSBsZW47XG59O1xuXG4vKipcbiAqIFRoZSBhcnJheSB0eXBlIHRvIHVzZSBmb3IgaW50ZXJuYWwgbnVtZXJpYyBjb21wdXRhdGlvbnMgdGhyb3VnaG91dCB0aGUgbGlicmFyeS4gRmxvYXQzMkFycmF5IGlzIHVzZWQgaWYgaXQgaXMgYXZhaWxhYmxlLCBidXQgZmFsbHMgYmFjayBvbiBBcnJheS4gSWYgeW91IHdhbnQgdG8gc2V0IGFycmF5IHR5cGUgbWFudWFsbHksIGluamVjdCBpdCB2aWEgdGhlIGdsb2JhbCB2YXJpYWJsZSBQMl9BUlJBWV9UWVBFLiBTZWUgZXhhbXBsZSBiZWxvdy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IEFSUkFZX1RZUEVcbiAqIEBleGFtcGxlXG4gKiAgICAgPHNjcmlwdD5cbiAqICAgICAgICAgPCEtLSBJbmplY3QgeW91ciBwcmVmZXJyZWQgYXJyYXkgdHlwZSBiZWZvcmUgbG9hZGluZyBwMi5qcyAtLT5cbiAqICAgICAgICAgUDJfQVJSQVlfVFlQRSA9IEFycmF5O1xuICogICAgIDwvc2NyaXB0PlxuICogICAgIDxzY3JpcHQgc3JjPVwicDIuanNcIj48L3NjcmlwdD5cbiAqL1xuaWYodHlwZW9mIFAyX0FSUkFZX1RZUEUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgVXRpbHMuQVJSQVlfVFlQRSA9IFAyX0FSUkFZX1RZUEU7XG59IGVsc2UgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKXtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gRmxvYXQzMkFycmF5O1xufSBlbHNlIHtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gQXJyYXk7XG59XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIGFub3RoZXJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0gIHtvYmplY3R9IGFcbiAqIEBwYXJhbSAge29iamVjdH0gYlxuICovXG5VdGlscy5leHRlbmQgPSBmdW5jdGlvbihhLGIpe1xuICAgIGZvcih2YXIga2V5IGluIGIpe1xuICAgICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxufTtcblxuLyoqXG4gKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGVmYXVsdHNcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuIE1heSBiZSBmYWxzeTogaW4gdGhpcyBjYXNlLCBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRlZmF1bHRzIEFuIG9iamVjdCBjb250YWluaW5nIGRlZmF1bHQgdmFsdWVzLlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgbW9kaWZpZWQgb3B0aW9ucyBvYmplY3QuXG4gKi9cblV0aWxzLmRlZmF1bHRzID0gZnVuY3Rpb24ob3B0aW9ucywgZGVmYXVsdHMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGZvcih2YXIga2V5IGluIGRlZmF1bHRzKXtcbiAgICAgICAgaWYoIShrZXkgaW4gb3B0aW9ucykpe1xuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbn0se31dLDUxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSXNsYW5kO1xuXG4vKipcbiAqIEFuIGlzbGFuZCBvZiBib2RpZXMgY29ubmVjdGVkIHdpdGggZXF1YXRpb25zLlxuICogQGNsYXNzIElzbGFuZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElzbGFuZCgpe1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBlcXVhdGlvbnMgaW4gdGhpcyBpc2xhbmQuXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBib2RpZXMgaW4gdGhpcyBpc2xhbmQuXG4gICAgICogQHByb3BlcnR5IGJvZGllc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZGllcyA9IFtdO1xufVxuXG4vKipcbiAqIENsZWFuIHRoaXMgaXNsYW5kIGZyb20gYm9kaWVzIGFuZCBlcXVhdGlvbnMuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbklzbGFuZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IHRoaXMuYm9kaWVzLmxlbmd0aCA9IDA7XG59O1xuXG52YXIgYm9keUlkcyA9IFtdO1xuXG4vKipcbiAqIEdldCBhbGwgdW5pcXVlIGJvZGllcyBpbiB0aGlzIGlzbGFuZC5cbiAqIEBtZXRob2QgZ2V0Qm9kaWVzXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgQm9keVxuICovXG5Jc2xhbmQucHJvdG90eXBlLmdldEJvZGllcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdmFyIGJvZGllcyA9IHJlc3VsdCB8fCBbXSxcbiAgICAgICAgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgYm9keUlkcy5sZW5ndGggPSAwO1xuICAgIGZvcih2YXIgaT0wOyBpIT09ZXFzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xuICAgICAgICBpZihib2R5SWRzLmluZGV4T2YoZXEuYm9keUEuaWQpPT09LTEpe1xuICAgICAgICAgICAgYm9kaWVzLnB1c2goZXEuYm9keUEpO1xuICAgICAgICAgICAgYm9keUlkcy5wdXNoKGVxLmJvZHlBLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZihib2R5SWRzLmluZGV4T2YoZXEuYm9keUIuaWQpPT09LTEpe1xuICAgICAgICAgICAgYm9kaWVzLnB1c2goZXEuYm9keUIpO1xuICAgICAgICAgICAgYm9keUlkcy5wdXNoKGVxLmJvZHlCLmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm9kaWVzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZW50aXJlIGlzbGFuZCB3YW50cyB0byBzbGVlcC5cbiAqIEBtZXRob2Qgd2FudHNUb1NsZWVwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Jc2xhbmQucHJvdG90eXBlLndhbnRzVG9TbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5ib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2ldO1xuICAgICAgICBpZihiLnR5cGUgPT09IEJvZHkuRFlOQU1JQyAmJiAhYi53YW50c1RvU2xlZXApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBNYWtlIGFsbCBib2RpZXMgaW4gdGhlIGlzbGFuZCBzbGVlcC5cbiAqIEBtZXRob2Qgc2xlZXBcbiAqL1xuSXNsYW5kLnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5ib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2ldO1xuICAgICAgICBiLnNsZWVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxufSx7XCIuLi9vYmplY3RzL0JvZHlcIjozMn1dLDUyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBJc2xhbmQgPSBfZGVyZXFfKCcuL0lzbGFuZCcpXG4sICAgSXNsYW5kTm9kZSA9IF9kZXJlcV8oJy4vSXNsYW5kTm9kZScpXG4sICAgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElzbGFuZE1hbmFnZXI7XG5cbi8qKlxuICogU3BsaXRzIHRoZSBzeXN0ZW0gb2YgYm9kaWVzIGFuZCBlcXVhdGlvbnMgaW50byBpbmRlcGVuZGVudCBpc2xhbmRzXG4gKlxuICogQGNsYXNzIElzbGFuZE1hbmFnZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGV4dGVuZHMgU29sdmVyXG4gKi9cbmZ1bmN0aW9uIElzbGFuZE1hbmFnZXIob3B0aW9ucyl7XG5cbiAgICAvLyBQb29saW5nIG9mIG5vZGUgb2JqZWN0cyBzYXZlcyBzb21lIEdDIGxvYWRcbiAgICB0aGlzLl9ub2RlUG9vbCA9IFtdO1xuICAgIHRoaXMuX2lzbGFuZFBvb2wgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlcXVhdGlvbnMgdG8gc3BsaXQuIE1hbnVhbGx5IGZpbGwgdGhpcyBhcnJheSBiZWZvcmUgcnVubmluZyAuc3BsaXQoKS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBlcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyB7eyNjcm9zc0xpbmsgXCJJc2xhbmRcIn19e3svY3Jvc3NMaW5rfX1zLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGlzbGFuZHNcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcgZ3JhcGggbm9kZXMuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbm9kZXNcbiAgICAgKi9cbiAgICB0aGlzLm5vZGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbm9kZSBxdWV1ZSwgdXNlZCB3aGVuIHRyYXZlcnNpbmcgdGhlIGdyYXBoIG9mIG5vZGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gcXVldWVcbiAgICAgKi9cbiAgICB0aGlzLnF1ZXVlID0gW107XG59XG5cbi8qKlxuICogR2V0IGFuIHVudmlzaXRlZCBub2RlIGZyb20gYSBsaXN0IG9mIG5vZGVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRVbnZpc2l0ZWROb2RlXG4gKiBAcGFyYW0gIHtBcnJheX0gbm9kZXNcbiAqIEByZXR1cm4ge0lzbGFuZE5vZGV8Ym9vbGVhbn0gVGhlIG5vZGUgaWYgZm91bmQsIGVsc2UgZmFsc2UuXG4gKi9cbklzbGFuZE1hbmFnZXIuZ2V0VW52aXNpdGVkTm9kZSA9IGZ1bmN0aW9uKG5vZGVzKXtcbiAgICB2YXIgTm5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09Tm5vZGVzOyBpKyspe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZighbm9kZS52aXNpdGVkICYmIG5vZGUuYm9keS50eXBlID09PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBWaXNpdCBhIG5vZGUuXG4gKiBAbWV0aG9kIHZpc2l0XG4gKiBAcGFyYW0gIHtJc2xhbmROb2RlfSBub2RlXG4gKiBAcGFyYW0gIHtBcnJheX0gYmRzXG4gKiBAcGFyYW0gIHtBcnJheX0gZXFzXG4gKi9cbklzbGFuZE1hbmFnZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUsYmRzLGVxcyl7XG4gICAgYmRzLnB1c2gobm9kZS5ib2R5KTtcbiAgICB2YXIgTmVxcyA9IG5vZGUuZXF1YXRpb25zLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5lcXM7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IG5vZGUuZXF1YXRpb25zW2ldO1xuICAgICAgICBpZihlcXMuaW5kZXhPZihlcSkgPT09IC0xKXsgLy8gQWxyZWFkeSBhZGRlZD9cbiAgICAgICAgICAgIGVxcy5wdXNoKGVxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUnVucyB0aGUgc2VhcmNoIGFsZ29yaXRobSwgc3RhcnRpbmcgYXQgYSByb290IG5vZGUuIFRoZSByZXN1bHRpbmcgYm9kaWVzIGFuZCBlcXVhdGlvbnMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIHByb3ZpZGVkIGFycmF5cy5cbiAqIEBtZXRob2QgYmZzXG4gKiBAcGFyYW0gIHtJc2xhbmROb2RlfSByb290IFRoZSBub2RlIHRvIHN0YXJ0IGZyb21cbiAqIEBwYXJhbSAge0FycmF5fSBiZHMgIEFuIGFycmF5IHRvIGFwcGVuZCByZXN1bHRpbmcgQm9kaWVzIHRvLlxuICogQHBhcmFtICB7QXJyYXl9IGVxcyAgQW4gYXJyYXkgdG8gYXBwZW5kIHJlc3VsdGluZyBFcXVhdGlvbnMgdG8uXG4gKi9cbklzbGFuZE1hbmFnZXIucHJvdG90eXBlLmJmcyA9IGZ1bmN0aW9uKHJvb3QsYmRzLGVxcyl7XG5cbiAgICAvLyBSZXNldCB0aGUgdmlzaXQgcXVldWVcbiAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlO1xuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBBZGQgcm9vdCBub2RlIHRvIHF1ZXVlXG4gICAgcXVldWUucHVzaChyb290KTtcbiAgICByb290LnZpc2l0ZWQgPSB0cnVlO1xuICAgIHRoaXMudmlzaXQocm9vdCxiZHMsZXFzKTtcblxuICAgIC8vIFByb2Nlc3MgYWxsIHF1ZXVlZCBub2Rlc1xuICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCkge1xuXG4gICAgICAgIC8vIEdldCBuZXh0IG5vZGUgaW4gdGhlIHF1ZXVlXG4gICAgICAgIHZhciBub2RlID0gcXVldWUucG9wKCk7XG5cbiAgICAgICAgLy8gVmlzaXQgdW52aXNpdGVkIG5laWdoYm9yaW5nIG5vZGVzXG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgd2hpbGUoKGNoaWxkID0gSXNsYW5kTWFuYWdlci5nZXRVbnZpc2l0ZWROb2RlKG5vZGUubmVpZ2hib3JzKSkpIHtcbiAgICAgICAgICAgIGNoaWxkLnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52aXNpdChjaGlsZCxiZHMsZXFzKTtcblxuICAgICAgICAgICAgLy8gT25seSB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlIGlmIGl0J3MgZHluYW1pY1xuICAgICAgICAgICAgaWYoY2hpbGQuYm9keS50eXBlID09PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBTcGxpdCB0aGUgd29ybGQgaW50byBpbmRlcGVuZGVudCBpc2xhbmRzLiBUaGUgcmVzdWx0IGlzIHN0b3JlZCBpbiAuaXNsYW5kcy5cbiAqIEBtZXRob2Qgc3BsaXRcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHJldHVybiB7QXJyYXl9IFRoZSBnZW5lcmF0ZWQgaXNsYW5kc1xuICovXG5Jc2xhbmRNYW5hZ2VyLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICBub2RlcyA9IHRoaXMubm9kZXMsXG4gICAgICAgIGVxdWF0aW9ucyA9IHRoaXMuZXF1YXRpb25zO1xuXG4gICAgLy8gTW92ZSBvbGQgbm9kZXMgdG8gdGhlIG5vZGUgcG9vbFxuICAgIHdoaWxlKG5vZGVzLmxlbmd0aCl7XG4gICAgICAgIHRoaXMuX25vZGVQb29sLnB1c2gobm9kZXMucG9wKCkpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZWVkZWQgbm9kZXMsIHJldXNlIGlmIHBvc3NpYmxlXG4gICAgZm9yKHZhciBpPTA7IGkhPT1ib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZih0aGlzLl9ub2RlUG9vbC5sZW5ndGgpe1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlUG9vbC5wb3AoKTtcbiAgICAgICAgICAgIG5vZGUucmVzZXQoKTtcbiAgICAgICAgICAgIG5vZGUuYm9keSA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBJc2xhbmROb2RlKGJvZGllc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGNvbm5lY3Rpdml0eSBkYXRhLiBFYWNoIGVxdWF0aW9uIGNvbm5lY3RzIDIgYm9kaWVzLlxuICAgIGZvcih2YXIgaz0wOyBrIT09ZXF1YXRpb25zLmxlbmd0aDsgaysrKXtcbiAgICAgICAgdmFyIGVxPWVxdWF0aW9uc1trXSxcbiAgICAgICAgICAgIGk9Ym9kaWVzLmluZGV4T2YoZXEuYm9keUEpLFxuICAgICAgICAgICAgaj1ib2RpZXMuaW5kZXhPZihlcS5ib2R5QiksXG4gICAgICAgICAgICBuaT1ub2Rlc1tpXSxcbiAgICAgICAgICAgIG5qPW5vZGVzW2pdO1xuICAgICAgICBuaS5uZWlnaGJvcnMucHVzaChuaik7XG4gICAgICAgIG5qLm5laWdoYm9ycy5wdXNoKG5pKTtcbiAgICAgICAgbmkuZXF1YXRpb25zLnB1c2goZXEpO1xuICAgICAgICBuai5lcXVhdGlvbnMucHVzaChlcSk7XG4gICAgfVxuXG4gICAgLy8gTW92ZSBvbGQgaXNsYW5kcyB0byB0aGUgaXNsYW5kIHBvb2xcbiAgICB2YXIgaXNsYW5kcyA9IHRoaXMuaXNsYW5kcztcbiAgICB3aGlsZShpc2xhbmRzLmxlbmd0aCl7XG4gICAgICAgIHZhciBpc2xhbmQgPSBpc2xhbmRzLnBvcCgpO1xuICAgICAgICBpc2xhbmQucmVzZXQoKTtcbiAgICAgICAgdGhpcy5faXNsYW5kUG9vbC5wdXNoKGlzbGFuZCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGlzbGFuZHNcbiAgICB2YXIgY2hpbGQ7XG4gICAgd2hpbGUoKGNoaWxkID0gSXNsYW5kTWFuYWdlci5nZXRVbnZpc2l0ZWROb2RlKG5vZGVzKSkpe1xuXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaXNsYW5kXG4gICAgICAgIHZhciBpc2xhbmQgPSB0aGlzLl9pc2xhbmRQb29sLmxlbmd0aCA/IHRoaXMuX2lzbGFuZFBvb2wucG9wKCkgOiBuZXcgSXNsYW5kKCk7XG5cbiAgICAgICAgLy8gR2V0IGFsbCBlcXVhdGlvbnMgYW5kIGJvZGllcyBpbiB0aGlzIGlzbGFuZFxuICAgICAgICB0aGlzLmJmcyhjaGlsZCwgaXNsYW5kLmJvZGllcywgaXNsYW5kLmVxdWF0aW9ucyk7XG5cbiAgICAgICAgaXNsYW5kcy5wdXNoKGlzbGFuZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzbGFuZHM7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzIsXCIuL0lzbGFuZFwiOjUxLFwiLi9Jc2xhbmROb2RlXCI6NTN9XSw1MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IElzbGFuZE5vZGU7XG5cbi8qKlxuICogSG9sZHMgYSBib2R5IGFuZCBrZWVwcyB0cmFjayBvZiBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyBuZWVkZWQgZm9yIGdyYXBoIHRyYXZlcnNhbC5cbiAqIEBjbGFzcyBJc2xhbmROb2RlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5mdW5jdGlvbiBJc2xhbmROb2RlKGJvZHkpe1xuXG5cdC8qKlxuXHQgKiBUaGUgYm9keSB0aGF0IGlzIGNvbnRhaW5lZCBpbiB0aGlzIG5vZGUuXG5cdCAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keVxuXHQgKi9cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgLyoqXG4gICAgICogTmVpZ2hib3JpbmcgSXNsYW5kTm9kZXNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBuZWlnaGJvcnNcbiAgICAgKi9cbiAgICB0aGlzLm5laWdoYm9ycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRXF1YXRpb25zIGNvbm5lY3RlZCB0byB0aGlzIG5vZGUuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZXF1YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgbm9kZSB3YXMgdmlzaXRpbmcgZHVyaW5nIHRoZSBncmFwaCB0cmF2ZXJzYWwuXG4gICAgICogQHByb3BlcnR5IHZpc2l0ZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBDbGVhbiB0aGlzIG5vZGUgZnJvbSBib2RpZXMgYW5kIGVxdWF0aW9ucy5cbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuSXNsYW5kTm9kZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5uZWlnaGJvcnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xufTtcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIHBlcmZvcm1hbmNlICovXG4vKmpzaGludCAtVzAyMCAqL1xuXG52YXIgIEdTU29sdmVyID0gX2RlcmVxXygnLi4vc29sdmVyL0dTU29sdmVyJylcbiwgICAgU29sdmVyID0gX2RlcmVxXygnLi4vc29sdmVyL1NvbHZlcicpXG4sICAgIE5haXZlQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UnKVxuLCAgICBSYXkgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5JylcbiwgICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgIENpcmNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9DaXJjbGUnKVxuLCAgICBSZWN0YW5nbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUmVjdGFuZ2xlJylcbiwgICAgQ29udmV4ID0gX2RlcmVxXygnLi4vc2hhcGVzL0NvbnZleCcpXG4sICAgIExpbmUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvTGluZScpXG4sICAgIFBsYW5lID0gX2RlcmVxXygnLi4vc2hhcGVzL1BsYW5lJylcbiwgICAgQ2Fwc3VsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9DYXBzdWxlJylcbiwgICAgUGFydGljbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGFydGljbGUnKVxuLCAgICBFdmVudEVtaXR0ZXIgPSBfZGVyZXFfKCcuLi9ldmVudHMvRXZlbnRFbWl0dGVyJylcbiwgICAgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpXG4sICAgIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJylcbiwgICAgTGluZWFyU3ByaW5nID0gX2RlcmVxXygnLi4vb2JqZWN0cy9MaW5lYXJTcHJpbmcnKVxuLCAgICBNYXRlcmlhbCA9IF9kZXJlcV8oJy4uL21hdGVyaWFsL01hdGVyaWFsJylcbiwgICAgQ29udGFjdE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJylcbiwgICAgRGlzdGFuY2VDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50JylcbiwgICAgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKVxuLCAgICBMb2NrQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JylcbiwgICAgUmV2b2x1dGVDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvUmV2b2x1dGVDb25zdHJhaW50JylcbiwgICAgUHJpc21hdGljQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnQnKVxuLCAgICBHZWFyQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0dlYXJDb25zdHJhaW50JylcbiwgICAgcGtnID0gX2RlcmVxXygnLi4vLi4vcGFja2FnZS5qc29uJylcbiwgICAgQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJylcbiwgICAgU0FQQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlJylcbiwgICAgTmFycm93cGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vTmFycm93cGhhc2UnKVxuLCAgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICAgT3ZlcmxhcEtlZXBlciA9IF9kZXJlcV8oJy4uL3V0aWxzL092ZXJsYXBLZWVwZXInKVxuLCAgICBJc2xhbmRNYW5hZ2VyID0gX2RlcmVxXygnLi9Jc2xhbmRNYW5hZ2VyJylcbiwgICAgUm90YXRpb25hbFNwcmluZyA9IF9kZXJlcV8oJy4uL29iamVjdHMvUm90YXRpb25hbFNwcmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkO1xuXG5pZih0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnKXtcbiAgICBwZXJmb3JtYW5jZSA9IHt9O1xufVxuaWYoIXBlcmZvcm1hbmNlLm5vdyl7XG4gICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XG4gICAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KXtcbiAgICAgICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgICB9XG4gICAgcGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBub3dPZmZzZXQ7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgZHluYW1pY3Mgd29ybGQsIHdoZXJlIGFsbCBib2RpZXMgYW5kIGNvbnN0cmFpbnRzIGxpdmVzLlxuICpcbiAqIEBjbGFzcyBXb3JsZFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge1NvbHZlcn0gICAgICAgICAgW29wdGlvbnMuc29sdmVyXSAgICAgICAgICAgIERlZmF1bHRzIHRvIEdTU29sdmVyLlxuICogQHBhcmFtIHtBcnJheX0gICAgICAgICAgIFtvcHRpb25zLmdyYXZpdHldICAgICAgICAgICBEZWZhdWx0cyB0byBbMCwtOS43OF1cbiAqIEBwYXJhbSB7QnJvYWRwaGFzZX0gICAgICBbb3B0aW9ucy5icm9hZHBoYXNlXSAgICAgICAgRGVmYXVsdHMgdG8gTmFpdmVCcm9hZHBoYXNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuaXNsYW5kU3BsaXQ9ZmFsc2VdXG4gKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuZG9Qcm9maWxpbmc9ZmFsc2VdXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCh7XG4gKiAgICAgICAgIGdyYXZpdHk6IFswLCAtOS44MV0sXG4gKiAgICAgICAgIGJyb2FkcGhhc2U6IG5ldyBTQVBCcm9hZHBoYXNlKClcbiAqICAgICB9KTtcbiAqL1xuZnVuY3Rpb24gV29ybGQob3B0aW9ucyl7XG4gICAgRXZlbnRFbWl0dGVyLmFwcGx5KHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBBbGwgc3ByaW5ncyBpbiB0aGUgd29ybGQuIFRvIGFkZCBhIHNwcmluZyB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRTcHJpbmc6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNwcmluZ3NcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zcHJpbmdzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBbGwgYm9kaWVzIGluIHRoZSB3b3JsZC4gVG8gYWRkIGEgYm9keSB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRCb2R5Om1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBib2RpZXNcbiAgICAgKi9cbiAgICB0aGlzLmJvZGllcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZWQgYm9keSBjb2xsaXNpb24gcGFpcnMuIFNlZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9kaXNhYmxlQm9keUNvbGxpc2lvbjptZXRob2RcIn19LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnNcbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc29sdmVyIHVzZWQgdG8gc2F0aXNmeSBjb25zdHJhaW50cyBhbmQgY29udGFjdHMuIERlZmF1bHQgaXMge3sjY3Jvc3NMaW5rIFwiR1NTb2x2ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtTb2x2ZXJ9IHNvbHZlclxuICAgICAqL1xuICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgfHwgbmV3IEdTU29sdmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFycm93cGhhc2UgdG8gdXNlIHRvIGdlbmVyYXRlIGNvbnRhY3RzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG5hcnJvd3BoYXNlXG4gICAgICogQHR5cGUge05hcnJvd3BoYXNlfVxuICAgICAqL1xuICAgIHRoaXMubmFycm93cGhhc2UgPSBuZXcgTmFycm93cGhhc2UodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaXNsYW5kIG1hbmFnZXIgb2YgdGhpcyB3b3JsZC5cbiAgICAgKiBAcHJvcGVydHkge0lzbGFuZE1hbmFnZXJ9IGlzbGFuZE1hbmFnZXJcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZE1hbmFnZXIgPSBuZXcgSXNsYW5kTWFuYWdlcigpO1xuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSBpbiB0aGUgd29ybGQuIFRoaXMgaXMgYXBwbGllZCBvbiBhbGwgYm9kaWVzIGluIHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBzdGVwKCkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZ3Jhdml0eVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmdyYXZpdHkgPSB2ZWMyLmZyb21WYWx1ZXMoMCwgLTkuNzgpO1xuICAgIGlmKG9wdGlvbnMuZ3Jhdml0eSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmdyYXZpdHksIG9wdGlvbnMuZ3Jhdml0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIHRoZSBmcmljdGlvbiBtYXggZm9yY2UgKG11Km1hc3MqZ3Jhdml0eSkuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uR3Jhdml0eVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25HcmF2aXR5ID0gdmVjMi5sZW5ndGgodGhpcy5ncmF2aXR5KSB8fCAxMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IC5mcmljdGlvbkdyYXZpdHkgdG8gYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIGxlbmd0aCBvZiAuZ3Jhdml0eS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5XG4gICAgICovXG4gICAgdGhpcy51c2VXb3JsZEdyYXZpdHlBc0ZyaWN0aW9uR3Jhdml0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbGVuZ3RoIG9mIC5ncmF2aXR5IGlzIHplcm8sIGFuZCAudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHk9dHJ1ZSwgdGhlbiBzd2l0Y2ggdG8gdXNpbmcgLmZyaWN0aW9uR3Jhdml0eSBmb3IgZnJpY3Rpb24gaW5zdGVhZC4gVGhpcyBmYWxsYmFjayBpcyB1c2VmdWwgZm9yIGdyYXZpdHlsZXNzIGdhbWVzLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdXNlRnJpY3Rpb25HcmF2aXR5T25aZXJvR3Jhdml0eVxuICAgICAqL1xuICAgIHRoaXMudXNlRnJpY3Rpb25HcmF2aXR5T25aZXJvR3Jhdml0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGRvIHRpbWluZyBtZWFzdXJlbWVudHMgZHVyaW5nIHRoZSBzdGVwKCkgb3Igbm90LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGRvUG9maWxpbmdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRvUHJvZmlsaW5nID0gb3B0aW9ucy5kb1Byb2ZpbGluZyB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEhvdyBtYW55IG1pbGxpc2VjY29uZHMgdGhlIGxhc3Qgc3RlcCgpIHRvb2suIFRoaXMgaXMgdXBkYXRlZCBlYWNoIHN0ZXAgaWYgLmRvUHJvZmlsaW5nIGlzIHNldCB0byB0cnVlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxhc3RTdGVwVGltZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0U3RlcFRpbWUgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYnJvYWRwaGFzZSBhbGdvcml0aG0gdG8gdXNlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJyb2FkcGhhc2VcbiAgICAgKiBAdHlwZSB7QnJvYWRwaGFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJyb2FkcGhhc2UgPSBvcHRpb25zLmJyb2FkcGhhc2UgfHwgbmV3IFNBUEJyb2FkcGhhc2UoKTtcbiAgICB0aGlzLmJyb2FkcGhhc2Uuc2V0V29ybGQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VyLWFkZGVkIGNvbnN0cmFpbnRzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIER1bW15IGRlZmF1bHQgbWF0ZXJpYWwgaW4gdGhlIHdvcmxkLCB1c2VkIGluIC5kZWZhdWx0Q29udGFjdE1hdGVyaWFsXG4gICAgICogQHByb3BlcnR5IHtNYXRlcmlhbH0gZGVmYXVsdE1hdGVyaWFsXG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGNvbnRhY3QgbWF0ZXJpYWwgdG8gdXNlLCBpZiBubyBjb250YWN0IG1hdGVyaWFsIHdhcyBzZXQgZm9yIHRoZSBjb2xsaWRpbmcgbWF0ZXJpYWxzLlxuICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdE1hdGVyaWFsfSBkZWZhdWx0Q29udGFjdE1hdGVyaWFsXG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsID0gbmV3IENvbnRhY3RNYXRlcmlhbCh0aGlzLmRlZmF1bHRNYXRlcmlhbCx0aGlzLmRlZmF1bHRNYXRlcmlhbCk7XG5cbiAgICAvKipcbiAgICAgKiBGb3Iga2VlcGluZyB0cmFjayBvZiB3aGF0IHRpbWUgc3RlcCBzaXplIHdlIHVzZWQgbGFzdCBzdGVwXG4gICAgICogQHByb3BlcnR5IGxhc3RUaW1lU3RlcFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0VGltZVN0ZXAgPSAxLzYwO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgc3ByaW5nIGZvcmNlcyBlYWNoIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IGFwcGx5U3ByaW5nRm9yY2VzXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hcHBseVNwcmluZ0ZvcmNlcyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBib2R5IGRhbXBpbmcgZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBhcHBseURhbXBpbmdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5RGFtcGluZyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBncmF2aXR5IGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgYXBwbHlHcmF2aXR5XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hcHBseUdyYXZpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlL2Rpc2FibGUgY29uc3RyYWludCBzb2x2aW5nIGluIGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgc29sdmVDb25zdHJhaW50c1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc29sdmVDb25zdHJhaW50cyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQ29udGFjdE1hdGVyaWFscyBhZGRlZCB0byB0aGUgV29ybGQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RNYXRlcmlhbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZCB0aW1lLlxuICAgICAqIEBwcm9wZXJ0eSB0aW1lXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWUgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0cnVlIGR1cmluZyB0aGUgc3RlcCgpLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc3RlcHBpbmdcbiAgICAgKi9cbiAgICB0aGlzLnN0ZXBwaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBCb2RpZXMgdGhhdCBhcmUgc2NoZWR1bGVkIHRvIGJlIHJlbW92ZWQgYXQgdGhlIGVuZCBvZiB0aGUgc3RlcC5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBib2RpZXNUb0JlUmVtb3ZlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5ib2RpZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgdGhpcy5maXhlZFN0ZXBUaW1lID0gMC4wO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBlbmFibGUgaXNsYW5kIHNwbGl0dGluZy4gSXNsYW5kIHNwbGl0dGluZyBjYW4gYmUgYW4gYWR2YW50YWdlIGZvciBtYW55IHRoaW5ncywgaW5jbHVkaW5nIHNvbHZlciBwZXJmb3JtYW5jZS4gU2VlIHt7I2Nyb3NzTGluayBcIklzbGFuZE1hbmFnZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc2xhbmRTcGxpdFxuICAgICAqL1xuICAgIHRoaXMuaXNsYW5kU3BsaXQgPSB0eXBlb2Yob3B0aW9ucy5pc2xhbmRTcGxpdCkhPT1cInVuZGVmaW5lZFwiID8gISFvcHRpb25zLmlzbGFuZFNwbGl0IDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byB0aGUgd29ybGQgdG8gZW1pdCB0aGUgXCJpbXBhY3RcIiBldmVudC4gVHVybmluZyB0aGlzIG9mZiBjb3VsZCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIEBwcm9wZXJ0eSBlbWl0SW1wYWN0RXZlbnRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVtaXRJbXBhY3RFdmVudCA9IHRydWU7XG5cbiAgICAvLyBJZCBjb3VudGVyc1xuICAgIHRoaXMuX2NvbnN0cmFpbnRJZENvdW50ZXIgPSAwO1xuICAgIHRoaXMuX2JvZHlJZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgYWZ0ZXIgdGhlIHN0ZXAoKS5cbiAgICAgKiBAZXZlbnQgcG9zdFN0ZXBcbiAgICAgKi9cbiAgICB0aGlzLnBvc3RTdGVwRXZlbnQgPSB7XG4gICAgICAgIHR5cGUgOiBcInBvc3RTdGVwXCIsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkQm9keVxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICAgICAqL1xuICAgIHRoaXMuYWRkQm9keUV2ZW50ID0ge1xuICAgICAgICB0eXBlIDogXCJhZGRCb2R5XCIsXG4gICAgICAgIGJvZHkgOiBudWxsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIHJlbW92ZWQgZnJvbSB0aGUgd29ybGQuXG4gICAgICogQGV2ZW50IHJlbW92ZUJvZHlcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAgICAgKi9cbiAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHtcbiAgICAgICAgdHlwZSA6IFwicmVtb3ZlQm9keVwiLFxuICAgICAgICBib2R5IDogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgc3ByaW5nIGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkU3ByaW5nXG4gICAgICogQHBhcmFtIHtTcHJpbmd9IHNwcmluZ1xuICAgICAqL1xuICAgIHRoaXMuYWRkU3ByaW5nRXZlbnQgPSB7XG4gICAgICAgIHR5cGUgOiBcImFkZFNwcmluZ1wiLFxuICAgICAgICBzcHJpbmcgOiBudWxsLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgZmlyc3QgY29udGFjdCBpcyBjcmVhdGVkIGJldHdlZW4gdHdvIGJvZGllcy4gVGhpcyBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgc3RlcCBoYXMgYmVlbiBkb25lLlxuICAgICAqIEBldmVudCBpbXBhY3RcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICAgICAqL1xuICAgIHRoaXMuaW1wYWN0RXZlbnQgPSB7XG4gICAgICAgIHR5cGU6IFwiaW1wYWN0XCIsXG4gICAgICAgIGJvZHlBIDogbnVsbCxcbiAgICAgICAgYm9keUIgOiBudWxsLFxuICAgICAgICBzaGFwZUEgOiBudWxsLFxuICAgICAgICBzaGFwZUIgOiBudWxsLFxuICAgICAgICBjb250YWN0RXF1YXRpb24gOiBudWxsLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBhZnRlciB0aGUgQnJvYWRwaGFzZSBoYXMgY29sbGVjdGVkIGNvbGxpc2lvbiBwYWlycyBpbiB0aGUgd29ybGQuXG4gICAgICogSW5zaWRlIHRoZSBldmVudCBoYW5kbGVyLCB5b3UgY2FuIG1vZGlmeSB0aGUgcGFpcnMgYXJyYXkgYXMgeW91IGxpa2UsIHRvXG4gICAgICogcHJldmVudCBjb2xsaXNpb25zIGJldHdlZW4gb2JqZWN0cyB0aGF0IHlvdSBkb24ndCB3YW50LlxuICAgICAqIEBldmVudCBwb3N0QnJvYWRwaGFzZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIEFuIGFycmF5IG9mIGNvbGxpc2lvbiBwYWlycy4gSWYgdGhpcyBhcnJheSBpcyBbYm9keTEsYm9keTIsYm9keTMsYm9keTRdLCB0aGVuIHRoZSBib2R5IHBhaXJzIDEsMiBhbmQgMyw0IHdvdWxkIGFkdmFuY2UgdG8gbmFycm93cGhhc2UuXG4gICAgICovXG4gICAgdGhpcy5wb3N0QnJvYWRwaGFzZUV2ZW50ID0ge1xuICAgICAgICB0eXBlOlwicG9zdEJyb2FkcGhhc2VcIixcbiAgICAgICAgcGFpcnM6bnVsbCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSG93IHRvIGRlYWN0aXZhdGUgYm9kaWVzIGR1cmluZyBzaW11bGF0aW9uLiBQb3NzaWJsZSBtb2RlcyBhcmU6IHt7I2Nyb3NzTGluayBcIldvcmxkL05PX1NMRUVQSU5HOnByb3BlcnR5XCJ9fVdvcmxkLk5PX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIldvcmxkL0JPRFlfU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuQk9EWV9TTEVFUElOR3t7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJXb3JsZC9JU0xBTkRfU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuSVNMQU5EX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0uXG4gICAgICogSWYgc2xlZXBpbmcgaXMgZW5hYmxlZCwgeW91IG1pZ2h0IG5lZWQgdG8ge3sjY3Jvc3NMaW5rIFwiQm9keS93YWtlVXA6bWV0aG9kXCJ9fXdha2UgdXB7ey9jcm9zc0xpbmt9fSB0aGUgYm9kaWVzIGlmIHRoZXkgZmFsbCBhc2xlZXAgd2hlbiB0aGV5IHNob3VsZG4ndC4gSWYgeW91IHdhbnQgdG8gZW5hYmxlIHNsZWVwaW5nIGluIHRoZSB3b3JsZCwgYnV0IHdhbnQgdG8gZGlzYWJsZSBpdCBmb3IgYSBwYXJ0aWN1bGFyIGJvZHksIHNlZSB7eyNjcm9zc0xpbmsgXCJCb2R5L2FsbG93U2xlZXA6cHJvcGVydHlcIn19Qm9keS5hbGxvd1NsZWVwe3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHNsZWVwTW9kZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgV29ybGQuTk9fU0xFRVBJTkdcbiAgICAgKi9cbiAgICB0aGlzLnNsZWVwTW9kZSA9IFdvcmxkLk5PX1NMRUVQSU5HO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0d28gc2hhcGVzIHN0YXJ0cyBzdGFydCB0byBvdmVybGFwLiBGaXJlZCBpbiB0aGUgbmFycm93cGhhc2UsIGR1cmluZyBzdGVwLlxuICAgICAqIEBldmVudCBiZWdpbkNvbnRhY3RcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUFcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUJcbiAgICAgKiBAcGFyYW0ge0JvZHl9ICBib2R5QVxuICAgICAqIEBwYXJhbSB7Qm9keX0gIGJvZHlCXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29udGFjdEVxdWF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuYmVnaW5Db250YWN0RXZlbnQgPSB7XG4gICAgICAgIHR5cGU6XCJiZWdpbkNvbnRhY3RcIixcbiAgICAgICAgc2hhcGVBIDogbnVsbCxcbiAgICAgICAgc2hhcGVCIDogbnVsbCxcbiAgICAgICAgYm9keUEgOiBudWxsLFxuICAgICAgICBib2R5QiA6IG51bGwsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvbnMgOiBbXSxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0d28gc2hhcGVzIHN0b3Agb3ZlcmxhcHBpbmcsIGFmdGVyIHRoZSBuYXJyb3dwaGFzZSAoZHVyaW5nIHN0ZXApLlxuICAgICAqIEBldmVudCBlbmRDb250YWN0XG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVBXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gICAgICogQHBhcmFtIHtCb2R5fSAgYm9keUFcbiAgICAgKiBAcGFyYW0ge0JvZHl9ICBib2R5QlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnRhY3RFcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmVuZENvbnRhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTpcImVuZENvbnRhY3RcIixcbiAgICAgICAgc2hhcGVBIDogbnVsbCxcbiAgICAgICAgc2hhcGVCIDogbnVsbCxcbiAgICAgICAgYm9keUEgOiBudWxsLFxuICAgICAgICBib2R5QiA6IG51bGwsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGVxdWF0aW9ucyBhcmUgYWRkZWQgdG8gdGhlIHNvbHZlciB0byBiZSBzb2x2ZWQuIENhbiBiZSB1c2VkIHRvIGNvbnRyb2wgd2hhdCBlcXVhdGlvbnMgZ29lcyBpbnRvIHRoZSBzb2x2ZXIuXG4gICAgICogQGV2ZW50IHByZVNvbHZlXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29udGFjdEVxdWF0aW9ucyAgQW4gYXJyYXkgb2YgY29udGFjdHMgdG8gYmUgc29sdmVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZyaWN0aW9uRXF1YXRpb25zIEFuIGFycmF5IG9mIGZyaWN0aW9uIGVxdWF0aW9ucyB0byBiZSBzb2x2ZWQuXG4gICAgICovXG4gICAgdGhpcy5wcmVTb2x2ZUV2ZW50ID0ge1xuICAgICAgICB0eXBlOlwicHJlU29sdmVcIixcbiAgICAgICAgY29udGFjdEVxdWF0aW9uczpudWxsLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uczpudWxsLFxuICAgIH07XG5cbiAgICAvLyBGb3Iga2VlcGluZyB0cmFjayBvZiBvdmVybGFwcGluZyBzaGFwZXNcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlID0geyBrZXlzOltdIH07XG4gICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZSA9IHsga2V5czpbXSB9O1xuXG4gICAgdGhpcy5vdmVybGFwS2VlcGVyID0gbmV3IE92ZXJsYXBLZWVwZXIoKTtcbn1cbldvcmxkLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5Xb3JsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXb3JsZDtcblxuLyoqXG4gKiBOZXZlciBkZWFjdGl2YXRlIGJvZGllcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT19TTEVFUElOR1xuICovXG5Xb3JsZC5OT19TTEVFUElORyA9IDE7XG5cbi8qKlxuICogRGVhY3RpdmF0ZSBpbmRpdmlkdWFsIGJvZGllcyBpZiB0aGV5IGFyZSBzbGVlcHkuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gQk9EWV9TTEVFUElOR1xuICovXG5Xb3JsZC5CT0RZX1NMRUVQSU5HID0gMjtcblxuLyoqXG4gKiBEZWFjdGl2YXRlcyBib2RpZXMgdGhhdCBhcmUgaW4gY29udGFjdCwgaWYgYWxsIG9mIHRoZW0gYXJlIHNsZWVweS4gTm90ZSB0aGF0IHlvdSBtdXN0IGVuYWJsZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9pc2xhbmRTcGxpdDpwcm9wZXJ0eVwifX0uaXNsYW5kU3BsaXR7ey9jcm9zc0xpbmt9fSBmb3IgdGhpcyB0byB3b3JrLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IElTTEFORF9TTEVFUElOR1xuICovXG5Xb3JsZC5JU0xBTkRfU0xFRVBJTkcgPSA0O1xuXG4vKipcbiAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHNpbXVsYXRpb24uXG4gKlxuICogQG1ldGhvZCBhZGRDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZENvbnN0cmFpbnQgPSBmdW5jdGlvbihjKXtcbiAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goYyk7XG59O1xuXG4vKipcbiAqIEFkZCBhIENvbnRhY3RNYXRlcmlhbCB0byB0aGUgc2ltdWxhdGlvbi5cbiAqIEBtZXRob2QgYWRkQ29udGFjdE1hdGVyaWFsXG4gKiBAcGFyYW0ge0NvbnRhY3RNYXRlcmlhbH0gY29udGFjdE1hdGVyaWFsXG4gKi9cbldvcmxkLnByb3RvdHlwZS5hZGRDb250YWN0TWF0ZXJpYWwgPSBmdW5jdGlvbihjb250YWN0TWF0ZXJpYWwpe1xuICAgIHRoaXMuY29udGFjdE1hdGVyaWFscy5wdXNoKGNvbnRhY3RNYXRlcmlhbCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjb250YWN0IG1hdGVyaWFsXG4gKlxuICogQG1ldGhvZCByZW1vdmVDb250YWN0TWF0ZXJpYWxcbiAqIEBwYXJhbSB7Q29udGFjdE1hdGVyaWFsfSBjbVxuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQ29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24oY20pe1xuICAgIHZhciBpZHggPSB0aGlzLmNvbnRhY3RNYXRlcmlhbHMuaW5kZXhPZihjbSk7XG4gICAgaWYoaWR4IT09LTEpe1xuICAgICAgICBVdGlscy5zcGxpY2UodGhpcy5jb250YWN0TWF0ZXJpYWxzLGlkeCwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGNvbnRhY3QgbWF0ZXJpYWwgZ2l2ZW4gdHdvIG1hdGVyaWFsc1xuICogQG1ldGhvZCBnZXRDb250YWN0TWF0ZXJpYWxcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQVxuICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxCXG4gKiBAcmV0dXJuIHtDb250YWN0TWF0ZXJpYWx9IFRoZSBtYXRjaGluZyBDb250YWN0TWF0ZXJpYWwsIG9yIGZhbHNlIG9uIGZhaWwuXG4gKiBAdG9kbyBVc2UgZmFzdGVyIGhhc2ggbWFwIHRvIGxvb2t1cCBmcm9tIG1hdGVyaWFsIGlkJ3NcbiAqL1xuV29ybGQucHJvdG90eXBlLmdldENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKG1hdGVyaWFsQSxtYXRlcmlhbEIpe1xuICAgIHZhciBjbWF0cyA9IHRoaXMuY29udGFjdE1hdGVyaWFscztcbiAgICBmb3IodmFyIGk9MCwgTj1jbWF0cy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgY20gPSBjbWF0c1tpXTtcbiAgICAgICAgaWYoIChjbS5tYXRlcmlhbEEuaWQgPT09IG1hdGVyaWFsQS5pZCkgJiYgKGNtLm1hdGVyaWFsQi5pZCA9PT0gbWF0ZXJpYWxCLmlkKSB8fFxuICAgICAgICAgICAgKGNtLm1hdGVyaWFsQS5pZCA9PT0gbWF0ZXJpYWxCLmlkKSAmJiAoY20ubWF0ZXJpYWxCLmlkID09PSBtYXRlcmlhbEEuaWQpICl7XG4gICAgICAgICAgICByZXR1cm4gY207XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgY29uc3RyYWludFxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQ29uc3RyYWludFxuICogQHBhcmFtIHtDb25zdHJhaW50fSBjXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24oYyl7XG4gICAgdmFyIGlkeCA9IHRoaXMuY29uc3RyYWludHMuaW5kZXhPZihjKTtcbiAgICBpZihpZHghPT0tMSl7XG4gICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLmNvbnN0cmFpbnRzLGlkeCwxKTtcbiAgICB9XG59O1xuXG52YXIgc3RlcF9yID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX3J1bml0ID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX3UgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfZiA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF9maE1pbnYgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfdmVsb2R0ID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX21nID0gdmVjMi5jcmVhdGUoKSxcbiAgICB4aXcgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICB4ancgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICB6ZXJvID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgaW50ZXJwdmVsbyA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIFN0ZXAgdGhlIHBoeXNpY3Mgd29ybGQgZm9yd2FyZCBpbiB0aW1lLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gbW9kZXMuIFRoZSBzaW1wbGUgbW9kZSBpcyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uLiBJbiB0aGlzIGNhc2UgeW91IG9ubHkgdXNlIHRoZSBmaXJzdCBhcmd1bWVudC4gVGhlIHNlY29uZCBjYXNlIHVzZXMgaW50ZXJwb2xhdGlvbi4gSW4gdGhhdCB5b3UgYWxzbyBwcm92aWRlIHRoZSB0aW1lIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCB1c2VkLCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIGZpeGVkIHRpbWVzdGVwcyB0byB0YWtlLlxuICpcbiAqIEBtZXRob2Qgc3RlcFxuICogQHBhcmFtIHtOdW1iZXJ9IGR0ICAgICAgICAgICAgICAgICAgICAgICBUaGUgZml4ZWQgdGltZSBzdGVwIHNpemUgdG8gdXNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lU2luY2VMYXN0Q2FsbGVkPTBdICBUaGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCBjYWxsZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gW21heFN1YlN0ZXBzPTEwXSAgICAgICAgIE1heGltdW0gbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHRvIHRha2UgcGVyIGZ1bmN0aW9uIGNhbGwuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uXG4gKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCk7XG4gKiAgICAgd29ybGQuc3RlcCgwLjAxKTtcbiAqXG4gKiBAc2VlIGh0dHA6Ly9idWxsZXRwaHlzaWNzLm9yZy9tZWRpYXdpa2ktMS41LjgvaW5kZXgucGhwL1N0ZXBwaW5nX1RoZV9Xb3JsZFxuICovXG5Xb3JsZC5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKGR0LHRpbWVTaW5jZUxhc3RDYWxsZWQsbWF4U3ViU3RlcHMpe1xuICAgIG1heFN1YlN0ZXBzID0gbWF4U3ViU3RlcHMgfHwgMTA7XG4gICAgdGltZVNpbmNlTGFzdENhbGxlZCA9IHRpbWVTaW5jZUxhc3RDYWxsZWQgfHwgMDtcblxuICAgIGlmKHRpbWVTaW5jZUxhc3RDYWxsZWQgPT09IDApeyAvLyBGaXhlZCwgc2ltcGxlIHN0ZXBwaW5nXG5cbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCB0aW1lXG4gICAgICAgIHRoaXMudGltZSArPSBkdDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHdlIHNob3VsZCBoYXZlIHRha2VuIHNpbmNlIHRoZSBsYXN0IHN0ZXBcbiAgICAgICAgdmFyIGludGVybmFsU3RlcHMgPSBNYXRoLmZsb29yKCAodGhpcy50aW1lK3RpbWVTaW5jZUxhc3RDYWxsZWQpIC8gZHQpIC0gTWF0aC5mbG9vcih0aGlzLnRpbWUgLyBkdCk7XG4gICAgICAgIGludGVybmFsU3RlcHMgPSBNYXRoLm1pbihpbnRlcm5hbFN0ZXBzLG1heFN1YlN0ZXBzKTtcblxuICAgICAgICAvLyBEbyBzb21lIGZpeGVkIHN0ZXBzIHRvIGNhdGNoIHVwXG4gICAgICAgIHZhciB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWludGVybmFsU3RlcHM7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG4gICAgICAgICAgICBpZihwZXJmb3JtYW5jZS5ub3coKSAtIHQwID4gZHQqMTAwMCl7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIHNsb3dlciB0aGFuIHJlYWwtdGltZS4gQmV0dGVyIGJhaWwgb3V0LlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IGludGVybmFsIGNsb2NrXG4gICAgICAgIHRoaXMudGltZSArPSB0aW1lU2luY2VMYXN0Q2FsbGVkO1xuXG4gICAgICAgIC8vIENvbXB1dGUgXCJMZWZ0IG92ZXJcIiB0aW1lIHN0ZXBcbiAgICAgICAgdmFyIGggPSB0aGlzLnRpbWUgJSBkdDtcbiAgICAgICAgdmFyIGhfZGl2X2R0ID0gaC9kdDtcblxuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PXRoaXMuYm9kaWVzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5ib2RpZXNbal07XG4gICAgICAgICAgICBpZihiLnR5cGUgIT09IEJvZHkuU1RBVElDICYmIGIuc2xlZXBTdGF0ZSAhPT0gQm9keS5TTEVFUElORyl7XG4gICAgICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICB2ZWMyLnN1YihpbnRlcnB2ZWxvLCBiLnBvc2l0aW9uLCBiLnByZXZpb3VzUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUoaW50ZXJwdmVsbywgaW50ZXJwdmVsbywgaF9kaXZfZHQpO1xuICAgICAgICAgICAgICAgIHZlYzIuYWRkKGIuaW50ZXJwb2xhdGVkUG9zaXRpb24sIGIucG9zaXRpb24sIGludGVycHZlbG8pO1xuXG4gICAgICAgICAgICAgICAgYi5pbnRlcnBvbGF0ZWRBbmdsZSA9IGIuYW5nbGUgKyAoYi5hbmdsZSAtIGIucHJldmlvdXNBbmdsZSkgKiBoX2Rpdl9kdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHN0YXRpYyBib2RpZXMsIGp1c3QgY29weS4gV2hvIGVsc2Ugd2lsbCBkbyBpdD9cbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoYi5pbnRlcnBvbGF0ZWRQb3NpdGlvbiwgYi5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgYi5pbnRlcnBvbGF0ZWRBbmdsZSA9IGIuYW5nbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZW5kT3ZlcmxhcHMgPSBbXTtcblxuLyoqXG4gKiBNYWtlIGEgZml4ZWQgc3RlcC5cbiAqIEBtZXRob2QgaW50ZXJuYWxTdGVwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGR0XG4gKiBAcHJpdmF0ZVxuICovXG5Xb3JsZC5wcm90b3R5cGUuaW50ZXJuYWxTdGVwID0gZnVuY3Rpb24oZHQpe1xuICAgIHRoaXMuc3RlcHBpbmcgPSB0cnVlO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICBkb1Byb2ZpbGluZyA9IHRoaXMuZG9Qcm9maWxpbmcsXG4gICAgICAgIE5zcHJpbmdzID0gdGhpcy5zcHJpbmdzLmxlbmd0aCxcbiAgICAgICAgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncyxcbiAgICAgICAgYm9kaWVzID0gdGhpcy5ib2RpZXMsXG4gICAgICAgIGcgPSB0aGlzLmdyYXZpdHksXG4gICAgICAgIHNvbHZlciA9IHRoaXMuc29sdmVyLFxuICAgICAgICBOYm9kaWVzID0gdGhpcy5ib2RpZXMubGVuZ3RoLFxuICAgICAgICBicm9hZHBoYXNlID0gdGhpcy5icm9hZHBoYXNlLFxuICAgICAgICBucCA9IHRoaXMubmFycm93cGhhc2UsXG4gICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyxcbiAgICAgICAgdDAsIHQxLFxuICAgICAgICBmaE1pbnYgPSBzdGVwX2ZoTWludixcbiAgICAgICAgdmVsb2R0ID0gc3RlcF92ZWxvZHQsXG4gICAgICAgIG1nID0gc3RlcF9tZyxcbiAgICAgICAgc2NhbGUgPSB2ZWMyLnNjYWxlLFxuICAgICAgICBhZGQgPSB2ZWMyLmFkZCxcbiAgICAgICAgcm90YXRlID0gdmVjMi5yb3RhdGUsXG4gICAgICAgIGlzbGFuZE1hbmFnZXIgPSB0aGlzLmlzbGFuZE1hbmFnZXI7XG5cbiAgICB0aGlzLm92ZXJsYXBLZWVwZXIudGljaygpO1xuXG4gICAgdGhpcy5sYXN0VGltZVN0ZXAgPSBkdDtcblxuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgYXBwcm94aW1hdGUgZnJpY3Rpb24gZ3Jhdml0eS5cbiAgICBpZih0aGlzLnVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5KXtcbiAgICAgICAgdmFyIGdyYXZpdHlMZW4gPSB2ZWMyLmxlbmd0aCh0aGlzLmdyYXZpdHkpO1xuICAgICAgICBpZighKGdyYXZpdHlMZW4gPT09IDAgJiYgdGhpcy51c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5KSl7XG4gICAgICAgICAgICAvLyBOb256ZXJvIGdyYXZpdHkuIFVzZSBpdC5cbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25HcmF2aXR5ID0gZ3Jhdml0eUxlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBncmF2aXR5IHRvIGJvZGllc1xuICAgIGlmKHRoaXMuYXBwbHlHcmF2aXR5KXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgZmkgPSBiLmZvcmNlO1xuICAgICAgICAgICAgaWYoYi50eXBlICE9PSBCb2R5LkRZTkFNSUMgfHwgYi5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlYzIuc2NhbGUobWcsZyxiLm1hc3MqYi5ncmF2aXR5U2NhbGUpOyAvLyBGPW0qZ1xuICAgICAgICAgICAgYWRkKGZpLGZpLG1nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBzcHJpbmcgZm9yY2VzXG4gICAgaWYodGhpcy5hcHBseVNwcmluZ0ZvcmNlcyl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TnNwcmluZ3M7IGkrKyl7XG4gICAgICAgICAgICB2YXIgcyA9IHNwcmluZ3NbaV07XG4gICAgICAgICAgICBzLmFwcGx5Rm9yY2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuYXBwbHlEYW1waW5nKXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV07XG4gICAgICAgICAgICBpZihiLnR5cGUgPT09IEJvZHkuRFlOQU1JQyl7XG4gICAgICAgICAgICAgICAgYi5hcHBseURhbXBpbmcoZHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnJvYWRwaGFzZVxuICAgIHZhciByZXN1bHQgPSBicm9hZHBoYXNlLmdldENvbGxpc2lvblBhaXJzKHRoaXMpO1xuXG4gICAgLy8gUmVtb3ZlIGlnbm9yZWQgY29sbGlzaW9uIHBhaXJzXG4gICAgdmFyIGlnbm9yZWRQYWlycyA9IHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnM7XG4gICAgZm9yKHZhciBpPWlnbm9yZWRQYWlycy5sZW5ndGgtMjsgaT49MDsgaS09Mil7XG4gICAgICAgIGZvcih2YXIgaj1yZXN1bHQubGVuZ3RoLTI7IGo+PTA7IGotPTIpe1xuICAgICAgICAgICAgaWYoIChpZ25vcmVkUGFpcnNbaV0gICA9PT0gcmVzdWx0W2pdICYmIGlnbm9yZWRQYWlyc1tpKzFdID09PSByZXN1bHRbaisxXSkgfHxcbiAgICAgICAgICAgICAgICAoaWdub3JlZFBhaXJzW2krMV0gPT09IHJlc3VsdFtqXSAmJiBpZ25vcmVkUGFpcnNbaV0gICA9PT0gcmVzdWx0W2orMV0pKXtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3BsaWNlKGosMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgY29uc3RyYWluZWQgcGFpcnMgd2l0aCBjb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlXG4gICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcbiAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICBpZighYy5jb2xsaWRlQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIGZvcih2YXIgaj1yZXN1bHQubGVuZ3RoLTI7IGo+PTA7IGotPTIpe1xuICAgICAgICAgICAgICAgIGlmKCAoYy5ib2R5QSA9PT0gcmVzdWx0W2pdICYmIGMuYm9keUIgPT09IHJlc3VsdFtqKzFdKSB8fFxuICAgICAgICAgICAgICAgICAgICAoYy5ib2R5QiA9PT0gcmVzdWx0W2pdICYmIGMuYm9keUEgPT09IHJlc3VsdFtqKzFdKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaiwyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb3N0QnJvYWRwaGFzZSBldmVudFxuICAgIHRoaXMucG9zdEJyb2FkcGhhc2VFdmVudC5wYWlycyA9IHJlc3VsdDtcbiAgICB0aGlzLmVtaXQodGhpcy5wb3N0QnJvYWRwaGFzZUV2ZW50KTtcblxuICAgIC8vIE5hcnJvd3BoYXNlXG4gICAgbnAucmVzZXQodGhpcyk7XG4gICAgZm9yKHZhciBpPTAsIE5yZXN1bHRzPXJlc3VsdC5sZW5ndGg7IGkhPT1OcmVzdWx0czsgaSs9Mil7XG4gICAgICAgIHZhciBiaSA9IHJlc3VsdFtpXSxcbiAgICAgICAgICAgIGJqID0gcmVzdWx0W2krMV07XG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIGFsbCBzaGFwZXMgb2YgYm9keSBpXG4gICAgICAgIGZvcih2YXIgaz0wLCBOc2hhcGVzaT1iaS5zaGFwZXMubGVuZ3RoOyBrIT09TnNoYXBlc2k7IGsrKyl7XG4gICAgICAgICAgICB2YXIgc2kgPSBiaS5zaGFwZXNba10sXG4gICAgICAgICAgICAgICAgeGkgPSBiaS5zaGFwZU9mZnNldHNba10sXG4gICAgICAgICAgICAgICAgYWkgPSBiaS5zaGFwZUFuZ2xlc1trXTtcblxuICAgICAgICAgICAgLy8gQWxsIHNoYXBlcyBvZiBib2R5IGpcbiAgICAgICAgICAgIGZvcih2YXIgbD0wLCBOc2hhcGVzaj1iai5zaGFwZXMubGVuZ3RoOyBsIT09TnNoYXBlc2o7IGwrKyl7XG4gICAgICAgICAgICAgICAgdmFyIHNqID0gYmouc2hhcGVzW2xdLFxuICAgICAgICAgICAgICAgICAgICB4aiA9IGJqLnNoYXBlT2Zmc2V0c1tsXSxcbiAgICAgICAgICAgICAgICAgICAgYWogPSBiai5zaGFwZUFuZ2xlc1tsXTtcblxuICAgICAgICAgICAgICAgIHZhciBjbSA9IHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcbiAgICAgICAgICAgICAgICBpZihzaS5tYXRlcmlhbCAmJiBzai5tYXRlcmlhbCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLmdldENvbnRhY3RNYXRlcmlhbChzaS5tYXRlcmlhbCxzai5tYXRlcmlhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRtcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucnVuTmFycm93cGhhc2UobnAsYmksc2kseGksYWksYmosc2oseGosYWosY20sdGhpcy5mcmljdGlvbkdyYXZpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2FrZSB1cCBib2RpZXNcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihib2R5Ll93YWtlVXBBZnRlck5hcnJvd3BoYXNlKXtcbiAgICAgICAgICAgIGJvZHkud2FrZVVwKCk7XG4gICAgICAgICAgICBib2R5Ll93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbWl0IGVuZCBvdmVybGFwIGV2ZW50c1xuICAgIGlmKHRoaXMuaGFzKCdlbmRDb250YWN0Jykpe1xuICAgICAgICB0aGlzLm92ZXJsYXBLZWVwZXIuZ2V0RW5kT3ZlcmxhcHMoZW5kT3ZlcmxhcHMpO1xuICAgICAgICB2YXIgZSA9IHRoaXMuZW5kQ29udGFjdEV2ZW50O1xuICAgICAgICB2YXIgbCA9IGVuZE92ZXJsYXBzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUobC0tKXtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZW5kT3ZlcmxhcHNbbF07XG4gICAgICAgICAgICBlLnNoYXBlQSA9IGRhdGEuc2hhcGVBO1xuICAgICAgICAgICAgZS5zaGFwZUIgPSBkYXRhLnNoYXBlQjtcbiAgICAgICAgICAgIGUuYm9keUEgPSBkYXRhLmJvZHlBO1xuICAgICAgICAgICAgZS5ib2R5QiA9IGRhdGEuYm9keUI7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJlU29sdmVFdmVudCA9IHRoaXMucHJlU29sdmVFdmVudDtcbiAgICBwcmVTb2x2ZUV2ZW50LmNvbnRhY3RFcXVhdGlvbnMgPSBucC5jb250YWN0RXF1YXRpb25zO1xuICAgIHByZVNvbHZlRXZlbnQuZnJpY3Rpb25FcXVhdGlvbnMgPSBucC5mcmljdGlvbkVxdWF0aW9ucztcbiAgICB0aGlzLmVtaXQocHJlU29sdmVFdmVudCk7XG5cbiAgICAvLyB1cGRhdGUgY29uc3RyYWludCBlcXVhdGlvbnNcbiAgICB2YXIgTmNvbnN0cmFpbnRzID0gY29uc3RyYWludHMubGVuZ3RoO1xuICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgIGNvbnN0cmFpbnRzW2ldLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGlmKG5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoIHx8IG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCB8fCBjb25zdHJhaW50cy5sZW5ndGgpe1xuICAgICAgICBpZih0aGlzLmlzbGFuZFNwbGl0KXtcbiAgICAgICAgICAgIC8vIFNwbGl0IGludG8gaXNsYW5kc1xuICAgICAgICAgICAgaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIFV0aWxzLmFwcGVuZEFycmF5KGlzbGFuZE1hbmFnZXIuZXF1YXRpb25zLCBucC5jb250YWN0RXF1YXRpb25zKTtcbiAgICAgICAgICAgIFV0aWxzLmFwcGVuZEFycmF5KGlzbGFuZE1hbmFnZXIuZXF1YXRpb25zLCBucC5mcmljdGlvbkVxdWF0aW9ucyk7XG4gICAgICAgICAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICAgICAgICAgIFV0aWxzLmFwcGVuZEFycmF5KGlzbGFuZE1hbmFnZXIuZXF1YXRpb25zLCBjb25zdHJhaW50c1tpXS5lcXVhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNsYW5kTWFuYWdlci5zcGxpdCh0aGlzKTtcblxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1pc2xhbmRNYW5hZ2VyLmlzbGFuZHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHZhciBpc2xhbmQgPSBpc2xhbmRNYW5hZ2VyLmlzbGFuZHNbaV07XG4gICAgICAgICAgICAgICAgaWYoaXNsYW5kLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICBzb2x2ZXIuc29sdmVJc2xhbmQoZHQsaXNsYW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gQWRkIGNvbnRhY3QgZXF1YXRpb25zIHRvIHNvbHZlclxuICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9ucyhucC5jb250YWN0RXF1YXRpb25zKTtcbiAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbnMobnAuZnJpY3Rpb25FcXVhdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdXNlci1kZWZpbmVkIGNvbnN0cmFpbnQgZXF1YXRpb25zXG4gICAgICAgICAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbnMoY29uc3RyYWludHNbaV0uZXF1YXRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5zb2x2ZUNvbnN0cmFpbnRzKXtcbiAgICAgICAgICAgICAgICBzb2x2ZXIuc29sdmUoZHQsdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgZm9yd2FyZFxuICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgaWYoYm9keS5zbGVlcFN0YXRlICE9PSBCb2R5LlNMRUVQSU5HICYmIGJvZHkudHlwZSAhPT0gQm9keS5TVEFUSUMpe1xuICAgICAgICAgICAgYm9keS5pbnRlZ3JhdGUoZHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgZm9yY2VcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgIGJvZGllc1tpXS5zZXRaZXJvRm9yY2UoKTtcbiAgICB9XG5cbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHQxID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoYXQubGFzdFN0ZXBUaW1lID0gdDEtdDA7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBpbXBhY3QgZXZlbnRcbiAgICBpZih0aGlzLmVtaXRJbXBhY3RFdmVudCAmJiB0aGlzLmhhcygnaW1wYWN0Jykpe1xuICAgICAgICB2YXIgZXYgPSB0aGlzLmltcGFjdEV2ZW50O1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PW5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGVxID0gbnAuY29udGFjdEVxdWF0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmKGVxLmZpcnN0SW1wYWN0KXtcbiAgICAgICAgICAgICAgICBldi5ib2R5QSA9IGVxLmJvZHlBO1xuICAgICAgICAgICAgICAgIGV2LmJvZHlCID0gZXEuYm9keUI7XG4gICAgICAgICAgICAgICAgZXYuc2hhcGVBID0gZXEuc2hhcGVBO1xuICAgICAgICAgICAgICAgIGV2LnNoYXBlQiA9IGVxLnNoYXBlQjtcbiAgICAgICAgICAgICAgICBldi5jb250YWN0RXF1YXRpb24gPSBlcTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2xlZXBpbmcgdXBkYXRlXG4gICAgaWYodGhpcy5zbGVlcE1vZGUgPT09IFdvcmxkLkJPRFlfU0xFRVBJTkcpe1xuICAgICAgICBmb3IoaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIGJvZGllc1tpXS5zbGVlcFRpY2sodGhpcy50aW1lLCBmYWxzZSwgZHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKHRoaXMuc2xlZXBNb2RlID09PSBXb3JsZC5JU0xBTkRfU0xFRVBJTkcgJiYgdGhpcy5pc2xhbmRTcGxpdCl7XG5cbiAgICAgICAgLy8gVGVsbCBhbGwgYm9kaWVzIHRvIHNsZWVwIHRpY2sgYnV0IGRvbnQgc2xlZXAgeWV0XG4gICAgICAgIGZvcihpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUsIHRydWUsIGR0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsZWVwIGlzbGFuZHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5pc2xhbmRNYW5hZ2VyLmlzbGFuZHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGlzbGFuZCA9IHRoaXMuaXNsYW5kTWFuYWdlci5pc2xhbmRzW2ldO1xuICAgICAgICAgICAgaWYoaXNsYW5kLndhbnRzVG9TbGVlcCgpKXtcbiAgICAgICAgICAgICAgICBpc2xhbmQuc2xlZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RlcHBpbmcgPSBmYWxzZTtcblxuICAgIC8vIFJlbW92ZSBib2RpZXMgdGhhdCBhcmUgc2NoZWR1bGVkIGZvciByZW1vdmFsXG4gICAgaWYodGhpcy5ib2RpZXNUb0JlUmVtb3ZlZC5sZW5ndGgpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PXRoaXMuYm9kaWVzVG9CZVJlbW92ZWQubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVCb2R5KHRoaXMuYm9kaWVzVG9CZVJlbW92ZWRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9kaWVzVG9CZVJlbW92ZWQubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQodGhpcy5wb3N0U3RlcEV2ZW50KTtcbn07XG5cbi8qKlxuICogUnVucyBuYXJyb3dwaGFzZSBmb3IgdGhlIHNoYXBlIHBhaXIgaSBhbmQgai5cbiAqIEBtZXRob2QgcnVuTmFycm93cGhhc2VcbiAqIEBwYXJhbSAge05hcnJvd3BoYXNlfSBucFxuICogQHBhcmFtICB7Qm9keX0gYmlcbiAqIEBwYXJhbSAge1NoYXBlfSBzaVxuICogQHBhcmFtICB7QXJyYXl9IHhpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFpXG4gKiBAcGFyYW0gIHtCb2R5fSBialxuICogQHBhcmFtICB7U2hhcGV9IHNqXG4gKiBAcGFyYW0gIHtBcnJheX0geGpcbiAqIEBwYXJhbSAge051bWJlcn0gYWpcbiAqIEBwYXJhbSAge051bWJlcn0gbXVcbiAqL1xuV29ybGQucHJvdG90eXBlLnJ1bk5hcnJvd3BoYXNlID0gZnVuY3Rpb24obnAsYmksc2kseGksYWksYmosc2oseGosYWosY20sZ2xlbil7XG5cbiAgICAvLyBDaGVjayBjb2xsaXNpb24gZ3JvdXBzIGFuZCBtYXNrc1xuICAgIGlmKCEoKHNpLmNvbGxpc2lvbkdyb3VwICYgc2ouY29sbGlzaW9uTWFzaykgIT09IDAgJiYgKHNqLmNvbGxpc2lvbkdyb3VwICYgc2kuY29sbGlzaW9uTWFzaykgIT09IDApKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCB3b3JsZCBwb3NpdGlvbiBhbmQgYW5nbGUgb2YgZWFjaCBzaGFwZVxuICAgIHZlYzIucm90YXRlKHhpdywgeGksIGJpLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh4ancsIHhqLCBiai5hbmdsZSk7XG4gICAgdmVjMi5hZGQoeGl3LCB4aXcsIGJpLnBvc2l0aW9uKTtcbiAgICB2ZWMyLmFkZCh4ancsIHhqdywgYmoucG9zaXRpb24pO1xuICAgIHZhciBhaXcgPSBhaSArIGJpLmFuZ2xlO1xuICAgIHZhciBhancgPSBhaiArIGJqLmFuZ2xlO1xuXG4gICAgbnAuZW5hYmxlRnJpY3Rpb24gPSBjbS5mcmljdGlvbiA+IDA7XG4gICAgbnAuZnJpY3Rpb25Db2VmZmljaWVudCA9IGNtLmZyaWN0aW9uO1xuICAgIHZhciByZWR1Y2VkTWFzcztcbiAgICBpZihiaS50eXBlID09PSBCb2R5LlNUQVRJQyB8fCBiaS50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHJlZHVjZWRNYXNzID0gYmoubWFzcztcbiAgICB9IGVsc2UgaWYoYmoudHlwZSA9PT0gQm9keS5TVEFUSUMgfHwgYmoudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuICAgICAgICByZWR1Y2VkTWFzcyA9IGJpLm1hc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVkdWNlZE1hc3MgPSAoYmkubWFzcypiai5tYXNzKS8oYmkubWFzcytiai5tYXNzKTtcbiAgICB9XG4gICAgbnAuc2xpcEZvcmNlID0gY20uZnJpY3Rpb24qZ2xlbipyZWR1Y2VkTWFzcztcbiAgICBucC5yZXN0aXR1dGlvbiA9IGNtLnJlc3RpdHV0aW9uO1xuICAgIG5wLnN1cmZhY2VWZWxvY2l0eSA9IGNtLnN1cmZhY2VWZWxvY2l0eTtcbiAgICBucC5mcmljdGlvblN0aWZmbmVzcyA9IGNtLmZyaWN0aW9uU3RpZmZuZXNzO1xuICAgIG5wLmZyaWN0aW9uUmVsYXhhdGlvbiA9IGNtLmZyaWN0aW9uUmVsYXhhdGlvbjtcbiAgICBucC5zdGlmZm5lc3MgPSBjbS5zdGlmZm5lc3M7XG4gICAgbnAucmVsYXhhdGlvbiA9IGNtLnJlbGF4YXRpb247XG4gICAgbnAuY29udGFjdFNraW5TaXplID0gY20uY29udGFjdFNraW5TaXplO1xuICAgIG5wLmVuYWJsZWRFcXVhdGlvbnMgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTtcblxuICAgIHZhciByZXNvbHZlciA9IG5wW3NpLnR5cGUgfCBzai50eXBlXSxcbiAgICAgICAgbnVtQ29udGFjdHMgPSAwO1xuICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICB2YXIgc2Vuc29yID0gc2kuc2Vuc29yIHx8IHNqLnNlbnNvcjtcbiAgICAgICAgdmFyIG51bUZyaWN0aW9uQmVmb3JlID0gbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoO1xuICAgICAgICBpZiAoc2kudHlwZSA8IHNqLnR5cGUpIHtcbiAgICAgICAgICAgIG51bUNvbnRhY3RzID0gcmVzb2x2ZXIuY2FsbChucCwgYmksc2kseGl3LGFpdywgYmosc2oseGp3LGFqdywgc2Vuc29yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG51bUNvbnRhY3RzID0gcmVzb2x2ZXIuY2FsbChucCwgYmosc2oseGp3LGFqdywgYmksc2kseGl3LGFpdywgc2Vuc29yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtRnJpY3Rpb25FcXVhdGlvbnMgPSBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggLSBudW1GcmljdGlvbkJlZm9yZTtcblxuICAgICAgICBpZihudW1Db250YWN0cyl7XG5cbiAgICAgICAgICAgIGlmKCBiaS5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICAgICAgYmkudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmXG4gICAgICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSAgPT09IEJvZHkuU0xFRVBJTkcgJiZcbiAgICAgICAgICAgICAgICBiai5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgICAgIGJqLnR5cGUgIT09IEJvZHkuU1RBVElDXG4gICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRCID0gdmVjMi5zcXVhcmVkTGVuZ3RoKGJqLnZlbG9jaXR5KSArIE1hdGgucG93KGJqLmFuZ3VsYXJWZWxvY2l0eSwyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWRCID0gTWF0aC5wb3coYmouc2xlZXBTcGVlZExpbWl0LDIpO1xuICAgICAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEIgPj0gc3BlZWRMaW1pdFNxdWFyZWRCKjIpe1xuICAgICAgICAgICAgICAgICAgICBiaS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggYmouYWxsb3dTbGVlcCAmJlxuICAgICAgICAgICAgICAgIGJqLnR5cGUgPT09IEJvZHkuRFlOQU1JQyAmJlxuICAgICAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgID09PSBCb2R5LlNMRUVQSU5HICYmXG4gICAgICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSAgPT09IEJvZHkuQVdBS0UgJiZcbiAgICAgICAgICAgICAgICBiaS50eXBlICE9PSBCb2R5LlNUQVRJQ1xuICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICB2YXIgc3BlZWRTcXVhcmVkQSA9IHZlYzIuc3F1YXJlZExlbmd0aChiaS52ZWxvY2l0eSkgKyBNYXRoLnBvdyhiaS5hbmd1bGFyVmVsb2NpdHksMik7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQSA9IE1hdGgucG93KGJpLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgICAgICAgICBpZihzcGVlZFNxdWFyZWRBID49IHNwZWVkTGltaXRTcXVhcmVkQSoyKXtcbiAgICAgICAgICAgICAgICAgICAgYmouX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vdmVybGFwS2VlcGVyLnNldE92ZXJsYXBwaW5nKGJpLCBzaSwgYmosIHNqKTtcbiAgICAgICAgICAgIGlmKHRoaXMuaGFzKCdiZWdpbkNvbnRhY3QnKSAmJiB0aGlzLm92ZXJsYXBLZWVwZXIuaXNOZXdPdmVybGFwKHNpLCBzaikpe1xuXG4gICAgICAgICAgICAgICAgLy8gUmVwb3J0IG5ldyBzaGFwZSBvdmVybGFwXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmJlZ2luQ29udGFjdEV2ZW50O1xuICAgICAgICAgICAgICAgIGUuc2hhcGVBID0gc2k7XG4gICAgICAgICAgICAgICAgZS5zaGFwZUIgPSBzajtcbiAgICAgICAgICAgICAgICBlLmJvZHlBID0gYmk7XG4gICAgICAgICAgICAgICAgZS5ib2R5QiA9IGJqO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgY29udGFjdCBlcXVhdGlvbnNcbiAgICAgICAgICAgICAgICBlLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZihudW1Db250YWN0cyk9PT1cIm51bWJlclwiKXtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpPW5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoLW51bUNvbnRhY3RzOyBpPG5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5jb250YWN0RXF1YXRpb25zLnB1c2gobnAuY29udGFjdEVxdWF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRpdmlkZSB0aGUgbWF4IGZyaWN0aW9uIGZvcmNlIGJ5IHRoZSBudW1iZXIgb2YgY29udGFjdHNcbiAgICAgICAgICAgIGlmKHR5cGVvZihudW1Db250YWN0cyk9PT1cIm51bWJlclwiICYmIG51bUZyaWN0aW9uRXF1YXRpb25zID4gMSl7IC8vIFdoeSBkaXZpZGUgYnkgMT9cbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9bnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoLW51bUZyaWN0aW9uRXF1YXRpb25zOyBpPG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBucC5mcmljdGlvbkVxdWF0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZi5zZXRTbGlwRm9yY2UoZi5nZXRTbGlwRm9yY2UoKSAvIG51bUZyaWN0aW9uRXF1YXRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8qKlxuICogQWRkIGEgc3ByaW5nIHRvIHRoZSBzaW11bGF0aW9uXG4gKlxuICogQG1ldGhvZCBhZGRTcHJpbmdcbiAqIEBwYXJhbSB7U3ByaW5nfSBzXG4gKi9cbldvcmxkLnByb3RvdHlwZS5hZGRTcHJpbmcgPSBmdW5jdGlvbihzKXtcbiAgICB0aGlzLnNwcmluZ3MucHVzaChzKTtcbiAgICB0aGlzLmFkZFNwcmluZ0V2ZW50LnNwcmluZyA9IHM7XG4gICAgdGhpcy5lbWl0KHRoaXMuYWRkU3ByaW5nRXZlbnQpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBzcHJpbmdcbiAqXG4gKiBAbWV0aG9kIHJlbW92ZVNwcmluZ1xuICogQHBhcmFtIHtTcHJpbmd9IHNcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZVNwcmluZyA9IGZ1bmN0aW9uKHMpe1xuICAgIHZhciBpZHggPSB0aGlzLnNwcmluZ3MuaW5kZXhPZihzKTtcbiAgICBpZihpZHghPT0tMSl7XG4gICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLnNwcmluZ3MsaWR4LDEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGEgYm9keSB0byB0aGUgc2ltdWxhdGlvblxuICpcbiAqIEBtZXRob2QgYWRkQm9keVxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgd29ybGQgPSBuZXcgV29ybGQoKSxcbiAqICAgICAgICAgYm9keSA9IG5ldyBCb2R5KCk7XG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcbiAqIEB0b2RvIFdoYXQgaWYgdGhpcyBpcyBkb25lIGR1cmluZyBzdGVwP1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkQm9keSA9IGZ1bmN0aW9uKGJvZHkpe1xuICAgIGlmKHRoaXMuYm9kaWVzLmluZGV4T2YoYm9keSkgPT09IC0xKXtcbiAgICAgICAgdGhpcy5ib2RpZXMucHVzaChib2R5KTtcbiAgICAgICAgYm9keS53b3JsZCA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWRkQm9keUV2ZW50LmJvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5hZGRCb2R5RXZlbnQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLiBJZiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgZHVyaW5nIHN0ZXAoKSwgdGhlIGJvZHkgcmVtb3ZhbCBpcyBzY2hlZHVsZWQgdG8gYWZ0ZXIgdGhlIHN0ZXAuXG4gKlxuICogQG1ldGhvZCByZW1vdmVCb2R5XG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZUJvZHkgPSBmdW5jdGlvbihib2R5KXtcbiAgICBpZih0aGlzLnN0ZXBwaW5nKXtcbiAgICAgICAgdGhpcy5ib2RpZXNUb0JlUmVtb3ZlZC5wdXNoKGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJvZHkud29ybGQgPSBudWxsO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5ib2RpZXMuaW5kZXhPZihib2R5KTtcbiAgICAgICAgaWYoaWR4IT09LTEpe1xuICAgICAgICAgICAgVXRpbHMuc3BsaWNlKHRoaXMuYm9kaWVzLGlkeCwxKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQm9keUV2ZW50LmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgYm9keS5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMucmVtb3ZlQm9keUV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGEgYm9keSBieSBpdHMgaWQuXG4gKiBAbWV0aG9kIGdldEJvZHlCeUlkXG4gKiBAcmV0dXJuIHtCb2R5fEJvb2xlYW59IFRoZSBib2R5LCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGZvdW5kLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Qm9keUJ5SWQgPSBmdW5jdGlvbihpZCl7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xuICAgIGZvcih2YXIgaT0wOyBpPGJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiLmlkID09PSBpZCl7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERpc2FibGUgY29sbGlzaW9uIGJldHdlZW4gdHdvIGJvZGllc1xuICogQG1ldGhvZCBkaXNhYmxlQ29sbGlzaW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbldvcmxkLnByb3RvdHlwZS5kaXNhYmxlQm9keUNvbGxpc2lvbiA9IGZ1bmN0aW9uKGJvZHlBLGJvZHlCKXtcbiAgICB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzLnB1c2goYm9keUEsYm9keUIpO1xufTtcblxuLyoqXG4gKiBFbmFibGUgY29sbGlzaW9ucyBiZXR3ZWVuIHRoZSBnaXZlbiB0d28gYm9kaWVzXG4gKiBAbWV0aG9kIGVuYWJsZUNvbGxpc2lvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZW5hYmxlQm9keUNvbGxpc2lvbiA9IGZ1bmN0aW9uKGJvZHlBLGJvZHlCKXtcbiAgICB2YXIgcGFpcnMgPSB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzO1xuICAgIGZvcih2YXIgaT0wOyBpPHBhaXJzLmxlbmd0aDsgaSs9Mil7XG4gICAgICAgIGlmKChwYWlyc1tpXSA9PT0gYm9keUEgJiYgcGFpcnNbaSsxXSA9PT0gYm9keUIpIHx8IChwYWlyc1tpKzFdID09PSBib2R5QSAmJiBwYWlyc1tpXSA9PT0gYm9keUIpKXtcbiAgICAgICAgICAgIHBhaXJzLnNwbGljZShpLDIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiB2MmEodil7XG4gICAgaWYoIXYpe1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmV0dXJuIFt2WzBdLHZbMV1dO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSxiKXtcbiAgICBmb3IodmFyIGtleSBpbiBiKXtcbiAgICAgICAgYVtrZXldID0gYltrZXldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29udGFjdE1hdGVyaWFsVG9KU09OKGNtKXtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZCA6IGNtLmlkLFxuICAgICAgICBtYXRlcmlhbEEgOiAgICAgICAgICAgICBjbS5tYXRlcmlhbEEuaWQsXG4gICAgICAgIG1hdGVyaWFsQiA6ICAgICAgICAgICAgIGNtLm1hdGVyaWFsQi5pZCxcbiAgICAgICAgZnJpY3Rpb24gOiAgICAgICAgICAgICAgY20uZnJpY3Rpb24sXG4gICAgICAgIHJlc3RpdHV0aW9uIDogICAgICAgICAgIGNtLnJlc3RpdHV0aW9uLFxuICAgICAgICBzdGlmZm5lc3MgOiAgICAgICAgICAgICBjbS5zdGlmZm5lc3MsXG4gICAgICAgIHJlbGF4YXRpb24gOiAgICAgICAgICAgIGNtLnJlbGF4YXRpb24sXG4gICAgICAgIGZyaWN0aW9uU3RpZmZuZXNzIDogICAgIGNtLmZyaWN0aW9uU3RpZmZuZXNzLFxuICAgICAgICBmcmljdGlvblJlbGF4YXRpb24gOiAgICBjbS5mcmljdGlvblJlbGF4YXRpb24sXG4gICAgfTtcbn1cblxuLyoqXG4gKiBSZXNldHMgdGhlIFdvcmxkLCByZW1vdmVzIGFsbCBib2RpZXMsIGNvbnN0cmFpbnRzIGFuZCBzcHJpbmdzLlxuICpcbiAqIEBtZXRob2QgY2xlYXJcbiAqL1xuV29ybGQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcblxuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5maXhlZFN0ZXBUaW1lID0gMDtcblxuICAgIC8vIFJlbW92ZSBhbGwgc29sdmVyIGVxdWF0aW9uc1xuICAgIGlmKHRoaXMuc29sdmVyICYmIHRoaXMuc29sdmVyLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICB0aGlzLnNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGNvbnN0cmFpbnRzXG4gICAgdmFyIGNzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICBmb3IodmFyIGk9Y3MubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29uc3RyYWludChjc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBib2RpZXNcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gICAgZm9yKHZhciBpPWJvZGllcy5sZW5ndGgtMTsgaT49MDsgaS0tKXtcbiAgICAgICAgdGhpcy5yZW1vdmVCb2R5KGJvZGllc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBzcHJpbmdzXG4gICAgdmFyIHNwcmluZ3MgPSB0aGlzLnNwcmluZ3M7XG4gICAgZm9yKHZhciBpPXNwcmluZ3MubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlU3ByaW5nKHNwcmluZ3NbaV0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgY29udGFjdCBtYXRlcmlhbHNcbiAgICB2YXIgY21zID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xuICAgIGZvcih2YXIgaT1jbXMubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29udGFjdE1hdGVyaWFsKGNtc1tpXSk7XG4gICAgfVxuXG4gICAgV29ybGQuYXBwbHkodGhpcyk7XG59O1xuXG4vKipcbiAqIEdldCBhIGNvcHkgb2YgdGhpcyBXb3JsZCBpbnN0YW5jZVxuICogQG1ldGhvZCBjbG9uZVxuICogQHJldHVybiB7V29ybGR9XG4gKi9cbldvcmxkLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCk7XG4gICAgd29ybGQuZnJvbUpTT04odGhpcy50b0pTT04oKSk7XG4gICAgcmV0dXJuIHdvcmxkO1xufTtcblxudmFyIGhpdFRlc3RfdG1wMSA9IHZlYzIuY3JlYXRlKCksXG4gICAgaGl0VGVzdF96ZXJvID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgaGl0VGVzdF90bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogVGVzdCBpZiBhIHdvcmxkIHBvaW50IG92ZXJsYXBzIGJvZGllc1xuICogQG1ldGhvZCBoaXRUZXN0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHdvcmxkUG9pbnQgIFBvaW50IHRvIHVzZSBmb3IgaW50ZXJzZWN0aW9uIHRlc3RzXG4gKiBAcGFyYW0gIHtBcnJheX0gIGJvZGllcyAgICAgIEEgbGlzdCBvZiBvYmplY3RzIHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb25cbiAqIEBwYXJhbSAge051bWJlcn0gcHJlY2lzaW9uICAgVXNlZCBmb3IgbWF0Y2hpbmcgYWdhaW5zdCBwYXJ0aWNsZXMgYW5kIGxpbmVzLiBBZGRzIHNvbWUgbWFyZ2luIHRvIHRoZXNlIGluZmluaXRlc2ltYWwgb2JqZWN0cy5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgQXJyYXkgb2YgYm9kaWVzIHRoYXQgb3ZlcmxhcCB0aGUgcG9pbnRcbiAqL1xuV29ybGQucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbih3b3JsZFBvaW50LGJvZGllcyxwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuXG4gICAgLy8gQ3JlYXRlIGEgZHVtbXkgcGFydGljbGUgYm9keSB3aXRoIGEgcGFydGljbGUgc2hhcGUgdG8gdGVzdCBhZ2FpbnN0IHRoZSBib2RpZXNcbiAgICB2YXIgcGIgPSBuZXcgQm9keSh7IHBvc2l0aW9uOndvcmxkUG9pbnQgfSksXG4gICAgICAgIHBzID0gbmV3IFBhcnRpY2xlKCksXG4gICAgICAgIHB4ID0gd29ybGRQb2ludCxcbiAgICAgICAgcGEgPSAwLFxuICAgICAgICB4ID0gaGl0VGVzdF90bXAxLFxuICAgICAgICB6ZXJvID0gaGl0VGVzdF96ZXJvLFxuICAgICAgICB0bXAgPSBoaXRUZXN0X3RtcDI7XG4gICAgcGIuYWRkU2hhcGUocHMpO1xuXG4gICAgdmFyIG4gPSB0aGlzLm5hcnJvd3BoYXNlLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIC8vIENoZWNrIGJvZGllc1xuICAgIGZvcih2YXIgaT0wLCBOPWJvZGllcy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTAsIE5TPWIuc2hhcGVzLmxlbmd0aDsgaiE9PU5TOyBqKyspe1xuICAgICAgICAgICAgdmFyIHMgPSBiLnNoYXBlc1tqXSxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBiLnNoYXBlT2Zmc2V0c1tqXSB8fCB6ZXJvLFxuICAgICAgICAgICAgICAgIGFuZ2xlID0gYi5zaGFwZUFuZ2xlc1tqXSB8fCAwLjA7XG5cbiAgICAgICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBwb3NpdGlvbiArIGFuZ2xlXG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZSh4LCBvZmZzZXQsIGIuYW5nbGUpO1xuICAgICAgICAgICAgdmVjMi5hZGQoeCwgeCwgYi5wb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgYSA9IGFuZ2xlICsgYi5hbmdsZTtcblxuICAgICAgICAgICAgaWYoIChzIGluc3RhbmNlb2YgQ2lyY2xlICAgICYmIG4uY2lyY2xlUGFydGljbGUgIChiLHMseCxhLCAgICAgcGIscHMscHgscGEsIHRydWUpKSB8fFxuICAgICAgICAgICAgICAgIChzIGluc3RhbmNlb2YgQ29udmV4ICAgICYmIG4ucGFydGljbGVDb252ZXggIChwYixwcyxweCxwYSwgYixzLHgsYSwgICAgIHRydWUpKSB8fFxuICAgICAgICAgICAgICAgIChzIGluc3RhbmNlb2YgUGxhbmUgICAgICYmIG4ucGFydGljbGVQbGFuZSAgIChwYixwcyxweCxwYSwgYixzLHgsYSwgICAgIHRydWUpKSB8fFxuICAgICAgICAgICAgICAgIChzIGluc3RhbmNlb2YgQ2Fwc3VsZSAgICYmIG4ucGFydGljbGVDYXBzdWxlIChwYixwcyxweCxwYSwgYixzLHgsYSwgICAgIHRydWUpKSB8fFxuICAgICAgICAgICAgICAgIChzIGluc3RhbmNlb2YgUGFydGljbGUgICYmIHZlYzIuc3F1YXJlZExlbmd0aCh2ZWMyLnN1Yih0bXAseCx3b3JsZFBvaW50KSkgPCBwcmVjaXNpb24qcHJlY2lzaW9uKVxuICAgICAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBFcXVhdGlvbiBwYXJhbWV0ZXJzIGZvciBhbGwgY29uc3RyYWludHMgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzLlxuICogQG1ldGhvZCBzZXRHbG9iYWxFcXVhdGlvblBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1ldGVyc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5yZWxheGF0aW9uXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnN0aWZmbmVzc11cbiAqL1xuV29ybGQucHJvdG90eXBlLnNldEdsb2JhbEVxdWF0aW9uUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpe1xuICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgLy8gU2V0IGZvciBhbGwgY29uc3RyYWludHNcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb25zdHJhaW50c1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGMuZXF1YXRpb25zLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBlcSA9IGMuZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgaWYodHlwZW9mKHBhcmFtZXRlcnMuc3RpZmZuZXNzKSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICAgICAgZXEuc3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0eXBlb2YocGFyYW1ldGVycy5yZWxheGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICAgICAgZXEucmVsYXhhdGlvbiA9IHBhcmFtZXRlcnMucmVsYXhhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBmb3IgYWxsIGNvbnRhY3QgbWF0ZXJpYWxzXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IHRoaXMuY29udGFjdE1hdGVyaWFscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzW2ldO1xuICAgICAgICBpZih0eXBlb2YocGFyYW1ldGVycy5zdGlmZm5lc3MpICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIGMuc3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgICAgICAgICBjLmZyaWN0aW9uU3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mKHBhcmFtZXRlcnMucmVsYXhhdGlvbikgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgYy5yZWxheGF0aW9uID0gcGFyYW1ldGVycy5yZWxheGF0aW9uO1xuICAgICAgICAgICAgYy5mcmljdGlvblJlbGF4YXRpb24gPSBwYXJhbWV0ZXJzLnJlbGF4YXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgZm9yIGRlZmF1bHQgY29udGFjdCBtYXRlcmlhbFxuICAgIHZhciBjID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xuICAgIGlmKHR5cGVvZihwYXJhbWV0ZXJzLnN0aWZmbmVzcykgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICBjLnN0aWZmbmVzcyA9IHBhcmFtZXRlcnMuc3RpZmZuZXNzO1xuICAgICAgICBjLmZyaWN0aW9uU3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgfVxuICAgIGlmKHR5cGVvZihwYXJhbWV0ZXJzLnJlbGF4YXRpb24pICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgYy5yZWxheGF0aW9uID0gcGFyYW1ldGVycy5yZWxheGF0aW9uO1xuICAgICAgICBjLmZyaWN0aW9uUmVsYXhhdGlvbiA9IHBhcmFtZXRlcnMucmVsYXhhdGlvbjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3RpZmZuZXNzIGZvciBhbGwgZXF1YXRpb25zIGFuZCBjb250YWN0IG1hdGVyaWFscy5cbiAqIEBtZXRob2Qgc2V0R2xvYmFsU3RpZmZuZXNzXG4gKiBAcGFyYW0ge051bWJlcn0gc3RpZmZuZXNzXG4gKi9cbldvcmxkLnByb3RvdHlwZS5zZXRHbG9iYWxTdGlmZm5lc3MgPSBmdW5jdGlvbihzdGlmZm5lc3Mpe1xuICAgIHRoaXMuc2V0R2xvYmFsRXF1YXRpb25QYXJhbWV0ZXJzKHtcbiAgICAgICAgc3RpZmZuZXNzOiBzdGlmZm5lc3NcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSByZWxheGF0aW9uIGZvciBhbGwgZXF1YXRpb25zIGFuZCBjb250YWN0IG1hdGVyaWFscy5cbiAqIEBtZXRob2Qgc2V0R2xvYmFsUmVsYXhhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJlbGF4YXRpb25cbiAqL1xuV29ybGQucHJvdG90eXBlLnNldEdsb2JhbFJlbGF4YXRpb24gPSBmdW5jdGlvbihyZWxheGF0aW9uKXtcbiAgICB0aGlzLnNldEdsb2JhbEVxdWF0aW9uUGFyYW1ldGVycyh7XG4gICAgICAgIHJlbGF4YXRpb246IHJlbGF4YXRpb25cbiAgICB9KTtcbn07XG5cbnZhciB0bXBSYXkgPSBuZXcgUmF5KCk7XG5cbi8qKlxuICogUmF5IGNhc3QgYWdhaW5zdCBhbGwgYm9kaWVzLiBUaGUgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaCBoaXQgd2l0aCBhIFJheWNhc3RSZXN1bHQgYXMgc2luZ2xlIGFyZ3VtZW50LlxuICogQG1ldGhvZCByYXljYXN0QWxsXG4gKiBAcGFyYW0gIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbk1hc2s9LTFdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkdyb3VwPS0xXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdEFsbCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zLCBjYWxsYmFjayl7XG4gICAgb3B0aW9ucy5tb2RlID0gUmF5LkFMTDtcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tO1xuICAgIG9wdGlvbnMudG8gPSB0bztcbiAgICBvcHRpb25zLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmF5IGNhc3QsIGFuZCBzdG9wIGF0IHRoZSBmaXJzdCByZXN1bHQuIE5vdGUgdGhhdCB0aGUgb3JkZXIgaXMgcmFuZG9tIC0gYnV0IHRoZSBtZXRob2QgaXMgZmFzdC5cbiAqIEBtZXRob2QgcmF5Y2FzdEFueVxuICogQHBhcmFtICB7VmVjM30gZnJvbVxuICogQHBhcmFtICB7VmVjM30gdG9cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25NYXNrPS0xXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25Hcm91cD0tMV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnJheWNhc3RBbnkgPSBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucywgcmVzdWx0KXtcbiAgICBvcHRpb25zLm1vZGUgPSBSYXkuQU5ZO1xuICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XG4gICAgb3B0aW9ucy50byA9IHRvO1xuICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0O1xuICAgIHJldHVybiB0bXBSYXkuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJheSBjYXN0LCBhbmQgcmV0dXJuIGluZm9ybWF0aW9uIG9mIHRoZSBjbG9zZXN0IGhpdC5cbiAqIEBtZXRob2QgcmF5Y2FzdENsb3Nlc3RcbiAqIEBwYXJhbSAge1ZlYzN9IGZyb21cbiAqIEBwYXJhbSAge1ZlYzN9IHRvXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uTWFzaz0tMV1cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uR3JvdXA9LTFdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yYXljYXN0Q2xvc2VzdCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zLCByZXN1bHQpe1xuICAgIG9wdGlvbnMubW9kZSA9IFJheS5DTE9TRVNUO1xuICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XG4gICAgb3B0aW9ucy50byA9IHRvO1xuICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0O1xuICAgIHJldHVybiB0bXBSYXkuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XG59O1xufSx7XCIuLi8uLi9wYWNrYWdlLmpzb25cIjo2LFwiLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo4LFwiLi4vY29sbGlzaW9uL05haXZlQnJvYWRwaGFzZVwiOjEwLFwiLi4vY29sbGlzaW9uL05hcnJvd3BoYXNlXCI6MTEsXCIuLi9jb2xsaXNpb24vUmF5XCI6MTIsXCIuLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZVwiOjE0LFwiLi4vY29uc3RyYWludHMvQ29uc3RyYWludFwiOjE1LFwiLi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50XCI6MTYsXCIuLi9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludFwiOjE3LFwiLi4vY29uc3RyYWludHMvTG9ja0NvbnN0cmFpbnRcIjoxOCxcIi4uL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnRcIjoxOSxcIi4uL2NvbnN0cmFpbnRzL1Jldm9sdXRlQ29uc3RyYWludFwiOjIwLFwiLi4vZXZlbnRzL0V2ZW50RW1pdHRlclwiOjI3LFwiLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsXCI6MjgsXCIuLi9tYXRlcmlhbC9NYXRlcmlhbFwiOjI5LFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9vYmplY3RzL0JvZHlcIjozMixcIi4uL29iamVjdHMvTGluZWFyU3ByaW5nXCI6MzMsXCIuLi9vYmplY3RzL1JvdGF0aW9uYWxTcHJpbmdcIjozNCxcIi4uL3NoYXBlcy9DYXBzdWxlXCI6MzcsXCIuLi9zaGFwZXMvQ2lyY2xlXCI6MzgsXCIuLi9zaGFwZXMvQ29udmV4XCI6MzksXCIuLi9zaGFwZXMvTGluZVwiOjQxLFwiLi4vc2hhcGVzL1BhcnRpY2xlXCI6NDIsXCIuLi9zaGFwZXMvUGxhbmVcIjo0MyxcIi4uL3NoYXBlcy9SZWN0YW5nbGVcIjo0NCxcIi4uL3NoYXBlcy9TaGFwZVwiOjQ1LFwiLi4vc29sdmVyL0dTU29sdmVyXCI6NDYsXCIuLi9zb2x2ZXIvU29sdmVyXCI6NDcsXCIuLi91dGlscy9PdmVybGFwS2VlcGVyXCI6NDgsXCIuLi91dGlscy9VdGlsc1wiOjUwLFwiLi9Jc2xhbmRNYW5hZ2VyXCI6NTJ9XX0se30sWzM2XSlcbigzNilcbn0pOzsiLCIhZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShlKTtlbHNle3ZhciBmO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/Zj13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9mPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGY9c2VsZiksZi5wb2x5MnRyaT1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzPXtcInZlcnNpb25cIjogXCIxLjMuNVwifVxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogUG9seTJUcmkgQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xuICogXG4gKiBwb2x5MnRyaS5qcyAoSmF2YVNjcmlwdCBwb3J0KSAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yM21pL3BvbHkydHJpLmpzXG4gKiBcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSAzLWNsYXVzZSBCU0QgTGljZW5zZSwgc2VlIExJQ0VOU0UudHh0XG4gKi9cblxuLyoganNoaW50IG1heGNvbXBsZXhpdHk6MTEgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLypcbiAqIE5vdGVcbiAqID09PT1cbiAqIHRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyBKYXZhU2NyaXB0IHZlcnNpb24gb2YgcG9seTJ0cmkgaW50ZW50aW9uYWxseSBmb2xsb3dzXG4gKiBhcyBjbG9zZWx5IGFzIHBvc3NpYmxlIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIHJlZmVyZW5jZSBDKysgdmVyc2lvbiwgdG8gbWFrZSBpdCBcbiAqIGVhc2llciB0byBrZWVwIHRoZSAyIHZlcnNpb25zIGluIHN5bmMuXG4gKi9cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tTm9kZVxuXG4vKipcbiAqIEFkdmFuY2luZyBmcm9udCBub2RlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKiBAc3RydWN0XG4gKiBAcGFyYW0geyFYWX0gcCAtIFBvaW50XG4gKiBAcGFyYW0ge1RyaWFuZ2xlPX0gdCB0cmlhbmdsZSAob3B0aW9uYWwpXG4gKi9cbnZhciBOb2RlID0gZnVuY3Rpb24ocCwgdCkge1xuICAgIC8qKiBAdHlwZSB7WFl9ICovXG4gICAgdGhpcy5wb2ludCA9IHA7XG5cbiAgICAvKiogQHR5cGUge1RyaWFuZ2xlfG51bGx9ICovXG4gICAgdGhpcy50cmlhbmdsZSA9IHQgfHwgbnVsbDtcblxuICAgIC8qKiBAdHlwZSB7Tm9kZXxudWxsfSAqL1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtOb2RlfG51bGx9ICovXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMudmFsdWUgPSBwLng7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1BZHZhbmNpbmdGcm9udFxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKiBAc3RydWN0XG4gKiBAcGFyYW0ge05vZGV9IGhlYWRcbiAqIEBwYXJhbSB7Tm9kZX0gdGFpbFxuICovXG52YXIgQWR2YW5jaW5nRnJvbnQgPSBmdW5jdGlvbihoZWFkLCB0YWlsKSB7XG4gICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgIHRoaXMuaGVhZF8gPSBoZWFkO1xuICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICB0aGlzLnRhaWxfID0gdGFpbDtcbiAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgdGhpcy5zZWFyY2hfbm9kZV8gPSBoZWFkO1xufTtcblxuLyoqIEByZXR1cm4ge05vZGV9ICovXG5BZHZhbmNpbmdGcm9udC5wcm90b3R5cGUuaGVhZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmhlYWRfO1xufTtcblxuLyoqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuQWR2YW5jaW5nRnJvbnQucHJvdG90eXBlLnNldEhlYWQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5oZWFkXyA9IG5vZGU7XG59O1xuXG4vKiogQHJldHVybiB7Tm9kZX0gKi9cbkFkdmFuY2luZ0Zyb250LnByb3RvdHlwZS50YWlsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFpbF87XG59O1xuXG4vKiogQHBhcmFtIHtOb2RlfSBub2RlICovXG5BZHZhbmNpbmdGcm9udC5wcm90b3R5cGUuc2V0VGFpbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLnRhaWxfID0gbm9kZTtcbn07XG5cbi8qKiBAcmV0dXJuIHtOb2RlfSAqL1xuQWR2YW5jaW5nRnJvbnQucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlYXJjaF9ub2RlXztcbn07XG5cbi8qKiBAcGFyYW0ge05vZGV9IG5vZGUgKi9cbkFkdmFuY2luZ0Zyb250LnByb3RvdHlwZS5zZXRTZWFyY2ggPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5zZWFyY2hfbm9kZV8gPSBub2RlO1xufTtcblxuLyoqIEByZXR1cm4ge05vZGV9ICovXG5BZHZhbmNpbmdGcm9udC5wcm90b3R5cGUuZmluZFNlYXJjaE5vZGUgPSBmdW5jdGlvbigvKngqLykge1xuICAgIC8vIFRPRE86IGltcGxlbWVudCBCU1QgaW5kZXhcbiAgICByZXR1cm4gdGhpcy5zZWFyY2hfbm9kZV87XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IHZhbHVlXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5BZHZhbmNpbmdGcm9udC5wcm90b3R5cGUubG9jYXRlTm9kZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc2VhcmNoX25vZGVfO1xuXG4gICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuICAgIGlmICh4IDwgbm9kZS52YWx1ZSkge1xuICAgICAgICB3aGlsZSAobm9kZSA9IG5vZGUucHJldikge1xuICAgICAgICAgICAgaWYgKHggPj0gbm9kZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoX25vZGVfID0gbm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChub2RlID0gbm9kZS5uZXh0KSB7XG4gICAgICAgICAgICBpZiAoeCA8IG5vZGUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaF9ub2RlXyA9IG5vZGUucHJldjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFYWX0gcG9pbnQgLSBQb2ludFxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuQWR2YW5jaW5nRnJvbnQucHJvdG90eXBlLmxvY2F0ZVBvaW50ID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB2YXIgcHggPSBwb2ludC54O1xuICAgIHZhciBub2RlID0gdGhpcy5maW5kU2VhcmNoTm9kZShweCk7XG4gICAgdmFyIG54ID0gbm9kZS5wb2ludC54O1xuXG4gICAgaWYgKHB4ID09PSBueCkge1xuICAgICAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgICAgICBpZiAocG9pbnQgIT09IG5vZGUucG9pbnQpIHtcbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGhhdmUgdHdvIG5vZGVzIHdpdGggc2FtZSB4IHZhbHVlIGZvciBhIHNob3J0IHRpbWVcbiAgICAgICAgICAgIGlmIChwb2ludCA9PT0gbm9kZS5wcmV2LnBvaW50KSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucHJldjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnQgPT09IG5vZGUubmV4dC5wb2ludCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seTJ0cmkgSW52YWxpZCBBZHZhbmNpbmdGcm9udC5sb2NhdGVQb2ludCgpIGNhbGwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHggPCBueCkge1xuICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgICAgIHdoaWxlIChub2RlID0gbm9kZS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAocG9pbnQgPT09IG5vZGUucG9pbnQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChub2RlID0gbm9kZS5uZXh0KSB7XG4gICAgICAgICAgICBpZiAocG9pbnQgPT09IG5vZGUucG9pbnQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoX25vZGVfID0gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1FeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0gQWR2YW5jaW5nRnJvbnQ7XG5tb2R1bGUuZXhwb3J0cy5Ob2RlID0gTm9kZTtcblxuXG59LHt9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBQb2x5MlRyaSBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXG4gKlxuICogcG9seTJ0cmkuanMgKEphdmFTY3JpcHQgcG9ydCkgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcjNtaS9wb2x5MnRyaS5qc1xuICpcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIDMtY2xhdXNlIEJTRCBMaWNlbnNlLCBzZWUgTElDRU5TRS50eHRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLypcbiAqIEZ1bmN0aW9uIGFkZGVkIGluIHRoZSBKYXZhU2NyaXB0IHZlcnNpb24gKHdhcyBub3QgcHJlc2VudCBpbiB0aGUgYysrIHZlcnNpb24pXG4gKi9cblxuLyoqXG4gKiBhc3NlcnQgYW5kIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb24gICB0aGUgY29uZGl0aW9uIHdoaWNoIGlzIGFzc2VydGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAgICAgIHRoZSBtZXNzYWdlIHdoaWNoIGlzIGRpc3BsYXkgaXMgY29uZGl0aW9uIGlzIGZhbHN5XG4gKi9cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCBcIkFzc2VydCBGYWlsZWRcIik7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBhc3NlcnQ7XG5cblxuXG59LHt9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBQb2x5MlRyaSBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXG4gKiBcbiAqIHBvbHkydHJpLmpzIChKYXZhU2NyaXB0IHBvcnQpIChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3IzbWkvcG9seTJ0cmkuanNcbiAqIFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIDMtY2xhdXNlIEJTRCBMaWNlbnNlLCBzZWUgTElDRU5TRS50eHRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKlxuICogTm90ZVxuICogPT09PVxuICogdGhlIHN0cnVjdHVyZSBvZiB0aGlzIEphdmFTY3JpcHQgdmVyc2lvbiBvZiBwb2x5MnRyaSBpbnRlbnRpb25hbGx5IGZvbGxvd3NcbiAqIGFzIGNsb3NlbHkgYXMgcG9zc2libGUgdGhlIHN0cnVjdHVyZSBvZiB0aGUgcmVmZXJlbmNlIEMrKyB2ZXJzaW9uLCB0byBtYWtlIGl0IFxuICogZWFzaWVyIHRvIGtlZXAgdGhlIDIgdmVyc2lvbnMgaW4gc3luYy5cbiAqL1xuXG52YXIgeHkgPSBfZGVyZXFfKCcuL3h5Jyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVBvaW50XG4vKipcbiAqIENvbnN0cnVjdCBhIHBvaW50XG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgcG9pbnQgPSBuZXcgcG9seTJ0cmkuUG9pbnQoMTUwLCAxNTApO1xuICogQHB1YmxpY1xuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKiBAcGFyYW0ge251bWJlcj19IHggICAgY29vcmRpbmF0ZSAoMCBpZiB1bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcj19IHkgICAgY29vcmRpbmF0ZSAoMCBpZiB1bmRlZmluZWQpXG4gKi9cbnZhciBQb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICB0aGlzLnggPSAreCB8fCAwO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIHRoaXMueSA9ICt5IHx8IDA7XG5cbiAgICAvLyBBbGwgZXh0cmEgZmllbGRzIGFkZGVkIHRvIFBvaW50IGFyZSBwcmVmaXhlZCB3aXRoIF9wMnRfXG4gICAgLy8gdG8gYXZvaWQgY29sbGlzaW9ucyBpZiBjdXN0b20gUG9pbnQgY2xhc3MgaXMgdXNlZC5cblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGdlcyB0aGlzIHBvaW50IGNvbnN0aXR1dGVzIGFuIHVwcGVyIGVuZGluZyBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjxFZGdlPn1cbiAgICAgKi9cbiAgICB0aGlzLl9wMnRfZWRnZV9saXN0ID0gbnVsbDtcbn07XG5cbi8qKlxuICogRm9yIHByZXR0eSBwcmludGluZ1xuICogQGV4YW1wbGVcbiAqICAgICAgXCJwPVwiICsgbmV3IHBvbHkydHJpLlBvaW50KDUsNDIpXG4gKiAgICAgIC8vIOKGkiBcInA9KDU7NDIpXCJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IDxjb2RlPlwiKHg7eSlcIjwvY29kZT5cbiAqL1xuUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHh5LnRvU3RyaW5nQmFzZSh0aGlzKTtcbn07XG5cbi8qKlxuICogSlNPTiBvdXRwdXQsIG9ubHkgY29vcmRpbmF0ZXNcbiAqIEBleGFtcGxlXG4gKiAgICAgIEpTT04uc3RyaW5naWZ5KG5ldyBwb2x5MnRyaS5Qb2ludCgxLDIpKVxuICogICAgICAvLyDihpIgJ3tcInhcIjoxLFwieVwiOjJ9J1xuICovXG5Qb2ludC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHsgeDogdGhpcy54LCB5OiB0aGlzLnkgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBQb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtQb2ludH0gbmV3IGNsb25lZCBwb2ludFxuICovXG5Qb2ludC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbn07XG5cbi8qKlxuICogU2V0IHRoaXMgUG9pbnQgaW5zdGFuY2UgdG8gdGhlIG9yaWdvLiA8Y29kZT4oMDsgMCk8L2NvZGU+XG4gKiBAcmV0dXJuIHtQb2ludH0gdGhpcyAoZm9yIGNoYWluaW5nKVxuICovXG5Qb2ludC5wcm90b3R5cGUuc2V0X3plcm8gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnggPSAwLjA7XG4gICAgdGhpcy55ID0gMC4wO1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGlzIGluc3RhbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggICBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0geSAgIGNvb3JkaW5hdGVcbiAqIEByZXR1cm4ge1BvaW50fSB0aGlzIChmb3IgY2hhaW5pbmcpXG4gKi9cblBvaW50LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy54ID0gK3ggfHwgMDtcbiAgICB0aGlzLnkgPSAreSB8fCAwO1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cbi8qKlxuICogTmVnYXRlIHRoaXMgUG9pbnQgaW5zdGFuY2UuIChjb21wb25lbnQtd2lzZSlcbiAqIEByZXR1cm4ge1BvaW50fSB0aGlzIChmb3IgY2hhaW5pbmcpXG4gKi9cblBvaW50LnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnggPSAtdGhpcy54O1xuICAgIHRoaXMueSA9IC10aGlzLnk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBBZGQgYW5vdGhlciBQb2ludCBvYmplY3QgdG8gdGhpcyBpbnN0YW5jZS4gKGNvbXBvbmVudC13aXNlKVxuICogQHBhcmFtIHshUG9pbnR9IG4gLSBQb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtQb2ludH0gdGhpcyAoZm9yIGNoYWluaW5nKVxuICovXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMueCArPSBuLng7XG4gICAgdGhpcy55ICs9IG4ueTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG4vKipcbiAqIFN1YnRyYWN0IHRoaXMgUG9pbnQgaW5zdGFuY2Ugd2l0aCBhbm90aGVyIHBvaW50IGdpdmVuLiAoY29tcG9uZW50LXdpc2UpXG4gKiBAcGFyYW0geyFQb2ludH0gbiAtIFBvaW50IG9iamVjdC5cbiAqIEByZXR1cm4ge1BvaW50fSB0aGlzIChmb3IgY2hhaW5pbmcpXG4gKi9cblBvaW50LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihuKSB7XG4gICAgdGhpcy54IC09IG4ueDtcbiAgICB0aGlzLnkgLT0gbi55O1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgdGhpcyBQb2ludCBpbnN0YW5jZSBieSBhIHNjYWxhci4gKGNvbXBvbmVudC13aXNlKVxuICogQHBhcmFtIHtudW1iZXJ9IHMgICBzY2FsYXIuXG4gKiBAcmV0dXJuIHtQb2ludH0gdGhpcyAoZm9yIGNoYWluaW5nKVxuICovXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24ocykge1xuICAgIHRoaXMueCAqPSBzO1xuICAgIHRoaXMueSAqPSBzO1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBkaXN0YW5jZSBvZiB0aGlzIFBvaW50IGluc3RhbmNlIGZyb20gdGhlIG9yaWdvLlxuICogQHJldHVybiB7bnVtYmVyfSBkaXN0YW5jZVxuICovXG5Qb2ludC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhpcyBQb2ludCBpbnN0YW5jZSAoYXMgYSB2ZWN0b3IpLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgb3JpZ2luYWwgZGlzdGFuY2Ugb2YgdGhpcyBpbnN0YW5jZSBmcm9tIHRoZSBvcmlnby5cbiAqL1xuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICAgIHRoaXMueCAvPSBsZW47XG4gICAgdGhpcy55IC89IGxlbjtcbiAgICByZXR1cm4gbGVuO1xufTtcblxuLyoqXG4gKiBUZXN0IHRoaXMgUG9pbnQgb2JqZWN0IHdpdGggYW5vdGhlciBmb3IgZXF1YWxpdHkuXG4gKiBAcGFyYW0geyFYWX0gcCAtIGFueSBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgc2FtZSB4IGFuZCB5IGNvb3JkaW5hdGVzLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICovXG5Qb2ludC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiB0aGlzLnggPT09IHAueCAmJiB0aGlzLnkgPT09IHAueTtcbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1Qb2ludCAoXCJzdGF0aWNcIiBtZXRob2RzKVxuXG4vKipcbiAqIE5lZ2F0ZSBhIHBvaW50IGNvbXBvbmVudC13aXNlIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBQb2ludCBvYmplY3QuXG4gKiBAcGFyYW0geyFYWX0gcCAtIGFueSBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7UG9pbnR9IHRoZSByZXN1bHRpbmcgUG9pbnQgb2JqZWN0LlxuICovXG5Qb2ludC5uZWdhdGUgPSBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCgtcC54LCAtcC55KTtcbn07XG5cbi8qKlxuICogQWRkIHR3byBwb2ludHMgY29tcG9uZW50LXdpc2UgYW5kIHJldHVybiB0aGUgcmVzdWx0IGFzIGEgbmV3IFBvaW50IG9iamVjdC5cbiAqIEBwYXJhbSB7IVhZfSBhIC0gYW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gYiAtIGFueSBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7UG9pbnR9IHRoZSByZXN1bHRpbmcgUG9pbnQgb2JqZWN0LlxuICovXG5Qb2ludC5hZGQgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludChhLnggKyBiLngsIGEueSArIGIueSk7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0IHR3byBwb2ludHMgY29tcG9uZW50LXdpc2UgYW5kIHJldHVybiB0aGUgcmVzdWx0IGFzIGEgbmV3IFBvaW50IG9iamVjdC5cbiAqIEBwYXJhbSB7IVhZfSBhIC0gYW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gYiAtIGFueSBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7UG9pbnR9IHRoZSByZXN1bHRpbmcgUG9pbnQgb2JqZWN0LlxuICovXG5Qb2ludC5zdWIgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludChhLnggLSBiLngsIGEueSAtIGIueSk7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGEgcG9pbnQgYnkgYSBzY2FsYXIgYW5kIHJldHVybiB0aGUgcmVzdWx0IGFzIGEgbmV3IFBvaW50IG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzIC0gdGhlIHNjYWxhclxuICogQHBhcmFtIHshWFl9IHAgLSBhbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge1BvaW50fSB0aGUgcmVzdWx0aW5nIFBvaW50IG9iamVjdC5cbiAqL1xuUG9pbnQubXVsID0gZnVuY3Rpb24ocywgcCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQocyAqIHAueCwgcyAqIHAueSk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gdGhlIGNyb3NzIHByb2R1Y3Qgb24gZWl0aGVyIHR3byBwb2ludHMgKHRoaXMgcHJvZHVjZXMgYSBzY2FsYXIpXG4gKiBvciBhIHBvaW50IGFuZCBhIHNjYWxhciAodGhpcyBwcm9kdWNlcyBhIHBvaW50KS5cbiAqIFRoaXMgZnVuY3Rpb24gcmVxdWlyZXMgdHdvIHBhcmFtZXRlcnMsIGVpdGhlciBtYXkgYmUgYSBQb2ludCBvYmplY3Qgb3IgYVxuICogbnVtYmVyLlxuICogQHBhcmFtICB7WFl8bnVtYmVyfSBhIC0gUG9pbnQgb2JqZWN0IG9yIHNjYWxhci5cbiAqIEBwYXJhbSAge1hZfG51bWJlcn0gYiAtIFBvaW50IG9iamVjdCBvciBzY2FsYXIuXG4gKiBAcmV0dXJuIHtQb2ludHxudW1iZXJ9IGEgUG9pbnQgb2JqZWN0IG9yIGEgbnVtYmVyLCBkZXBlbmRpbmcgb24gdGhlIHBhcmFtZXRlcnMuXG4gKi9cblBvaW50LmNyb3NzID0gZnVuY3Rpb24oYSwgYikge1xuICAgIGlmICh0eXBlb2YoYSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICh0eXBlb2YoYikgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAqIGI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KC1hICogYi55LCBhICogYi54KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YoYikgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KGIgKiBhLnksIC1iICogYS54KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhLnggKiBiLnkgLSBhLnkgKiBiLng7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCJQb2ludC1MaWtlXCJcbi8qXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBvcGVyYXRlIG9uIFwiUG9pbnRcIiBvciBhbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IFxuICogd2l0aCB7eCx5fSAoZHVjayB0eXBpbmcpLlxuICovXG5cblBvaW50LnRvU3RyaW5nID0geHkudG9TdHJpbmc7XG5Qb2ludC5jb21wYXJlID0geHkuY29tcGFyZTtcblBvaW50LmNtcCA9IHh5LmNvbXBhcmU7IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblBvaW50LmVxdWFscyA9IHh5LmVxdWFscztcblxuLyoqXG4gKiBQZWZvcm0gdGhlIGRvdCBwcm9kdWN0IG9uIHR3byB2ZWN0b3JzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHshWFl9IGEgLSBhbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBiIC0gYW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkb3QgcHJvZHVjdFxuICovXG5Qb2ludC5kb3QgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEueCAqIGIueCArIGEueSAqIGIueTtcbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tRXhwb3J0cyAocHVibGljIEFQSSlcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxufSx7XCIuL3h5XCI6MTF9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBQb2x5MlRyaSBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXG4gKiBcbiAqIHBvbHkydHJpLmpzIChKYXZhU2NyaXB0IHBvcnQpIChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3IzbWkvcG9seTJ0cmkuanNcbiAqIFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIDMtY2xhdXNlIEJTRCBMaWNlbnNlLCBzZWUgTElDRU5TRS50eHRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLypcbiAqIENsYXNzIGFkZGVkIGluIHRoZSBKYXZhU2NyaXB0IHZlcnNpb24gKHdhcyBub3QgcHJlc2VudCBpbiB0aGUgYysrIHZlcnNpb24pXG4gKi9cblxudmFyIHh5ID0gX2RlcmVxXygnLi94eScpO1xuXG4vKipcbiAqIEN1c3RvbSBleGNlcHRpb24gY2xhc3MgdG8gaW5kaWNhdGUgaW52YWxpZCBQb2ludCB2YWx1ZXNcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICogQGV4dGVuZHMgRXJyb3JcbiAqIEBzdHJ1Y3RcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSAtIGVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7QXJyYXkuPFhZPj19IHBvaW50cyAtIGludmFsaWQgcG9pbnRzXG4gKi9cbnZhciBQb2ludEVycm9yID0gZnVuY3Rpb24obWVzc2FnZSwgcG9pbnRzKSB7XG4gICAgdGhpcy5uYW1lID0gXCJQb2ludEVycm9yXCI7XG4gICAgLyoqXG4gICAgICogSW52YWxpZCBwb2ludHNcbiAgICAgKiBAcHVibGljXG4gICAgICogQHR5cGUge0FycmF5LjxYWT59XG4gICAgICovXG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHMgPSBwb2ludHMgfHwgW107XG4gICAgLyoqXG4gICAgICogRXJyb3IgbWVzc2FnZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJJbnZhbGlkIFBvaW50cyFcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gXCIgXCIgKyB4eS50b1N0cmluZyhwb2ludHNbaV0pO1xuICAgIH1cbn07XG5Qb2ludEVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuUG9pbnRFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludEVycm9yO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnRFcnJvcjtcblxufSx7XCIuL3h5XCI6MTF9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qXG4gKiBQb2x5MlRyaSBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXG4gKiBcbiAqIHBvbHkydHJpLmpzIChKYXZhU2NyaXB0IHBvcnQpIChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3IzbWkvcG9seTJ0cmkuanNcbiAqXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBQdWJsaWMgQVBJIGZvciBwb2x5MnRyaS5qc1xuICogQG1vZHVsZSBwb2x5MnRyaVxuICovXG5cblxuLyoqXG4gKiBJZiB5b3UgYXJlIG5vdCB1c2luZyBhIG1vZHVsZSBzeXN0ZW0gKGUuZy4gQ29tbW9uSlMsIFJlcXVpcmVKUyksIHlvdSBjYW4gYWNjZXNzIHRoaXMgbGlicmFyeVxuICogYXMgYSBnbG9iYWwgdmFyaWFibGUgPGNvZGU+cG9seTJ0cmk8L2NvZGU+IGkuZS4gPGNvZGU+d2luZG93LnBvbHkydHJpPC9jb2RlPiBpbiBhIGJyb3dzZXIuXG4gKiBAbmFtZSBwb2x5MnRyaVxuICogQGdsb2JhbFxuICogQHB1YmxpY1xuICogQHR5cGUge21vZHVsZTpwb2x5MnRyaX1cbiAqL1xudmFyIHByZXZpb3VzUG9seTJ0cmkgPSBnbG9iYWwucG9seTJ0cmk7XG4vKipcbiAqIEZvciBCcm93c2VyICsgJmx0O3NjcmlwdCZndDsgOlxuICogcmV2ZXJ0cyB0aGUge0BsaW5rY29kZSBwb2x5MnRyaX0gZ2xvYmFsIG9iamVjdCB0byBpdHMgcHJldmlvdXMgdmFsdWUsXG4gKiBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2UgY2FsbGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgICAgICAgICAgdmFyIHAgPSBwb2x5MnRyaS5ub0NvbmZsaWN0KCk7XG4gKiBAcHVibGljXG4gKiBAcmV0dXJuIHttb2R1bGU6cG9seTJ0cml9IGluc3RhbmNlIGNhbGxlZFxuICovXG4vLyAodGhpcyBmZWF0dXJlIGlzIG5vdCBhdXRvbWF0aWNhbGx5IHByb3ZpZGVkIGJ5IGJyb3dzZXJpZnkpLlxuZXhwb3J0cy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgZ2xvYmFsLnBvbHkydHJpID0gcHJldmlvdXNQb2x5MnRyaTtcbiAgICByZXR1cm4gZXhwb3J0cztcbn07XG5cbi8qKlxuICogcG9seTJ0cmkgbGlicmFyeSB2ZXJzaW9uXG4gKiBAcHVibGljXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5WRVJTSU9OID0gX2RlcmVxXygnLi4vZGlzdC92ZXJzaW9uLmpzb24nKS52ZXJzaW9uO1xuXG4vKipcbiAqIEV4cG9ydHMgdGhlIHtAbGlua2NvZGUgUG9pbnRFcnJvcn0gY2xhc3MuXG4gKiBAcHVibGljXG4gKiBAdHlwZWRlZiB7UG9pbnRFcnJvcn0gbW9kdWxlOnBvbHkydHJpLlBvaW50RXJyb3JcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnRzLlBvaW50RXJyb3IgPSBfZGVyZXFfKCcuL3BvaW50ZXJyb3InKTtcbi8qKlxuICogRXhwb3J0cyB0aGUge0BsaW5rY29kZSBQb2ludH0gY2xhc3MuXG4gKiBAcHVibGljXG4gKiBAdHlwZWRlZiB7UG9pbnR9IG1vZHVsZTpwb2x5MnRyaS5Qb2ludFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMuUG9pbnQgPSBfZGVyZXFfKCcuL3BvaW50Jyk7XG4vKipcbiAqIEV4cG9ydHMgdGhlIHtAbGlua2NvZGUgVHJpYW5nbGV9IGNsYXNzLlxuICogQHB1YmxpY1xuICogQHR5cGVkZWYge1RyaWFuZ2xlfSBtb2R1bGU6cG9seTJ0cmkuVHJpYW5nbGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnRzLlRyaWFuZ2xlID0gX2RlcmVxXygnLi90cmlhbmdsZScpO1xuLyoqXG4gKiBFeHBvcnRzIHRoZSB7QGxpbmtjb2RlIFN3ZWVwQ29udGV4dH0gY2xhc3MuXG4gKiBAcHVibGljXG4gKiBAdHlwZWRlZiB7U3dlZXBDb250ZXh0fSBtb2R1bGU6cG9seTJ0cmkuU3dlZXBDb250ZXh0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0cy5Td2VlcENvbnRleHQgPSBfZGVyZXFfKCcuL3N3ZWVwY29udGV4dCcpO1xuXG5cbi8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbnZhciBzd2VlcCA9IF9kZXJlcV8oJy4vc3dlZXAnKTtcbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rY29kZSBTd2VlcENvbnRleHQjdHJpYW5ndWxhdGV9IGluc3RlYWRcbiAqL1xuZXhwb3J0cy50cmlhbmd1bGF0ZSA9IHN3ZWVwLnRyaWFuZ3VsYXRlO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rY29kZSBTd2VlcENvbnRleHQjdHJpYW5ndWxhdGV9IGluc3RlYWRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFRyaWFuZ3VsYXRlIC0gdXNlIHtAbGlua2NvZGUgU3dlZXBDb250ZXh0I3RyaWFuZ3VsYXRlfSBpbnN0ZWFkXG4gKi9cbmV4cG9ydHMuc3dlZXAgPSB7VHJpYW5ndWxhdGU6IHN3ZWVwLnRyaWFuZ3VsYXRlfTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi4vZGlzdC92ZXJzaW9uLmpzb25cIjoxLFwiLi9wb2ludFwiOjQsXCIuL3BvaW50ZXJyb3JcIjo1LFwiLi9zd2VlcFwiOjcsXCIuL3N3ZWVwY29udGV4dFwiOjgsXCIuL3RyaWFuZ2xlXCI6OX1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIFBvbHkyVHJpIENvcHlyaWdodCAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cbiAqIFxuICogcG9seTJ0cmkuanMgKEphdmFTY3JpcHQgcG9ydCkgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcjNtaS9wb2x5MnRyaS5qc1xuICogXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgMy1jbGF1c2UgQlNEIExpY2Vuc2UsIHNlZSBMSUNFTlNFLnR4dFxuICovXG5cbi8qIGpzaGludCBsYXRlZGVmOm5vZnVuYywgbWF4Y29tcGxleGl0eTo5ICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFRoaXMgJ1N3ZWVwJyBtb2R1bGUgaXMgcHJlc2VudCBpbiBvcmRlciB0byBrZWVwIHRoaXMgSmF2YVNjcmlwdCB2ZXJzaW9uXG4gKiBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byB0aGUgcmVmZXJlbmNlIEMrKyB2ZXJzaW9uLCBldmVuIHRob3VnaCBhbG1vc3QgYWxsXG4gKiBmdW5jdGlvbnMgY291bGQgYmUgZGVjbGFyZWQgYXMgbWV0aG9kcyBvbiB0aGUge0BsaW5rY29kZSBtb2R1bGU6c3dlZXBjb250ZXh0flN3ZWVwQ29udGV4dH0gb2JqZWN0LlxuICogQG1vZHVsZVxuICogQHByaXZhdGVcbiAqL1xuXG4vKlxuICogTm90ZVxuICogPT09PVxuICogdGhlIHN0cnVjdHVyZSBvZiB0aGlzIEphdmFTY3JpcHQgdmVyc2lvbiBvZiBwb2x5MnRyaSBpbnRlbnRpb25hbGx5IGZvbGxvd3NcbiAqIGFzIGNsb3NlbHkgYXMgcG9zc2libGUgdGhlIHN0cnVjdHVyZSBvZiB0aGUgcmVmZXJlbmNlIEMrKyB2ZXJzaW9uLCB0byBtYWtlIGl0IFxuICogZWFzaWVyIHRvIGtlZXAgdGhlIDIgdmVyc2lvbnMgaW4gc3luYy5cbiAqL1xuXG52YXIgYXNzZXJ0ID0gX2RlcmVxXygnLi9hc3NlcnQnKTtcbnZhciBQb2ludEVycm9yID0gX2RlcmVxXygnLi9wb2ludGVycm9yJyk7XG52YXIgVHJpYW5nbGUgPSBfZGVyZXFfKCcuL3RyaWFuZ2xlJyk7XG52YXIgTm9kZSA9IF9kZXJlcV8oJy4vYWR2YW5jaW5nZnJvbnQnKS5Ob2RlO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXV0aWxzXG5cbnZhciB1dGlscyA9IF9kZXJlcV8oJy4vdXRpbHMnKTtcblxuLyoqIEBjb25zdCAqL1xudmFyIEVQU0lMT04gPSB1dGlscy5FUFNJTE9OO1xuXG4vKiogQGNvbnN0ICovXG52YXIgT3JpZW50YXRpb24gPSB1dGlscy5PcmllbnRhdGlvbjtcbi8qKiBAY29uc3QgKi9cbnZhciBvcmllbnQyZCA9IHV0aWxzLm9yaWVudDJkO1xuLyoqIEBjb25zdCAqL1xudmFyIGluU2NhbkFyZWEgPSB1dGlscy5pblNjYW5BcmVhO1xuLyoqIEBjb25zdCAqL1xudmFyIGlzQW5nbGVPYnR1c2UgPSB1dGlscy5pc0FuZ2xlT2J0dXNlO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVN3ZWVwXG5cbi8qKlxuICogVHJpYW5ndWxhdGUgdGhlIHBvbHlnb24gd2l0aCBob2xlcyBhbmQgU3RlaW5lciBwb2ludHMuXG4gKiBEbyB0aGlzIEFGVEVSIHlvdSd2ZSBhZGRlZCB0aGUgcG9seWxpbmUsIGhvbGVzLCBhbmQgU3RlaW5lciBwb2ludHNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyFTd2VlcENvbnRleHR9IHRjeCAtIFN3ZWVwQ29udGV4dCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gdHJpYW5ndWxhdGUodGN4KSB7XG4gICAgdGN4LmluaXRUcmlhbmd1bGF0aW9uKCk7XG4gICAgdGN4LmNyZWF0ZUFkdmFuY2luZ0Zyb250KCk7XG4gICAgLy8gU3dlZXAgcG9pbnRzOyBidWlsZCBtZXNoXG4gICAgc3dlZXBQb2ludHModGN4KTtcbiAgICAvLyBDbGVhbiB1cFxuICAgIGZpbmFsaXphdGlvblBvbHlnb24odGN4KTtcbn1cblxuLyoqXG4gKiBTdGFydCBzd2VlcGluZyB0aGUgWS1zb3J0ZWQgcG9pbnQgc2V0IGZyb20gYm90dG9tIHRvIHRvcFxuICogQHBhcmFtIHshU3dlZXBDb250ZXh0fSB0Y3ggLSBTd2VlcENvbnRleHQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHN3ZWVwUG9pbnRzKHRjeCkge1xuICAgIHZhciBpLCBsZW4gPSB0Y3gucG9pbnRDb3VudCgpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0Y3guZ2V0UG9pbnQoaSk7XG4gICAgICAgIHZhciBub2RlID0gcG9pbnRFdmVudCh0Y3gsIHBvaW50KTtcbiAgICAgICAgdmFyIGVkZ2VzID0gcG9pbnQuX3AydF9lZGdlX2xpc3Q7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBlZGdlcyAmJiBqIDwgZWRnZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGVkZ2VFdmVudEJ5RWRnZSh0Y3gsIGVkZ2VzW2pdLCBub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyFTd2VlcENvbnRleHR9IHRjeCAtIFN3ZWVwQ29udGV4dCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZmluYWxpemF0aW9uUG9seWdvbih0Y3gpIHtcbiAgICAvLyBHZXQgYW4gSW50ZXJuYWwgdHJpYW5nbGUgdG8gc3RhcnQgd2l0aFxuICAgIHZhciB0ID0gdGN4LmZyb250KCkuaGVhZCgpLm5leHQudHJpYW5nbGU7XG4gICAgdmFyIHAgPSB0Y3guZnJvbnQoKS5oZWFkKCkubmV4dC5wb2ludDtcbiAgICB3aGlsZSAoIXQuZ2V0Q29uc3RyYWluZWRFZGdlQ1cocCkpIHtcbiAgICAgICAgdCA9IHQubmVpZ2hib3JDQ1cocCk7XG4gICAgfVxuXG4gICAgLy8gQ29sbGVjdCBpbnRlcmlvciB0cmlhbmdsZXMgY29uc3RyYWluZWQgYnkgZWRnZXNcbiAgICB0Y3gubWVzaENsZWFuKHQpO1xufVxuXG4vKipcbiAqIEZpbmQgY2xvc2VzIG5vZGUgdG8gdGhlIGxlZnQgb2YgdGhlIG5ldyBwb2ludCBhbmRcbiAqIGNyZWF0ZSBhIG5ldyB0cmlhbmdsZS4gSWYgbmVlZGVkIG5ldyBob2xlcyBhbmQgYmFzaW5zXG4gKiB3aWxsIGJlIGZpbGxlZCB0by5cbiAqIEBwYXJhbSB7IVN3ZWVwQ29udGV4dH0gdGN4IC0gU3dlZXBDb250ZXh0IG9iamVjdFxuICogQHBhcmFtIHshWFl9IHBvaW50ICAgUG9pbnRcbiAqL1xuZnVuY3Rpb24gcG9pbnRFdmVudCh0Y3gsIHBvaW50KSB7XG4gICAgdmFyIG5vZGUgPSB0Y3gubG9jYXRlTm9kZShwb2ludCk7XG4gICAgdmFyIG5ld19ub2RlID0gbmV3RnJvbnRUcmlhbmdsZSh0Y3gsIHBvaW50LCBub2RlKTtcblxuICAgIC8vIE9ubHkgbmVlZCB0byBjaGVjayArZXBzaWxvbiBzaW5jZSBwb2ludCBuZXZlciBoYXZlIHNtYWxsZXJcbiAgICAvLyB4IHZhbHVlIHRoYW4gbm9kZSBkdWUgdG8gaG93IHdlIGZldGNoIG5vZGVzIGZyb20gdGhlIGZyb250XG4gICAgaWYgKHBvaW50LnggPD0gbm9kZS5wb2ludC54ICsgKEVQU0lMT04pKSB7XG4gICAgICAgIGZpbGwodGN4LCBub2RlKTtcbiAgICB9XG5cbiAgICAvL3RjeC5BZGROb2RlKG5ld19ub2RlKTtcblxuICAgIGZpbGxBZHZhbmNpbmdGcm9udCh0Y3gsIG5ld19ub2RlKTtcbiAgICByZXR1cm4gbmV3X25vZGU7XG59XG5cbmZ1bmN0aW9uIGVkZ2VFdmVudEJ5RWRnZSh0Y3gsIGVkZ2UsIG5vZGUpIHtcbiAgICB0Y3guZWRnZV9ldmVudC5jb25zdHJhaW5lZF9lZGdlID0gZWRnZTtcbiAgICB0Y3guZWRnZV9ldmVudC5yaWdodCA9IChlZGdlLnAueCA+IGVkZ2UucS54KTtcblxuICAgIGlmIChpc0VkZ2VTaWRlT2ZUcmlhbmdsZShub2RlLnRyaWFuZ2xlLCBlZGdlLnAsIGVkZ2UucSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZvciBub3cgd2Ugd2lsbCBkbyBhbGwgbmVlZGVkIGZpbGxpbmdcbiAgICAvLyBUT0RPOiBpbnRlZ3JhdGUgd2l0aCBmbGlwIHByb2Nlc3MgbWlnaHQgZ2l2ZSBzb21lIGJldHRlciBwZXJmb3JtYW5jZVxuICAgIC8vICAgICAgIGJ1dCBmb3Igbm93IHRoaXMgYXZvaWQgdGhlIGlzc3VlIHdpdGggY2FzZXMgdGhhdCBuZWVkcyBib3RoIGZsaXBzIGFuZCBmaWxsc1xuICAgIGZpbGxFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICBlZGdlRXZlbnRCeVBvaW50cyh0Y3gsIGVkZ2UucCwgZWRnZS5xLCBub2RlLnRyaWFuZ2xlLCBlZGdlLnEpO1xufVxuXG5mdW5jdGlvbiBlZGdlRXZlbnRCeVBvaW50cyh0Y3gsIGVwLCBlcSwgdHJpYW5nbGUsIHBvaW50KSB7XG4gICAgaWYgKGlzRWRnZVNpZGVPZlRyaWFuZ2xlKHRyaWFuZ2xlLCBlcCwgZXEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcDEgPSB0cmlhbmdsZS5wb2ludENDVyhwb2ludCk7XG4gICAgdmFyIG8xID0gb3JpZW50MmQoZXEsIHAxLCBlcCk7XG4gICAgaWYgKG8xID09PSBPcmllbnRhdGlvbi5DT0xMSU5FQVIpIHtcbiAgICAgICAgLy8gVE9ETyBpbnRlZ3JhdGUgaGVyZSBjaGFuZ2VzIGZyb20gQysrIHZlcnNpb25cbiAgICAgICAgLy8gKEMrKyByZXBvIHJldmlzaW9uIDA5ODgwYTg2OTA5NSBkYXRlZCBNYXJjaCA4LCAyMDExKVxuICAgICAgICB0aHJvdyBuZXcgUG9pbnRFcnJvcigncG9seTJ0cmkgRWRnZUV2ZW50OiBDb2xsaW5lYXIgbm90IHN1cHBvcnRlZCEnLCBbZXEsIHAxLCBlcF0pO1xuICAgIH1cblxuICAgIHZhciBwMiA9IHRyaWFuZ2xlLnBvaW50Q1cocG9pbnQpO1xuICAgIHZhciBvMiA9IG9yaWVudDJkKGVxLCBwMiwgZXApO1xuICAgIGlmIChvMiA9PT0gT3JpZW50YXRpb24uQ09MTElORUFSKSB7XG4gICAgICAgIC8vIFRPRE8gaW50ZWdyYXRlIGhlcmUgY2hhbmdlcyBmcm9tIEMrKyB2ZXJzaW9uXG4gICAgICAgIC8vIChDKysgcmVwbyByZXZpc2lvbiAwOTg4MGE4NjkwOTUgZGF0ZWQgTWFyY2ggOCwgMjAxMSlcbiAgICAgICAgdGhyb3cgbmV3IFBvaW50RXJyb3IoJ3BvbHkydHJpIEVkZ2VFdmVudDogQ29sbGluZWFyIG5vdCBzdXBwb3J0ZWQhJywgW2VxLCBwMiwgZXBdKTtcbiAgICB9XG5cbiAgICBpZiAobzEgPT09IG8yKSB7XG4gICAgICAgIC8vIE5lZWQgdG8gZGVjaWRlIGlmIHdlIGFyZSByb3RhdGluZyBDVyBvciBDQ1cgdG8gZ2V0IHRvIGEgdHJpYW5nbGVcbiAgICAgICAgLy8gdGhhdCB3aWxsIGNyb3NzIGVkZ2VcbiAgICAgICAgaWYgKG8xID09PSBPcmllbnRhdGlvbi5DVykge1xuICAgICAgICAgICAgdHJpYW5nbGUgPSB0cmlhbmdsZS5uZWlnaGJvckNDVyhwb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmlhbmdsZSA9IHRyaWFuZ2xlLm5laWdoYm9yQ1cocG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVkZ2VFdmVudEJ5UG9pbnRzKHRjeCwgZXAsIGVxLCB0cmlhbmdsZSwgcG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdHJpYW5nbGUgY3Jvc3NlcyBjb25zdHJhaW50IHNvIGxldHMgZmxpcHBpbiBzdGFydCFcbiAgICAgICAgZmxpcEVkZ2VFdmVudCh0Y3gsIGVwLCBlcSwgdHJpYW5nbGUsIHBvaW50KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRWRnZVNpZGVPZlRyaWFuZ2xlKHRyaWFuZ2xlLCBlcCwgZXEpIHtcbiAgICB2YXIgaW5kZXggPSB0cmlhbmdsZS5lZGdlSW5kZXgoZXAsIGVxKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRyaWFuZ2xlLm1hcmtDb25zdHJhaW5lZEVkZ2VCeUluZGV4KGluZGV4KTtcbiAgICAgICAgdmFyIHQgPSB0cmlhbmdsZS5nZXROZWlnaGJvcihpbmRleCk7XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICB0Lm1hcmtDb25zdHJhaW5lZEVkZ2VCeVBvaW50cyhlcCwgZXEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmcm9udCB0cmlhbmdsZSBhbmQgbGVnYWxpemUgaXRcbiAqIEBwYXJhbSB7IVN3ZWVwQ29udGV4dH0gdGN4IC0gU3dlZXBDb250ZXh0IG9iamVjdFxuICovXG5mdW5jdGlvbiBuZXdGcm9udFRyaWFuZ2xlKHRjeCwgcG9pbnQsIG5vZGUpIHtcbiAgICB2YXIgdHJpYW5nbGUgPSBuZXcgVHJpYW5nbGUocG9pbnQsIG5vZGUucG9pbnQsIG5vZGUubmV4dC5wb2ludCk7XG5cbiAgICB0cmlhbmdsZS5tYXJrTmVpZ2hib3Iobm9kZS50cmlhbmdsZSk7XG4gICAgdGN4LmFkZFRvTWFwKHRyaWFuZ2xlKTtcblxuICAgIHZhciBuZXdfbm9kZSA9IG5ldyBOb2RlKHBvaW50KTtcbiAgICBuZXdfbm9kZS5uZXh0ID0gbm9kZS5uZXh0O1xuICAgIG5ld19ub2RlLnByZXYgPSBub2RlO1xuICAgIG5vZGUubmV4dC5wcmV2ID0gbmV3X25vZGU7XG4gICAgbm9kZS5uZXh0ID0gbmV3X25vZGU7XG5cbiAgICBpZiAoIWxlZ2FsaXplKHRjeCwgdHJpYW5nbGUpKSB7XG4gICAgICAgIHRjeC5tYXBUcmlhbmdsZVRvTm9kZXModHJpYW5nbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdfbm9kZTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgdHJpYW5nbGUgdG8gdGhlIGFkdmFuY2luZyBmcm9udCB0byBmaWxsIGEgaG9sZS5cbiAqIEBwYXJhbSB7IVN3ZWVwQ29udGV4dH0gdGN4IC0gU3dlZXBDb250ZXh0IG9iamVjdFxuICogQHBhcmFtIG5vZGUgLSBtaWRkbGUgbm9kZSwgdGhhdCBpcyB0aGUgYm90dG9tIG9mIHRoZSBob2xlXG4gKi9cbmZ1bmN0aW9uIGZpbGwodGN4LCBub2RlKSB7XG4gICAgdmFyIHRyaWFuZ2xlID0gbmV3IFRyaWFuZ2xlKG5vZGUucHJldi5wb2ludCwgbm9kZS5wb2ludCwgbm9kZS5uZXh0LnBvaW50KTtcblxuICAgIC8vIFRPRE86IHNob3VsZCBjb3B5IHRoZSBjb25zdHJhaW5lZF9lZGdlIHZhbHVlIGZyb20gbmVpZ2hib3IgdHJpYW5nbGVzXG4gICAgLy8gICAgICAgZm9yIG5vdyBjb25zdHJhaW5lZF9lZGdlIHZhbHVlcyBhcmUgY29waWVkIGR1cmluZyB0aGUgbGVnYWxpemVcbiAgICB0cmlhbmdsZS5tYXJrTmVpZ2hib3Iobm9kZS5wcmV2LnRyaWFuZ2xlKTtcbiAgICB0cmlhbmdsZS5tYXJrTmVpZ2hib3Iobm9kZS50cmlhbmdsZSk7XG5cbiAgICB0Y3guYWRkVG9NYXAodHJpYW5nbGUpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBhZHZhbmNpbmcgZnJvbnRcbiAgICBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcblxuXG4gICAgLy8gSWYgaXQgd2FzIGxlZ2FsaXplZCB0aGUgdHJpYW5nbGUgaGFzIGFscmVhZHkgYmVlbiBtYXBwZWRcbiAgICBpZiAoIWxlZ2FsaXplKHRjeCwgdHJpYW5nbGUpKSB7XG4gICAgICAgIHRjeC5tYXBUcmlhbmdsZVRvTm9kZXModHJpYW5nbGUpO1xuICAgIH1cblxuICAgIC8vdGN4LnJlbW92ZU5vZGUobm9kZSk7XG59XG5cbi8qKlxuICogRmlsbHMgaG9sZXMgaW4gdGhlIEFkdmFuY2luZyBGcm9udFxuICogQHBhcmFtIHshU3dlZXBDb250ZXh0fSB0Y3ggLSBTd2VlcENvbnRleHQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGZpbGxBZHZhbmNpbmdGcm9udCh0Y3gsIG4pIHtcbiAgICAvLyBGaWxsIHJpZ2h0IGhvbGVzXG4gICAgdmFyIG5vZGUgPSBuLm5leHQ7XG4gICAgd2hpbGUgKG5vZGUubmV4dCkge1xuICAgICAgICAvLyBUT0RPIGludGVncmF0ZSBoZXJlIGNoYW5nZXMgZnJvbSBDKysgdmVyc2lvblxuICAgICAgICAvLyAoQysrIHJlcG8gcmV2aXNpb24gYWNmODFmMWYxNzY0IGRhdGVkIEFwcmlsIDcsIDIwMTIpXG4gICAgICAgIGlmIChpc0FuZ2xlT2J0dXNlKG5vZGUucG9pbnQsIG5vZGUubmV4dC5wb2ludCwgbm9kZS5wcmV2LnBvaW50KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZmlsbCh0Y3gsIG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH1cblxuICAgIC8vIEZpbGwgbGVmdCBob2xlc1xuICAgIG5vZGUgPSBuLnByZXY7XG4gICAgd2hpbGUgKG5vZGUucHJldikge1xuICAgICAgICAvLyBUT0RPIGludGVncmF0ZSBoZXJlIGNoYW5nZXMgZnJvbSBDKysgdmVyc2lvblxuICAgICAgICAvLyAoQysrIHJlcG8gcmV2aXNpb24gYWNmODFmMWYxNzY0IGRhdGVkIEFwcmlsIDcsIDIwMTIpXG4gICAgICAgIGlmIChpc0FuZ2xlT2J0dXNlKG5vZGUucG9pbnQsIG5vZGUubmV4dC5wb2ludCwgbm9kZS5wcmV2LnBvaW50KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZmlsbCh0Y3gsIG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wcmV2O1xuICAgIH1cblxuICAgIC8vIEZpbGwgcmlnaHQgYmFzaW5zXG4gICAgaWYgKG4ubmV4dCAmJiBuLm5leHQubmV4dCkge1xuICAgICAgICBpZiAoaXNCYXNpbkFuZ2xlUmlnaHQobikpIHtcbiAgICAgICAgICAgIGZpbGxCYXNpbih0Y3gsIG4pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBiYXNpbiBhbmdsZSBpcyBkZWNpZGVkIGFnYWluc3QgdGhlIGhvcml6b250YWwgbGluZSBbMSwwXS5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbmdsZSA8IDMqz4AvNFxuICovXG5mdW5jdGlvbiBpc0Jhc2luQW5nbGVSaWdodChub2RlKSB7XG4gICAgdmFyIGF4ID0gbm9kZS5wb2ludC54IC0gbm9kZS5uZXh0Lm5leHQucG9pbnQueDtcbiAgICB2YXIgYXkgPSBub2RlLnBvaW50LnkgLSBub2RlLm5leHQubmV4dC5wb2ludC55O1xuICAgIGFzc2VydChheSA+PSAwLCBcInVub3JkZXJlZCB5XCIpO1xuICAgIHJldHVybiAoYXggPj0gMCB8fCBNYXRoLmFicyhheCkgPCBheSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRyaWFuZ2xlIHdhcyBsZWdhbGl6ZWRcbiAqIEBwYXJhbSB7IVN3ZWVwQ29udGV4dH0gdGN4IC0gU3dlZXBDb250ZXh0IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbGVnYWxpemUodGN4LCB0KSB7XG4gICAgLy8gVG8gbGVnYWxpemUgYSB0cmlhbmdsZSB3ZSBzdGFydCBieSBmaW5kaW5nIGlmIGFueSBvZiB0aGUgdGhyZWUgZWRnZXNcbiAgICAvLyB2aW9sYXRlIHRoZSBEZWxhdW5heSBjb25kaXRpb25cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7ICsraSkge1xuICAgICAgICBpZiAodC5kZWxhdW5heV9lZGdlW2ldKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3QgPSB0LmdldE5laWdoYm9yKGkpO1xuICAgICAgICBpZiAob3QpIHtcbiAgICAgICAgICAgIHZhciBwID0gdC5nZXRQb2ludChpKTtcbiAgICAgICAgICAgIHZhciBvcCA9IG90Lm9wcG9zaXRlUG9pbnQodCwgcCk7XG4gICAgICAgICAgICB2YXIgb2kgPSBvdC5pbmRleChvcCk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBDb25zdHJhaW5lZCBFZGdlIG9yIGEgRGVsYXVuYXkgRWRnZShvbmx5IGR1cmluZyByZWN1cnNpdmUgbGVnYWxpemF0aW9uKVxuICAgICAgICAgICAgLy8gdGhlbiB3ZSBzaG91bGQgbm90IHRyeSB0byBsZWdhbGl6ZVxuICAgICAgICAgICAgaWYgKG90LmNvbnN0cmFpbmVkX2VkZ2Vbb2ldIHx8IG90LmRlbGF1bmF5X2VkZ2Vbb2ldKSB7XG4gICAgICAgICAgICAgICAgdC5jb25zdHJhaW5lZF9lZGdlW2ldID0gb3QuY29uc3RyYWluZWRfZWRnZVtvaV07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbnNpZGUgPSBpbkNpcmNsZShwLCB0LnBvaW50Q0NXKHApLCB0LnBvaW50Q1cocCksIG9wKTtcbiAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBMZXRzIG1hcmsgdGhpcyBzaGFyZWQgZWRnZSBhcyBEZWxhdW5heVxuICAgICAgICAgICAgICAgIHQuZGVsYXVuYXlfZWRnZVtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgb3QuZGVsYXVuYXlfZWRnZVtvaV0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gTGV0cyByb3RhdGUgc2hhcmVkIGVkZ2Ugb25lIHZlcnRleCBDVyB0byBsZWdhbGl6ZSBpdFxuICAgICAgICAgICAgICAgIHJvdGF0ZVRyaWFuZ2xlUGFpcih0LCBwLCBvdCwgb3ApO1xuXG4gICAgICAgICAgICAgICAgLy8gV2Ugbm93IGdvdCBvbmUgdmFsaWQgRGVsYXVuYXkgRWRnZSBzaGFyZWQgYnkgdHdvIHRyaWFuZ2xlc1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZ2l2ZXMgdXMgNCBuZXcgZWRnZXMgdG8gY2hlY2sgZm9yIERlbGF1bmF5XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0cmlhbmdsZSB0byBub2RlIG1hcHBpbmcgaXMgZG9uZSBvbmx5IG9uZSB0aW1lIGZvciBhIHNwZWNpZmljIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgdmFyIG5vdF9sZWdhbGl6ZWQgPSAhbGVnYWxpemUodGN4LCB0KTtcbiAgICAgICAgICAgICAgICBpZiAobm90X2xlZ2FsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICB0Y3gubWFwVHJpYW5nbGVUb05vZGVzKHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vdF9sZWdhbGl6ZWQgPSAhbGVnYWxpemUodGN4LCBvdCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vdF9sZWdhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGN4Lm1hcFRyaWFuZ2xlVG9Ob2RlcyhvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBEZWxhdW5heSBlZGdlcywgc2luY2UgdGhleSBvbmx5IGFyZSB2YWxpZCBEZWxhdW5heSBlZGdlc1xuICAgICAgICAgICAgICAgIC8vIHVudGlsIHdlIGFkZCBhIG5ldyB0cmlhbmdsZSBvciBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBYWFg6IG5lZWQgdG8gdGhpbmsgYWJvdXQgdGhpcy4gQ2FuIHRoZXNlIGVkZ2VzIGJlIHRyaWVkIGFmdGVyIHdlXG4gICAgICAgICAgICAgICAgLy8gICAgICByZXR1cm4gdG8gcHJldmlvdXMgcmVjdXJzaXZlIGxldmVsP1xuICAgICAgICAgICAgICAgIHQuZGVsYXVuYXlfZWRnZVtpXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG90LmRlbGF1bmF5X2VkZ2Vbb2ldID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0cmlhbmdsZSBoYXZlIGJlZW4gbGVnYWxpemVkIG5vIG5lZWQgdG8gY2hlY2sgdGhlIG90aGVyIGVkZ2VzIHNpbmNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlY3Vyc2l2ZSBsZWdhbGl6YXRpb24gd2lsbCBoYW5kbGVzIHRob3NlIHNvIHdlIGNhbiBlbmQgaGVyZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogPGI+UmVxdWlyZW1lbnQ8L2I+Ojxicj5cbiAqIDEuIGEsYiBhbmQgYyBmb3JtIGEgdHJpYW5nbGUuPGJyPlxuICogMi4gYSBhbmQgZCBpcyBrbm93IHRvIGJlIG9uIG9wcG9zaXRlIHNpZGUgb2YgYmM8YnI+XG4gKiA8cHJlPlxuICogICAgICAgICAgICAgICAgYVxuICogICAgICAgICAgICAgICAgK1xuICogICAgICAgICAgICAgICAvIFxcXG4gKiAgICAgICAgICAgICAgLyAgIFxcXG4gKiAgICAgICAgICAgIGIvICAgICBcXGNcbiAqICAgICAgICAgICAgKy0tLS0tLS0rXG4gKiAgICAgICAgICAgLyAgICBkICAgIFxcXG4gKiAgICAgICAgICAvICAgICAgICAgICBcXFxuICogPC9wcmU+XG4gKiA8Yj5GYWN0PC9iPjogZCBoYXMgdG8gYmUgaW4gYXJlYSBCIHRvIGhhdmUgYSBjaGFuY2UgdG8gYmUgaW5zaWRlIHRoZSBjaXJjbGUgZm9ybWVkIGJ5XG4gKiAgYSxiIGFuZCBjPGJyPlxuICogIGQgaXMgb3V0c2lkZSBCIGlmIG9yaWVudDJkKGEsYixkKSBvciBvcmllbnQyZChjLGEsZCkgaXMgQ1c8YnI+XG4gKiAgVGhpcyBwcmVrbm93bGVkZ2UgZ2l2ZXMgdXMgYSB3YXkgdG8gb3B0aW1pemUgdGhlIGluY2lyY2xlIHRlc3RcbiAqIEBwYXJhbSBwYSAtIHRyaWFuZ2xlIHBvaW50LCBvcHBvc2l0ZSBkXG4gKiBAcGFyYW0gcGIgLSB0cmlhbmdsZSBwb2ludFxuICogQHBhcmFtIHBjIC0gdHJpYW5nbGUgcG9pbnRcbiAqIEBwYXJhbSBwZCAtIHBvaW50IG9wcG9zaXRlIGFcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgZCBpcyBpbnNpZGUgY2lyY2xlLCBmYWxzZSBpZiBvbiBjaXJjbGUgZWRnZVxuICovXG5mdW5jdGlvbiBpbkNpcmNsZShwYSwgcGIsIHBjLCBwZCkge1xuICAgIHZhciBhZHggPSBwYS54IC0gcGQueDtcbiAgICB2YXIgYWR5ID0gcGEueSAtIHBkLnk7XG4gICAgdmFyIGJkeCA9IHBiLnggLSBwZC54O1xuICAgIHZhciBiZHkgPSBwYi55IC0gcGQueTtcblxuICAgIHZhciBhZHhiZHkgPSBhZHggKiBiZHk7XG4gICAgdmFyIGJkeGFkeSA9IGJkeCAqIGFkeTtcbiAgICB2YXIgb2FiZCA9IGFkeGJkeSAtIGJkeGFkeTtcbiAgICBpZiAob2FiZCA8PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2R4ID0gcGMueCAtIHBkLng7XG4gICAgdmFyIGNkeSA9IHBjLnkgLSBwZC55O1xuXG4gICAgdmFyIGNkeGFkeSA9IGNkeCAqIGFkeTtcbiAgICB2YXIgYWR4Y2R5ID0gYWR4ICogY2R5O1xuICAgIHZhciBvY2FkID0gY2R4YWR5IC0gYWR4Y2R5O1xuICAgIGlmIChvY2FkIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBiZHhjZHkgPSBiZHggKiBjZHk7XG4gICAgdmFyIGNkeGJkeSA9IGNkeCAqIGJkeTtcblxuICAgIHZhciBhbGlmdCA9IGFkeCAqIGFkeCArIGFkeSAqIGFkeTtcbiAgICB2YXIgYmxpZnQgPSBiZHggKiBiZHggKyBiZHkgKiBiZHk7XG4gICAgdmFyIGNsaWZ0ID0gY2R4ICogY2R4ICsgY2R5ICogY2R5O1xuXG4gICAgdmFyIGRldCA9IGFsaWZ0ICogKGJkeGNkeSAtIGNkeGJkeSkgKyBibGlmdCAqIG9jYWQgKyBjbGlmdCAqIG9hYmQ7XG4gICAgcmV0dXJuIGRldCA+IDA7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIHRyaWFuZ2xlIHBhaXIgb25lIHZlcnRleCBDV1xuICo8cHJlPlxuICogICAgICAgbjIgICAgICAgICAgICAgICAgICAgIG4yXG4gKiAgUCArLS0tLS0rICAgICAgICAgICAgIFAgKy0tLS0tK1xuICogICAgfCB0ICAvfCAgICAgICAgICAgICAgIHxcXCAgdCB8XG4gKiAgICB8ICAgLyB8ICAgICAgICAgICAgICAgfCBcXCAgIHxcbiAqICBuMXwgIC8gIHxuMyAgICAgICAgICAgbjF8ICBcXCAgfG4zXG4gKiAgICB8IC8gICB8ICAgIGFmdGVyIENXICAgfCAgIFxcIHxcbiAqICAgIHwvIG9UIHwgICAgICAgICAgICAgICB8IG9UIFxcfFxuICogICAgKy0tLS0tKyBvUCAgICAgICAgICAgICstLS0tLStcbiAqICAgICAgIG40ICAgICAgICAgICAgICAgICAgICBuNFxuICogPC9wcmU+XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVRyaWFuZ2xlUGFpcih0LCBwLCBvdCwgb3ApIHtcbiAgICB2YXIgbjEsIG4yLCBuMywgbjQ7XG4gICAgbjEgPSB0Lm5laWdoYm9yQ0NXKHApO1xuICAgIG4yID0gdC5uZWlnaGJvckNXKHApO1xuICAgIG4zID0gb3QubmVpZ2hib3JDQ1cob3ApO1xuICAgIG40ID0gb3QubmVpZ2hib3JDVyhvcCk7XG5cbiAgICB2YXIgY2UxLCBjZTIsIGNlMywgY2U0O1xuICAgIGNlMSA9IHQuZ2V0Q29uc3RyYWluZWRFZGdlQ0NXKHApO1xuICAgIGNlMiA9IHQuZ2V0Q29uc3RyYWluZWRFZGdlQ1cocCk7XG4gICAgY2UzID0gb3QuZ2V0Q29uc3RyYWluZWRFZGdlQ0NXKG9wKTtcbiAgICBjZTQgPSBvdC5nZXRDb25zdHJhaW5lZEVkZ2VDVyhvcCk7XG5cbiAgICB2YXIgZGUxLCBkZTIsIGRlMywgZGU0O1xuICAgIGRlMSA9IHQuZ2V0RGVsYXVuYXlFZGdlQ0NXKHApO1xuICAgIGRlMiA9IHQuZ2V0RGVsYXVuYXlFZGdlQ1cocCk7XG4gICAgZGUzID0gb3QuZ2V0RGVsYXVuYXlFZGdlQ0NXKG9wKTtcbiAgICBkZTQgPSBvdC5nZXREZWxhdW5heUVkZ2VDVyhvcCk7XG5cbiAgICB0LmxlZ2FsaXplKHAsIG9wKTtcbiAgICBvdC5sZWdhbGl6ZShvcCwgcCk7XG5cbiAgICAvLyBSZW1hcCBkZWxhdW5heV9lZGdlXG4gICAgb3Quc2V0RGVsYXVuYXlFZGdlQ0NXKHAsIGRlMSk7XG4gICAgdC5zZXREZWxhdW5heUVkZ2VDVyhwLCBkZTIpO1xuICAgIHQuc2V0RGVsYXVuYXlFZGdlQ0NXKG9wLCBkZTMpO1xuICAgIG90LnNldERlbGF1bmF5RWRnZUNXKG9wLCBkZTQpO1xuXG4gICAgLy8gUmVtYXAgY29uc3RyYWluZWRfZWRnZVxuICAgIG90LnNldENvbnN0cmFpbmVkRWRnZUNDVyhwLCBjZTEpO1xuICAgIHQuc2V0Q29uc3RyYWluZWRFZGdlQ1cocCwgY2UyKTtcbiAgICB0LnNldENvbnN0cmFpbmVkRWRnZUNDVyhvcCwgY2UzKTtcbiAgICBvdC5zZXRDb25zdHJhaW5lZEVkZ2VDVyhvcCwgY2U0KTtcblxuICAgIC8vIFJlbWFwIG5laWdoYm9yc1xuICAgIC8vIFhYWDogbWlnaHQgb3B0aW1pemUgdGhlIG1hcmtOZWlnaGJvciBieSBrZWVwaW5nIHRyYWNrIG9mXG4gICAgLy8gICAgICB3aGF0IHNpZGUgc2hvdWxkIGJlIGFzc2lnbmVkIHRvIHdoYXQgbmVpZ2hib3IgYWZ0ZXIgdGhlXG4gICAgLy8gICAgICByb3RhdGlvbi4gTm93IG1hcmsgbmVpZ2hib3IgZG9lcyBsb3RzIG9mIHRlc3RpbmcgdG8gZmluZFxuICAgIC8vICAgICAgdGhlIHJpZ2h0IHNpZGUuXG4gICAgdC5jbGVhck5laWdoYm9ycygpO1xuICAgIG90LmNsZWFyTmVpZ2hib3JzKCk7XG4gICAgaWYgKG4xKSB7XG4gICAgICAgIG90Lm1hcmtOZWlnaGJvcihuMSk7XG4gICAgfVxuICAgIGlmIChuMikge1xuICAgICAgICB0Lm1hcmtOZWlnaGJvcihuMik7XG4gICAgfVxuICAgIGlmIChuMykge1xuICAgICAgICB0Lm1hcmtOZWlnaGJvcihuMyk7XG4gICAgfVxuICAgIGlmIChuNCkge1xuICAgICAgICBvdC5tYXJrTmVpZ2hib3IobjQpO1xuICAgIH1cbiAgICB0Lm1hcmtOZWlnaGJvcihvdCk7XG59XG5cbi8qKlxuICogRmlsbHMgYSBiYXNpbiB0aGF0IGhhcyBmb3JtZWQgb24gdGhlIEFkdmFuY2luZyBGcm9udCB0byB0aGUgcmlnaHRcbiAqIG9mIGdpdmVuIG5vZGUuPGJyPlxuICogRmlyc3Qgd2UgZGVjaWRlIGEgbGVmdCxib3R0b20gYW5kIHJpZ2h0IG5vZGUgdGhhdCBmb3JtcyB0aGVcbiAqIGJvdW5kYXJpZXMgb2YgdGhlIGJhc2luLiBUaGVuIHdlIGRvIGEgcmVxdXJzaXZlIGZpbGwuXG4gKlxuICogQHBhcmFtIHshU3dlZXBDb250ZXh0fSB0Y3ggLSBTd2VlcENvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0gbm9kZSAtIHN0YXJ0aW5nIG5vZGUsIHRoaXMgb3IgbmV4dCBub2RlIHdpbGwgYmUgbGVmdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGZpbGxCYXNpbih0Y3gsIG5vZGUpIHtcbiAgICBpZiAob3JpZW50MmQobm9kZS5wb2ludCwgbm9kZS5uZXh0LnBvaW50LCBub2RlLm5leHQubmV4dC5wb2ludCkgPT09IE9yaWVudGF0aW9uLkNDVykge1xuICAgICAgICB0Y3guYmFzaW4ubGVmdF9ub2RlID0gbm9kZS5uZXh0Lm5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGN4LmJhc2luLmxlZnRfbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBib3R0b20gYW5kIHJpZ2h0IG5vZGVcbiAgICB0Y3guYmFzaW4uYm90dG9tX25vZGUgPSB0Y3guYmFzaW4ubGVmdF9ub2RlO1xuICAgIHdoaWxlICh0Y3guYmFzaW4uYm90dG9tX25vZGUubmV4dCAmJiB0Y3guYmFzaW4uYm90dG9tX25vZGUucG9pbnQueSA+PSB0Y3guYmFzaW4uYm90dG9tX25vZGUubmV4dC5wb2ludC55KSB7XG4gICAgICAgIHRjeC5iYXNpbi5ib3R0b21fbm9kZSA9IHRjeC5iYXNpbi5ib3R0b21fbm9kZS5uZXh0O1xuICAgIH1cbiAgICBpZiAodGN4LmJhc2luLmJvdHRvbV9ub2RlID09PSB0Y3guYmFzaW4ubGVmdF9ub2RlKSB7XG4gICAgICAgIC8vIE5vIHZhbGlkIGJhc2luXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0Y3guYmFzaW4ucmlnaHRfbm9kZSA9IHRjeC5iYXNpbi5ib3R0b21fbm9kZTtcbiAgICB3aGlsZSAodGN4LmJhc2luLnJpZ2h0X25vZGUubmV4dCAmJiB0Y3guYmFzaW4ucmlnaHRfbm9kZS5wb2ludC55IDwgdGN4LmJhc2luLnJpZ2h0X25vZGUubmV4dC5wb2ludC55KSB7XG4gICAgICAgIHRjeC5iYXNpbi5yaWdodF9ub2RlID0gdGN4LmJhc2luLnJpZ2h0X25vZGUubmV4dDtcbiAgICB9XG4gICAgaWYgKHRjeC5iYXNpbi5yaWdodF9ub2RlID09PSB0Y3guYmFzaW4uYm90dG9tX25vZGUpIHtcbiAgICAgICAgLy8gTm8gdmFsaWQgYmFzaW5zXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0Y3guYmFzaW4ud2lkdGggPSB0Y3guYmFzaW4ucmlnaHRfbm9kZS5wb2ludC54IC0gdGN4LmJhc2luLmxlZnRfbm9kZS5wb2ludC54O1xuICAgIHRjeC5iYXNpbi5sZWZ0X2hpZ2hlc3QgPSB0Y3guYmFzaW4ubGVmdF9ub2RlLnBvaW50LnkgPiB0Y3guYmFzaW4ucmlnaHRfbm9kZS5wb2ludC55O1xuXG4gICAgZmlsbEJhc2luUmVxKHRjeCwgdGN4LmJhc2luLmJvdHRvbV9ub2RlKTtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmUgYWxnb3JpdGhtIHRvIGZpbGwgYSBCYXNpbiB3aXRoIHRyaWFuZ2xlc1xuICpcbiAqIEBwYXJhbSB7IVN3ZWVwQ29udGV4dH0gdGN4IC0gU3dlZXBDb250ZXh0IG9iamVjdFxuICogQHBhcmFtIG5vZGUgLSBib3R0b21fbm9kZVxuICovXG5mdW5jdGlvbiBmaWxsQmFzaW5SZXEodGN4LCBub2RlKSB7XG4gICAgLy8gaWYgc2hhbGxvdyBzdG9wIGZpbGxpbmdcbiAgICBpZiAoaXNTaGFsbG93KHRjeCwgbm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZpbGwodGN4LCBub2RlKTtcblxuICAgIHZhciBvO1xuICAgIGlmIChub2RlLnByZXYgPT09IHRjeC5iYXNpbi5sZWZ0X25vZGUgJiYgbm9kZS5uZXh0ID09PSB0Y3guYmFzaW4ucmlnaHRfbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChub2RlLnByZXYgPT09IHRjeC5iYXNpbi5sZWZ0X25vZGUpIHtcbiAgICAgICAgbyA9IG9yaWVudDJkKG5vZGUucG9pbnQsIG5vZGUubmV4dC5wb2ludCwgbm9kZS5uZXh0Lm5leHQucG9pbnQpO1xuICAgICAgICBpZiAobyA9PT0gT3JpZW50YXRpb24uQ1cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ID09PSB0Y3guYmFzaW4ucmlnaHRfbm9kZSkge1xuICAgICAgICBvID0gb3JpZW50MmQobm9kZS5wb2ludCwgbm9kZS5wcmV2LnBvaW50LCBub2RlLnByZXYucHJldi5wb2ludCk7XG4gICAgICAgIGlmIChvID09PSBPcmllbnRhdGlvbi5DQ1cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wcmV2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG5laWdoYm9yIG5vZGUgd2l0aCBsb3dlc3QgWSB2YWx1ZVxuICAgICAgICBpZiAobm9kZS5wcmV2LnBvaW50LnkgPCBub2RlLm5leHQucG9pbnQueSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucHJldjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaWxsQmFzaW5SZXEodGN4LCBub2RlKTtcbn1cblxuZnVuY3Rpb24gaXNTaGFsbG93KHRjeCwgbm9kZSkge1xuICAgIHZhciBoZWlnaHQ7XG4gICAgaWYgKHRjeC5iYXNpbi5sZWZ0X2hpZ2hlc3QpIHtcbiAgICAgICAgaGVpZ2h0ID0gdGN4LmJhc2luLmxlZnRfbm9kZS5wb2ludC55IC0gbm9kZS5wb2ludC55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhlaWdodCA9IHRjeC5iYXNpbi5yaWdodF9ub2RlLnBvaW50LnkgLSBub2RlLnBvaW50Lnk7XG4gICAgfVxuXG4gICAgLy8gaWYgc2hhbGxvdyBzdG9wIGZpbGxpbmdcbiAgICBpZiAodGN4LmJhc2luLndpZHRoID4gaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbGxFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKSB7XG4gICAgaWYgKHRjeC5lZGdlX2V2ZW50LnJpZ2h0KSB7XG4gICAgICAgIGZpbGxSaWdodEFib3ZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmlsbExlZnRBYm92ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsbFJpZ2h0QWJvdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUubmV4dC5wb2ludC54IDwgZWRnZS5wLngpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbmV4dCBub2RlIGlzIGJlbG93IHRoZSBlZGdlXG4gICAgICAgIGlmIChvcmllbnQyZChlZGdlLnEsIG5vZGUubmV4dC5wb2ludCwgZWRnZS5wKSA9PT0gT3JpZW50YXRpb24uQ0NXKSB7XG4gICAgICAgICAgICBmaWxsUmlnaHRCZWxvd0VkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsbFJpZ2h0QmVsb3dFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKSB7XG4gICAgaWYgKG5vZGUucG9pbnQueCA8IGVkZ2UucC54KSB7XG4gICAgICAgIGlmIChvcmllbnQyZChub2RlLnBvaW50LCBub2RlLm5leHQucG9pbnQsIG5vZGUubmV4dC5uZXh0LnBvaW50KSA9PT0gT3JpZW50YXRpb24uQ0NXKSB7XG4gICAgICAgICAgICAvLyBDb25jYXZlXG4gICAgICAgICAgICBmaWxsUmlnaHRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDb252ZXhcbiAgICAgICAgICAgIGZpbGxSaWdodENvbnZleEVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgICAgICAgICAgLy8gUmV0cnkgdGhpcyBvbmVcbiAgICAgICAgICAgIGZpbGxSaWdodEJlbG93RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbGxSaWdodENvbmNhdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKSB7XG4gICAgZmlsbCh0Y3gsIG5vZGUubmV4dCk7XG4gICAgaWYgKG5vZGUubmV4dC5wb2ludCAhPT0gZWRnZS5wKSB7XG4gICAgICAgIC8vIE5leHQgYWJvdmUgb3IgYmVsb3cgZWRnZT9cbiAgICAgICAgaWYgKG9yaWVudDJkKGVkZ2UucSwgbm9kZS5uZXh0LnBvaW50LCBlZGdlLnApID09PSBPcmllbnRhdGlvbi5DQ1cpIHtcbiAgICAgICAgICAgIC8vIEJlbG93XG4gICAgICAgICAgICBpZiAob3JpZW50MmQobm9kZS5wb2ludCwgbm9kZS5uZXh0LnBvaW50LCBub2RlLm5leHQubmV4dC5wb2ludCkgPT09IE9yaWVudGF0aW9uLkNDVykge1xuICAgICAgICAgICAgICAgIC8vIE5leHQgaXMgY29uY2F2ZVxuICAgICAgICAgICAgICAgIGZpbGxSaWdodENvbmNhdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTmV4dCBpcyBjb252ZXhcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgbm9lbXB0eTpmYWxzZSAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWxsUmlnaHRDb252ZXhFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKSB7XG4gICAgLy8gTmV4dCBjb25jYXZlIG9yIGNvbnZleD9cbiAgICBpZiAob3JpZW50MmQobm9kZS5uZXh0LnBvaW50LCBub2RlLm5leHQubmV4dC5wb2ludCwgbm9kZS5uZXh0Lm5leHQubmV4dC5wb2ludCkgPT09IE9yaWVudGF0aW9uLkNDVykge1xuICAgICAgICAvLyBDb25jYXZlXG4gICAgICAgIGZpbGxSaWdodENvbmNhdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlLm5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnZleFxuICAgICAgICAvLyBOZXh0IGFib3ZlIG9yIGJlbG93IGVkZ2U/XG4gICAgICAgIGlmIChvcmllbnQyZChlZGdlLnEsIG5vZGUubmV4dC5uZXh0LnBvaW50LCBlZGdlLnApID09PSBPcmllbnRhdGlvbi5DQ1cpIHtcbiAgICAgICAgICAgIC8vIEJlbG93XG4gICAgICAgICAgICBmaWxsUmlnaHRDb252ZXhFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlLm5leHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWJvdmVcbiAgICAgICAgICAgIC8qIGpzaGludCBub2VtcHR5OmZhbHNlICovXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbGxMZWZ0QWJvdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUucHJldi5wb2ludC54ID4gZWRnZS5wLngpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbmV4dCBub2RlIGlzIGJlbG93IHRoZSBlZGdlXG4gICAgICAgIGlmIChvcmllbnQyZChlZGdlLnEsIG5vZGUucHJldi5wb2ludCwgZWRnZS5wKSA9PT0gT3JpZW50YXRpb24uQ1cpIHtcbiAgICAgICAgICAgIGZpbGxMZWZ0QmVsb3dFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnByZXY7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbGxMZWZ0QmVsb3dFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKSB7XG4gICAgaWYgKG5vZGUucG9pbnQueCA+IGVkZ2UucC54KSB7XG4gICAgICAgIGlmIChvcmllbnQyZChub2RlLnBvaW50LCBub2RlLnByZXYucG9pbnQsIG5vZGUucHJldi5wcmV2LnBvaW50KSA9PT0gT3JpZW50YXRpb24uQ1cpIHtcbiAgICAgICAgICAgIC8vIENvbmNhdmVcbiAgICAgICAgICAgIGZpbGxMZWZ0Q29uY2F2ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29udmV4XG4gICAgICAgICAgICBmaWxsTGVmdENvbnZleEVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgICAgICAgICAgLy8gUmV0cnkgdGhpcyBvbmVcbiAgICAgICAgICAgIGZpbGxMZWZ0QmVsb3dFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsbExlZnRDb252ZXhFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKSB7XG4gICAgLy8gTmV4dCBjb25jYXZlIG9yIGNvbnZleD9cbiAgICBpZiAob3JpZW50MmQobm9kZS5wcmV2LnBvaW50LCBub2RlLnByZXYucHJldi5wb2ludCwgbm9kZS5wcmV2LnByZXYucHJldi5wb2ludCkgPT09IE9yaWVudGF0aW9uLkNXKSB7XG4gICAgICAgIC8vIENvbmNhdmVcbiAgICAgICAgZmlsbExlZnRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZS5wcmV2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb252ZXhcbiAgICAgICAgLy8gTmV4dCBhYm92ZSBvciBiZWxvdyBlZGdlP1xuICAgICAgICBpZiAob3JpZW50MmQoZWRnZS5xLCBub2RlLnByZXYucHJldi5wb2ludCwgZWRnZS5wKSA9PT0gT3JpZW50YXRpb24uQ1cpIHtcbiAgICAgICAgICAgIC8vIEJlbG93XG4gICAgICAgICAgICBmaWxsTGVmdENvbnZleEVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUucHJldik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBYm92ZVxuICAgICAgICAgICAgLyoganNoaW50IG5vZW1wdHk6ZmFsc2UgKi9cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsbExlZnRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSkge1xuICAgIGZpbGwodGN4LCBub2RlLnByZXYpO1xuICAgIGlmIChub2RlLnByZXYucG9pbnQgIT09IGVkZ2UucCkge1xuICAgICAgICAvLyBOZXh0IGFib3ZlIG9yIGJlbG93IGVkZ2U/XG4gICAgICAgIGlmIChvcmllbnQyZChlZGdlLnEsIG5vZGUucHJldi5wb2ludCwgZWRnZS5wKSA9PT0gT3JpZW50YXRpb24uQ1cpIHtcbiAgICAgICAgICAgIC8vIEJlbG93XG4gICAgICAgICAgICBpZiAob3JpZW50MmQobm9kZS5wb2ludCwgbm9kZS5wcmV2LnBvaW50LCBub2RlLnByZXYucHJldi5wb2ludCkgPT09IE9yaWVudGF0aW9uLkNXKSB7XG4gICAgICAgICAgICAgICAgLy8gTmV4dCBpcyBjb25jYXZlXG4gICAgICAgICAgICAgICAgZmlsbExlZnRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5leHQgaXMgY29udmV4XG4gICAgICAgICAgICAgICAgLyoganNoaW50IG5vZW1wdHk6ZmFsc2UgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmxpcEVkZ2VFdmVudCh0Y3gsIGVwLCBlcSwgdCwgcCkge1xuICAgIHZhciBvdCA9IHQubmVpZ2hib3JBY3Jvc3MocCk7XG4gICAgYXNzZXJ0KG90LCBcIkZMSVAgZmFpbGVkIGR1ZSB0byBtaXNzaW5nIHRyaWFuZ2xlIVwiKTtcblxuICAgIHZhciBvcCA9IG90Lm9wcG9zaXRlUG9pbnQodCwgcCk7XG5cbiAgICAvLyBBZGRpdGlvbmFsIGNoZWNrIGZyb20gSmF2YSB2ZXJzaW9uIChzZWUgaXNzdWUgIzg4KVxuICAgIGlmICh0LmdldENvbnN0cmFpbmVkRWRnZUFjcm9zcyhwKSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0LmluZGV4KHApO1xuICAgICAgICB0aHJvdyBuZXcgUG9pbnRFcnJvcihcInBvbHkydHJpIEludGVyc2VjdGluZyBDb25zdHJhaW50c1wiLFxuICAgICAgICAgICAgICAgIFtwLCBvcCwgdC5nZXRQb2ludCgoaW5kZXggKyAxKSAlIDMpLCB0LmdldFBvaW50KChpbmRleCArIDIpICUgMyldKTtcbiAgICB9XG5cbiAgICBpZiAoaW5TY2FuQXJlYShwLCB0LnBvaW50Q0NXKHApLCB0LnBvaW50Q1cocCksIG9wKSkge1xuICAgICAgICAvLyBMZXRzIHJvdGF0ZSBzaGFyZWQgZWRnZSBvbmUgdmVydGV4IENXXG4gICAgICAgIHJvdGF0ZVRyaWFuZ2xlUGFpcih0LCBwLCBvdCwgb3ApO1xuICAgICAgICB0Y3gubWFwVHJpYW5nbGVUb05vZGVzKHQpO1xuICAgICAgICB0Y3gubWFwVHJpYW5nbGVUb05vZGVzKG90KTtcblxuICAgICAgICAvLyBYWFg6IGluIHRoZSBvcmlnaW5hbCBDKysgY29kZSBmb3IgdGhlIG5leHQgMiBsaW5lcywgd2UgYXJlXG4gICAgICAgIC8vIGNvbXBhcmluZyBwb2ludCB2YWx1ZXMgKGFuZCBub3QgcG9pbnRlcnMpLiBJbiB0aGlzIEphdmFTY3JpcHRcbiAgICAgICAgLy8gY29kZSwgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzIChwb2ludGVycykuIFRoaXMgd29ya3NcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBjYW4ndCBoYXZlIDIgZGlmZmVyZW50IHBvaW50cyB3aXRoIHRoZSBzYW1lIHZhbHVlcy5cbiAgICAgICAgLy8gQnV0IHRvIGJlIHJlYWxseSBlcXVpdmFsZW50LCB3ZSBzaG91bGQgdXNlIFwiUG9pbnQuZXF1YWxzXCIgaGVyZS5cbiAgICAgICAgaWYgKHAgPT09IGVxICYmIG9wID09PSBlcCkge1xuICAgICAgICAgICAgaWYgKGVxID09PSB0Y3guZWRnZV9ldmVudC5jb25zdHJhaW5lZF9lZGdlLnEgJiYgZXAgPT09IHRjeC5lZGdlX2V2ZW50LmNvbnN0cmFpbmVkX2VkZ2UucCkge1xuICAgICAgICAgICAgICAgIHQubWFya0NvbnN0cmFpbmVkRWRnZUJ5UG9pbnRzKGVwLCBlcSk7XG4gICAgICAgICAgICAgICAgb3QubWFya0NvbnN0cmFpbmVkRWRnZUJ5UG9pbnRzKGVwLCBlcSk7XG4gICAgICAgICAgICAgICAgbGVnYWxpemUodGN4LCB0KTtcbiAgICAgICAgICAgICAgICBsZWdhbGl6ZSh0Y3gsIG90KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gWFhYOiBJIHRoaW5rIG9uZSBvZiB0aGUgdHJpYW5nbGVzIHNob3VsZCBiZSBsZWdhbGl6ZWQgaGVyZT9cbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgbm9lbXB0eTpmYWxzZSAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG8gPSBvcmllbnQyZChlcSwgb3AsIGVwKTtcbiAgICAgICAgICAgIHQgPSBuZXh0RmxpcFRyaWFuZ2xlKHRjeCwgbywgdCwgb3QsIHAsIG9wKTtcbiAgICAgICAgICAgIGZsaXBFZGdlRXZlbnQodGN4LCBlcCwgZXEsIHQsIHApO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld1AgPSBuZXh0RmxpcFBvaW50KGVwLCBlcSwgb3QsIG9wKTtcbiAgICAgICAgZmxpcFNjYW5FZGdlRXZlbnQodGN4LCBlcCwgZXEsIHQsIG90LCBuZXdQKTtcbiAgICAgICAgZWRnZUV2ZW50QnlQb2ludHModGN4LCBlcCwgZXEsIHQsIHApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBZnRlciBhIGZsaXAgd2UgaGF2ZSB0d28gdHJpYW5nbGVzIGFuZCBrbm93IHRoYXQgb25seSBvbmUgd2lsbCBzdGlsbCBiZVxuICogaW50ZXJzZWN0aW5nIHRoZSBlZGdlLiBTbyBkZWNpZGUgd2hpY2ggdG8gY29udGl1bmUgd2l0aCBhbmQgbGVnYWxpemUgdGhlIG90aGVyXG4gKlxuICogQHBhcmFtIHshU3dlZXBDb250ZXh0fSB0Y3ggLSBTd2VlcENvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0gbyAtIHNob3VsZCBiZSB0aGUgcmVzdWx0IG9mIGFuIG9yaWVudDJkKCBlcSwgb3AsIGVwIClcbiAqIEBwYXJhbSB0IC0gdHJpYW5nbGUgMVxuICogQHBhcmFtIG90IC0gdHJpYW5nbGUgMlxuICogQHBhcmFtIHAgLSBhIHBvaW50IHNoYXJlZCBieSBib3RoIHRyaWFuZ2xlc1xuICogQHBhcmFtIG9wIC0gYW5vdGhlciBwb2ludCBzaGFyZWQgYnkgYm90aCB0cmlhbmdsZXNcbiAqIEByZXR1cm4gcmV0dXJucyB0aGUgdHJpYW5nbGUgc3RpbGwgaW50ZXJzZWN0aW5nIHRoZSBlZGdlXG4gKi9cbmZ1bmN0aW9uIG5leHRGbGlwVHJpYW5nbGUodGN4LCBvLCB0LCBvdCwgcCwgb3ApIHtcbiAgICB2YXIgZWRnZV9pbmRleDtcbiAgICBpZiAobyA9PT0gT3JpZW50YXRpb24uQ0NXKSB7XG4gICAgICAgIC8vIG90IGlzIG5vdCBjcm9zc2luZyBlZGdlIGFmdGVyIGZsaXBcbiAgICAgICAgZWRnZV9pbmRleCA9IG90LmVkZ2VJbmRleChwLCBvcCk7XG4gICAgICAgIG90LmRlbGF1bmF5X2VkZ2VbZWRnZV9pbmRleF0gPSB0cnVlO1xuICAgICAgICBsZWdhbGl6ZSh0Y3gsIG90KTtcbiAgICAgICAgb3QuY2xlYXJEZWxhdW5heUVkZ2VzKCk7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIC8vIHQgaXMgbm90IGNyb3NzaW5nIGVkZ2UgYWZ0ZXIgZmxpcFxuICAgIGVkZ2VfaW5kZXggPSB0LmVkZ2VJbmRleChwLCBvcCk7XG5cbiAgICB0LmRlbGF1bmF5X2VkZ2VbZWRnZV9pbmRleF0gPSB0cnVlO1xuICAgIGxlZ2FsaXplKHRjeCwgdCk7XG4gICAgdC5jbGVhckRlbGF1bmF5RWRnZXMoKTtcbiAgICByZXR1cm4gb3Q7XG59XG5cbi8qKlxuICogV2hlbiB3ZSBuZWVkIHRvIHRyYXZlcnNlIGZyb20gb25lIHRyaWFuZ2xlIHRvIHRoZSBuZXh0IHdlIG5lZWRcbiAqIHRoZSBwb2ludCBpbiBjdXJyZW50IHRyaWFuZ2xlIHRoYXQgaXMgdGhlIG9wcG9zaXRlIHBvaW50IHRvIHRoZSBuZXh0XG4gKiB0cmlhbmdsZS5cbiAqL1xuZnVuY3Rpb24gbmV4dEZsaXBQb2ludChlcCwgZXEsIG90LCBvcCkge1xuICAgIHZhciBvMmQgPSBvcmllbnQyZChlcSwgb3AsIGVwKTtcbiAgICBpZiAobzJkID09PSBPcmllbnRhdGlvbi5DVykge1xuICAgICAgICAvLyBSaWdodFxuICAgICAgICByZXR1cm4gb3QucG9pbnRDQ1cob3ApO1xuICAgIH0gZWxzZSBpZiAobzJkID09PSBPcmllbnRhdGlvbi5DQ1cpIHtcbiAgICAgICAgLy8gTGVmdFxuICAgICAgICByZXR1cm4gb3QucG9pbnRDVyhvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFBvaW50RXJyb3IoXCJwb2x5MnRyaSBbVW5zdXBwb3J0ZWRdIG5leHRGbGlwUG9pbnQ6IG9wcG9zaW5nIHBvaW50IG9uIGNvbnN0cmFpbmVkIGVkZ2UhXCIsIFtlcSwgb3AsIGVwXSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFNjYW4gcGFydCBvZiB0aGUgRmxpcFNjYW4gYWxnb3JpdGhtPGJyPlxuICogV2hlbiBhIHRyaWFuZ2xlIHBhaXIgaXNuJ3QgZmxpcHBhYmxlIHdlIHdpbGwgc2NhbiBmb3IgdGhlIG5leHRcbiAqIHBvaW50IHRoYXQgaXMgaW5zaWRlIHRoZSBmbGlwIHRyaWFuZ2xlIHNjYW4gYXJlYS4gV2hlbiBmb3VuZFxuICogd2UgZ2VuZXJhdGUgYSBuZXcgZmxpcEVkZ2VFdmVudFxuICpcbiAqIEBwYXJhbSB7IVN3ZWVwQ29udGV4dH0gdGN4IC0gU3dlZXBDb250ZXh0IG9iamVjdFxuICogQHBhcmFtIGVwIC0gbGFzdCBwb2ludCBvbiB0aGUgZWRnZSB3ZSBhcmUgdHJhdmVyc2luZ1xuICogQHBhcmFtIGVxIC0gZmlyc3QgcG9pbnQgb24gdGhlIGVkZ2Ugd2UgYXJlIHRyYXZlcnNpbmdcbiAqIEBwYXJhbSB7IVRyaWFuZ2xlfSBmbGlwX3RyaWFuZ2xlIC0gdGhlIGN1cnJlbnQgdHJpYW5nbGUgc2hhcmluZyB0aGUgcG9pbnQgZXEgd2l0aCBlZGdlXG4gKiBAcGFyYW0gdFxuICogQHBhcmFtIHBcbiAqL1xuZnVuY3Rpb24gZmxpcFNjYW5FZGdlRXZlbnQodGN4LCBlcCwgZXEsIGZsaXBfdHJpYW5nbGUsIHQsIHApIHtcbiAgICB2YXIgb3QgPSB0Lm5laWdoYm9yQWNyb3NzKHApO1xuICAgIGFzc2VydChvdCwgXCJGTElQIGZhaWxlZCBkdWUgdG8gbWlzc2luZyB0cmlhbmdsZVwiKTtcblxuICAgIHZhciBvcCA9IG90Lm9wcG9zaXRlUG9pbnQodCwgcCk7XG5cbiAgICBpZiAoaW5TY2FuQXJlYShlcSwgZmxpcF90cmlhbmdsZS5wb2ludENDVyhlcSksIGZsaXBfdHJpYW5nbGUucG9pbnRDVyhlcSksIG9wKSkge1xuICAgICAgICAvLyBmbGlwIHdpdGggbmV3IGVkZ2Ugb3AuZXFcbiAgICAgICAgZmxpcEVkZ2VFdmVudCh0Y3gsIGVxLCBvcCwgb3QsIG9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3UCA9IG5leHRGbGlwUG9pbnQoZXAsIGVxLCBvdCwgb3ApO1xuICAgICAgICBmbGlwU2NhbkVkZ2VFdmVudCh0Y3gsIGVwLCBlcSwgZmxpcF90cmlhbmdsZSwgb3QsIG5ld1ApO1xuICAgIH1cbn1cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tRXhwb3J0c1xuXG5leHBvcnRzLnRyaWFuZ3VsYXRlID0gdHJpYW5ndWxhdGU7XG5cbn0se1wiLi9hZHZhbmNpbmdmcm9udFwiOjIsXCIuL2Fzc2VydFwiOjMsXCIuL3BvaW50ZXJyb3JcIjo1LFwiLi90cmlhbmdsZVwiOjksXCIuL3V0aWxzXCI6MTB9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBQb2x5MlRyaSBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXG4gKiBcbiAqIHBvbHkydHJpLmpzIChKYXZhU2NyaXB0IHBvcnQpIChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3IzbWkvcG9seTJ0cmkuanNcbiAqIFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIDMtY2xhdXNlIEJTRCBMaWNlbnNlLCBzZWUgTElDRU5TRS50eHRcbiAqL1xuXG4vKiBqc2hpbnQgbWF4Y29tcGxleGl0eTo2ICovXG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qXG4gKiBOb3RlXG4gKiA9PT09XG4gKiB0aGUgc3RydWN0dXJlIG9mIHRoaXMgSmF2YVNjcmlwdCB2ZXJzaW9uIG9mIHBvbHkydHJpIGludGVudGlvbmFsbHkgZm9sbG93c1xuICogYXMgY2xvc2VseSBhcyBwb3NzaWJsZSB0aGUgc3RydWN0dXJlIG9mIHRoZSByZWZlcmVuY2UgQysrIHZlcnNpb24sIHRvIG1ha2UgaXQgXG4gKiBlYXNpZXIgdG8ga2VlcCB0aGUgMiB2ZXJzaW9ucyBpbiBzeW5jLlxuICovXG5cbnZhciBQb2ludEVycm9yID0gX2RlcmVxXygnLi9wb2ludGVycm9yJyk7XG52YXIgUG9pbnQgPSBfZGVyZXFfKCcuL3BvaW50Jyk7XG52YXIgVHJpYW5nbGUgPSBfZGVyZXFfKCcuL3RyaWFuZ2xlJyk7XG52YXIgc3dlZXAgPSBfZGVyZXFfKCcuL3N3ZWVwJyk7XG52YXIgQWR2YW5jaW5nRnJvbnQgPSBfZGVyZXFfKCcuL2FkdmFuY2luZ2Zyb250Jyk7XG52YXIgTm9kZSA9IEFkdmFuY2luZ0Zyb250Lk5vZGU7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tdXRpbHNcblxuLyoqXG4gKiBJbml0aWFsIHRyaWFuZ2xlIGZhY3Rvciwgc2VlZCB0cmlhbmdsZSB3aWxsIGV4dGVuZCAzMCUgb2ZcbiAqIFBvaW50U2V0IHdpZHRoIHRvIGJvdGggbGVmdCBhbmQgcmlnaHQuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0XG4gKi9cbnZhciBrQWxwaGEgPSAwLjM7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLUVkZ2Vcbi8qKlxuICogUmVwcmVzZW50cyBhIHNpbXBsZSBwb2x5Z29uJ3MgZWRnZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gcDFcbiAqIEBwYXJhbSB7UG9pbnR9IHAyXG4gKiBAdGhyb3cge1BvaW50RXJyb3J9IGlmIHAxIGlzIHNhbWUgYXMgcDJcbiAqL1xudmFyIEVkZ2UgPSBmdW5jdGlvbihwMSwgcDIpIHtcbiAgICB0aGlzLnAgPSBwMTtcbiAgICB0aGlzLnEgPSBwMjtcblxuICAgIGlmIChwMS55ID4gcDIueSkge1xuICAgICAgICB0aGlzLnEgPSBwMTtcbiAgICAgICAgdGhpcy5wID0gcDI7XG4gICAgfSBlbHNlIGlmIChwMS55ID09PSBwMi55KSB7XG4gICAgICAgIGlmIChwMS54ID4gcDIueCkge1xuICAgICAgICAgICAgdGhpcy5xID0gcDE7XG4gICAgICAgICAgICB0aGlzLnAgPSBwMjtcbiAgICAgICAgfSBlbHNlIGlmIChwMS54ID09PSBwMi54KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUG9pbnRFcnJvcigncG9seTJ0cmkgSW52YWxpZCBFZGdlIGNvbnN0cnVjdG9yOiByZXBlYXRlZCBwb2ludHMhJywgW3AxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucS5fcDJ0X2VkZ2VfbGlzdCkge1xuICAgICAgICB0aGlzLnEuX3AydF9lZGdlX2xpc3QgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5xLl9wMnRfZWRnZV9saXN0LnB1c2godGhpcyk7XG59O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLUJhc2luXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0cnVjdFxuICogQHByaXZhdGVcbiAqL1xudmFyIEJhc2luID0gZnVuY3Rpb24oKSB7XG4gICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgIHRoaXMubGVmdF9ub2RlID0gbnVsbDtcbiAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgdGhpcy5ib3R0b21fbm9kZSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgIHRoaXMucmlnaHRfbm9kZSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy53aWR0aCA9IDAuMDtcbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5sZWZ0X2hpZ2hlc3QgPSBmYWxzZTtcbn07XG5cbkJhc2luLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGVmdF9ub2RlID0gbnVsbDtcbiAgICB0aGlzLmJvdHRvbV9ub2RlID0gbnVsbDtcbiAgICB0aGlzLnJpZ2h0X25vZGUgPSBudWxsO1xuICAgIHRoaXMud2lkdGggPSAwLjA7XG4gICAgdGhpcy5sZWZ0X2hpZ2hlc3QgPSBmYWxzZTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tRWRnZUV2ZW50XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0cnVjdFxuICogQHByaXZhdGVcbiAqL1xudmFyIEVkZ2VFdmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qKiBAdHlwZSB7RWRnZX0gKi9cbiAgICB0aGlzLmNvbnN0cmFpbmVkX2VkZ2UgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnJpZ2h0ID0gZmFsc2U7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tU3dlZXBDb250ZXh0IChwdWJsaWMgQVBJKVxuLyoqXG4gKiBTd2VlcENvbnRleHQgY29uc3RydWN0b3Igb3B0aW9uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTd2VlcENvbnRleHRPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW49fSBjbG9uZUFycmF5cyAtIGlmIDxjb2RlPnRydWU8L2NvZGU+LCBkbyBhIHNoYWxsb3cgY29weSBvZiB0aGUgQXJyYXkgcGFyYW1ldGVyc1xuICogICAgICAgICAgICAgICAgICAoY29udG91ciwgaG9sZXMpLiBQb2ludHMgaW5zaWRlIGFycmF5cyBhcmUgbmV2ZXIgY29waWVkLlxuICogICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIDxjb2RlPmZhbHNlPC9jb2RlPiA6IGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGFycmF5IGFyZ3VtZW50cyxcbiAqICAgICAgICAgICAgICAgICAgd2hvIHdpbGwgYmUgbW9kaWZpZWQgaW4gcGxhY2UuXG4gKi9cbi8qKlxuICogQ29uc3RydWN0b3IgZm9yIHRoZSB0cmlhbmd1bGF0aW9uIGNvbnRleHQuXG4gKiBJdCBhY2NlcHRzIGEgc2ltcGxlIHBvbHlsaW5lICh3aXRoIG5vbiByZXBlYXRpbmcgcG9pbnRzKSwgXG4gKiB3aGljaCBkZWZpbmVzIHRoZSBjb25zdHJhaW5lZCBlZGdlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgICAgICAgdmFyIGNvbnRvdXIgPSBbXG4gKiAgICAgICAgICAgICAgbmV3IHBvbHkydHJpLlBvaW50KDEwMCwgMTAwKSxcbiAqICAgICAgICAgICAgICBuZXcgcG9seTJ0cmkuUG9pbnQoMTAwLCAzMDApLFxuICogICAgICAgICAgICAgIG5ldyBwb2x5MnRyaS5Qb2ludCgzMDAsIDMwMCksXG4gKiAgICAgICAgICAgICAgbmV3IHBvbHkydHJpLlBvaW50KDMwMCwgMTAwKVxuICogICAgICAgICAgXTtcbiAqICAgICAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91ciwge2Nsb25lQXJyYXlzOiB0cnVlfSk7XG4gKiBAZXhhbXBsZVxuICogICAgICAgICAgdmFyIGNvbnRvdXIgPSBbe3g6MTAwLCB5OjEwMH0sIHt4OjEwMCwgeTozMDB9LCB7eDozMDAsIHk6MzAwfSwge3g6MzAwLCB5OjEwMH1dO1xuICogICAgICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyLCB7Y2xvbmVBcnJheXM6IHRydWV9KTtcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICogQHN0cnVjdFxuICogQHBhcmFtIHtBcnJheS48WFk+fSBjb250b3VyIC0gYXJyYXkgb2YgcG9pbnQgb2JqZWN0cy4gVGhlIHBvaW50cyBjYW4gYmUgZWl0aGVyIHtAbGlua2NvZGUgUG9pbnR9IGluc3RhbmNlcyxcbiAqICAgICAgICAgIG9yIGFueSBcIlBvaW50IGxpa2VcIiBjdXN0b20gY2xhc3Mgd2l0aCA8Y29kZT57eCwgeX08L2NvZGU+IGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge1N3ZWVwQ29udGV4dE9wdGlvbnM9fSBvcHRpb25zIC0gY29uc3RydWN0b3Igb3B0aW9uc1xuICovXG52YXIgU3dlZXBDb250ZXh0ID0gZnVuY3Rpb24oY29udG91ciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMudHJpYW5nbGVzXyA9IFtdO1xuICAgIHRoaXMubWFwXyA9IFtdO1xuICAgIHRoaXMucG9pbnRzXyA9IChvcHRpb25zLmNsb25lQXJyYXlzID8gY29udG91ci5zbGljZSgwKSA6IGNvbnRvdXIpO1xuICAgIHRoaXMuZWRnZV9saXN0ID0gW107XG5cbiAgICAvLyBCb3VuZGluZyBib3ggb2YgYWxsIHBvaW50cy4gQ29tcHV0ZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSB0cmlhbmd1bGF0aW9uLCBcbiAgICAvLyBpdCBpcyBzdG9yZWQgaW4gY2FzZSBpdCBpcyBuZWVkZWQgYnkgdGhlIGNhbGxlci5cbiAgICB0aGlzLnBtaW5fID0gdGhpcy5wbWF4XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNpbmcgZnJvbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBZHZhbmNpbmdGcm9udH1cbiAgICAgKi9cbiAgICB0aGlzLmZyb250XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBoZWFkIHBvaW50IHVzZWQgd2l0aCBhZHZhbmNpbmcgZnJvbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIHRhaWwgcG9pbnQgdXNlZCB3aXRoIGFkdmFuY2luZyBmcm9udFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqL1xuICAgIHRoaXMudGFpbF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgKi9cbiAgICB0aGlzLmFmX2hlYWRfID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtOb2RlfVxuICAgICAqL1xuICAgIHRoaXMuYWZfbWlkZGxlXyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgKi9cbiAgICB0aGlzLmFmX3RhaWxfID0gbnVsbDtcblxuICAgIHRoaXMuYmFzaW4gPSBuZXcgQmFzaW4oKTtcbiAgICB0aGlzLmVkZ2VfZXZlbnQgPSBuZXcgRWRnZUV2ZW50KCk7XG5cbiAgICB0aGlzLmluaXRFZGdlcyh0aGlzLnBvaW50c18pO1xufTtcblxuXG4vKipcbiAqIEFkZCBhIGhvbGUgdG8gdGhlIGNvbnN0cmFpbnRzXG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICogICAgICB2YXIgaG9sZSA9IFtcbiAqICAgICAgICAgIG5ldyBwb2x5MnRyaS5Qb2ludCgyMDAsIDIwMCksXG4gKiAgICAgICAgICBuZXcgcG9seTJ0cmkuUG9pbnQoMjAwLCAyNTApLFxuICogICAgICAgICAgbmV3IHBvbHkydHJpLlBvaW50KDI1MCwgMjUwKVxuICogICAgICBdO1xuICogICAgICBzd2N0eC5hZGRIb2xlKGhvbGUpO1xuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqICAgICAgc3djdHguYWRkSG9sZShbe3g6MjAwLCB5OjIwMH0sIHt4OjIwMCwgeToyNTB9LCB7eDoyNTAsIHk6MjUwfV0pO1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtBcnJheS48WFk+fSBwb2x5bGluZSAtIGFycmF5IG9mIFwiUG9pbnQgbGlrZVwiIG9iamVjdHMgd2l0aCB7eCx5fVxuICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmFkZEhvbGUgPSBmdW5jdGlvbihwb2x5bGluZSkge1xuICAgIHRoaXMuaW5pdEVkZ2VzKHBvbHlsaW5lKTtcbiAgICB2YXIgaSwgbGVuID0gcG9seWxpbmUubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnBvaW50c18ucHVzaChwb2x5bGluZVtpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cbi8qKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAqIEBmdW5jdGlvblxuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGlua2NvZGUgU3dlZXBDb250ZXh0I2FkZEhvbGV9IGluc3RlYWRcbiAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5BZGRIb2xlID0gU3dlZXBDb250ZXh0LnByb3RvdHlwZS5hZGRIb2xlO1xuXG5cbi8qKlxuICogQWRkIHNldmVyYWwgaG9sZXMgdG8gdGhlIGNvbnN0cmFpbnRzXG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICogICAgICB2YXIgaG9sZXMgPSBbXG4gKiAgICAgICAgICBbIG5ldyBwb2x5MnRyaS5Qb2ludCgyMDAsIDIwMCksIG5ldyBwb2x5MnRyaS5Qb2ludCgyMDAsIDI1MCksIG5ldyBwb2x5MnRyaS5Qb2ludCgyNTAsIDI1MCkgXSxcbiAqICAgICAgICAgIFsgbmV3IHBvbHkydHJpLlBvaW50KDMwMCwgMzAwKSwgbmV3IHBvbHkydHJpLlBvaW50KDMwMCwgMzUwKSwgbmV3IHBvbHkydHJpLlBvaW50KDM1MCwgMzUwKSBdXG4gKiAgICAgIF07XG4gKiAgICAgIHN3Y3R4LmFkZEhvbGVzKGhvbGVzKTtcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKiAgICAgIHZhciBob2xlcyA9IFtcbiAqICAgICAgICAgIFt7eDoyMDAsIHk6MjAwfSwge3g6MjAwLCB5OjI1MH0sIHt4OjI1MCwgeToyNTB9XSxcbiAqICAgICAgICAgIFt7eDozMDAsIHk6MzAwfSwge3g6MzAwLCB5OjM1MH0sIHt4OjM1MCwgeTozNTB9XVxuICogICAgICBdO1xuICogICAgICBzd2N0eC5hZGRIb2xlcyhob2xlcyk7XG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48WFk+Pn0gaG9sZXMgLSBhcnJheSBvZiBhcnJheSBvZiBcIlBvaW50IGxpa2VcIiBvYmplY3RzIHdpdGgge3gseX1cbiAqL1xuLy8gTWV0aG9kIGFkZGVkIGluIHRoZSBKYXZhU2NyaXB0IHZlcnNpb24gKHdhcyBub3QgcHJlc2VudCBpbiB0aGUgYysrIHZlcnNpb24pXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmFkZEhvbGVzID0gZnVuY3Rpb24oaG9sZXMpIHtcbiAgICB2YXIgaSwgbGVuID0gaG9sZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLmluaXRFZGdlcyhob2xlc1tpXSk7XG4gICAgfVxuICAgIHRoaXMucG9pbnRzXyA9IHRoaXMucG9pbnRzXy5jb25jYXQuYXBwbHkodGhpcy5wb2ludHNfLCBob2xlcyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuXG4vKipcbiAqIEFkZCBhIFN0ZWluZXIgcG9pbnQgdG8gdGhlIGNvbnN0cmFpbnRzXG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICogICAgICB2YXIgcG9pbnQgPSBuZXcgcG9seTJ0cmkuUG9pbnQoMTUwLCAxNTApO1xuICogICAgICBzd2N0eC5hZGRQb2ludChwb2ludCk7XG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICogICAgICBzd2N0eC5hZGRQb2ludCh7eDoxNTAsIHk6MTUwfSk7XG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1hZfSBwb2ludCAtIGFueSBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCB7eCx5fVxuICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmFkZFBvaW50ID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB0aGlzLnBvaW50c18ucHVzaChwb2ludCk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICogQGZ1bmN0aW9uXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rY29kZSBTd2VlcENvbnRleHQjYWRkUG9pbnR9IGluc3RlYWRcbiAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5BZGRQb2ludCA9IFN3ZWVwQ29udGV4dC5wcm90b3R5cGUuYWRkUG9pbnQ7XG5cblxuLyoqXG4gKiBBZGQgc2V2ZXJhbCBTdGVpbmVyIHBvaW50cyB0byB0aGUgY29uc3RyYWludHNcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKiAgICAgIHZhciBwb2ludHMgPSBbXG4gKiAgICAgICAgICBuZXcgcG9seTJ0cmkuUG9pbnQoMTUwLCAxNTApLFxuICogICAgICAgICAgbmV3IHBvbHkydHJpLlBvaW50KDIwMCwgMjUwKSxcbiAqICAgICAgICAgIG5ldyBwb2x5MnRyaS5Qb2ludCgyNTAsIDI1MClcbiAqICAgICAgXTtcbiAqICAgICAgc3djdHguYWRkUG9pbnRzKHBvaW50cyk7XG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICogICAgICBzd2N0eC5hZGRQb2ludHMoW3t4OjE1MCwgeToxNTB9LCB7eDoyMDAsIHk6MjUwfSwge3g6MjUwLCB5OjI1MH1dKTtcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QXJyYXkuPFhZPn0gcG9pbnRzIC0gYXJyYXkgb2YgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGgge3gseX1cbiAqL1xuLy8gTWV0aG9kIGFkZGVkIGluIHRoZSBKYXZhU2NyaXB0IHZlcnNpb24gKHdhcyBub3QgcHJlc2VudCBpbiB0aGUgYysrIHZlcnNpb24pXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmFkZFBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIHRoaXMucG9pbnRzXyA9IHRoaXMucG9pbnRzXy5jb25jYXQocG9pbnRzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG5cbi8qKlxuICogVHJpYW5ndWxhdGUgdGhlIHBvbHlnb24gd2l0aCBob2xlcyBhbmQgU3RlaW5lciBwb2ludHMuXG4gKiBEbyB0aGlzIEFGVEVSIHlvdSd2ZSBhZGRlZCB0aGUgcG9seWxpbmUsIGhvbGVzLCBhbmQgU3RlaW5lciBwb2ludHNcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKiAgICAgIHN3Y3R4LnRyaWFuZ3VsYXRlKCk7XG4gKiAgICAgIHZhciB0cmlhbmdsZXMgPSBzd2N0eC5nZXRUcmlhbmdsZXMoKTtcbiAqIEBwdWJsaWNcbiAqL1xuLy8gU2hvcnRjdXQgbWV0aG9kIGZvciBzd2VlcC50cmlhbmd1bGF0ZShTd2VlcENvbnRleHQpLlxuLy8gTWV0aG9kIGFkZGVkIGluIHRoZSBKYXZhU2NyaXB0IHZlcnNpb24gKHdhcyBub3QgcHJlc2VudCBpbiB0aGUgYysrIHZlcnNpb24pXG5Td2VlcENvbnRleHQucHJvdG90eXBlLnRyaWFuZ3VsYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgc3dlZXAudHJpYW5ndWxhdGUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBwcm92aWRlZCBjb25zdHJhaW50cyAoY29udG91ciwgaG9sZXMgYW5kIFxuICogU3RlaW50ZXIgcG9pbnRzKS4gV2FybmluZyA6IHRoZXNlIHZhbHVlcyBhcmUgbm90IGF2YWlsYWJsZSBpZiB0aGUgdHJpYW5ndWxhdGlvbiBcbiAqIGhhcyBub3QgYmVlbiBkb25lIHlldC5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIHt7bWluOlBvaW50LG1heDpQb2ludH19IG9iamVjdCB3aXRoICdtaW4nIGFuZCAnbWF4JyBQb2ludFxuICovXG4vLyBNZXRob2QgYWRkZWQgaW4gdGhlIEphdmFTY3JpcHQgdmVyc2lvbiAod2FzIG5vdCBwcmVzZW50IGluIHRoZSBjKysgdmVyc2lvbilcblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge21pbjogdGhpcy5wbWluXywgbWF4OiB0aGlzLnBtYXhffTtcbn07XG5cbi8qKlxuICogR2V0IHJlc3VsdCBvZiB0cmlhbmd1bGF0aW9uLlxuICogVGhlIG91dHB1dCB0cmlhbmdsZXMgaGF2ZSB2ZXJ0aWNlcyB3aGljaCBhcmUgcmVmZXJlbmNlc1xuICogdG8gdGhlIGluaXRpYWwgaW5wdXQgcG9pbnRzIChub3QgY29waWVzKTogYW55IGN1c3RvbSBmaWVsZHMgaW4gdGhlXG4gKiBpbml0aWFsIHBvaW50cyBjYW4gYmUgcmV0cmlldmVkIGluIHRoZSBvdXRwdXQgdHJpYW5nbGVzLlxuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqICAgICAgc3djdHgudHJpYW5ndWxhdGUoKTtcbiAqICAgICAgdmFyIHRyaWFuZ2xlcyA9IHN3Y3R4LmdldFRyaWFuZ2xlcygpO1xuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIGNvbnRvdXIgPSBbe3g6MTAwLCB5OjEwMCwgaWQ6MX0sIHt4OjEwMCwgeTozMDAsIGlkOjJ9LCB7eDozMDAsIHk6MzAwLCBpZDozfV07XG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKiAgICAgIHN3Y3R4LnRyaWFuZ3VsYXRlKCk7XG4gKiAgICAgIHZhciB0cmlhbmdsZXMgPSBzd2N0eC5nZXRUcmlhbmdsZXMoKTtcbiAqICAgICAgdHlwZW9mIHRyaWFuZ2xlc1swXS5nZXRQb2ludCgwKS5pZFxuICogICAgICAvLyDihpIgXCJudW1iZXJcIlxuICogQHB1YmxpY1xuICogQHJldHVybnMge2FycmF5PFRyaWFuZ2xlPn0gICBhcnJheSBvZiB0cmlhbmdsZXNcbiAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5nZXRUcmlhbmdsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cmlhbmdsZXNfO1xufTtcblxuLyoqXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICogQGZ1bmN0aW9uXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rY29kZSBTd2VlcENvbnRleHQjZ2V0VHJpYW5nbGVzfSBpbnN0ZWFkXG4gKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuR2V0VHJpYW5nbGVzID0gU3dlZXBDb250ZXh0LnByb3RvdHlwZS5nZXRUcmlhbmdsZXM7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tU3dlZXBDb250ZXh0IChwcml2YXRlIEFQSSlcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmZyb250ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbnRfO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLnBvaW50Q291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNfLmxlbmd0aDtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZF87XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuc2V0SGVhZCA9IGZ1bmN0aW9uKHAxKSB7XG4gICAgdGhpcy5oZWFkXyA9IHAxO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLnRhaWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWlsXztcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5zZXRUYWlsID0gZnVuY3Rpb24ocDEpIHtcbiAgICB0aGlzLnRhaWxfID0gcDE7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuZ2V0TWFwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwXztcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5pbml0VHJpYW5ndWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4bWF4ID0gdGhpcy5wb2ludHNfWzBdLng7XG4gICAgdmFyIHhtaW4gPSB0aGlzLnBvaW50c19bMF0ueDtcbiAgICB2YXIgeW1heCA9IHRoaXMucG9pbnRzX1swXS55O1xuICAgIHZhciB5bWluID0gdGhpcy5wb2ludHNfWzBdLnk7XG5cbiAgICAvLyBDYWxjdWxhdGUgYm91bmRzXG4gICAgdmFyIGksIGxlbiA9IHRoaXMucG9pbnRzXy5sZW5ndGg7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wb2ludHNfW2ldO1xuICAgICAgICAvKiBqc2hpbnQgZXhwcjp0cnVlICovXG4gICAgICAgIChwLnggPiB4bWF4KSAmJiAoeG1heCA9IHAueCk7XG4gICAgICAgIChwLnggPCB4bWluKSAmJiAoeG1pbiA9IHAueCk7XG4gICAgICAgIChwLnkgPiB5bWF4KSAmJiAoeW1heCA9IHAueSk7XG4gICAgICAgIChwLnkgPCB5bWluKSAmJiAoeW1pbiA9IHAueSk7XG4gICAgfVxuICAgIHRoaXMucG1pbl8gPSBuZXcgUG9pbnQoeG1pbiwgeW1pbik7XG4gICAgdGhpcy5wbWF4XyA9IG5ldyBQb2ludCh4bWF4LCB5bWF4KTtcblxuICAgIHZhciBkeCA9IGtBbHBoYSAqICh4bWF4IC0geG1pbik7XG4gICAgdmFyIGR5ID0ga0FscGhhICogKHltYXggLSB5bWluKTtcbiAgICB0aGlzLmhlYWRfID0gbmV3IFBvaW50KHhtYXggKyBkeCwgeW1pbiAtIGR5KTtcbiAgICB0aGlzLnRhaWxfID0gbmV3IFBvaW50KHhtaW4gLSBkeCwgeW1pbiAtIGR5KTtcblxuICAgIC8vIFNvcnQgcG9pbnRzIGFsb25nIHktYXhpc1xuICAgIHRoaXMucG9pbnRzXy5zb3J0KFBvaW50LmNvbXBhcmUpO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmluaXRFZGdlcyA9IGZ1bmN0aW9uKHBvbHlsaW5lKSB7XG4gICAgdmFyIGksIGxlbiA9IHBvbHlsaW5lLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdGhpcy5lZGdlX2xpc3QucHVzaChuZXcgRWRnZShwb2x5bGluZVtpXSwgcG9seWxpbmVbKGkgKyAxKSAlIGxlbl0pKTtcbiAgICB9XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c19baW5kZXhdO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmFkZFRvTWFwID0gZnVuY3Rpb24odHJpYW5nbGUpIHtcbiAgICB0aGlzLm1hcF8ucHVzaCh0cmlhbmdsZSk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUubG9jYXRlTm9kZSA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbnRfLmxvY2F0ZU5vZGUocG9pbnQueCk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQWR2YW5jaW5nRnJvbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGVhZDtcbiAgICB2YXIgbWlkZGxlO1xuICAgIHZhciB0YWlsO1xuICAgIC8vIEluaXRpYWwgdHJpYW5nbGVcbiAgICB2YXIgdHJpYW5nbGUgPSBuZXcgVHJpYW5nbGUodGhpcy5wb2ludHNfWzBdLCB0aGlzLnRhaWxfLCB0aGlzLmhlYWRfKTtcblxuICAgIHRoaXMubWFwXy5wdXNoKHRyaWFuZ2xlKTtcblxuICAgIGhlYWQgPSBuZXcgTm9kZSh0cmlhbmdsZS5nZXRQb2ludCgxKSwgdHJpYW5nbGUpO1xuICAgIG1pZGRsZSA9IG5ldyBOb2RlKHRyaWFuZ2xlLmdldFBvaW50KDApLCB0cmlhbmdsZSk7XG4gICAgdGFpbCA9IG5ldyBOb2RlKHRyaWFuZ2xlLmdldFBvaW50KDIpKTtcblxuICAgIHRoaXMuZnJvbnRfID0gbmV3IEFkdmFuY2luZ0Zyb250KGhlYWQsIHRhaWwpO1xuXG4gICAgaGVhZC5uZXh0ID0gbWlkZGxlO1xuICAgIG1pZGRsZS5uZXh0ID0gdGFpbDtcbiAgICBtaWRkbGUucHJldiA9IGhlYWQ7XG4gICAgdGFpbC5wcmV2ID0gbWlkZGxlO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICAgIC8qIGpzaGludCB1bnVzZWQ6ZmFsc2UgKi9cbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5tYXBUcmlhbmdsZVRvTm9kZXMgPSBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgaWYgKCF0LmdldE5laWdoYm9yKGkpKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuZnJvbnRfLmxvY2F0ZVBvaW50KHQucG9pbnRDVyh0LmdldFBvaW50KGkpKSk7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgIG4udHJpYW5nbGUgPSB0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLnJlbW92ZUZyb21NYXAgPSBmdW5jdGlvbih0cmlhbmdsZSkge1xuICAgIHZhciBpLCBtYXAgPSB0aGlzLm1hcF8sIGxlbiA9IG1hcC5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChtYXBbaV0gPT09IHRyaWFuZ2xlKSB7XG4gICAgICAgICAgICBtYXAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIERvIGEgZGVwdGggZmlyc3QgdHJhdmVyc2FsIHRvIGNvbGxlY3QgdHJpYW5nbGVzXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtUcmlhbmdsZX0gdHJpYW5nbGUgc3RhcnRcbiAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5tZXNoQ2xlYW4gPSBmdW5jdGlvbih0cmlhbmdsZSkge1xuICAgIC8vIE5ldyBpbXBsZW1lbnRhdGlvbiBhdm9pZHMgcmVjdXJzaXZlIGNhbGxzIGFuZCB1c2UgYSBsb29wIGluc3RlYWQuXG4gICAgLy8gQ2YuIGlzc3VlcyAjIDU3LCA2NSBhbmQgNjkuXG4gICAgdmFyIHRyaWFuZ2xlcyA9IFt0cmlhbmdsZV0sIHQsIGk7XG4gICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuICAgIHdoaWxlICh0ID0gdHJpYW5nbGVzLnBvcCgpKSB7XG4gICAgICAgIGlmICghdC5pc0ludGVyaW9yKCkpIHtcbiAgICAgICAgICAgIHQuc2V0SW50ZXJpb3IodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlc18ucHVzaCh0KTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXQuY29uc3RyYWluZWRfZWRnZVtpXSkge1xuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaCh0LmdldE5laWdoYm9yKGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tRXhwb3J0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN3ZWVwQ29udGV4dDtcblxufSx7XCIuL2FkdmFuY2luZ2Zyb250XCI6MixcIi4vcG9pbnRcIjo0LFwiLi9wb2ludGVycm9yXCI6NSxcIi4vc3dlZXBcIjo3LFwiLi90cmlhbmdsZVwiOjl9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBQb2x5MlRyaSBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXG4gKiBcbiAqIHBvbHkydHJpLmpzIChKYXZhU2NyaXB0IHBvcnQpIChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3IzbWkvcG9seTJ0cmkuanNcbiAqXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgMy1jbGF1c2UgQlNEIExpY2Vuc2UsIHNlZSBMSUNFTlNFLnR4dFxuICovXG5cbi8qIGpzaGludCBtYXhjb21wbGV4aXR5OjEwICovXG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qXG4gKiBOb3RlXG4gKiA9PT09XG4gKiB0aGUgc3RydWN0dXJlIG9mIHRoaXMgSmF2YVNjcmlwdCB2ZXJzaW9uIG9mIHBvbHkydHJpIGludGVudGlvbmFsbHkgZm9sbG93c1xuICogYXMgY2xvc2VseSBhcyBwb3NzaWJsZSB0aGUgc3RydWN0dXJlIG9mIHRoZSByZWZlcmVuY2UgQysrIHZlcnNpb24sIHRvIG1ha2UgaXQgXG4gKiBlYXNpZXIgdG8ga2VlcCB0aGUgMiB2ZXJzaW9ucyBpbiBzeW5jLlxuICovXG5cbnZhciB4eSA9IF9kZXJlcV8oXCIuL3h5XCIpO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVRyaWFuZ2xlXG4vKipcbiAqIFRyaWFuZ2xlIGNsYXNzLjxicj5cbiAqIFRyaWFuZ2xlLWJhc2VkIGRhdGEgc3RydWN0dXJlcyBhcmUga25vd24gdG8gaGF2ZSBiZXR0ZXIgcGVyZm9ybWFuY2UgdGhhblxuICogcXVhZC1lZGdlIHN0cnVjdHVyZXMuXG4gKiBTZWU6IEouIFNoZXdjaHVrLCBcIlRyaWFuZ2xlOiBFbmdpbmVlcmluZyBhIDJEIFF1YWxpdHkgTWVzaCBHZW5lcmF0b3IgYW5kXG4gKiBEZWxhdW5heSBUcmlhbmd1bGF0b3JcIiwgXCJUcmlhbmd1bGF0aW9ucyBpbiBDR0FMXCJcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqIEBwYXJhbSB7IVhZfSBwYSAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBwYiAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBwYyAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqL1xudmFyIFRyaWFuZ2xlID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgIC8qKlxuICAgICAqIFRyaWFuZ2xlIHBvaW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjxYWT59XG4gICAgICovXG4gICAgdGhpcy5wb2ludHNfID0gW2EsIGIsIGNdO1xuXG4gICAgLyoqXG4gICAgICogTmVpZ2hib3IgbGlzdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjxUcmlhbmdsZT59XG4gICAgICovXG4gICAgdGhpcy5uZWlnaGJvcnNfID0gW251bGwsIG51bGwsIG51bGxdO1xuXG4gICAgLyoqXG4gICAgICogSGFzIHRoaXMgdHJpYW5nbGUgYmVlbiBtYXJrZWQgYXMgYW4gaW50ZXJpb3IgdHJpYW5nbGU/XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmludGVyaW9yXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRmxhZ3MgdG8gZGV0ZXJtaW5lIGlmIGFuIGVkZ2UgaXMgYSBDb25zdHJhaW5lZCBlZGdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWluZWRfZWRnZSA9IFtmYWxzZSwgZmFsc2UsIGZhbHNlXTtcblxuICAgIC8qKlxuICAgICAqIEZsYWdzIHRvIGRldGVybWluZSBpZiBhbiBlZGdlIGlzIGEgRGVsYXVuZXkgZWRnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5Ljxib29sZWFuPn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbGF1bmF5X2VkZ2UgPSBbZmFsc2UsIGZhbHNlLCBmYWxzZV07XG59O1xuXG52YXIgcDJzID0geHkudG9TdHJpbmc7XG4vKipcbiAqIEZvciBwcmV0dHkgcHJpbnRpbmcgZXguIDxjb2RlPlwiWyg1OzQyKSgxMDsyMCkoMjE7MzApXVwiPC9jb2RlPi5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIChcIltcIiArIHAycyh0aGlzLnBvaW50c19bMF0pICsgcDJzKHRoaXMucG9pbnRzX1sxXSkgKyBwMnModGhpcy5wb2ludHNfWzJdKSArIFwiXVwiKTtcbn07XG5cbi8qKlxuICogR2V0IG9uZSB2ZXJ0aWNlIG9mIHRoZSB0cmlhbmdsZS5cbiAqIFRoZSBvdXRwdXQgdHJpYW5nbGVzIG9mIGEgdHJpYW5ndWxhdGlvbiBoYXZlIHZlcnRpY2VzIHdoaWNoIGFyZSByZWZlcmVuY2VzXG4gKiB0byB0aGUgaW5pdGlhbCBpbnB1dCBwb2ludHMgKG5vdCBjb3BpZXMpOiBhbnkgY3VzdG9tIGZpZWxkcyBpbiB0aGVcbiAqIGluaXRpYWwgcG9pbnRzIGNhbiBiZSByZXRyaWV2ZWQgaW4gdGhlIG91dHB1dCB0cmlhbmdsZXMuXG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgY29udG91ciA9IFt7eDoxMDAsIHk6MTAwLCBpZDoxfSwge3g6MTAwLCB5OjMwMCwgaWQ6Mn0sIHt4OjMwMCwgeTozMDAsIGlkOjN9XTtcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqICAgICAgc3djdHgudHJpYW5ndWxhdGUoKTtcbiAqICAgICAgdmFyIHRyaWFuZ2xlcyA9IHN3Y3R4LmdldFRyaWFuZ2xlcygpO1xuICogICAgICB0eXBlb2YgdHJpYW5nbGVzWzBdLmdldFBvaW50KDApLmlkXG4gKiAgICAgIC8vIOKGkiBcIm51bWJlclwiXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB2ZXJ0aWNlIGluZGV4OiAwLCAxIG9yIDJcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIHtYWX1cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNfW2luZGV4XTtcbn07XG5cbi8qKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAqIEBmdW5jdGlvblxuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGlua2NvZGUgVHJpYW5nbGUjZ2V0UG9pbnR9IGluc3RlYWRcbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLkdldFBvaW50ID0gVHJpYW5nbGUucHJvdG90eXBlLmdldFBvaW50O1xuXG4vKipcbiAqIEdldCBhbGwgMyB2ZXJ0aWNlcyBvZiB0aGUgdHJpYW5nbGUgYXMgYW4gYXJyYXlcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm4ge0FycmF5LjxYWT59XG4gKi9cbi8vIE1ldGhvZCBhZGRlZCBpbiB0aGUgSmF2YVNjcmlwdCB2ZXJzaW9uICh3YXMgbm90IHByZXNlbnQgaW4gdGhlIGMrKyB2ZXJzaW9uKVxuVHJpYW5nbGUucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c187XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm5zIHs/VHJpYW5nbGV9XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5nZXROZWlnaGJvciA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubmVpZ2hib3JzX1tpbmRleF07XG59O1xuXG4vKipcbiAqIFRlc3QgaWYgdGhpcyBUcmlhbmdsZSBjb250YWlucyB0aGUgUG9pbnQgb2JqZWN0IGdpdmVuIGFzIHBhcmFtZXRlciBhcyBvbmUgb2YgaXRzIHZlcnRpY2VzLlxuICogT25seSBwb2ludCByZWZlcmVuY2VzIGFyZSBjb21wYXJlZCwgbm90IHZhbHVlcy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7WFl9IHBvaW50IC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPlRydWU8L2NvZGU+IGlmIHRoZSBQb2ludCBvYmplY3QgaXMgb2YgdGhlIFRyaWFuZ2xlJ3MgdmVydGljZXMsXG4gKiAgICAgICAgIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNfO1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgcmV0dXJuIChwb2ludCA9PT0gcG9pbnRzWzBdIHx8IHBvaW50ID09PSBwb2ludHNbMV0gfHwgcG9pbnQgPT09IHBvaW50c1syXSk7XG59O1xuXG4vKipcbiAqIFRlc3QgaWYgdGhpcyBUcmlhbmdsZSBjb250YWlucyB0aGUgRWRnZSBvYmplY3QgZ2l2ZW4gYXMgcGFyYW1ldGVyIGFzIGl0c1xuICogYm91bmRpbmcgZWRnZXMuIE9ubHkgcG9pbnQgcmVmZXJlbmNlcyBhcmUgY29tcGFyZWQsIG5vdCB2YWx1ZXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gKiBAcmV0dXJuIHtib29sZWFufSA8Y29kZT5UcnVlPC9jb2RlPiBpZiB0aGUgRWRnZSBvYmplY3QgaXMgb2YgdGhlIFRyaWFuZ2xlJ3MgYm91bmRpbmdcbiAqICAgICAgICAgZWRnZXMsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5jb250YWluc0VkZ2UgPSBmdW5jdGlvbihlZGdlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbnNQb2ludChlZGdlLnApICYmIHRoaXMuY29udGFpbnNQb2ludChlZGdlLnEpO1xufTtcblxuLyoqXG4gKiBUZXN0IGlmIHRoaXMgVHJpYW5nbGUgY29udGFpbnMgdGhlIHR3byBQb2ludCBvYmplY3RzIGdpdmVuIGFzIHBhcmFtZXRlcnMgYW1vbmcgaXRzIHZlcnRpY2VzLlxuICogT25seSBwb2ludCByZWZlcmVuY2VzIGFyZSBjb21wYXJlZCwgbm90IHZhbHVlcy5cbiAqIEBwYXJhbSB7WFl9IHAxIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7WFl9IHAyIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5jb250YWluc1BvaW50cyA9IGZ1bmN0aW9uKHAxLCBwMikge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5zUG9pbnQocDEpICYmIHRoaXMuY29udGFpbnNQb2ludChwMik7XG59O1xuXG4vKipcbiAqIEhhcyB0aGlzIHRyaWFuZ2xlIGJlZW4gbWFya2VkIGFzIGFuIGludGVyaW9yIHRyaWFuZ2xlP1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5pc0ludGVyaW9yID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJpb3JfO1xufTtcblxuLyoqXG4gKiBNYXJrIHRoaXMgdHJpYW5nbGUgYXMgYW4gaW50ZXJpb3IgdHJpYW5nbGVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludGVyaW9yXG4gKiBAcmV0dXJucyB7VHJpYW5nbGV9IHRoaXNcbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLnNldEludGVyaW9yID0gZnVuY3Rpb24oaW50ZXJpb3IpIHtcbiAgICB0aGlzLmludGVyaW9yXyA9IGludGVyaW9yO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgbmVpZ2hib3IgcG9pbnRlcnMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtYWX0gcDEgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHtYWX0gcDIgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHtUcmlhbmdsZX0gdCBUcmlhbmdsZSBvYmplY3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgY2FuJ3QgZmluZCBvYmplY3RzXG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5tYXJrTmVpZ2hib3JQb2ludGVycyA9IGZ1bmN0aW9uKHAxLCBwMiwgdCkge1xuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAoKHAxID09PSBwb2ludHNbMl0gJiYgcDIgPT09IHBvaW50c1sxXSkgfHwgKHAxID09PSBwb2ludHNbMV0gJiYgcDIgPT09IHBvaW50c1syXSkpIHtcbiAgICAgICAgdGhpcy5uZWlnaGJvcnNfWzBdID0gdDtcbiAgICB9IGVsc2UgaWYgKChwMSA9PT0gcG9pbnRzWzBdICYmIHAyID09PSBwb2ludHNbMl0pIHx8IChwMSA9PT0gcG9pbnRzWzJdICYmIHAyID09PSBwb2ludHNbMF0pKSB7XG4gICAgICAgIHRoaXMubmVpZ2hib3JzX1sxXSA9IHQ7XG4gICAgfSBlbHNlIGlmICgocDEgPT09IHBvaW50c1swXSAmJiBwMiA9PT0gcG9pbnRzWzFdKSB8fCAocDEgPT09IHBvaW50c1sxXSAmJiBwMiA9PT0gcG9pbnRzWzBdKSkge1xuICAgICAgICB0aGlzLm5laWdoYm9yc19bMl0gPSB0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seTJ0cmkgSW52YWxpZCBUcmlhbmdsZS5tYXJrTmVpZ2hib3JQb2ludGVycygpIGNhbGwnKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEV4aGF1c3RpdmUgc2VhcmNoIHRvIHVwZGF0ZSBuZWlnaGJvciBwb2ludGVyc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7IVRyaWFuZ2xlfSB0XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5tYXJrTmVpZ2hib3IgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICBpZiAodC5jb250YWluc1BvaW50cyhwb2ludHNbMV0sIHBvaW50c1syXSkpIHtcbiAgICAgICAgdGhpcy5uZWlnaGJvcnNfWzBdID0gdDtcbiAgICAgICAgdC5tYXJrTmVpZ2hib3JQb2ludGVycyhwb2ludHNbMV0sIHBvaW50c1syXSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmICh0LmNvbnRhaW5zUG9pbnRzKHBvaW50c1swXSwgcG9pbnRzWzJdKSkge1xuICAgICAgICB0aGlzLm5laWdoYm9yc19bMV0gPSB0O1xuICAgICAgICB0Lm1hcmtOZWlnaGJvclBvaW50ZXJzKHBvaW50c1swXSwgcG9pbnRzWzJdLCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHQuY29udGFpbnNQb2ludHMocG9pbnRzWzBdLCBwb2ludHNbMV0pKSB7XG4gICAgICAgIHRoaXMubmVpZ2hib3JzX1syXSA9IHQ7XG4gICAgICAgIHQubWFya05laWdoYm9yUG9pbnRlcnMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHRoaXMpO1xuICAgIH1cbn07XG5cblxuVHJpYW5nbGUucHJvdG90eXBlLmNsZWFyTmVpZ2hib3JzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5uZWlnaGJvcnNfWzBdID0gbnVsbDtcbiAgICB0aGlzLm5laWdoYm9yc19bMV0gPSBudWxsO1xuICAgIHRoaXMubmVpZ2hib3JzX1syXSA9IG51bGw7XG59O1xuXG5UcmlhbmdsZS5wcm90b3R5cGUuY2xlYXJEZWxhdW5heUVkZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kZWxhdW5heV9lZGdlWzBdID0gZmFsc2U7XG4gICAgdGhpcy5kZWxhdW5heV9lZGdlWzFdID0gZmFsc2U7XG4gICAgdGhpcy5kZWxhdW5heV9lZGdlWzJdID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBvaW50IGNsb2Nrd2lzZSB0byB0aGUgZ2l2ZW4gcG9pbnQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtYWX0gcCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5wb2ludENXID0gZnVuY3Rpb24ocCkge1xuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gcG9pbnRzWzBdKSB7XG4gICAgICAgIHJldHVybiBwb2ludHNbMl07XG4gICAgfSBlbHNlIGlmIChwID09PSBwb2ludHNbMV0pIHtcbiAgICAgICAgcmV0dXJuIHBvaW50c1swXTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHBvaW50c1syXSkge1xuICAgICAgICByZXR1cm4gcG9pbnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9pbnQgY291bnRlci1jbG9ja3dpc2UgdG8gdGhlIGdpdmVuIHBvaW50LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WFl9IHAgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUucG9pbnRDQ1cgPSBmdW5jdGlvbihwKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSBwb2ludHNbMF0pIHtcbiAgICAgICAgcmV0dXJuIHBvaW50c1sxXTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHBvaW50c1sxXSkge1xuICAgICAgICByZXR1cm4gcG9pbnRzWzJdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gcG9pbnRzWzJdKSB7XG4gICAgICAgIHJldHVybiBwb2ludHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZWlnaGJvciBjbG9ja3dpc2UgdG8gZ2l2ZW4gcG9pbnQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtYWX0gcCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5uZWlnaGJvckNXID0gZnVuY3Rpb24ocCkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHRoaXMucG9pbnRzX1swXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcnNfWzFdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yc19bMl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3JzX1swXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5laWdoYm9yIGNvdW50ZXItY2xvY2t3aXNlIHRvIGdpdmVuIHBvaW50LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WFl9IHAgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUubmVpZ2hib3JDQ1cgPSBmdW5jdGlvbihwKSB7XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzBdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yc19bMl07XG4gICAgfSBlbHNlIGlmIChwID09PSB0aGlzLnBvaW50c19bMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3JzX1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcnNfWzFdO1xuICAgIH1cbn07XG5cblRyaWFuZ2xlLnByb3RvdHlwZS5nZXRDb25zdHJhaW5lZEVkZ2VDVyA9IGZ1bmN0aW9uKHApIHtcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSB0aGlzLnBvaW50c19bMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWluZWRfZWRnZVsxXTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHRoaXMucG9pbnRzX1sxXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW5lZF9lZGdlWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMF07XG4gICAgfVxufTtcblxuVHJpYW5nbGUucHJvdG90eXBlLmdldENvbnN0cmFpbmVkRWRnZUNDVyA9IGZ1bmN0aW9uKHApIHtcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSB0aGlzLnBvaW50c19bMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWluZWRfZWRnZVsyXTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHRoaXMucG9pbnRzX1sxXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW5lZF9lZGdlWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMV07XG4gICAgfVxufTtcblxuLy8gQWRkaXRpb25hbCBjaGVjayBmcm9tIEphdmEgdmVyc2lvbiAoc2VlIGlzc3VlICM4OClcblRyaWFuZ2xlLnByb3RvdHlwZS5nZXRDb25zdHJhaW5lZEVkZ2VBY3Jvc3MgPSBmdW5jdGlvbihwKSB7XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzBdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMF07XG4gICAgfSBlbHNlIGlmIChwID09PSB0aGlzLnBvaW50c19bMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWluZWRfZWRnZVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW5lZF9lZGdlWzJdO1xuICAgIH1cbn07XG5cblRyaWFuZ2xlLnByb3RvdHlwZS5zZXRDb25zdHJhaW5lZEVkZ2VDVyA9IGZ1bmN0aW9uKHAsIGNlKSB7XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzBdKSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWluZWRfZWRnZVsxXSA9IGNlO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzFdKSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWluZWRfZWRnZVsyXSA9IGNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWluZWRfZWRnZVswXSA9IGNlO1xuICAgIH1cbn07XG5cblRyaWFuZ2xlLnByb3RvdHlwZS5zZXRDb25zdHJhaW5lZEVkZ2VDQ1cgPSBmdW5jdGlvbihwLCBjZSkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHRoaXMucG9pbnRzX1swXSkge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMl0gPSBjZTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHRoaXMucG9pbnRzX1sxXSkge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMF0gPSBjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMV0gPSBjZTtcbiAgICB9XG59O1xuXG5UcmlhbmdsZS5wcm90b3R5cGUuZ2V0RGVsYXVuYXlFZGdlQ1cgPSBmdW5jdGlvbihwKSB7XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzBdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGF1bmF5X2VkZ2VbMV07XG4gICAgfSBlbHNlIGlmIChwID09PSB0aGlzLnBvaW50c19bMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsYXVuYXlfZWRnZVsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxhdW5heV9lZGdlWzBdO1xuICAgIH1cbn07XG5cblRyaWFuZ2xlLnByb3RvdHlwZS5nZXREZWxhdW5heUVkZ2VDQ1cgPSBmdW5jdGlvbihwKSB7XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzBdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGF1bmF5X2VkZ2VbMl07XG4gICAgfSBlbHNlIGlmIChwID09PSB0aGlzLnBvaW50c19bMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsYXVuYXlfZWRnZVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxhdW5heV9lZGdlWzFdO1xuICAgIH1cbn07XG5cblRyaWFuZ2xlLnByb3RvdHlwZS5zZXREZWxhdW5heUVkZ2VDVyA9IGZ1bmN0aW9uKHAsIGUpIHtcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSB0aGlzLnBvaW50c19bMF0pIHtcbiAgICAgICAgdGhpcy5kZWxhdW5heV9lZGdlWzFdID0gZTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHRoaXMucG9pbnRzX1sxXSkge1xuICAgICAgICB0aGlzLmRlbGF1bmF5X2VkZ2VbMl0gPSBlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVsYXVuYXlfZWRnZVswXSA9IGU7XG4gICAgfVxufTtcblxuVHJpYW5nbGUucHJvdG90eXBlLnNldERlbGF1bmF5RWRnZUNDVyA9IGZ1bmN0aW9uKHAsIGUpIHtcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSB0aGlzLnBvaW50c19bMF0pIHtcbiAgICAgICAgdGhpcy5kZWxhdW5heV9lZGdlWzJdID0gZTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHRoaXMucG9pbnRzX1sxXSkge1xuICAgICAgICB0aGlzLmRlbGF1bmF5X2VkZ2VbMF0gPSBlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVsYXVuYXlfZWRnZVsxXSA9IGU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgbmVpZ2hib3IgYWNyb3NzIHRvIGdpdmVuIHBvaW50LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WFl9IHAgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybnMge1RyaWFuZ2xlfVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUubmVpZ2hib3JBY3Jvc3MgPSBmdW5jdGlvbihwKSB7XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzBdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yc19bMF07XG4gICAgfSBlbHNlIGlmIChwID09PSB0aGlzLnBvaW50c19bMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3JzX1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcnNfWzJdO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7IVRyaWFuZ2xlfSB0IFRyaWFuZ2xlIG9iamVjdC5cbiAqIEBwYXJhbSB7WFl9IHAgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUub3Bwb3NpdGVQb2ludCA9IGZ1bmN0aW9uKHQsIHApIHtcbiAgICB2YXIgY3cgPSB0LnBvaW50Q1cocCk7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRDVyhjdyk7XG59O1xuXG4vKipcbiAqIExlZ2FsaXplIHRyaWFuZ2xlIGJ5IHJvdGF0aW5nIGNsb2Nrd2lzZSBhcm91bmQgb1BvaW50XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtYWX0gb3BvaW50IC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7WFl9IG5wb2ludCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgb1BvaW50IGNhbiBub3QgYmUgZm91bmRcbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLmxlZ2FsaXplID0gZnVuY3Rpb24ob3BvaW50LCBucG9pbnQpIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNfO1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKG9wb2ludCA9PT0gcG9pbnRzWzBdKSB7XG4gICAgICAgIHBvaW50c1sxXSA9IHBvaW50c1swXTtcbiAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRzWzJdO1xuICAgICAgICBwb2ludHNbMl0gPSBucG9pbnQ7XG4gICAgfSBlbHNlIGlmIChvcG9pbnQgPT09IHBvaW50c1sxXSkge1xuICAgICAgICBwb2ludHNbMl0gPSBwb2ludHNbMV07XG4gICAgICAgIHBvaW50c1sxXSA9IHBvaW50c1swXTtcbiAgICAgICAgcG9pbnRzWzBdID0gbnBvaW50O1xuICAgIH0gZWxzZSBpZiAob3BvaW50ID09PSBwb2ludHNbMl0pIHtcbiAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRzWzJdO1xuICAgICAgICBwb2ludHNbMl0gPSBwb2ludHNbMV07XG4gICAgICAgIHBvaW50c1sxXSA9IG5wb2ludDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHkydHJpIEludmFsaWQgVHJpYW5nbGUubGVnYWxpemUoKSBjYWxsJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhIHBvaW50IGluIHRoZSB0cmlhbmdsZS4gXG4gKiBUaGUgcG9pbnQgKm11c3QqIGJlIGEgcmVmZXJlbmNlIHRvIG9uZSBvZiB0aGUgdHJpYW5nbGUncyB2ZXJ0aWNlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1hZfSBwIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGluZGV4IDAsIDEgb3IgMlxuICogQHRocm93cyB7RXJyb3J9IGlmIHAgY2FuIG5vdCBiZSBmb3VuZFxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbihwKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSBwb2ludHNbMF0pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChwID09PSBwb2ludHNbMV0pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChwID09PSBwb2ludHNbMl0pIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5MnRyaSBJbnZhbGlkIFRyaWFuZ2xlLmluZGV4KCkgY2FsbCcpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WFl9IHAxIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7WFl9IHAyIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge251bWJlcn0gaW5kZXggMCwgMSBvciAyLCBvciAtMSBpZiBlcnJyb3JcbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLmVkZ2VJbmRleCA9IGZ1bmN0aW9uKHAxLCBwMikge1xuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocDEgPT09IHBvaW50c1swXSkge1xuICAgICAgICBpZiAocDIgPT09IHBvaW50c1sxXSkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocDIgPT09IHBvaW50c1syXSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHAxID09PSBwb2ludHNbMV0pIHtcbiAgICAgICAgaWYgKHAyID09PSBwb2ludHNbMl0pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2UgaWYgKHAyID09PSBwb2ludHNbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChwMSA9PT0gcG9pbnRzWzJdKSB7XG4gICAgICAgIGlmIChwMiA9PT0gcG9pbnRzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIGlmIChwMiA9PT0gcG9pbnRzWzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIE1hcmsgYW4gZWRnZSBvZiB0aGlzIHRyaWFuZ2xlIGFzIGNvbnN0cmFpbmVkLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGVkZ2UgaW5kZXhcbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLm1hcmtDb25zdHJhaW5lZEVkZ2VCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbaW5kZXhdID0gdHJ1ZTtcbn07XG4vKipcbiAqIE1hcmsgYW4gZWRnZSBvZiB0aGlzIHRyaWFuZ2xlIGFzIGNvbnN0cmFpbmVkLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RWRnZX0gZWRnZSBpbnN0YW5jZVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUubWFya0NvbnN0cmFpbmVkRWRnZUJ5RWRnZSA9IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICB0aGlzLm1hcmtDb25zdHJhaW5lZEVkZ2VCeVBvaW50cyhlZGdlLnAsIGVkZ2UucSk7XG59O1xuLyoqXG4gKiBNYXJrIGFuIGVkZ2Ugb2YgdGhpcyB0cmlhbmdsZSBhcyBjb25zdHJhaW5lZC5cbiAqIFRoaXMgbWV0aG9kIHRha2VzIHR3byBQb2ludCBpbnN0YW5jZXMgZGVmaW5pbmcgdGhlIGVkZ2Ugb2YgdGhlIHRyaWFuZ2xlLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WFl9IHAgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHtYWX0gcSAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5tYXJrQ29uc3RyYWluZWRFZGdlQnlQb2ludHMgPSBmdW5jdGlvbihwLCBxKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlcyAgICAgICAgXG4gICAgaWYgKChxID09PSBwb2ludHNbMF0gJiYgcCA9PT0gcG9pbnRzWzFdKSB8fCAocSA9PT0gcG9pbnRzWzFdICYmIHAgPT09IHBvaW50c1swXSkpIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW5lZF9lZGdlWzJdID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKChxID09PSBwb2ludHNbMF0gJiYgcCA9PT0gcG9pbnRzWzJdKSB8fCAocSA9PT0gcG9pbnRzWzJdICYmIHAgPT09IHBvaW50c1swXSkpIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW5lZF9lZGdlWzFdID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKChxID09PSBwb2ludHNbMV0gJiYgcCA9PT0gcG9pbnRzWzJdKSB8fCAocSA9PT0gcG9pbnRzWzJdICYmIHAgPT09IHBvaW50c1sxXSkpIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW5lZF9lZGdlWzBdID0gdHJ1ZTtcbiAgICB9XG59O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLUV4cG9ydHMgKHB1YmxpYyBBUEkpXG5cbm1vZHVsZS5leHBvcnRzID0gVHJpYW5nbGU7XG5cbn0se1wiLi94eVwiOjExfV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIFBvbHkyVHJpIENvcHlyaWdodCAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cbiAqIFxuICogcG9seTJ0cmkuanMgKEphdmFTY3JpcHQgcG9ydCkgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcjNtaS9wb2x5MnRyaS5qc1xuICogXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgMy1jbGF1c2UgQlNEIExpY2Vuc2UsIHNlZSBMSUNFTlNFLnR4dFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFByZWNpc2lvbiB0byBkZXRlY3QgcmVwZWF0ZWQgb3IgY29sbGluZWFyIHBvaW50c1xuICogQHByaXZhdGVcbiAqIEBjb25zdCB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xudmFyIEVQU0lMT04gPSAxZS0xMjtcbmV4cG9ydHMuRVBTSUxPTiA9IEVQU0lMT047XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAcmVhZG9ubHlcbiAqL1xudmFyIE9yaWVudGF0aW9uID0ge1xuICAgIFwiQ1dcIjogMSxcbiAgICBcIkNDV1wiOiAtMSxcbiAgICBcIkNPTExJTkVBUlwiOiAwXG59O1xuZXhwb3J0cy5PcmllbnRhdGlvbiA9IE9yaWVudGF0aW9uO1xuXG5cbi8qKlxuICogRm9ybXVsYSB0byBjYWxjdWxhdGUgc2lnbmVkIGFyZWE8YnI+XG4gKiBQb3NpdGl2ZSBpZiBDQ1c8YnI+XG4gKiBOZWdhdGl2ZSBpZiBDVzxicj5cbiAqIDAgaWYgY29sbGluZWFyPGJyPlxuICogPHByZT5cbiAqIEFbUDEsUDIsUDNdICA9ICAoeDEqeTIgLSB5MSp4MikgKyAoeDIqeTMgLSB5Mip4MykgKyAoeDMqeTEgLSB5Myp4MSlcbiAqICAgICAgICAgICAgICA9ICAoeDEteDMpKih5Mi15MykgLSAoeTEteTMpKih4Mi14MylcbiAqIDwvcHJlPlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyFYWX0gcGEgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gcGIgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gcGMgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtPcmllbnRhdGlvbn1cbiAqL1xuZnVuY3Rpb24gb3JpZW50MmQocGEsIHBiLCBwYykge1xuICAgIHZhciBkZXRsZWZ0ID0gKHBhLnggLSBwYy54KSAqIChwYi55IC0gcGMueSk7XG4gICAgdmFyIGRldHJpZ2h0ID0gKHBhLnkgLSBwYy55KSAqIChwYi54IC0gcGMueCk7XG4gICAgdmFyIHZhbCA9IGRldGxlZnQgLSBkZXRyaWdodDtcbiAgICBpZiAodmFsID4gLShFUFNJTE9OKSAmJiB2YWwgPCAoRVBTSUxPTikpIHtcbiAgICAgICAgcmV0dXJuIE9yaWVudGF0aW9uLkNPTExJTkVBUjtcbiAgICB9IGVsc2UgaWYgKHZhbCA+IDApIHtcbiAgICAgICAgcmV0dXJuIE9yaWVudGF0aW9uLkNDVztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3JpZW50YXRpb24uQ1c7XG4gICAgfVxufVxuZXhwb3J0cy5vcmllbnQyZCA9IG9yaWVudDJkO1xuXG5cbi8qKlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyFYWX0gcGEgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gcGIgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gcGMgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gcGQgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpblNjYW5BcmVhKHBhLCBwYiwgcGMsIHBkKSB7XG4gICAgdmFyIG9hZGIgPSAocGEueCAtIHBiLngpICogKHBkLnkgLSBwYi55KSAtIChwZC54IC0gcGIueCkgKiAocGEueSAtIHBiLnkpO1xuICAgIGlmIChvYWRiID49IC1FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgb2FkYyA9IChwYS54IC0gcGMueCkgKiAocGQueSAtIHBjLnkpIC0gKHBkLnggLSBwYy54KSAqIChwYS55IC0gcGMueSk7XG4gICAgaWYgKG9hZGMgPD0gRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pblNjYW5BcmVhID0gaW5TY2FuQXJlYTtcblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBhbmdsZSBiZXR3ZWVuIChwYSxwYikgYW5kIChwYSxwYykgaXMgb2J0dXNlIGkuZS4gKGFuZ2xlID4gz4AvMiB8fCBhbmdsZSA8IC3PgC8yKVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyFYWX0gcGEgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gcGIgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gcGMgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGFuZ2xlIGlzIG9idHVzZVxuICovXG5mdW5jdGlvbiBpc0FuZ2xlT2J0dXNlKHBhLCBwYiwgcGMpIHtcbiAgICB2YXIgYXggPSBwYi54IC0gcGEueDtcbiAgICB2YXIgYXkgPSBwYi55IC0gcGEueTtcbiAgICB2YXIgYnggPSBwYy54IC0gcGEueDtcbiAgICB2YXIgYnkgPSBwYy55IC0gcGEueTtcbiAgICByZXR1cm4gKGF4ICogYnggKyBheSAqIGJ5KSA8IDA7XG59XG5leHBvcnRzLmlzQW5nbGVPYnR1c2UgPSBpc0FuZ2xlT2J0dXNlO1xuXG5cbn0se31dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBQb2x5MlRyaSBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXG4gKiBcbiAqIHBvbHkydHJpLmpzIChKYXZhU2NyaXB0IHBvcnQpIChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3IzbWkvcG9seTJ0cmkuanNcbiAqIFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIDMtY2xhdXNlIEJTRCBMaWNlbnNlLCBzZWUgTElDRU5TRS50eHRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBvcGVyYXRlIG9uIFwiUG9pbnRcIiBvciBhbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGgge3gseX0sXG4gKiBhcyBkZWZpbmVkIGJ5IHRoZSB7QGxpbmsgWFl9IHR5cGVcbiAqIChbZHVjayB0eXBpbmdde0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRHVja190eXBpbmd9KS5cbiAqIEBtb2R1bGVcbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBwb2x5MnRyaS5qcyBzdXBwb3J0cyB1c2luZyBjdXN0b20gcG9pbnQgY2xhc3MgaW5zdGVhZCBvZiB7QGxpbmtjb2RlIFBvaW50fS5cbiAqIEFueSBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCA8Y29kZT57eCwgeX08L2NvZGU+IGF0dHJpYnV0ZXMgaXMgc3VwcG9ydGVkXG4gKiB0byBpbml0aWFsaXplIHRoZSBTd2VlcENvbnRleHQgcG9seWxpbmVzIGFuZCBwb2ludHNcbiAqIChbZHVjayB0eXBpbmdde0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRHVja190eXBpbmd9KS5cbiAqXG4gKiBwb2x5MnRyaS5qcyBtaWdodCBhZGQgZXh0cmEgZmllbGRzIHRvIHRoZSBwb2ludCBvYmplY3RzIHdoZW4gY29tcHV0aW5nIHRoZVxuICogdHJpYW5ndWxhdGlvbiA6IHRoZXkgYXJlIHByZWZpeGVkIHdpdGggPGNvZGU+X3AydF88L2NvZGU+IHRvIGF2b2lkIGNvbGxpc2lvbnNcbiAqIHdpdGggZmllbGRzIGluIHRoZSBjdXN0b20gY2xhc3MuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIGNvbnRvdXIgPSBbe3g6MTAwLCB5OjEwMH0sIHt4OjEwMCwgeTozMDB9LCB7eDozMDAsIHk6MzAwfSwge3g6MzAwLCB5OjEwMH1dO1xuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFhZXG4gKiBAcHJvcGVydHkge251bWJlcn0geCAtIHggY29vcmRpbmF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSB5IGNvb3JkaW5hdGVcbiAqL1xuXG5cbi8qKlxuICogUG9pbnQgcHJldHR5IHByaW50aW5nIDogcHJpbnRzIHggYW5kIHkgY29vcmRpbmF0ZXMuXG4gKiBAZXhhbXBsZVxuICogICAgICB4eS50b1N0cmluZ0Jhc2Uoe3g6NSwgeTo0Mn0pXG4gKiAgICAgIC8vIOKGkiBcIig1OzQyKVwiXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0geyFYWX0gcCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJucyB7c3RyaW5nfSA8Y29kZT5cIih4O3kpXCI8L2NvZGU+XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nQmFzZShwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIHAueCArIFwiO1wiICsgcC55ICsgXCIpXCIpO1xufVxuXG4vKipcbiAqIFBvaW50IHByZXR0eSBwcmludGluZy4gRGVsZWdhdGVzIHRvIHRoZSBwb2ludCdzIGN1c3RvbSBcInRvU3RyaW5nKClcIiBtZXRob2QgaWYgZXhpc3RzLFxuICogZWxzZSBzaW1wbHkgcHJpbnRzIHggYW5kIHkgY29vcmRpbmF0ZXMuXG4gKiBAZXhhbXBsZVxuICogICAgICB4eS50b1N0cmluZyh7eDo1LCB5OjQyfSlcbiAqICAgICAgLy8g4oaSIFwiKDU7NDIpXCJcbiAqIEBleGFtcGxlXG4gKiAgICAgIHh5LnRvU3RyaW5nKHt4OjUseTo0Mix0b1N0cmluZzpmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy54K1wiOlwiK3RoaXMueTt9fSlcbiAqICAgICAgLy8g4oaSIFwiNTo0MlwiXG4gKiBAcGFyYW0geyFYWX0gcCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJucyB7c3RyaW5nfSA8Y29kZT5cIih4O3kpXCI8L2NvZGU+XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHApIHtcbiAgICAvLyBUcnkgYSBjdXN0b20gdG9TdHJpbmcgZmlyc3QsIGFuZCBmYWxsYmFjayB0byBvd24gaW1wbGVtZW50YXRpb24gaWYgbm9uZVxuICAgIHZhciBzID0gcC50b1N0cmluZygpO1xuICAgIHJldHVybiAocyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyB0b1N0cmluZ0Jhc2UocCkgOiBzKTtcbn1cblxuXG4vKipcbiAqIENvbXBhcmUgdHdvIHBvaW50cyBjb21wb25lbnQtd2lzZS4gT3JkZXJlZCBieSB5IGF4aXMgZmlyc3QsIHRoZW4geCBheGlzLlxuICogQHBhcmFtIHshWFl9IGEgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IGIgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7bnVtYmVyfSA8Y29kZT4mbHQ7IDA8L2NvZGU+IGlmIDxjb2RlPmEgJmx0OyBiPC9jb2RlPixcbiAqICAgICAgICAgPGNvZGU+Jmd0OyAwPC9jb2RlPiBpZiA8Y29kZT5hICZndDsgYjwvY29kZT4sIFxuICogICAgICAgICA8Y29kZT4wPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgIGlmIChhLnkgPT09IGIueSkge1xuICAgICAgICByZXR1cm4gYS54IC0gYi54O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLnkgLSBiLnk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRlc3QgdHdvIFBvaW50IG9iamVjdHMgZm9yIGVxdWFsaXR5LlxuICogQHBhcmFtIHshWFl9IGEgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IGIgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+VHJ1ZTwvY29kZT4gaWYgPGNvZGU+YSA9PSBiPC9jb2RlPiwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgIHRvU3RyaW5nQmFzZTogdG9TdHJpbmdCYXNlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUsXG4gICAgZXF1YWxzOiBlcXVhbHNcbn07XG5cbn0se31dfSx7fSxbNl0pXG4oNilcbn0pOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRNT1ZFX1RPOiAxLFxuXHRMSU5FX1RPOiAyLFxuXHRCRVpJRVJfVE86IDMsXG5cdFFVQURSQV9UTzogNCxcblx0QVJDOiA1LFxuXHRFTExJUFNFOiA2XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0ZGVmaW5pdGlvbjogMSxcblx0d29ybGRXaWR0aDogMTUwLFxuXHRtdWx0aUNhbnZhczogdHJ1ZSxcblx0d2luZDogNSxcblx0ZGVidWc6IGZhbHNlLFxuXHRzaW1SZW5kZXJGcmVxOiA1MCxcblx0Z3Jhdml0eTogWzAsIC05LjhdLFxuXHRncm91cHM6XG5cdHtcblx0XHRkZWZhdWx0OiB7IGZpeGVkOiB0cnVlLCBwaHlzaWNzOiB7IGJvZHlUeXBlOiAnZ2hvc3QnIH0gfSxcblx0XHRnaG9zdDogeyBmaXhlZDogdHJ1ZSwgcGh5c2ljczogeyBib2R5VHlwZTogJ2dob3N0JyB9IH0sXG5cdFx0c29mdDpcblx0XHR7XG5cdFx0XHRzdHJ1Y3R1cmU6ICd0cmlhbmd1bGF0ZScsXG5cdFx0XHRub2RlUmFkaXVzOiAwLjEsXG5cdFx0XHRwaHlzaWNzOlxuXHRcdFx0e1xuXHRcdFx0XHRkaXN0YW5jZUNvbnN0cmFpbnQ6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzdGlmZm5lc3M6IDEwMDAwMCxcblx0XHRcdFx0XHRyZWxheGF0aW9uOiAxXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1hc3M6IDEsXG5cdFx0XHRcdGJvZHlUeXBlOiAnc29mdCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRyZWU6XG5cdFx0e1xuXHRcdFx0c3RydWN0dXJlOiAndHJpYW5ndWxhdGUnLFxuXHRcdFx0bm9kZVJhZGl1czogMC4xLFxuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0ZGlzdGFuY2VDb25zdHJhaW50OiBudWxsLFxuXHRcdFx0XHRsb2NrQ29uc3RyYWludDpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHN0aWZmbmVzczogMTAwMDAsXG5cdFx0XHRcdFx0cmVsYXhhdGlvbjogMC45XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1hc3M6IDUsXG5cdFx0XHRcdGRhbXBpbmc6IDAuOCxcblx0XHRcdFx0c3RydWN0dXJhbE1hc3NEZWNheTogMyxcblx0XHRcdFx0Ym9keVR5cGU6ICdzb2Z0J1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZmxvcmE6XG5cdFx0e1xuXHRcdFx0c3RydWN0dXJlOiAnbGluZScsXG5cdFx0XHRub2RlUmFkaXVzOiAwLjEsXG5cdFx0XHRwaHlzaWNzOlxuXHRcdFx0e1xuXHRcdFx0XHRkaXN0YW5jZUNvbnN0cmFpbnQ6IG51bGwsXG5cdFx0XHRcdGxvY2tDb25zdHJhaW50OlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3RpZmZuZXNzOiAxMDAwLFxuXHRcdFx0XHRcdHJlbGF4YXRpb246IDFcblx0XHRcdFx0fSxcblx0XHRcdFx0bWFzczogMC4xLFxuXHRcdFx0XHRzdHJ1Y3R1cmFsTWFzc0RlY2F5OiAzLFxuXHRcdFx0XHRib2R5VHlwZTogJ3NvZnQnXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRqZWxseTpcblx0XHR7XG5cdFx0XHRzdHJ1Y3R1cmU6ICdoZXhhRmlsbCcsXG5cdFx0XHRpbm5lclN0cnVjdHVyZURlZjogMC4wMSxcblx0XHRcdG5vZGVSYWRpdXM6IDAuMSxcblx0XHRcdHBoeXNpY3M6XG5cdFx0XHR7XG5cdFx0XHRcdGRpc3RhbmNlQ29uc3RyYWludDpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHN0aWZmbmVzczogMTAwMDAsXG5cdFx0XHRcdFx0cmVsYXhhdGlvbjogMzBcblx0XHRcdFx0fSxcblx0XHRcdFx0bWFzczogMSxcblx0XHRcdFx0Ym9keVR5cGU6ICdzb2Z0J1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bGluZTpcblx0XHR7XG5cdFx0XHRzdHJ1Y3R1cmU6ICdsaW5lJyxcblx0XHRcdG5vZGVSYWRpdXM6IDAuMSxcblx0XHRcdHBoeXNpY3M6XG5cdFx0XHR7XG5cdFx0XHRcdGRpc3RhbmNlQ29uc3RyYWludDogbnVsbCxcblx0XHRcdFx0bG9ja0NvbnN0cmFpbnQ6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzdGlmZm5lc3M6IDEwLFxuXHRcdFx0XHRcdHJlbGF4YXRpb246IDFcblx0XHRcdFx0fSxcblx0XHRcdFx0bWFzczogMSxcblx0XHRcdFx0Ym9keVR5cGU6ICdzb2Z0J1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cm9wZTpcblx0XHR7XG5cdFx0XHRzdHJ1Y3R1cmU6ICdsaW5lJyxcblx0XHRcdG5vZGVSYWRpdXM6IDAuMSxcblx0XHRcdHBoeXNpY3M6XG5cdFx0XHR7XG5cdFx0XHRcdGRpc3RhbmNlQ29uc3RyYWludDpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHN0aWZmbmVzczogMTAwMCxcblx0XHRcdFx0XHRyZWxheGF0aW9uOiAxXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1hc3M6IDEsXG5cdFx0XHRcdGJvZHlUeXBlOiAnc29mdCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhcmQ6XG5cdFx0e1xuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0bWFzczogMSxcblx0XHRcdFx0Ym9keVR5cGU6ICdoYXJkJ1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bWV0YWw6XG5cdFx0e1xuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0bWFzczogMTAsXG5cdFx0XHRcdGJvZHlUeXBlOiAnaGFyZCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdHdvb2Q6XG5cdFx0e1xuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0bWFzczogMSxcblx0XHRcdFx0Ym9keVR5cGU6ICdoYXJkJ1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YmFsbG9vbjpcblx0XHR7XG5cdFx0XHRwaHlzaWNzOlxuXHRcdFx0e1xuXHRcdFx0XHRtYXNzOiAwLjAxLFxuXHRcdFx0XHRncmF2aXR5U2NhbGU6IC0xMCxcblx0XHRcdFx0Ym9keVR5cGU6ICdoYXJkJ1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3RhdGljOlxuXHRcdHtcblx0XHRcdGZpeGVkOiB0cnVlLFxuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0bWFzczogMCxcblx0XHRcdFx0Ym9keVR5cGU6ICdoYXJkJ1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bm9Db2xsaWRlOlxuXHRcdHtcblx0XHRcdHBoeXNpY3M6XG5cdFx0XHR7XG5cdFx0XHRcdG1hc3M6IDEsXG5cdFx0XHRcdGJvZHlUeXBlOiAnaGFyZCcsXG5cdFx0XHRcdG5vQ29sbGlkZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bGVhdmVzOlxuXHRcdHtcblx0XHRcdHBoeXNpY3M6XG5cdFx0XHR7XG5cdFx0XHRcdG1hc3M6IDAuMDAxLFxuXHRcdFx0XHRncmF2aXR5U2NhbGU6IDAsXG5cdFx0XHRcdGJvZHlUeXBlOiAnaGFyZCcsXG5cdFx0XHRcdG5vQ29sbGlkZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuIiwidmFyIEdyaWQgPVxue1xuXHRpbml0OiBmdW5jdGlvbiAoJGdyYXBoKVxuXHR7XG5cdFx0dGhpcy5fZ3JhcGggPSAkZ3JhcGg7XG5cdFx0dmFyIG5vZGVzQXJyYXkgPSB0aGlzLl9ub2Rlc0FycmF5ID0gW107XG5cdFx0dGhpcy5fZ3JhcGguZm9yRWFjaChmdW5jdGlvbiAoJGxpbmUpXG5cdFx0e1xuXHRcdFx0aWYgKCRsaW5lKVxuXHRcdFx0e1xuXHRcdFx0XHQkbGluZS5mb3JFYWNoKGZ1bmN0aW9uICgkbm9kZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICgkbm9kZSkgeyBub2Rlc0FycmF5LnB1c2goJG5vZGUpOyB9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNyZWF0ZUZyb21Qb2x5Z29uOiBmdW5jdGlvbiAoJHBvbHlnb24sICRkZWYsICRoZXhhKVxuXHR7XG5cdFx0dmFyIGJvdW5kaW5nQm94ID0gJHBvbHlnb24uZ2V0Qm91bmRpbmdCb3goKTtcblxuXHRcdHZhciBkZWYgPSAkZGVmO1xuXHRcdC8vdmFyIGRlZiA9IHdpZHRoIC8gJGRlZjtcblx0XHR2YXIgdG9SZXR1cm4gPSBbXTtcblx0XHR2YXIgeUluYyA9ICRoZXhhID8gZGVmICogKE1hdGguc3FydCgzKSAvIDIpIDogZGVmO1xuXHRcdHZhciBoYWxmRGVmID0gZGVmICogMC41O1xuXHRcdGZvciAodmFyIHlQb3MgPSBib3VuZGluZ0JveFswXVsxXTsgeVBvcyA8PSBib3VuZGluZ0JveFsxXVsxXTsgeVBvcyArPSB5SW5jKVxuXHRcdHtcblx0XHRcdHZhciBsaW5lID0gW107XG5cdFx0XHQvL3ZhciBpbnRlcnNlY3Rpb25zID0gJHBvbHlnb24uZ2V0SW50ZXJzZWN0aW9uc0F0WSh5UG9zKTtcblx0XHRcdHZhciB4UG9zID0gYm91bmRpbmdCb3hbMF1bMF07XG5cdFx0XHR4UG9zID0gKCRoZXhhICYmIHRvUmV0dXJuLmxlbmd0aCAlIDIgIT09IDApID8geFBvcyArIGhhbGZEZWYgOiB4UG9zO1xuXHRcdFx0Zm9yICh4UG9zOyB4UG9zIDw9IGJvdW5kaW5nQm94WzFdWzBdICsgaGFsZkRlZjsgeFBvcyArPSBkZWYpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICgkcG9seWdvbi5pc0luc2lkZShbeFBvcywgeVBvc10pKSB7IGxpbmUucHVzaChbeFBvcywgeVBvc10pOyB9XG5cdFx0XHRcdGVsc2UgeyBsaW5lLnB1c2gobnVsbCk7IH1cblx0XHRcdH1cblx0XHRcdHRvUmV0dXJuLnB1c2gobGluZSk7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3QuY3JlYXRlKEdyaWQpLmluaXQodG9SZXR1cm4pO1xuXHR9LFxuXG5cdGdldEdyYXBoOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ncmFwaDsgfSxcblxuXHRnZXROb2Rlc0FycmF5OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ub2Rlc0FycmF5OyB9LFxuXG5cdGdldENsb3Nlc3Q6IGZ1bmN0aW9uICgkeCwgJHksICRzaXplKVxuXHR7XG5cdFx0dmFyIHNpemUgPSAkc2l6ZSB8fCAxO1xuXHRcdHZhciBjbG9zZXN0ID0gdGhpcy5fbm9kZXNBcnJheS5jb25jYXQoKTtcblx0XHRjbG9zZXN0LnNvcnQoZnVuY3Rpb24gKCRhLCAkYilcblx0XHR7XG5cdFx0XHRpZiAoJGEgPT09IG51bGwgfHwgJGIgPT09IG51bGwpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdHZhciBzaWRlWDEgPSBNYXRoLmFicygkYVswXSAtICR4KTtcblx0XHRcdHZhciBzaWRlWTEgPSBNYXRoLmFicygkYVsxXSAtICR5KTtcblx0XHRcdHZhciBkaXN0MSA9IE1hdGguc3FydChzaWRlWDEgKiBzaWRlWDEgKyBzaWRlWTEgKiBzaWRlWTEpO1xuXG5cdFx0XHR2YXIgc2lkZVgyID0gTWF0aC5hYnMoJGJbMF0gLSAkeCk7XG5cdFx0XHR2YXIgc2lkZVkyID0gTWF0aC5hYnMoJGJbMV0gLSAkeSk7XG5cdFx0XHR2YXIgZGlzdDIgPSBNYXRoLnNxcnQoc2lkZVgyICogc2lkZVgyICsgc2lkZVkyICogc2lkZVkyKTtcblxuXHRcdFx0cmV0dXJuIGRpc3QxIC0gZGlzdDI7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGNsb3Nlc3Quc2xpY2UoMCwgc2l6ZSk7XG5cdH0sXG5cblx0Z2V0TmVpZ2hib3VyczogZnVuY3Rpb24gKCR4LCAkeSwgJHJldHVybkVtcHR5KVxuXHR7XG5cdFx0dmFyIHRvUmV0dXJuID0gW107XG5cdFx0dmFyIGdyYXBoID0gdGhpcy5fZ3JhcGg7XG5cdFx0dmFyIGV2ZW4gPSAkeSAlIDIgPiAwO1xuXHRcdHZhciBsZWZ0ID0gZXZlbiA/ICR4IDogJHggLSAxO1xuXHRcdHZhciByaWdodCA9IGV2ZW4gPyAkeCArIDEgOiAkeDtcblxuXHRcdHZhciBORSA9IGdyYXBoWyR5IC0gMV0gJiYgZ3JhcGhbJHkgLSAxXVtyaWdodF0gPyBncmFwaFskeSAtIDFdW3JpZ2h0XSA6IG51bGw7XG5cdFx0dmFyIEUgPSBncmFwaFskeSArIDBdICYmIGdyYXBoWyR5ICsgMF1bJHggKyAxXSA/IGdyYXBoWyR5XVskeCArIDFdIDogbnVsbDtcblx0XHR2YXIgU0UgPSBncmFwaFskeSArIDFdICYmIGdyYXBoWyR5ICsgMV1bcmlnaHRdID8gZ3JhcGhbJHkgKyAxXVtyaWdodF0gOiBudWxsO1xuXHRcdHZhciBTVyA9IGdyYXBoWyR5ICsgMV0gJiYgZ3JhcGhbJHkgKyAxXVtsZWZ0XSA/IGdyYXBoWyR5ICsgMV1bbGVmdF0gOiBudWxsO1xuXHRcdHZhciBXID0gZ3JhcGhbJHkgKyAwXSAmJiBncmFwaFskeSArIDBdWyR4IC0gMV0gPyBncmFwaFskeV1bJHggLSAxXSA6IG51bGw7XG5cdFx0dmFyIE5XID0gZ3JhcGhbJHkgLSAxXSAmJiBncmFwaFskeSAtIDFdW2xlZnRdID8gZ3JhcGhbJHkgLSAxXVtsZWZ0XSA6IG51bGw7XG5cblx0XHRpZiAoTkUgfHwgJHJldHVybkVtcHR5KSB7IHRvUmV0dXJuLnB1c2goTkUpOyB9XG5cdFx0aWYgKEUgfHwgJHJldHVybkVtcHR5KSB7IHRvUmV0dXJuLnB1c2goRSk7IH1cblx0XHRpZiAoU0UgfHwgJHJldHVybkVtcHR5KSB7IHRvUmV0dXJuLnB1c2goU0UpOyB9XG5cdFx0aWYgKFNXIHx8ICRyZXR1cm5FbXB0eSkgeyB0b1JldHVybi5wdXNoKFNXKTsgfVxuXHRcdGlmIChXIHx8ICRyZXR1cm5FbXB0eSkgeyB0b1JldHVybi5wdXNoKFcpOyB9XG5cdFx0aWYgKE5XIHx8ICRyZXR1cm5FbXB0eSkgeyB0b1JldHVybi5wdXNoKE5XKTsgfVxuXG5cdFx0cmV0dXJuIHRvUmV0dXJuO1xuXHR9LFxuXG5cdGdldE5ldHdvcms6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgZ3JhcGggPSB0aGlzLl9ncmFwaDtcblx0XHR2YXIgbmV0d29yayA9IFtdO1xuXHRcdHZhciB2aXNpdGVkID0gW107XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciByb3dzTGVuZ3RoID0gZ3JhcGgubGVuZ3RoO1xuXHRcdGZvciAoaTsgaSA8IHJvd3NMZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgayA9IDA7XG5cdFx0XHR2YXIgcG9pbnRzTGVuZ3RoID0gZ3JhcGhbaV0ubGVuZ3RoO1xuXHRcdFx0Zm9yIChrOyBrIDwgcG9pbnRzTGVuZ3RoOyBrICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjdXJyUG9pbnQgPSBncmFwaFtpXVtrXTtcblx0XHRcdFx0aWYgKGN1cnJQb2ludClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciBjdXJyUG9pbnROZWlnaGJvdXJzID0gdGhpcy5nZXROZWlnaGJvdXJzKGssIGkpO1xuXHRcdFx0XHRcdGZvciAodmFyIG0gPSAwLCBuZWlnaGJvdXJzTGVuZ3RoID0gY3VyclBvaW50TmVpZ2hib3Vycy5sZW5ndGg7IG0gPCBuZWlnaGJvdXJzTGVuZ3RoOyBtICs9IDEpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGN1cnJOZWlnaCA9IGN1cnJQb2ludE5laWdoYm91cnNbbV07XG5cdFx0XHRcdFx0XHRpZiAoY3Vyck5laWdoICYmIHZpc2l0ZWQuaW5kZXhPZihjdXJyTmVpZ2gpID09PSAtMSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0bmV0d29yay5wdXNoKFtjdXJyUG9pbnQsIGN1cnJOZWlnaF0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2aXNpdGVkLnB1c2goY3VyclBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbmV0d29yaztcblx0fSxcblxuXHRnZXRPdXRsaW5lOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0aWYgKCF0aGlzLm91dGxpbmUpXG5cdFx0e1xuXHRcdFx0dmFyIGdyYXBoID0gdGhpcy5fZ3JhcGg7XG5cdFx0XHR2YXIgb3V0bGluZUdyYXBoID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgcm93c0xlbmd0aCA9IGdyYXBoLmxlbmd0aDsgaSA8IHJvd3NMZW5ndGg7IGkgKz0gMSlcblx0XHRcdHtcblx0XHRcdFx0b3V0bGluZUdyYXBoW2ldID0gW107XG5cdFx0XHRcdGZvciAodmFyIGsgPSAwLCBwb2ludHNMZW5ndGggPSBncmFwaFtpXS5sZW5ndGg7IGsgPCBwb2ludHNMZW5ndGg7IGsgKz0gMSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciBwb2ludCA9IGdyYXBoW2ldW2tdO1xuXHRcdFx0XHRcdG91dGxpbmVHcmFwaFtpXVtrXSA9IG51bGw7XG5cdFx0XHRcdFx0aWYgKHBvaW50KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBpc0VkZ2UgPSB0aGlzLmdldE5laWdoYm91cnMoaywgaSkubGVuZ3RoIDwgNjtcblx0XHRcdFx0XHRcdGlmIChpc0VkZ2UpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdG91dGxpbmVHcmFwaFtpXVtrXSA9IFtrLCBpXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMub3V0bGluZSA9IE9iamVjdC5jcmVhdGUoR3JpZCkuaW5pdChvdXRsaW5lR3JhcGgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm91dGxpbmU7XG5cdH0sXG5cblx0Z2V0U2hhcGVQYXRoOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIHBhdGggPSBbXTtcblx0XHR2YXIgY3VycmVudE91dGxpbmUgPSB0aGlzLmdldE91dGxpbmVzKClbMF07XG5cdFx0dmFyIG91dGxpbmVHcmFwaCA9IGN1cnJlbnRPdXRsaW5lLmdldEdyYXBoKCk7XG5cdFx0dmFyIGdldFN0YXJ0aW5nSW5kZXggPSBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvdXRsaW5lR3JhcGgubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghb3V0bGluZUdyYXBoW2ldKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcdGZvciAodmFyIGsgPSAwLCBwb2ludHNMZW5ndGggPSBvdXRsaW5lR3JhcGhbaV0ubGVuZ3RoOyBrIDwgcG9pbnRzTGVuZ3RoOyBrICs9IDEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgY3VyclBvaW50ID0gb3V0bGluZUdyYXBoW2ldW2tdO1xuXHRcdFx0XHRcdC8vIGlmIChjdXJyUG9pbnQpXG5cdFx0XHRcdFx0Ly8ge1xuXHRcdFx0XHRcdC8vIFx0Y29uc29sZS5sb2coY3VyclBvaW50LCBjdXJyZW50T3V0bGluZS5nZXROZWlnaGJvdXJzKGN1cnJQb2ludFswXSwgY3VyclBvaW50WzFdKSk7XG5cdFx0XHRcdFx0Ly8gfVxuXHRcdFx0XHRcdGlmIChjdXJyUG9pbnQgJiYgY3VycmVudE91dGxpbmUuZ2V0TmVpZ2hib3VycyhjdXJyUG9pbnRbMF0sIGN1cnJQb2ludFsxXSkubGVuZ3RoID09PSAyKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJldHVybiBjdXJyUG9pbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciB2aXNpdGVkID0gW107XG5cdFx0dmFyIHN0YXJ0aW5nSW5kZXggPSBnZXRTdGFydGluZ0luZGV4LmNhbGwodGhpcyk7XG5cdFx0aWYgKCFzdGFydGluZ0luZGV4KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGdldEFuZ2xlID0gZnVuY3Rpb24gKCRpbmRleClcblx0XHR7XG5cdFx0XHR2YXIgYW5nbGUgPSAoJGluZGV4ICsgMSkgKiA2MDtcblx0XHRcdGFuZ2xlID0gYW5nbGUgPT09IDAgPyAzNjAgOiBhbmdsZTtcblx0XHRcdHJldHVybiBhbmdsZTtcblx0XHR9O1xuXHRcdHZhciBnZXROZWlnaGJvdXJJbmRleCA9IGZ1bmN0aW9uICgkcG9pbnQsICRuZWlnaGJvdXIpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGN1cnJlbnRPdXRsaW5lLmdldE5laWdoYm91cnMoJHBvaW50WzBdLCAkcG9pbnRbMV0sIHRydWUpLmluZGV4T2YoJG5laWdoYm91cik7XG5cdFx0fTtcblxuXHRcdHZhciBuZXh0ID0gY3VycmVudE91dGxpbmUuZ2V0TmVpZ2hib3VycyhzdGFydGluZ0luZGV4WzBdLCBzdGFydGluZ0luZGV4WzFdKVswXTtcblx0XHR2YXIgbGFzdEFuZ2xlID0gZ2V0QW5nbGUoZ2V0TmVpZ2hib3VySW5kZXgoc3RhcnRpbmdJbmRleCwgbmV4dCkpO1xuXHRcdHZhciBjdXJySW5kZXggPSBuZXh0O1xuXHRcdHBhdGgucHVzaCh0aGlzLl9ncmFwaFtzdGFydGluZ0luZGV4WzFdXVtzdGFydGluZ0luZGV4WzBdXSk7XG5cdFx0cGF0aC5wdXNoKHRoaXMuX2dyYXBoW25leHRbMV1dW25leHRbMF1dKTtcblx0XHR2aXNpdGVkLnB1c2goc3RhcnRpbmdJbmRleCk7XG5cblx0XHR2YXIgYmVzdDtcblx0XHR2YXIgbmVpZ2hib3Vycztcblx0XHR2YXIgYmVzdEFuZ2xlO1xuXHRcdHZhciBvdXRsaW5lTm9kZXNBcnJheSA9IGN1cnJlbnRPdXRsaW5lLmdldE5vZGVzQXJyYXkoKTtcblx0XHR2YXIgb3V0bGluZVBvaW50c0xlbmd0aCA9IG91dGxpbmVOb2Rlc0FycmF5Lmxlbmd0aDtcblxuXHRcdHdoaWxlICh2aXNpdGVkLmxlbmd0aCA8IG91dGxpbmVQb2ludHNMZW5ndGggLSAxKS8vY3VyckluZGV4ICE9PSBzdGFydGluZ0luZGV4KVxuXHRcdHtcblx0XHRcdG5laWdoYm91cnMgPSBjdXJyZW50T3V0bGluZS5nZXROZWlnaGJvdXJzKGN1cnJJbmRleFswXSwgY3VyckluZGV4WzFdKTtcblx0XHRcdHZhciBiZXN0U2NvcmUgPSAwO1xuXHRcdFx0YmVzdCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5laWdoYm91cnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjdXJyTmVpZ2ggPSBuZWlnaGJvdXJzW2ldO1xuXHRcdFx0XHR2YXIgY3VyclNjb3JlID0gMDtcblx0XHRcdFx0dmFyIGN1cnJBbmdsZSA9IGdldEFuZ2xlKGdldE5laWdoYm91ckluZGV4KGN1cnJJbmRleCwgY3Vyck5laWdoKSk7XG5cdFx0XHRcdGN1cnJTY29yZSA9IGN1cnJBbmdsZSAtIGxhc3RBbmdsZTtcblx0XHRcdFx0aWYgKGN1cnJTY29yZSA+IDE4MCkgeyBjdXJyU2NvcmUgPSBjdXJyU2NvcmUgLSAzNjA7IH1cblx0XHRcdFx0aWYgKGN1cnJTY29yZSA8IC0xODApIHsgY3VyclNjb3JlID0gY3VyclNjb3JlICsgMzYwOyB9XG5cdFx0XHRcdHZhciBuZWlnaEluZGV4ID0gdmlzaXRlZC5pbmRleE9mKGN1cnJOZWlnaCk7XG5cdFx0XHRcdGlmIChuZWlnaEluZGV4ICE9PSAtMSkgeyBjdXJyU2NvcmUgPSBuZWlnaEluZGV4IC8gdmlzaXRlZC5sZW5ndGggKiAxMDAwMCArIDEwMDAwICsgY3VyclNjb3JlOyB9XG5cdFx0XHRcdGlmICghYmVzdCB8fCBjdXJyU2NvcmUgPCBiZXN0U2NvcmUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRiZXN0U2NvcmUgPSBjdXJyU2NvcmU7XG5cdFx0XHRcdFx0YmVzdCA9IGN1cnJOZWlnaDtcblx0XHRcdFx0XHRiZXN0QW5nbGUgPSBjdXJyQW5nbGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxhc3RBbmdsZSA9IGJlc3RBbmdsZTtcblx0XHRcdGlmICh2aXNpdGVkLmluZGV4T2YoY3VyckluZGV4KSAhPT0gLTEpIHsgdmlzaXRlZC5zcGxpY2UodmlzaXRlZC5pbmRleE9mKGN1cnJJbmRleCksIDEpOyB9XG5cdFx0XHR2aXNpdGVkLnB1c2goY3VyckluZGV4KTtcblx0XHRcdGN1cnJJbmRleCA9IGJlc3Q7XG5cblx0XHRcdHBhdGgucHVzaCh0aGlzLl9ncmFwaFtjdXJySW5kZXhbMV1dW2N1cnJJbmRleFswXV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcGF0aDtcblx0fSxcblxuXHRnZXRPdXRsaW5lczogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciB0b1JldHVybiA9IFtdO1xuXHRcdHZhciBjdXJyZW50R3JhcGg7XG5cdFx0dmFyIG91dGxpbmUgPSB0aGlzLmdldE91dGxpbmUoKTtcblx0XHR2YXIgcmVtYWluaW5nID0gb3V0bGluZS5nZXROb2Rlc0FycmF5KCkuY29uY2F0KCk7XG5cblx0XHR2YXIgcmVjdXIgPSBmdW5jdGlvbiAoJHBvaW50KVxuXHRcdHtcblx0XHRcdGN1cnJlbnRHcmFwaFskcG9pbnRbMV1dID0gY3VycmVudEdyYXBoWyRwb2ludFsxXV0gfHwgW107XG5cdFx0XHRjdXJyZW50R3JhcGhbJHBvaW50WzFdXVskcG9pbnRbMF1dID0gJHBvaW50O1xuXHRcdFx0dmFyIG5laWdoYm91cnMgPSBvdXRsaW5lLmdldE5laWdoYm91cnMoJHBvaW50WzBdLCAkcG9pbnRbMV0pO1xuXHRcdFx0cmVtYWluaW5nLnNwbGljZShyZW1haW5pbmcuaW5kZXhPZigkcG9pbnQpLCAxKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBuZWlnaGJvdXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgbmVpZ2ggPSBuZWlnaGJvdXJzW2ldO1xuXHRcdFx0XHRpZiAocmVtYWluaW5nLmluZGV4T2YobmVpZ2gpICE9PSAtMSkgeyByZWN1cihuZWlnaCk7IH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0d2hpbGUgKHJlbWFpbmluZy5sZW5ndGgpXG5cdFx0e1xuXHRcdFx0Y3VycmVudEdyYXBoID0gW107XG5cdFx0XHR2YXIgc3RhcnRpbmdQb2ludCA9IHJlbWFpbmluZ1swXTtcblx0XHRcdHJlY3VyKHN0YXJ0aW5nUG9pbnQpO1xuXHRcdFx0dG9SZXR1cm4ucHVzaChPYmplY3QuY3JlYXRlKEdyaWQpLmluaXQoY3VycmVudEdyYXBoKSk7XG5cdFx0fVxuXHRcdHJldHVybiB0b1JldHVybjtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkO1xuXG4iLCJ2YXIgTm9kZUdyYXBoID0gZnVuY3Rpb24gKClcbntcblx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xuXHR0aGlzLmVkZ2VzID0gW107XG59O1xuXG5Ob2RlR3JhcGgucHJvdG90eXBlLmdldFZlcnRleCA9IGZ1bmN0aW9uICgkbm9kZSlcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1tpXTtcblx0XHRpZiAodmVydGV4Lm5vZGUgPT09ICRub2RlKVxuXHRcdHtcblx0XHRcdHJldHVybiB2ZXJ0ZXg7XG5cdFx0fVxuXHR9XG59O1xuXG5Ob2RlR3JhcGgucHJvdG90eXBlLmNyZWF0ZVZlcnRleCA9IGZ1bmN0aW9uICgkbm9kZSlcbntcblx0dmFyIHZlcnRleCA9IHsgbm9kZTogJG5vZGUgfTtcblx0dGhpcy52ZXJ0aWNlcy5wdXNoKHZlcnRleCk7XG5cdHJldHVybiB2ZXJ0ZXg7XG59O1xuXG5Ob2RlR3JhcGgucHJvdG90eXBlLmdldEVkZ2VXZWlnaHQgPSBmdW5jdGlvbiAoJGVkZ2UpXG57XG5cdHZhciBkWCA9IE1hdGguYWJzKCRlZGdlLnZlcnRleEEubm9kZS5vWCAtICRlZGdlLnZlcnRleEIubm9kZS5vWCk7XG5cdHZhciBkWSA9IE1hdGguYWJzKCRlZGdlLnZlcnRleEEubm9kZS5vWSAtICRlZGdlLnZlcnRleEIubm9kZS5vWSk7XG5cdHZhciBkaXN0ID0gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcblx0cmV0dXJuIGRpc3Q7XG59O1xuXG5Ob2RlR3JhcGgucHJvdG90eXBlLmdldFZlcnRleEVkZ2VzID0gZnVuY3Rpb24gKCR2ZXJ0ZXgpXG57XG5cdHZhciB0b1JldHVybiA9IFtdO1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5lZGdlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBlZGdlID0gdGhpcy5lZGdlc1tpXTtcblx0XHRpZiAoZWRnZS52ZXJ0ZXhBID09PSAkdmVydGV4IHx8IGVkZ2UudmVydGV4QiA9PT0gJHZlcnRleClcblx0XHR7XG5cdFx0XHR0b1JldHVybi5wdXNoKGVkZ2UpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdG9SZXR1cm47XG59O1xuXG5Ob2RlR3JhcGgucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoJEFOb2RlLCAkQk5vZGUpXG57XG5cdHZhciB2ZXJ0ZXhBID0gdGhpcy5nZXRWZXJ0ZXgoJEFOb2RlKSB8fCB0aGlzLmNyZWF0ZVZlcnRleCgkQU5vZGUpO1xuXHR2YXIgdmVydGV4QiA9IHRoaXMuZ2V0VmVydGV4KCRCTm9kZSkgfHwgdGhpcy5jcmVhdGVWZXJ0ZXgoJEJOb2RlKTtcblxuXHR2YXIgZXhpc3RzID0gZmFsc2U7XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmVkZ2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xuXHRcdGlmICgoZWRnZS52ZXJ0ZXhBID09PSB2ZXJ0ZXhBICYmXG5cdFx0XHRlZGdlLnZlcnRleEIgPT09IHZlcnRleEIpIHx8XG5cdFx0XHQoZWRnZS52ZXJ0ZXhBID09PSB2ZXJ0ZXhCICYmXG5cdFx0XHRlZGdlLnZlcnRleEIgPT09IHZlcnRleEEpKVxuXHRcdHtcblx0XHRcdGV4aXN0cyA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdGlmICghZXhpc3RzKVxuXHR7XG5cdFx0dGhpcy5lZGdlcy5wdXNoKHsgdmVydGV4QTogdmVydGV4QSwgdmVydGV4QjogdmVydGV4QiB9KTtcblx0fVxufTtcblxuTm9kZUdyYXBoLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uICgkc3RhcnRpbmdWZXJ0aWNlcylcbntcblx0dmFyIGk7XG5cdHZhciBvcGVuTGlzdCA9IFtdO1xuXHR2YXIgZWRnZXNMZW5ndGg7XG5cdHZhciB2ZXJ0ZXhFZGdlcztcblx0dmFyIHN0YXJ0aW5nVmVydGljZXNMZW5ndGggPSAkc3RhcnRpbmdWZXJ0aWNlcy5sZW5ndGg7XG5cdGZvciAoaSA9IDA7IGkgPCBzdGFydGluZ1ZlcnRpY2VzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHQkc3RhcnRpbmdWZXJ0aWNlc1tpXS5tYXBWYWx1ZSA9IDA7XG5cdFx0JHN0YXJ0aW5nVmVydGljZXNbaV0ub3BlbmVkID0gdHJ1ZTtcblx0XHRvcGVuTGlzdC5wdXNoKCRzdGFydGluZ1ZlcnRpY2VzW2ldKTtcblx0fVxuXG5cdHdoaWxlIChvcGVuTGlzdC5sZW5ndGgpXG5cdHtcblx0XHR2YXIgY2xvc2VkVmVydGV4ID0gb3Blbkxpc3Quc2hpZnQoKTtcblx0XHRjbG9zZWRWZXJ0ZXguY2xvc2VkID0gdHJ1ZTtcblxuXHRcdHZlcnRleEVkZ2VzID0gdGhpcy5nZXRWZXJ0ZXhFZGdlcyhjbG9zZWRWZXJ0ZXgpO1xuXHRcdGVkZ2VzTGVuZ3RoID0gdmVydGV4RWRnZXMubGVuZ3RoO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBlZGdlc0xlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyRWRnZSA9IHZlcnRleEVkZ2VzW2ldO1xuXHRcdFx0dmFyIG90aGVyVmVydGV4ID0gY3VyckVkZ2UudmVydGV4QSA9PT0gY2xvc2VkVmVydGV4ID8gY3VyckVkZ2UudmVydGV4QiA6IGN1cnJFZGdlLnZlcnRleEE7XG5cdFx0XHRpZiAob3RoZXJWZXJ0ZXguY2xvc2VkKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcblx0XHRcdGlmICghb3RoZXJWZXJ0ZXgub3BlbmVkKVxuXHRcdFx0e1xuXHRcdFx0XHRvdGhlclZlcnRleC5vcGVuZWQgPSB0cnVlO1xuXHRcdFx0XHRvcGVuTGlzdC5wdXNoKG90aGVyVmVydGV4KTtcblx0XHRcdH1cblx0XHRcdHZhciB2YWwgPSBjbG9zZWRWZXJ0ZXgubWFwVmFsdWUgKyB0aGlzLmdldEVkZ2VXZWlnaHQoY3VyckVkZ2UpO1xuXHRcdFx0b3RoZXJWZXJ0ZXgubWFwVmFsdWUgPSBvdGhlclZlcnRleC5tYXBWYWx1ZSA8IHZhbCA/IG90aGVyVmVydGV4Lm1hcFZhbHVlIDogdmFsOyAvL3dvcmtzIGV2ZW4gaWYgdW5kZWZpbmVkXG5cdFx0fVxuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVHcmFwaDtcbiIsInZhciBQb2x5Z29uID1cbntcblx0aW5pdDogZnVuY3Rpb24gKCRwb2ludHMpXG5cdHtcblx0XHR2YXIgcG9seWdvbiA9IE9iamVjdC5jcmVhdGUoUG9seWdvbik7XG5cdFx0cG9seWdvbi5wb2ludHMgPSAkcG9pbnRzO1xuXHRcdHBvbHlnb24uX2JvdW5kaW5nQm94ID0gdW5kZWZpbmVkO1xuXHRcdHJldHVybiBwb2x5Z29uO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgc3VtQSA9IDA7XG5cdFx0dmFyIHN1bUIgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3VyclBvaW50ID0gdGhpcy5wb2ludHNbaV07XG5cdFx0XHR2YXIgbmV4dCA9IGkgPT09IGxlbmd0aCAtIDEgPyB0aGlzLnBvaW50c1swXSA6IHRoaXMucG9pbnRzW2kgKyAxXTtcblx0XHRcdHN1bUEgKz0gY3VyclBvaW50WzBdICogbmV4dFsxXTtcblx0XHRcdHN1bUIgKz0gY3VyclBvaW50WzFdICogbmV4dFswXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoKHN1bUEgLSBzdW1CKSAqIDAuNSk7XG5cdH0sXG5cblx0Z2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRpZiAoIXRoaXMuX2JvdW5kaW5nQm94KVxuXHRcdHtcblx0XHRcdHZhciBtaW5YID0gdGhpcy5wb2ludHNbMF1bMF07XG5cdFx0XHR2YXIgbWF4WCA9IG1pblg7XG5cdFx0XHR2YXIgbWluWSA9IHRoaXMucG9pbnRzWzBdWzFdO1xuXHRcdFx0dmFyIG1heFkgPSBtaW5ZO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBwb2ludCA9IHRoaXMucG9pbnRzW2ldO1xuXHRcdFx0XHRtaW5YID0gTWF0aC5taW4obWluWCwgcG9pbnRbMF0pO1xuXHRcdFx0XHRtYXhYID0gTWF0aC5tYXgobWF4WCwgcG9pbnRbMF0pO1xuXHRcdFx0XHRtaW5ZID0gTWF0aC5taW4obWluWSwgcG9pbnRbMV0pO1xuXHRcdFx0XHRtYXhZID0gTWF0aC5tYXgobWF4WSwgcG9pbnRbMV0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYm91bmRpbmdCb3ggPSBbW21pblgsIG1pblldLCBbbWF4WCwgbWF4WV1dO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fYm91bmRpbmdCb3g7XG5cdH0sXG5cblx0Z2V0U2VnbWVudHM6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgc2VnbWVudHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoIC0gMTsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHNlZ21lbnRzLnB1c2goW3RoaXMucG9pbnRzW2ldLCB0aGlzLnBvaW50c1tpICsgMV1dKTtcblx0XHR9XG5cdFx0c2VnbWVudHMucHVzaChbdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV0sIHRoaXMucG9pbnRzWzBdXSk7XG5cdFx0cmV0dXJuIHNlZ21lbnRzO1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbnNBdFk6IGZ1bmN0aW9uICgkdGVzdFkpXG5cdHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLmdldFNlZ21lbnRzKCk7XG5cdFx0dmFyIGludGVyc2VjdGlvbnMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJTZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHR2YXIgeDEgPSBjdXJyU2VnbWVudFswXVswXTtcblx0XHRcdHZhciB5MSA9IGN1cnJTZWdtZW50WzBdWzFdO1xuXHRcdFx0dmFyIHgyID0gY3VyclNlZ21lbnRbMV1bMF07XG5cdFx0XHR2YXIgeTIgPSBjdXJyU2VnbWVudFsxXVsxXTtcblx0XHRcdHZhciBzbWFsbFkgPSBNYXRoLm1pbih5MSwgeTIpO1xuXHRcdFx0dmFyIGJpZ1kgPSBNYXRoLm1heCh5MSwgeTIpO1xuXG5cdFx0XHRpZiAoJHRlc3RZID4gc21hbGxZICYmICR0ZXN0WSA8IGJpZ1kpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBwWSA9IHkyIC0gJHRlc3RZO1xuXHRcdFx0XHR2YXIgc2VnWSA9IHkyIC0geTE7XG5cdFx0XHRcdHZhciBzZWdYID0geDIgLSB4MTtcblx0XHRcdFx0dmFyIHBYID0gcFkgKiBzZWdYIC8gc2VnWTtcblx0XHRcdFx0aW50ZXJzZWN0aW9ucy5wdXNoKHgyIC0gcFgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaW50ZXJzZWN0aW9ucztcblx0fSxcblxuXHRpc0luc2lkZTogZnVuY3Rpb24gKCRwb2ludClcblx0e1xuXHRcdHZhciBpbmZOdW1iZXIgPSAwO1xuXHRcdHZhciBpbnRlcnNlY3Rpb25zID0gdGhpcy5nZXRJbnRlcnNlY3Rpb25zQXRZKCRwb2ludFsxXSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGludGVyc2VjdGlvbnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0aWYgKCRwb2ludFswXSA8IGludGVyc2VjdGlvbnNbaV0pIHsgaW5mTnVtYmVyICs9IDE7IH1cblx0XHR9XG5cdFx0cmV0dXJuIGluZk51bWJlciAlIDIgPiAwO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlnb247XG5cbiIsInZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4vQ29tbWFuZHMnKTtcbnZhciBBUkMgPSBDb21tYW5kcy5BUkM7XG52YXIgTElORV9UTyA9IENvbW1hbmRzLkxJTkVfVE87XG52YXIgTU9WRV9UTyA9IENvbW1hbmRzLk1PVkVfVE87XG52YXIgQkVaSUVSX1RPID0gQ29tbWFuZHMuQkVaSUVSX1RPO1xudmFyIFFVQURSQV9UTyA9IENvbW1hbmRzLlFVQURSQV9UTztcbnZhciBFTExJUFNFID0gQ29tbWFuZHMuRUxMSVBTRTtcblxudmFyIFNWR1BhcnNlciA9IGZ1bmN0aW9uICgpIHt9O1xuLy92YXIgaXNQb2x5Z29uID0gL3BvbHlnb258cmVjdC9pZztcbi8vIHZhciBpc0xpbmUgPSAvcG9seWxpbmV8bGluZXxwYXRoL2lnO1xuLy8gdmFyIGxpbmVUYWdzID0gJ3BvbHlsaW5lLCBsaW5lLCBwYXRoJztcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgkd29ybGQsICRTVkcpXG57XG5cdHRoaXMuU1ZHID0gJFNWRztcblx0dmFyIHZpZXdCb3hBdHRyID0gdGhpcy5TVkcuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG5cdHRoaXMudmlld0JveFdpZHRoID0gdmlld0JveEF0dHIgPyBOdW1iZXIodmlld0JveEF0dHIuc3BsaXQoJyAnKVsyXSkgOiBOdW1iZXIodGhpcy5TVkcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTtcblx0dGhpcy52aWV3Qm94SGVpZ2h0ID0gdmlld0JveEF0dHIgPyBOdW1iZXIodmlld0JveEF0dHIuc3BsaXQoJyAnKVszXSkgOiBOdW1iZXIodGhpcy5TVkcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7XG5cdHRoaXMucmF0aW8gPSAkd29ybGQuZ2V0V2lkdGgoKSAvIHRoaXMudmlld0JveFdpZHRoO1xuXHR0aGlzLndvcmxkID0gJHdvcmxkO1xuXHR0aGlzLndvcmxkLnNldEhlaWdodCh0aGlzLnZpZXdCb3hIZWlnaHQgKiB0aGlzLnJhdGlvKTtcblxuXHQvL3RlbXBcblx0dGhpcy5lbGVtZW50c1F1ZXJ5ID0gJyo6bm90KGRlZnMpOm5vdChnKTpub3QodGl0bGUpOm5vdChsaW5lYXJHcmFkaWVudCk6bm90KHJhZGlhbEdyYWRpZW50KTpub3Qoc3RvcCk6bm90KFtpZCo9XCJqb2ludFwiXSk6bm90KFtpZCo9XCJjb25zdHJhaW50XCJdKSc7XG5cdHZhciBlbGVtUmF3cyA9IHRoaXMuU1ZHLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5lbGVtZW50c1F1ZXJ5KTtcblxuXHR2YXIgaSA9IDA7XG5cdHZhciByYXdHcm91cFBhaXJpbmdzID0gW107XG5cdHZhciBlbGVtc0xlbmd0aCA9IGVsZW1SYXdzLmxlbmd0aDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgZWxlbXNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciByYXdFbGVtZW50ID0gZWxlbVJhd3NbaV07XG5cdFx0Ly9pZiAocmF3RWxlbWVudC5ub2RlVHlwZSA9PT0gMykgeyBjb250aW51ZTsgfVxuXHRcdHZhciBncm91cEluZm9zID0gdGhpcy5nZXRHcm91cEluZm9zKHJhd0VsZW1lbnQpO1xuXHRcdHZhciBjdXJyR3JvdXAgPSAkd29ybGQuY3JlYXRlR3JvdXAoZ3JvdXBJbmZvcy50eXBlLCBncm91cEluZm9zLklEKTtcblx0XHRjdXJyR3JvdXAucmF3U1ZHRWxlbWVudCA9IHJhd0VsZW1lbnQ7XG5cblx0XHQvL3ZhciBlbGVtZW50cyA9IHJhd0VsZW1lbnQ7XG5cdFx0Ly90aGlzLnBhcnNlRWxlbWVudHMoZWxlbWVudHMsIGN1cnJHcm91cCk7XG5cblx0XHR2YXIgZHJhd2luZ0NvbW1hbmRzID0gdGhpcy5wYXJzZUVsZW1lbnQocmF3RWxlbWVudCk7XG5cdFx0dmFyIG5vZGVzVG9EcmF3ID0gY3Vyckdyb3VwLnN0cnVjdHVyZS5jcmVhdGUoZHJhd2luZ0NvbW1hbmRzKTtcblx0XHR0aGlzLnNldEdyYXBoaWNJbnN0cnVjdGlvbnMoY3Vyckdyb3VwLCByYXdFbGVtZW50LCBub2Rlc1RvRHJhdywgZHJhd2luZ0NvbW1hbmRzKTtcblxuXHRcdC8vIHZhciBoYXNHcm91cDtcblx0XHQvLyBmb3IgKHZhciBrID0gMCwgbGVuZ3RoID0gcmF3R3JvdXBQYWlyaW5ncy5sZW5ndGg7IGsgPCBsZW5ndGg7IGsgKz0gMSlcblx0XHQvLyB7XG5cdFx0Ly8gXHR2YXIgY3VyciA9IHJhd0dyb3VwUGFpcmluZ3Nba107XG5cdFx0Ly8gXHRpZiAoY3Vyci5ncm91cCA9PT0gY3Vyckdyb3VwKVxuXHRcdC8vIFx0e1xuXHRcdC8vIFx0XHRoYXNHcm91cCA9IHRydWU7XG5cdFx0Ly8gXHRcdGJyZWFrO1xuXHRcdC8vIFx0fVxuXHRcdC8vIH1cblx0XHQvLyBpZiAoIWhhc0dyb3VwKSB7IHJhd0dyb3VwUGFpcmluZ3MucHVzaCh7IGdyb3VwOiBjdXJyR3JvdXAsIHJhdzogcmF3RWxlbWVudC5wYXJlbnROb2RlIH0pOyB9XG5cdFx0cmF3R3JvdXBQYWlyaW5ncy5wdXNoKHsgZ3JvdXA6IGN1cnJHcm91cCwgcmF3OiByYXdFbGVtZW50LnBhcmVudE5vZGUgfSk7XG5cdH1cblxuXHQvLyB2YXIgcGFpcmluZ3NMZW5ndGggPSByYXdHcm91cFBhaXJpbmdzLmxlbmd0aDtcblx0Ly8gZm9yIChpID0gMDsgaSA8IHBhaXJpbmdzTGVuZ3RoOyBpICs9IDEpXG5cdC8vIHtcblx0Ly8gXHR2YXIgcGFpcmluZyA9IHJhd0dyb3VwUGFpcmluZ3NbaV07XG5cdC8vIFx0Ly8gdGhpcy5wYXJzZUFuY2hvcnMocGFpcmluZy5yYXcsIHBhaXJpbmcuZ3JvdXApO1xuXHQvLyBcdHRoaXMucGFyc2VDb25zdHJhaW50cyhwYWlyaW5nLnJhdywgcGFpcmluZy5ncm91cCk7XG5cdC8vIFx0dGhpcy5wYXJzZUN1c3RvbUpvaW50cyhwYWlyaW5nLnJhdywgcGFpcmluZy5ncm91cCk7XG5cdC8vIH1cblxuXHR0aGlzLnBhcnNlQ29uc3RyYWludHMoKTtcblxuXHR0aGlzLndvcmxkLmFkZEdyb3Vwc1RvV29ybGQoKTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuZ2V0R3JvdXBJbmZvcyA9IGZ1bmN0aW9uICgkcmF3R3JvdXApXG57XG5cdHZhciBncm91cEVsZW1lbnQgPSAoISRyYXdHcm91cC5pZCB8fCAkcmF3R3JvdXAuaWQuaW5kZXhPZignc3ZnJykgPT09IDApICYmICRyYXdHcm91cC5wYXJlbnROb2RlLnRhZ05hbWUgIT09ICdzdmcnID8gJHJhd0dyb3VwLnBhcmVudE5vZGUgOiAkcmF3R3JvdXA7XG5cdHZhciB0eXBlO1xuXHR2YXIgSUQ7XG5cdHZhciByZWdleCA9IC8oW2EtelxcZF0rKVxcdyovaWdtO1xuXHR2YXIgZmlyc3QgPSByZWdleC5leGVjKGdyb3VwRWxlbWVudC5pZCk7XG5cdHZhciBzZWNvbmQgPSByZWdleC5leGVjKGdyb3VwRWxlbWVudC5pZCk7XG5cdC8vaWYgKGZpcnN0KSB7IHR5cGUgPSBzZWNvbmQgPyBzZWNvbmRbMV0gOiBmaXJzdFsxXTsgfVxuXHQvL3ZhciBncm91cFR5cGUgPSBncm91cEVsZW1lbnQuaWQubWF0Y2goKTtcblx0Ly9pZiAoZ3JvdXBUeXBlKSB7IHJldHVybiBncm91cFR5cGVbMV0gfHwgZ3JvdXBUeXBlWzBdOyB9XG5cdC8vYXV0b21hdGljIGZvciBsaW5lc1xuXHQvLyBpZiAoIWZpcnN0ICYmIChncm91cEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChsaW5lVGFncykubGVuZ3RoID4gMCB8fCBncm91cEVsZW1lbnQudGFnTmFtZS5zZWFyY2goaXNMaW5lKSA+IC0xKSlcblx0Ly8ge1xuXHQvLyBcdHR5cGUgPSAnbGluZSc7XG5cdC8vIH1cblx0dHlwZSA9IGZpcnN0ID8gZmlyc3RbMV0gOiB1bmRlZmluZWQ7XG5cdElEID0gc2Vjb25kID8gc2Vjb25kWzFdIDogbnVsbDtcblx0dmFyIHRpdGxlID0gZ3JvdXBFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RpdGxlJyk7XG5cdGlmIChJRCA9PT0gbnVsbCkgeyBJRCA9IHRpdGxlID8gdGl0bGUubm9kZVZhbHVlIDogSUQ7IH1cblx0Ly8gaWYgKCRyYXdHcm91cC5wYXJlbnROb2RlLmlkID09PSAndHJlZS10cmVlJylcblx0Ly8ge1xuXHQvLyBcdGNvbnNvbGUubG9nKCRyYXdHcm91cCwgJHJhd0dyb3VwLmlkLCB0eXBlLCBJRCk7XG5cdC8vIFx0ZGVidWdnZXI7XG5cdC8vIH1cblx0cmV0dXJuIHsgSUQ6IElELCB0eXBlOiB0eXBlIH07XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uICgkcG9pbnRDb21tYW5kcylcbntcblx0dmFyIHBvaW50cyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gJHBvaW50Q29tbWFuZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyclBvaW50Q29tbWFuZCA9ICRwb2ludENvbW1hbmRzW2ldO1xuXHRcdHBvaW50cy5wdXNoKGN1cnJQb2ludENvbW1hbmQucG9pbnQpO1xuXHR9XG5cdHJldHVybiBwb2ludHM7XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLmdldEdyb3VwRnJvbVJhd1NWR0VsZW1lbnQgPSBmdW5jdGlvbiAoJHJhdylcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMud29ybGQuZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJHcm91cCA9IHRoaXMud29ybGQuZ3JvdXBzW2ldO1xuXHRcdGlmIChjdXJyR3JvdXAucmF3U1ZHRWxlbWVudCA9PT0gJHJhdykgeyByZXR1cm4gY3Vyckdyb3VwOyB9XG5cdH1cbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2VDb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciByYXdDb25zdHJhaW50cyA9IHRoaXMuU1ZHLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZCo9XCJjb25zdHJhaW50XCJdJyk7XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSByYXdDb25zdHJhaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyUmF3Q29uc3RyYWludCA9IHJhd0NvbnN0cmFpbnRzW2ldO1xuXHRcdHZhciByYXdFbGVtZW50cyA9IGN1cnJSYXdDb25zdHJhaW50LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbCh0aGlzLmVsZW1lbnRzUXVlcnkpO1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cyh0aGlzLnBhcnNlRWxlbWVudChjdXJyUmF3Q29uc3RyYWludCkucG9pbnRDb21tYW5kcyk7XG5cdFx0dmFyIHJlc3VsdCA9IC9jb25zdHJhaW50LShbYS16XFxkXSopL2lnLmV4ZWMoY3VyclJhd0NvbnN0cmFpbnQuaWQpO1xuXHRcdHZhciBwYXJlbnRHcm91cElEID0gcmVzdWx0ID8gcmVzdWx0WzFdIDogdW5kZWZpbmVkO1xuXHRcdHZhciBwYXJlbnRHcm91cCA9IHBhcmVudEdyb3VwSUQgPyB0aGlzLndvcmxkLmdldEdyb3VwQnlJRChwYXJlbnRHcm91cElEKSA6IHVuZGVmaW5lZDtcblxuXHRcdGZvciAodmFyIGsgPSAwLCByYXdFbGVtZW50c0xlbmd0aCA9IHJhd0VsZW1lbnRzLmxlbmd0aDsgayA8IHJhd0VsZW1lbnRzTGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJSYXdFbGVtZW50ID0gcmF3RWxlbWVudHNba107XG5cdFx0XHR2YXIgZ3JvdXAgPSB0aGlzLmdldEdyb3VwRnJvbVJhd1NWR0VsZW1lbnQoY3VyclJhd0VsZW1lbnQpO1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhncm91cCk7XG5cdFx0XHR0aGlzLndvcmxkLmNvbnN0cmFpbkdyb3Vwcyhncm91cCwgcGFyZW50R3JvdXAsIHBvaW50cyk7XG5cdFx0fVxuXHR9XG5cdC8vIHZhciBjaGlsZHJlbiA9ICRyYXdHcm91cC5jaGlsZE5vZGVzOy8vJHJhd0dyb3VwLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZCo9XCJjb25zdHJhaW50XCJdJyk7XG5cblx0Ly8gZm9yICh2YXIgaSA9IDAsIGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkgKz0gMSlcblx0Ly8ge1xuXHQvLyBcdGlmIChjaGlsZHJlbltpXS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgfHwgY2hpbGRyZW5baV0uaWQuc2VhcmNoKC9jb25zdHJhaW50L2kpIDwgMCkgeyBjb250aW51ZTsgfVxuXHQvLyBcdHZhciBjdXJyQ29uc3RyYWludCA9IGNoaWxkcmVuW2ldO1xuXHQvLyBcdHZhciByZXN1bHQgPSAvY29uc3RyYWludC0oW2EtelxcZF0qKS9pZy5leGVjKGN1cnJDb25zdHJhaW50LmlkKTtcblxuXHQvLyBcdHZhciBwYXJlbnRHcm91cElEID0gcmVzdWx0ID8gcmVzdWx0WzFdIDogdW5kZWZpbmVkO1xuXHQvLyBcdHZhciBwYXJlbnRHcm91cCA9IHBhcmVudEdyb3VwSUQgPyB0aGlzLndvcmxkLmdldEdyb3VwQnlJRChwYXJlbnRHcm91cElEKSA6IHVuZGVmaW5lZDtcblx0Ly8gXHR2YXIgcG9pbnRDb21tYW5kcyA9IHRoaXMucGFyc2VFbGVtZW50KGN1cnJDb25zdHJhaW50KS5wb2ludENvbW1hbmRzO1xuXHQvLyBcdC8vIGNvbnNvbGUubG9nKCRncm91cC5JRCwgcGFyZW50R3JvdXAgPyBwYXJlbnRHcm91cC5JRCA6IHVuZGVmaW5lZCk7XG5cdC8vIFx0dGhpcy53b3JsZC5jb25zdHJhaW5Hcm91cHMoJGdyb3VwLCBwYXJlbnRHcm91cCwgdGhpcy5nZXRQb2ludHMocG9pbnRDb21tYW5kcykpO1xuXHQvLyB9XG59O1xuXG4vLyBTVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlRWxlbWVudHMgPSBmdW5jdGlvbiAoJGVsZW1lbnRzLCAkZ3JvdXApXG4vLyB7XG4vLyBcdGZvciAodmFyIGkgPSAwLCBlbGVtZW50c0xlbmd0aCA9ICRlbGVtZW50cy5sZW5ndGg7IGkgPCBlbGVtZW50c0xlbmd0aDsgaSArPSAxKVxuLy8gXHR7XG4vLyBcdFx0dmFyIHJhd0VsZW1lbnQgPSAkZWxlbWVudHNbaV07XG5cbi8vIFx0XHR2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VFbGVtZW50KHJhd0VsZW1lbnQpO1xuXG4vLyBcdFx0dmFyIG5vZGVzVG9EcmF3ID0gJGdyb3VwLnN0cnVjdHVyZS5jcmVhdGUoZWxlbWVudCk7XG4vLyBcdFx0dGhpcy5zZXRHcmFwaGljSW5zdHJ1Y3Rpb25zKCRncm91cCwgcmF3RWxlbWVudCwgbm9kZXNUb0RyYXcsIGVsZW1lbnQpO1xuLy8gXHR9XG4vLyB9O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlRWxlbWVudCA9IGZ1bmN0aW9uICgkcmF3RWxlbWVudClcbntcblx0dmFyIHRhZ05hbWUgPSAkcmF3RWxlbWVudC50YWdOYW1lO1xuXG5cdHN3aXRjaCAodGFnTmFtZSlcblx0e1xuXHRcdGNhc2UgJ2xpbmUnOlxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VMaW5lKCRyYXdFbGVtZW50KTtcblx0XHRjYXNlICdyZWN0Jzpcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlUmVjdCgkcmF3RWxlbWVudCk7XG5cblx0XHRjYXNlICdwb2x5Z29uJzpcblx0XHRjYXNlICdwb2x5bGluZSc6XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZVBvbHkoJHJhd0VsZW1lbnQpO1xuXG5cdFx0Y2FzZSAncGF0aCc6XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZVBhdGgoJHJhd0VsZW1lbnQpO1xuXG5cdFx0Y2FzZSAnY2lyY2xlJzpcblx0XHRjYXNlICdlbGxpcHNlJzpcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ2lyY2xlKCRyYXdFbGVtZW50KTtcblx0fVxufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5zZXRHcmFwaGljSW5zdHJ1Y3Rpb25zID0gZnVuY3Rpb24gKCRncm91cCwgJHJhdywgJG5vZGVzVG9EcmF3LCAkZHJhd2luZ0NvbW1hbmRzKVxue1xuXHR2YXIgZHJhd2luZyA9ICRncm91cC5kcmF3aW5nID0ge307XG5cdGRyYXdpbmcubm9kZXMgPSAkbm9kZXNUb0RyYXc7XG5cdHZhciBwcm9wcyA9IGRyYXdpbmcucHJvcGVydGllcyA9IHt9O1xuXHQvL3NvcnRpbmcgbm9kZXNUb0RyYXcgc28gdGhlIHBhdGggaXMgZHJhd24gY29ycmVjdGx5XG5cdHZhciBzdGFydDtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICRub2Rlc1RvRHJhdy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyTm9kZSA9ICRub2Rlc1RvRHJhd1tpXTtcblx0XHRpZiAoY3Vyck5vZGUuZHJhd2luZy5jb21tYW5kID09PSBNT1ZFX1RPIHx8IGkgPT09IGxlbmd0aCAtIDEpXG5cdFx0e1xuXHRcdFx0aWYgKHN0YXJ0KSB7IHN0YXJ0LmRyYXdpbmcuZW5kTm9kZSA9IGN1cnJOb2RlOyB9XG5cdFx0XHRzdGFydCA9IGN1cnJOb2RlO1xuXHRcdH1cblxuXHRcdCRncm91cC5ub2Rlcy5zcGxpY2UoJGdyb3VwLm5vZGVzLmluZGV4T2YoY3Vyck5vZGUpLCAxKTtcblx0XHQkZ3JvdXAubm9kZXMuc3BsaWNlKGksIDAsIGN1cnJOb2RlKTtcblx0fVxuXG5cdHZhciByYXdGaWxsID0gJHJhdy5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcblx0dmFyIHJhd1N0cm9rZVdpZHRoID0gJHJhdy5nZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcpO1xuXHR2YXIgcmF3U3Ryb2tlID0gJHJhdy5nZXRBdHRyaWJ1dGUoJ3N0cm9rZScpO1xuXHR2YXIgcmF3TGluZWNhcCA9ICRyYXcuZ2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcpO1xuXHR2YXIgcmF3TGluZWpvaW4gPSAkcmF3LmdldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJyk7XG5cdHZhciByYXdPcGFjaXR5ID0gJHJhdy5nZXRBdHRyaWJ1dGUoJ29wYWNpdHknKTtcblxuXHRwcm9wcy5maWxsID0gcmF3RmlsbCB8fCAnIzAwMDAwMCc7XG5cdHByb3BzLmxpbmVXaWR0aCA9IHJhd1N0cm9rZVdpZHRoICogdGhpcy5yYXRpbyB8fCAwO1xuXHRwcm9wcy5zdHJva2UgPSByYXdTdHJva2UgJiYgcHJvcHMubGluZVdpZHRoICE9PSAwID8gcmF3U3Ryb2tlIDogJ25vbmUnO1xuXHRwcm9wcy5saW5lQ2FwID0gcmF3TGluZWNhcCAmJiByYXdMaW5lY2FwICE9PSAnbnVsbCcgPyByYXdMaW5lY2FwIDogJ2J1dHQnO1xuXHRwcm9wcy5saW5lSm9pbiA9IHJhd0xpbmVqb2luICYmIHJhd0xpbmVqb2luICE9PSAnbnVsbCcgPyByYXdMaW5lam9pbiA6ICdtaXRlcic7XG5cdHByb3BzLm9wYWNpdHkgPSByYXdPcGFjaXR5IHx8IDE7XG5cblx0cHJvcHMuY2xvc2VQYXRoID0gJGRyYXdpbmdDb21tYW5kcy5jbG9zZVBhdGg7XG5cblx0cHJvcHMucmFkaXVzWCA9ICRkcmF3aW5nQ29tbWFuZHMucmFkaXVzWDtcblx0cHJvcHMucmFkaXVzWSA9ICRkcmF3aW5nQ29tbWFuZHMucmFkaXVzWTtcblxuXHRwcm9wcy5zdHJva2VHcmFkaWVudCA9IHRoaXMuZ2V0R3JhZGllbnQocHJvcHMuc3Ryb2tlKTtcblx0cHJvcHMuZHluYW1pY0dyYWRpZW50ID0gJGdyb3VwLmNvbmYuc3RydWN0dXJlID09PSAnbGluZScgJiYgcHJvcHMuc3Ryb2tlR3JhZGllbnQ7XG5cdHByb3BzLmZpbGxHcmFkaWVudCA9IHRoaXMuZ2V0R3JhZGllbnQocHJvcHMuZmlsbCk7XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLmdldEdyYWRpZW50ID0gZnVuY3Rpb24gKCR2YWx1ZSlcbntcblx0dmFyIGdyYWRpZW50SUQgPSAvdXJsXFwoIyguKilcXCkvaW0uZXhlYygkdmFsdWUpO1xuXHRpZiAoZ3JhZGllbnRJRClcblx0e1xuXHRcdHZhciBncmFkaWVudEVsZW1lbnQgPSB0aGlzLlNWRy5xdWVyeVNlbGVjdG9yKCcjJyArIGdyYWRpZW50SURbMV0pO1xuXHRcdHZhciBtID0gdGhpcy5nZXRNYXRyaXgoZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKSk7XG5cblx0XHRpZiAoZ3JhZGllbnRFbGVtZW50LnRhZ05hbWUgIT09ICdsaW5lYXJHcmFkaWVudCcgJiYgZ3JhZGllbnRFbGVtZW50LnRhZ05hbWUgIT09ICdyYWRpYWxHcmFkaWVudCcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgZ3JhZGllbnQgPSB7IHN0b3BzOiBbXSwgdHlwZTogZ3JhZGllbnRFbGVtZW50LnRhZ05hbWUgfTtcblxuXHRcdGlmIChncmFkaWVudEVsZW1lbnQudGFnTmFtZSA9PT0gJ2xpbmVhckdyYWRpZW50Jylcblx0XHR7XG5cdFx0XHRncmFkaWVudC54MSA9IHRoaXMuZ2V0Q29vcmQoZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgneDEnKSk7XG5cdFx0XHRncmFkaWVudC55MSA9IHRoaXMuZ2V0Q29vcmQoZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgneTEnKSk7XG5cdFx0XHRncmFkaWVudC54MiA9IHRoaXMuZ2V0Q29vcmQoZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgneDInKSk7XG5cdFx0XHRncmFkaWVudC55MiA9IHRoaXMuZ2V0Q29vcmQoZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgneTInKSk7XG5cblx0XHRcdGlmIChtKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgdGZYMSA9IG1bMF0gKiBncmFkaWVudC54MSArIG1bMV0gKiBncmFkaWVudC55MSArIG1bMl07XG5cdFx0XHRcdHZhciB0ZlkxID0gbVszXSAqIGdyYWRpZW50LngxICsgbVs0XSAqIGdyYWRpZW50LnkxICsgbVs1XTtcblx0XHRcdFx0dmFyIHRmWDIgPSBtWzBdICogZ3JhZGllbnQueDIgKyBtWzFdICogZ3JhZGllbnQueTIgKyBtWzJdO1xuXHRcdFx0XHR2YXIgdGZZMiA9IG1bM10gKiBncmFkaWVudC54MiArIG1bNF0gKiBncmFkaWVudC55MiArIG1bNV07XG5cblx0XHRcdFx0Z3JhZGllbnQueDEgPSB0ZlgxO1xuXHRcdFx0XHRncmFkaWVudC55MSA9IHRmWTE7XG5cdFx0XHRcdGdyYWRpZW50LngyID0gdGZYMjtcblx0XHRcdFx0Z3JhZGllbnQueTIgPSB0ZlkyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZ3JhZGllbnRFbGVtZW50LnRhZ05hbWUgPT09ICdyYWRpYWxHcmFkaWVudCcpXG5cdFx0e1xuXHRcdFx0Z3JhZGllbnQuY3ggPSB0aGlzLmdldENvb3JkKGdyYWRpZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2N4JykpO1xuXHRcdFx0Z3JhZGllbnQuY3kgPSB0aGlzLmdldENvb3JkKGdyYWRpZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2N5JykpO1xuXHRcdFx0Z3JhZGllbnQuZnggPSBncmFkaWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmeCcpID8gdGhpcy5nZXRDb29yZChncmFkaWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmeCcpKSA6IGdyYWRpZW50LmN4O1xuXHRcdFx0Z3JhZGllbnQuZnkgPSBncmFkaWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmeScpID8gdGhpcy5nZXRDb29yZChncmFkaWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmeScpKSA6IGdyYWRpZW50LmN5O1xuXHRcdFx0Z3JhZGllbnQuciA9IHRoaXMuZ2V0Q29vcmQoZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgncicpKTtcblxuXHRcdFx0aWYgKG0pXG5cdFx0XHR7XG5cdFx0XHRcdHZhciB0ZkNYID0gbVswXSAqIGdyYWRpZW50LmN4ICsgbVsxXSAqIGdyYWRpZW50LmN5ICsgbVsyXTtcblx0XHRcdFx0dmFyIHRmQ1kgPSBtWzNdICogZ3JhZGllbnQuY3ggKyBtWzRdICogZ3JhZGllbnQuY3kgKyBtWzVdO1xuXHRcdFx0XHR2YXIgdGZGWCA9IG1bMF0gKiBncmFkaWVudC5meCArIG1bMV0gKiBncmFkaWVudC5meSArIG1bMl07XG5cdFx0XHRcdHZhciB0ZkZZID0gbVszXSAqIGdyYWRpZW50LmZ4ICsgbVs0XSAqIGdyYWRpZW50LmZ5ICsgbVs1XTtcblxuXHRcdFx0XHRncmFkaWVudC5jeCA9IHRmQ1g7XG5cdFx0XHRcdGdyYWRpZW50LmN5ID0gdGZDWTtcblx0XHRcdFx0Z3JhZGllbnQuZnggPSB0ZkZYO1xuXHRcdFx0XHRncmFkaWVudC5meSA9IHRmRlk7XG5cdFx0XHRcdC8vIGdyYWRpZW50LnIgPSAxMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgc3RvcHMgPSBncmFkaWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3RvcCcpO1xuXHRcdGZvciAodmFyIGsgPSAwLCBzdG9wTGVuZ3RoID0gc3RvcHMubGVuZ3RoOyBrIDwgc3RvcExlbmd0aDsgayArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyU3RvcCA9IHN0b3BzW2tdO1xuXHRcdFx0dmFyIG9mZnNldCA9IE51bWJlcihjdXJyU3RvcC5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpKTtcblx0XHRcdHZhciBjb2xvciA9IGN1cnJTdG9wLmdldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicpIHx8IC9zdG9wLWNvbG9yOigjWzAtOUEtRl0rKS9pbS5leGVjKGN1cnJTdG9wLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSlbMV07XG5cdFx0XHR2YXIgb3BhY2l0eSA9IGN1cnJTdG9wLmdldEF0dHJpYnV0ZSgnc3RvcC1vcGFjaXR5Jyk7XG5cdFx0XHRncmFkaWVudC5zdG9wcy5wdXNoKHsgb2Zmc2V0OiBvZmZzZXQsIGNvbG9yOiBjb2xvciwgb3BhY2l0eTogb3BhY2l0eSB9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZ3JhZGllbnQ7XG5cdH1cbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2VDaXJjbGUgPSBmdW5jdGlvbiAoJHJhd0NpcmNsZSlcbntcblx0dmFyIHhQb3MgPSB0aGlzLmdldENvb3JkKCRyYXdDaXJjbGUuZ2V0QXR0cmlidXRlKCdjeCcpIHx8IDApO1xuXHR2YXIgeVBvcyA9IHRoaXMuZ2V0Q29vcmQoJHJhd0NpcmNsZS5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgMCk7XG5cdHZhciByYWRpdXNBdHRyWCA9ICRyYXdDaXJjbGUuZ2V0QXR0cmlidXRlKCdyJykgfHwgJHJhd0NpcmNsZS5nZXRBdHRyaWJ1dGUoJ3J4Jyk7XG5cdHZhciByYWRpdXNBdHRyWSA9ICRyYXdDaXJjbGUuZ2V0QXR0cmlidXRlKCdyeScpO1xuXHR2YXIgcmFkaXVzWCA9IHRoaXMuZ2V0Q29vcmQocmFkaXVzQXR0clgpO1xuXHR2YXIgcmFkaXVzWSA9IHRoaXMuZ2V0Q29vcmQocmFkaXVzQXR0clkpIHx8IHJhZGl1c1g7XG5cdHZhciByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oJHJhd0NpcmNsZS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKTtcblx0dmFyIHBvaW50Q29tbWFuZHMgPSBbeyBjb21tYW5kOiByYWRpdXNZICE9PSByYWRpdXNYID8gRUxMSVBTRSA6IEFSQywgcG9pbnQ6IFt4UG9zLCB5UG9zXSwgb3B0aW9uczogW3JhZGl1c1gsIHJhZGl1c1ksIHJvdGF0aW9uXSB9XTtcblx0cmV0dXJuIHsgdHlwZTogJ2VsbGlwc2UnLCBwb2ludENvbW1hbmRzOiBwb2ludENvbW1hbmRzLCByYWRpdXNYOiByYWRpdXNYLCByYWRpdXNZOiByYWRpdXNZLCBjbG9zZVBhdGg6IGZhbHNlIH07XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlTGluZSA9IGZ1bmN0aW9uICgkcmF3TGluZSlcbntcblx0dmFyIHgxID0gdGhpcy5nZXRDb29yZCgkcmF3TGluZS5nZXRBdHRyaWJ1dGUoJ3gxJykpO1xuXHR2YXIgeDIgPSB0aGlzLmdldENvb3JkKCRyYXdMaW5lLmdldEF0dHJpYnV0ZSgneDInKSk7XG5cdHZhciB5MSA9IHRoaXMuZ2V0Q29vcmQoJHJhd0xpbmUuZ2V0QXR0cmlidXRlKCd5MScpKTtcblx0dmFyIHkyID0gdGhpcy5nZXRDb29yZCgkcmF3TGluZS5nZXRBdHRyaWJ1dGUoJ3kyJykpO1xuXHR2YXIgcG9pbnRDb21tYW5kcyA9IFtdO1xuXHRwb2ludENvbW1hbmRzLnB1c2goeyBjb21tYW5kOiBNT1ZFX1RPLCBwb2ludDogW3gxLCB5MV0sIG9wdGlvbnM6IFtdIH0pO1xuXHRwb2ludENvbW1hbmRzLnB1c2goeyBjb21tYW5kOiBMSU5FX1RPLCBwb2ludDogW3gyLCB5Ml0sIG9wdGlvbnM6IFtdIH0pO1xuXHRyZXR1cm4geyB0eXBlOiAnbGluZScsIHBvaW50Q29tbWFuZHM6IHBvaW50Q29tbWFuZHMsIGNsb3NlUGF0aDogZmFsc2UgfTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2VSZWN0ID0gZnVuY3Rpb24gKCRyYXdSZWN0KVxue1xuXHR2YXIgeDEgPSAkcmF3UmVjdC5nZXRBdHRyaWJ1dGUoJ3gnKSA/IHRoaXMuZ2V0Q29vcmQoJHJhd1JlY3QuZ2V0QXR0cmlidXRlKCd4JykpIDogMDtcblx0dmFyIHkxID0gJHJhd1JlY3QuZ2V0QXR0cmlidXRlKCd5JykgPyB0aGlzLmdldENvb3JkKCRyYXdSZWN0LmdldEF0dHJpYnV0ZSgneScpKSA6IDA7XG5cdHZhciB4MiA9IHgxICsgdGhpcy5nZXRDb29yZCgkcmF3UmVjdC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO1xuXHR2YXIgeTIgPSB5MSArIHRoaXMuZ2V0Q29vcmQoJHJhd1JlY3QuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7XG5cblx0dmFyIHBvaW50cyA9XG5cdFtcblx0XHRbeDEsIHkxXSxcblx0XHRbeDEsIHkyXSxcblx0XHRbeDIsIHkyXSxcblx0XHRbeDIsIHkxXVxuXHRdO1xuXG5cdHZhciBtID0gdGhpcy5nZXRNYXRyaXgoJHJhd1JlY3QuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSk7XG5cdGlmIChtKVxuXHR7XG5cdFx0cG9pbnRzID1cblx0XHRbXG5cdFx0XHR0aGlzLm11bHRpcGx5UG9pbnRCeU1hdHJpeChwb2ludHNbMF0sIG0pLFxuXHRcdFx0dGhpcy5tdWx0aXBseVBvaW50QnlNYXRyaXgocG9pbnRzWzFdLCBtKSxcblx0XHRcdHRoaXMubXVsdGlwbHlQb2ludEJ5TWF0cml4KHBvaW50c1syXSwgbSksXG5cdFx0XHR0aGlzLm11bHRpcGx5UG9pbnRCeU1hdHJpeChwb2ludHNbM10sIG0pXG5cdFx0XHQvLyBbbVswXSAqIHgxICsgbVsxXSAqIHkxICsgbVsyXSwgbVszXSAqIHgxICsgbVs0XSAqIHkxICsgbVs1XV0sXG5cdFx0XHQvLyBbbVswXSAqIHgxICsgbVsxXSAqIHkyICsgbVsyXSwgbVszXSAqIHgxICsgbVs0XSAqIHkyICsgbVs1XV0sXG5cdFx0XHQvLyBbbVswXSAqIHgyICsgbVsxXSAqIHkyICsgbVsyXSwgbVszXSAqIHgyICsgbVs0XSAqIHkyICsgbVs1XV0sXG5cdFx0XHQvLyBbbVswXSAqIHgyICsgbVsxXSAqIHkxICsgbVsyXSwgbVszXSAqIHgyICsgbVs0XSAqIHkxICsgbVs1XV1cblx0XHRdO1xuXHR9XG5cblx0dmFyIHBvaW50Q29tbWFuZHMgPSBbXTtcblx0cG9pbnRDb21tYW5kcy5wdXNoKHsgY29tbWFuZDogTU9WRV9UTywgcG9pbnQ6IHBvaW50c1swXSwgb3B0aW9uczogW10gfSk7XG5cdHBvaW50Q29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IExJTkVfVE8sIHBvaW50OiBwb2ludHNbMV0sIG9wdGlvbnM6IFtdIH0pO1xuXHRwb2ludENvbW1hbmRzLnB1c2goeyBjb21tYW5kOiBMSU5FX1RPLCBwb2ludDogcG9pbnRzWzJdLCBvcHRpb25zOiBbXSB9KTtcblx0cG9pbnRDb21tYW5kcy5wdXNoKHsgY29tbWFuZDogTElORV9UTywgcG9pbnQ6IHBvaW50c1szXSwgb3B0aW9uczogW10gfSk7XG5cblx0cmV0dXJuIHsgdHlwZTogJ3BvbHlnb24nLCBwb2ludENvbW1hbmRzOiBwb2ludENvbW1hbmRzLCBjbG9zZVBhdGg6IHRydWUgfTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2VQb2x5ID0gZnVuY3Rpb24gKCRyYXdQb2x5KVxue1xuXHR2YXIgcmVnZXggPSAvKFtcXC0uXFxkXSspWywgXShbXFwtLlxcZF0rKS9pZztcblx0dmFyIHJlc3VsdCA9IHJlZ2V4LmV4ZWMoJHJhd1BvbHkuZ2V0QXR0cmlidXRlKCdwb2ludHMnKSk7XG5cdHZhciBwb2ludENvbW1hbmRzID0gW107XG5cblx0d2hpbGUgKHJlc3VsdClcblx0e1xuXHRcdHZhciBjb21tYW5kID0gcG9pbnRDb21tYW5kcy5sZW5ndGggPT09IDAgPyBNT1ZFX1RPIDogTElORV9UTztcblx0XHR2YXIgcG9pbnQgPSBbdGhpcy5nZXRDb29yZChyZXN1bHRbMV0pLCB0aGlzLmdldENvb3JkKHJlc3VsdFsyXSldO1xuXHRcdHBvaW50Q29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IGNvbW1hbmQsIHBvaW50OiBwb2ludCwgb3B0aW9uczogW10gfSk7XG5cdFx0cmVzdWx0ID0gcmVnZXguZXhlYygkcmF3UG9seS5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpKTtcblx0fVxuXHRyZXR1cm4geyB0eXBlOiAkcmF3UG9seS50YWdOYW1lLCBwb2ludENvbW1hbmRzOiBwb2ludENvbW1hbmRzLCBjbG9zZVBhdGg6ICRyYXdQb2x5LnRhZ05hbWUgIT09ICdwb2x5bGluZScgfTtcblxuXHQvLyB2YXIgc3BsaXRzID0gJHJhd1BvbHkuZ2V0QXR0cmlidXRlKCdwb2ludHMnKS5zcGxpdCgnICcpO1xuXHQvLyB2YXIgcG9pbnRDb21tYW5kcyA9IHt9O1xuXG5cdC8vIGZvciAodmFyIGkgPSAwLCBzcGxpdHNMZW5ndGggPSBzcGxpdHMubGVuZ3RoOyBpIDwgc3BsaXRzTGVuZ3RoOyBpICs9IDEpXG5cdC8vIHtcblx0Ly8gXHR2YXIgY3VyclNwbGl0ID0gc3BsaXRzW2ldO1xuXG5cdC8vIFx0aWYgKGN1cnJTcGxpdCAhPT0gJycpXG5cdC8vIFx0e1xuXHQvLyBcdFx0dmFyIHBvaW50ID0gY3VyclNwbGl0LnNwbGl0KCcsJyk7XG5cdC8vIFx0XHR2YXIgcG9pbnRYID0gdGhpcy5nZXRDb29yZChwb2ludFswXSk7XG5cdC8vIFx0XHR2YXIgcG9pbnRZID0gdGhpcy5nZXRDb29yZChwb2ludFsxXSk7XG5cdC8vIFx0XHR2YXIgZXhpc3RzID0gZmFsc2U7XG5cdC8vIFx0XHRmb3IgKHZhciBrID0gMCwgb3RoZXJDb29yZHNBcnJheUxlbmd0aCA9IHBvaW50cy5sZW5ndGg7IGsgPCBvdGhlckNvb3Jkc0FycmF5TGVuZ3RoOyBrICs9IDEpXG5cdC8vIFx0XHR7XG5cdC8vIFx0XHRcdHZhciBvdGhlclBvaW50ID0gcG9pbnRzW2tdO1xuXHQvLyBcdFx0XHR2YXIgb3RoZXJYID0gb3RoZXJQb2ludFswXTtcblx0Ly8gXHRcdFx0dmFyIG90aGVyWSA9IG90aGVyUG9pbnRbMV07XG5cdC8vIFx0XHRcdGlmIChvdGhlclggPT09IHBvaW50WCAmJiBvdGhlclkgPT09IHBvaW50WSlcblx0Ly8gXHRcdFx0e1xuXHQvLyBcdFx0XHRcdGV4aXN0cyA9IHRydWU7XG5cdC8vIFx0XHRcdH1cblx0Ly8gXHRcdH1cblx0Ly8gXHRcdGlmIChleGlzdHMgPT09IGZhbHNlKVxuXHQvLyBcdFx0e1xuXHQvLyBcdFx0XHRwb2ludHMucHVzaChbcG9pbnRYLCBwb2ludFldKTtcblx0Ly8gXHRcdH1cblx0Ly8gXHR9XG5cdC8vfVxuXG5cdC8vIHZhciB0aGlja25lc3MgPSB0aGlzLmdldENvb3JkKCRyYXdQb2x5LmdldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJykpO1xuXHQvLyB2YXIgdHlwZSA9ICRyYXdQb2x5LnRhZ05hbWUgPT09ICdwb2x5bGluZScgPyAncG9seWxpbmUnIDogJ3BvbHlnb24nO1xuXHQvLyByZXR1cm4geyB0eXBlOiB0eXBlLCBwb2ludENvbW1hbmRzOiBwb2ludHMsIHRoaWNrbmVzczogdGhpY2tuZXNzIH07XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlUGF0aCA9IGZ1bmN0aW9uICgkcmF3UGF0aClcbntcblx0dmFyIGQgPSAkcmF3UGF0aC5nZXRBdHRyaWJ1dGUoJ2QnKTtcblx0dmFyIHBhdGhSZWcgPSAvKFthLXldKShbLlxcLSxcXGRdKykvaWdtO1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgY2xvc2VQYXRoID0gL3ovaWdtLnRlc3QoZCk7XG5cdHZhciBjb29yZHNSZWdleCA9IC8tP1tcXGQuXSsvaWdtO1xuXHR2YXIgcG9pbnRDb21tYW5kcyA9IFtdO1xuXHR2YXIgbGFzdFggPSB0aGlzLmdldENvb3JkKDApO1xuXHR2YXIgbGFzdFkgPSB0aGlzLmdldENvb3JkKDApO1xuXG5cdHZhciB0aGF0ID0gdGhpcztcblx0dmFyIGdldFBvaW50ID0gZnVuY3Rpb24gKCR4LCAkeSwgJHJlbGF0aXZlKVxuXHR7XG5cdFx0dmFyIHggPSAkeCA9PT0gdW5kZWZpbmVkID8gbGFzdFggOiB0aGF0LmdldENvb3JkKCR4KTtcblx0XHR2YXIgeSA9ICR5ID09PSB1bmRlZmluZWQgPyBsYXN0WSA6IHRoYXQuZ2V0Q29vcmQoJHkpO1xuXHRcdGlmICgkcmVsYXRpdmUpXG5cdFx0e1xuXHRcdFx0eCA9IGxhc3RYICsgeDtcblx0XHRcdHkgPSBsYXN0WSArIHk7XG5cdFx0fVxuXHRcdHJldHVybiBbeCwgeV07XG5cdH07XG5cblx0dmFyIGdldFJlbGF0aXZlUG9pbnQgPSBmdW5jdGlvbiAoJHBvaW50LCAkeCwgJHksICRyZWxhdGl2ZSlcblx0e1xuXHRcdHZhciB4ID0gdGhhdC5nZXRDb29yZCgkeCk7XG5cdFx0dmFyIHkgPSB0aGF0LmdldENvb3JkKCR5KTtcblx0XHRpZiAoJHJlbGF0aXZlKVxuXHRcdHtcblx0XHRcdHggPSBsYXN0WCArIHg7XG5cdFx0XHR5ID0gbGFzdFkgKyB5O1xuXHRcdH1cblx0XHR4ID0geCAtICRwb2ludFswXTtcblx0XHR5ID0geSAtICRwb2ludFsxXTtcblx0XHRyZXR1cm4gW3gsIHldO1xuXHR9O1xuXG5cdHZhciBjcmVhdGVQb2ludCA9IGZ1bmN0aW9uICgkY29tbWFuZCwgJHBvaW50LCAkb3B0aW9ucylcblx0e1xuXHRcdHZhciBpbmZvID0geyBjb21tYW5kOiAkY29tbWFuZCwgcG9pbnQ6ICRwb2ludCwgb3B0aW9uczogJG9wdGlvbnMgfHwgW10gfTtcblx0XHRsYXN0WCA9IGluZm8ucG9pbnRbMF07XG5cdFx0bGFzdFkgPSBpbmZvLnBvaW50WzFdO1xuXHRcdHBvaW50Q29tbWFuZHMucHVzaChpbmZvKTtcblx0fTtcblxuXHR2YXIgcG9pbnQ7XG5cdHZhciBjdWJpYzE7XG5cdHZhciBjdWJpYzI7XG5cdHZhciBxdWFkcmExO1xuXG5cdGRvXG5cdHtcblx0XHRyZXN1bHQgPSBwYXRoUmVnLmV4ZWMoZCk7XG5cdFx0aWYgKHJlc3VsdCA9PT0gbnVsbClcblx0XHR7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0dmFyIGluc3RydWN0aW9uID0gcmVzdWx0WzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0dmFyIGNvb3JkcyA9IHJlc3VsdFsyXS5tYXRjaChjb29yZHNSZWdleCk7XG5cdFx0dmFyIGlzTG93c2VyQ2FzZSA9IC9bYS16XS8udGVzdChyZXN1bHRbMV0pO1xuXG5cdFx0c3dpdGNoIChpbnN0cnVjdGlvbilcblx0XHR7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0Y2FzZSAnbSc6XG5cdFx0XHRcdHF1YWRyYTEgPSBudWxsO1xuXHRcdFx0XHRjdWJpYzIgPSBudWxsO1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KGNvb3Jkc1swXSwgY29vcmRzWzFdLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRjcmVhdGVQb2ludChNT1ZFX1RPLCBwb2ludCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbCc6XG5cdFx0XHRcdHF1YWRyYTEgPSBudWxsO1xuXHRcdFx0XHRjdWJpYzIgPSBudWxsO1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KGNvb3Jkc1swXSwgY29vcmRzWzFdLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRjcmVhdGVQb2ludChMSU5FX1RPLCBwb2ludCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndic6XG5cdFx0XHRcdHF1YWRyYTEgPSBudWxsO1xuXHRcdFx0XHRjdWJpYzIgPSBudWxsO1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KHVuZGVmaW5lZCwgY29vcmRzWzBdLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRjcmVhdGVQb2ludChMSU5FX1RPLCBwb2ludCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnaCc6XG5cdFx0XHRcdHF1YWRyYTEgPSBudWxsO1xuXHRcdFx0XHRjdWJpYzIgPSBudWxsO1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KGNvb3Jkc1swXSwgdW5kZWZpbmVkLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRjcmVhdGVQb2ludChMSU5FX1RPLCBwb2ludCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdHF1YWRyYTEgPSBudWxsO1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KGNvb3Jkc1s0XSwgY29vcmRzWzVdLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRjdWJpYzEgPSBnZXRSZWxhdGl2ZVBvaW50KHBvaW50LCBjb29yZHNbMF0sIGNvb3Jkc1sxXSwgaXNMb3dzZXJDYXNlKTtcblx0XHRcdFx0Y3ViaWMyID0gZ2V0UmVsYXRpdmVQb2ludChwb2ludCwgY29vcmRzWzJdLCBjb29yZHNbM10sIGlzTG93c2VyQ2FzZSk7XG5cdFx0XHRcdGNyZWF0ZVBvaW50KEJFWklFUl9UTywgcG9pbnQsIFtjdWJpYzEsIGN1YmljMl0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3MnOlxuXHRcdFx0XHRxdWFkcmExID0gbnVsbDtcblx0XHRcdFx0cG9pbnQgPSBnZXRQb2ludChjb29yZHNbMl0sIGNvb3Jkc1szXSwgaXNMb3dzZXJDYXNlKTtcblx0XHRcdFx0Y3ViaWMxID0gY3ViaWMyID8gW2xhc3RYIC0gY3ViaWMyWzBdIC0gcG9pbnRbMF0sIGxhc3RZIC0gY3ViaWMyWzFdIC0gcG9pbnRbMV1dIDogdW5kZWZpbmVkO1xuXHRcdFx0XHRjdWJpYzIgPSBnZXRSZWxhdGl2ZVBvaW50KHBvaW50LCBjb29yZHNbMF0sIGNvb3Jkc1sxXSwgaXNMb3dzZXJDYXNlKTtcblx0XHRcdFx0Y3ViaWMxID0gY3ViaWMxIHx8IFtjdWJpYzJbMF0sIGN1YmljMlsxXV07XG5cdFx0XHRcdGNyZWF0ZVBvaW50KEJFWklFUl9UTywgcG9pbnQsIFtjdWJpYzEsIGN1YmljMl0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3EnOlxuXHRcdFx0XHRjdWJpYzIgPSBudWxsO1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KGNvb3Jkc1syXSwgY29vcmRzWzNdLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRxdWFkcmExID0gZ2V0UmVsYXRpdmVQb2ludChwb2ludCwgY29vcmRzWzBdLCBjb29yZHNbMV0sIGlzTG93c2VyQ2FzZSk7XG5cdFx0XHRcdGNyZWF0ZVBvaW50KFFVQURSQV9UTywgcG9pbnQsIFtxdWFkcmExXSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndCc6XG5cdFx0XHRcdGN1YmljMiA9IG51bGw7XG5cdFx0XHRcdHF1YWRyYTEgPSBxdWFkcmExID8gcXVhZHJhMSA6IHBvaW50O1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KGNvb3Jkc1swXSwgY29vcmRzWzFdLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRjcmVhdGVQb2ludChRVUFEUkFfVE8sIHBvaW50LCBbcXVhZHJhMV0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0XHRjdWJpYzIgPSBudWxsO1xuXHRcdFx0XHRxdWFkcmExID0gbnVsbDtcblx0XHRcdFx0cG9pbnQgPSBnZXRQb2ludChjb29yZHNbNV0sIGNvb3Jkc1s2XSwgaXNMb3dzZXJDYXNlKTtcblx0XHRcdFx0Y3JlYXRlUG9pbnQoJ2FyY1RvJywgcG9pbnQpO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ25vdCBzdXBwb3J0ZWQnKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cdHdoaWxlIChyZXN1bHQpO1xuXG5cdHJldHVybiB7IHR5cGU6ICdwYXRoJywgcG9pbnRDb21tYW5kczogcG9pbnRDb21tYW5kcywgY2xvc2VQYXRoOiBjbG9zZVBhdGggfTtcblx0Ly92YXIgcG9pbnRzID1cblx0Ly8gdmFyIHBhdGhSZWcgPSAvKFttbHNjdmhdKSgtP1tcXGRcXC5dKlssLV0rW1xcZFxcLl0qKSw/KC0/W1xcZFxcLl0qLD8tP1tcXGRcXC5dKiksPygtP1tcXGRcXC5dKiw/LT9bXFxkXFwuXSopL2lnbTtcblx0Ly8gdmFyIHBvaW50cyA9IFtdO1xuXHQvLyB2YXIgbGFzdENvb3JkWCA9IHRoaXMuZ2V0Q29vcmQoMCk7XG5cdC8vIHZhciBsYXN0Q29vcmRZID0gdGhpcy5nZXRDb29yZCgwKTtcblx0Ly8gY29uc29sZS5sb2cocGF0aFJlZy5leGVjKGQpKTtcblx0Ly8gZGVidWdnZXI7XG5cdC8vIGZvciAodmFyIGFycmF5ID0gcGF0aFJlZy5leGVjKGQpOyBhcnJheSAhPT0gbnVsbDsgYXJyYXkgPSBwYXRoUmVnLmV4ZWMoZCkpXG5cdC8vIHtcblx0Ly8gXHR2YXIgY29vcmRTdHJpbmc7XG5cdC8vIFx0dmFyIG51bWJlckNvb3JkWDtcblx0Ly8gXHR2YXIgbnVtYmVyQ29vcmRZO1xuXHQvLyBcdGlmIChhcnJheVsxXSA9PT0gJ3YnKVxuXHQvLyBcdHtcblx0Ly8gXHRcdG51bWJlckNvb3JkWCA9IGxhc3RDb29yZFg7XG5cdC8vIFx0XHRudW1iZXJDb29yZFkgPSBsYXN0Q29vcmRZICsgdGhpcy5nZXRDb29yZChhcnJheVsyXSk7XG5cdC8vIFx0fVxuXHQvLyBcdGVsc2UgaWYgKGFycmF5WzFdID09PSAnaCcpXG5cdC8vIFx0e1xuXHQvLyBcdFx0bnVtYmVyQ29vcmRYID0gbGFzdENvb3JkWCArIHRoaXMuZ2V0Q29vcmQoYXJyYXlbMl0pO1xuXHQvLyBcdFx0bnVtYmVyQ29vcmRZID0gbGFzdENvb3JkWTtcblx0Ly8gXHR9XG5cdC8vIFx0ZWxzZVxuXHQvLyBcdHtcblx0Ly8gXHRcdGlmIChhcnJheVs0XSAhPT0gJycpXG5cdC8vIFx0XHR7XG5cdC8vIFx0XHRcdGNvb3JkU3RyaW5nID0gYXJyYXlbNF07XG5cdC8vIFx0XHR9XG5cdC8vIFx0XHRlbHNlIGlmIChhcnJheVszXSAhPT0gJycpXG5cdC8vIFx0XHR7XG5cdC8vIFx0XHRcdGNvb3JkU3RyaW5nID0gYXJyYXlbM107XG5cdC8vIFx0XHR9XG5cdC8vIFx0XHRlbHNlXG5cdC8vIFx0XHR7XG5cdC8vIFx0XHRcdGNvb3JkU3RyaW5nID0gYXJyYXlbMl07XG5cdC8vIFx0XHR9XG5cdC8vIFx0XHR2YXIgY29vcmRSZWcgPSAvKC0/XFxkK1xcLj9cXGQqKS9pZ207XG5cdC8vIFx0XHR2YXIgY29vcmRzID0gY29vcmRTdHJpbmcubWF0Y2goY29vcmRSZWcpO1xuXG5cdC8vIFx0XHRudW1iZXJDb29yZFggPSBsYXN0Q29vcmRYICsgdGhpcy5nZXRDb29yZChjb29yZHNbMF0pO1xuXHQvLyBcdFx0bnVtYmVyQ29vcmRZID0gbGFzdENvb3JkWSArIHRoaXMuZ2V0Q29vcmQoY29vcmRzWzFdKTtcblx0Ly8gXHR9XG5cdC8vIFx0Ly9jb25zb2xlLmxvZyhudW1iZXJDb29yZFgsIG51bWJlckNvb3JkWSk7XG5cdC8vIFx0cG9pbnRzLnB1c2goW251bWJlckNvb3JkWCwgbnVtYmVyQ29vcmRZXSk7XG5cblx0Ly8gXHRsYXN0Q29vcmRYID0gbnVtYmVyQ29vcmRYO1xuXHQvLyBcdGxhc3RDb29yZFkgPSBudW1iZXJDb29yZFk7XG5cdC8vIH1cblx0Ly8gY29uc29sZS5sb2cocG9pbnRzKTtcblx0Ly8gZGVidWdnZXI7XG5cblx0Ly8gdmFyIHRoaWNrbmVzcyA9IHRoaXMuZ2V0Q29vcmQoJHJhd1BhdGguZ2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnKSk7XG5cdC8vIHJldHVybiB7IHR5cGU6ICdwYXRoJywgcG9pbnRzOiBwb2ludHMsIHRoaWNrbmVzczogdGhpY2tuZXNzIH07XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24gKCRudW1iZXIpXG57XG5cdC8vIHZhciBudW1iZXIgPSBOdW1iZXIoJG51bWJlcik7XG5cdC8vIHJldHVybiBNYXRoLmZsb29yKG51bWJlciAqIDEwMCkgLyAxMDA7XG5cdHJldHVybiAkbnVtYmVyO1xuXHQvL3JldHVybiBNYXRoLmZsb29yKE51bWJlcigkbnVtYmVyKSk7XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uICgkYXR0cmlidXRlKVxue1xuXHRpZiAoISRhdHRyaWJ1dGUpIHsgcmV0dXJuIG51bGw7IH1cblxuXHR2YXIgVEZUeXBlID0gJGF0dHJpYnV0ZS5tYXRjaCgvKFthLXpdKykvaWdtKVswXTtcblx0dmFyIHZhbHVlcyA9ICRhdHRyaWJ1dGUubWF0Y2goLygtP1tcXGQuXSspL2lnbSk7XG5cblx0dmFyIG1hdHJpY2VzID0gW107XG5cdHZhciB0WDtcblx0dmFyIHRZO1xuXHR2YXIgYW5nbGU7XG5cblx0aWYgKFRGVHlwZSA9PT0gJ21hdHJpeCcpXG5cdHtcblx0XHRyZXR1cm4gW051bWJlcih2YWx1ZXNbMF0pLCBOdW1iZXIodmFsdWVzWzJdKSwgdGhpcy5nZXRDb29yZCh2YWx1ZXNbNF0pLCBOdW1iZXIodmFsdWVzWzFdKSwgTnVtYmVyKHZhbHVlc1szXSksIHRoaXMuZ2V0Q29vcmQodmFsdWVzWzVdKSwgMCwgMCwgMV07XG5cdH1cblx0ZWxzZSBpZiAoVEZUeXBlID09PSAncm90YXRlJylcblx0e1xuXHRcdGFuZ2xlID0gTnVtYmVyKHZhbHVlc1swXSkgKiAoTWF0aC5QSSAvIDE4MCk7XG5cdFx0dFggPSB0aGlzLmdldENvb3JkKE51bWJlcih2YWx1ZXNbMV0gfHwgMCkpO1xuXHRcdHRZID0gdGhpcy5nZXRDb29yZChOdW1iZXIodmFsdWVzWzJdIHx8IDApKTtcblx0XHR2YXIgbTEgPSBbMSwgMCwgdFgsIDAsIDEsIHRZLCAwLCAwLCAxXTtcblx0XHR2YXIgbTIgPSBbTWF0aC5jb3MoYW5nbGUpLCAtTWF0aC5zaW4oYW5nbGUpLCAwLCBNYXRoLnNpbihhbmdsZSksIE1hdGguY29zKGFuZ2xlKSwgMCwgMCwgMCwgMV07XG5cdFx0dmFyIG0zID0gWzEsIDAsIC10WCwgMCwgMSwgLXRZLCAwLCAwLCAxXTtcblxuXHRcdG1hdHJpY2VzLnB1c2gobTEsIG0yLCBtMyk7XG5cdFx0dmFyIHAgPSBtMTtcblxuXHRcdGZvciAodmFyIGkgPSAxLCBtYXRyaWNlc0xlbmd0aCA9IG1hdHJpY2VzLmxlbmd0aDsgaSA8IG1hdHJpY2VzTGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJNYXQgPSBtYXRyaWNlc1tpXTtcblx0XHRcdHZhciBuZXdQID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuXHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCA5OyBrICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciByb3cgPSBNYXRoLmZsb29yKGsgLyAzKTtcblx0XHRcdFx0dmFyIGNvbCA9IGsgJSAzO1xuXHRcdFx0XHQvL3ZhciBtVmFsID0gcFtyb3cgKiBjb2wgLSAxXTtcblx0XHRcdFx0Zm9yICh2YXIgcG9zID0gMDsgcG9zIDwgMzsgcG9zICs9IDEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuZXdQW2tdID0gbmV3UFtrXSArIHBbcm93ICogMyArIHBvc10gKiBjdXJyTWF0W3BvcyAqIDMgKyBjb2xdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwID0gbmV3UDtcblx0XHR9XG5cdFx0cmV0dXJuIHA7XG5cdH1cblx0ZWxzZSBpZiAoVEZUeXBlID09PSAndHJhbnNsYXRlJylcblx0e1xuXHRcdHRYID0gdGhpcy5nZXRDb29yZChOdW1iZXIodmFsdWVzWzBdIHx8IDApKTtcblx0XHR0WSA9IHRoaXMuZ2V0Q29vcmQoTnVtYmVyKHZhbHVlc1sxXSB8fCAwKSk7XG5cdFx0cmV0dXJuIFsxLCAwLCB0WCwgMCwgMSwgdFksIDAsIDAsIDFdO1xuXHR9XG5cdGVsc2UgaWYgKFRGVHlwZSA9PT0gJ3NjYWxlJylcblx0e1xuXHRcdHZhciBzWCA9IHRoaXMuZ2V0Q29vcmQoTnVtYmVyKHZhbHVlc1swXSB8fCAwKSk7XG5cdFx0dmFyIHNZID0gdGhpcy5nZXRDb29yZChOdW1iZXIodmFsdWVzWzFdIHx8IDApKTtcblx0XHRyZXR1cm4gW3NYLCAwLCAwLCAwLCBzWSwgMF07XG5cdH1cblx0ZWxzZSBpZiAoVEZUeXBlID09PSAnc2tld1gnKVxuXHR7XG5cdFx0YW5nbGUgPSBOdW1iZXIodmFsdWVzWzBdKSAqIChNYXRoLlBJIC8gMTgwKTtcblx0XHRyZXR1cm4gWzEsIE1hdGgudGFuKGFuZ2xlKSwgMCwgMCwgMSwgMCwgMCwgMCwgMV07XG5cdH1cblx0ZWxzZSBpZiAoVEZUeXBlID09PSAnc2tld1knKVxuXHR7XG5cdFx0YW5nbGUgPSBOdW1iZXIodmFsdWVzWzBdKSAqIChNYXRoLlBJIC8gMTgwKTtcblx0XHRyZXR1cm4gWzEsIDAsIDAsIE1hdGgudGFuKGFuZ2xlKSwgMSwgMCwgMCwgMCwgMV07XG5cdH1cbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUubXVsdGlwbHlQb2ludEJ5TWF0cml4ID0gZnVuY3Rpb24gKCRwb2ludCwgbSlcbntcblx0dmFyIGggPSBbJHBvaW50WzBdLCAkcG9pbnRbMV0sIDFdO1xuXHR2YXIgcCA9XG5cdFtcblx0XHRtWzBdICogaFswXSArIG1bMV0gKiBoWzFdICsgbVsyXSAqIGhbMl0sXG5cdFx0bVszXSAqIGhbMF0gKyBtWzRdICogaFsxXSArIG1bNV0gKiBoWzJdLFxuXHRcdG1bNl0gKiBoWzBdICsgbVs3XSAqIGhbMV0gKyBtWzhdICogaFsyXVxuXHRdO1xuXHRyZXR1cm4gW3BbMF0gLyBwWzJdLCBwWzFdIC8gcFsyXV07XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKCRhdHRyaWJ1dGUpXG57XG5cdHZhciBtYXRyaXggPSB0aGlzLmdldE1hdHJpeCgkYXR0cmlidXRlKTtcblx0aWYgKG1hdHJpeClcblx0e1xuXHRcdHJldHVybiBNYXRoLmF0YW4yKG1hdHJpeFswXSwgbWF0cml4WzNdKTtcblx0fVxuXHRyZXR1cm4gMDtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuZ2V0Q29vcmQgPSBmdW5jdGlvbiAoJGNvb3JkU1RSKVxue1xuXHR2YXIgbnVtYmVyID0gdGhpcy5yb3VuZCgkY29vcmRTVFIpO1xuXHRyZXR1cm4gbnVtYmVyICogdGhpcy5yYXRpbztcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2VDdXN0b21Kb2ludHMgPSBmdW5jdGlvbiAoJHJhd0dyb3VwLCAkZ3JvdXApXG57XG5cdHZhciBjaGlsZHJlbiA9ICRyYXdHcm91cC5jaGlsZE5vZGVzOy8vJHJhd0dyb3VwLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZCo9XCJjb25zdHJhaW50XCJdJyk7XG5cblx0Zm9yICh2YXIgaSA9IDAsIGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdGlmIChjaGlsZHJlbltpXS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgfHwgY2hpbGRyZW5baV0uaWQuc2VhcmNoKC9qb2ludC9pKSA8IDApIHsgY29udGludWU7IH1cblxuXHRcdHZhciBjdXJyUmF3Sm9pbnQgPSBjaGlsZHJlbltpXTtcblx0XHR2YXIgcDF4ID0gdGhpcy5nZXRDb29yZChjdXJyUmF3Sm9pbnQuZ2V0QXR0cmlidXRlKCd4MScpKTtcblx0XHR2YXIgcDF5ID0gdGhpcy5nZXRDb29yZChjdXJyUmF3Sm9pbnQuZ2V0QXR0cmlidXRlKCd5MScpKTtcblx0XHR2YXIgcDJ4ID0gdGhpcy5nZXRDb29yZChjdXJyUmF3Sm9pbnQuZ2V0QXR0cmlidXRlKCd4MicpKTtcblx0XHR2YXIgcDJ5ID0gdGhpcy5nZXRDb29yZChjdXJyUmF3Sm9pbnQuZ2V0QXR0cmlidXRlKCd5MicpKTtcblxuXHRcdHZhciBuMSA9ICRncm91cC5nZXROb2RlQXRQb2ludChwMXgsIHAxeSkgfHwgJGdyb3VwLmNyZWF0ZU5vZGUocDF4LCBwMXkpO1xuXHRcdHZhciBuMiA9ICRncm91cC5nZXROb2RlQXRQb2ludChwMngsIHAyeSkgfHwgJGdyb3VwLmNyZWF0ZU5vZGUocDJ4LCBwMnkpO1xuXHRcdCRncm91cC5jcmVhdGVKb2ludChuMSwgbjIpO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1BhcnNlcjtcblxuIiwidmFyIFNWSmVsbHlOb2RlID0gcmVxdWlyZSgnLi9TVkplbGx5Tm9kZScpO1xudmFyIFNWSmVsbHlKb2ludCA9IHJlcXVpcmUoJy4vU1ZKZWxseUpvaW50Jyk7XG5cbnZhciBTVkplbGx5R3JvdXAgPSBmdW5jdGlvbiAoJHR5cGUsICRjb25mLCAkSUQpXG57XG5cdHRoaXMucGh5c2ljc01hbmFnZXIgPSB1bmRlZmluZWQ7XG5cdHRoaXMuZHJhd2luZyA9IHVuZGVmaW5lZDtcblx0dGhpcy5zdHJ1Y3R1cmUgPSB1bmRlZmluZWQ7XG5cdHRoaXMuY29uZiA9ICRjb25mO1xuXHR0aGlzLmZpeGVkID0gdGhpcy5jb25mLmZpeGVkO1xuXHR0aGlzLnR5cGUgPSAkdHlwZTtcblx0dGhpcy5ub2RlcyA9IFtdO1xuXHR0aGlzLmpvaW50cyA9IFtdO1xuXHR0aGlzLklEID0gJElEO1xufTtcblxuU1ZKZWxseUdyb3VwLnByb3RvdHlwZS5nZXROb2RlQXRQb2ludCA9IGZ1bmN0aW9uICgkeCwgJHkpXG57XG5cdGZvciAodmFyIGkgPSAwLCBub2Rlc0xlbmd0aCA9IHRoaXMubm9kZXMubGVuZ3RoOyBpIDwgbm9kZXNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBub2RlID0gdGhpcy5ub2Rlc1tpXTtcblxuXHRcdGlmIChub2RlLm9YID09PSAkeCAmJiBub2RlLm9ZID09PSAkeSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9XG5cdH1cbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uICgkcHgsICRweSwgJG9wdGlvbnMsICRvdmVyd3JpdGUpXG57XG5cdHZhciBub2RlID0gdGhpcy5nZXROb2RlQXRQb2ludCgkcHgsICRweSk7XG5cdGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgJG92ZXJ3cml0ZSlcblx0e1xuXHRcdG5vZGUuc2V0T3B0aW9ucygkb3B0aW9ucyk7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0bm9kZSA9IG5ldyBTVkplbGx5Tm9kZSgkcHgsICRweSwgJG9wdGlvbnMpO1xuXHRcdHRoaXMubm9kZXMucHVzaChub2RlKTtcblx0fVxuXG5cdC8vdGhpcy5waHlzaWNzTWFuYWdlci5hZGROb2RlVG9Xb3JsZChub2RlKTtcblxuXHRyZXR1cm4gbm9kZTtcbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuZ2V0Q2xvc2VzdFBvaW50ID0gZnVuY3Rpb24gKCRwb2ludHMsICRub2Rlcylcbntcblx0dmFyIG5vZGVzID0gJG5vZGVzIHx8IHRoaXMubm9kZXM7XG5cdHZhciBjbG9zZXN0RGlzdCA9IEluZmluaXR5O1xuXHR2YXIgY2xvc2VzdFBvaW50O1xuXHR2YXIgY2xvc2VzdE5vZGU7XG5cdHZhciBjbG9zZXN0T2Zmc2V0WDtcblx0dmFyIGNsb3Nlc3RPZmZzZXRZO1xuXG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSAkcG9pbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJQb2ludCA9ICRwb2ludHNbaV07XG5cdFx0Zm9yICh2YXIgayA9IDAsIG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoOyBrIDwgbm9kZXNMZW5ndGg7IGsgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3Vyck5vZGUgPSBub2Rlc1trXTtcblx0XHRcdHZhciBvZmZzZXRYID0gY3VyclBvaW50WzBdIC0gY3Vyck5vZGUub1g7XG5cdFx0XHR2YXIgb2Zmc2V0WSA9IGN1cnJQb2ludFsxXSAtIGN1cnJOb2RlLm9ZO1xuXHRcdFx0dmFyIGNYID0gTWF0aC5hYnMob2Zmc2V0WCk7XG5cdFx0XHR2YXIgY1kgPSBNYXRoLmFicyhvZmZzZXRZKTtcblx0XHRcdHZhciBkaXN0ID0gTWF0aC5zcXJ0KGNYICogY1ggKyBjWSAqIGNZKTtcblx0XHRcdGlmIChkaXN0IDwgY2xvc2VzdERpc3QpXG5cdFx0XHR7XG5cdFx0XHRcdGNsb3Nlc3ROb2RlID0gY3Vyck5vZGU7XG5cdFx0XHRcdGNsb3Nlc3RQb2ludCA9IGN1cnJQb2ludDtcblx0XHRcdFx0Y2xvc2VzdERpc3QgPSBkaXN0O1xuXHRcdFx0XHRjbG9zZXN0T2Zmc2V0WCA9IG9mZnNldFg7XG5cdFx0XHRcdGNsb3Nlc3RPZmZzZXRZID0gb2Zmc2V0WTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2xvc2VzdFBvaW50O1xufTtcblxuU1ZKZWxseUdyb3VwLnByb3RvdHlwZS5nZXRDbG9zZXN0Tm9kZSA9IGZ1bmN0aW9uICgkY29vcmQsICRub2Rlcylcbntcblx0dmFyIG5vZGVzID0gJG5vZGVzIHx8IHRoaXMubm9kZXM7XG5cdHZhciBjbG9zZXN0RGlzdCA9IEluZmluaXR5O1xuXHR2YXIgY2xvc2VzdDtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIG5vZGUgPSBub2Rlc1tpXTtcblx0XHR2YXIgb2Zmc2V0WCA9ICRjb29yZFswXSAtIG5vZGUub1g7XG5cdFx0dmFyIG9mZnNldFkgPSAkY29vcmRbMV0gLSBub2RlLm9ZO1xuXHRcdHZhciBjWCA9IE1hdGguYWJzKG9mZnNldFgpO1xuXHRcdHZhciBjWSA9IE1hdGguYWJzKG9mZnNldFkpO1xuXHRcdHZhciBkaXN0ID0gTWF0aC5zcXJ0KGNYICogY1ggKyBjWSAqIGNZKTtcblx0XHRpZiAoZGlzdCA8IGNsb3Nlc3REaXN0KVxuXHRcdHtcblx0XHRcdGNsb3Nlc3QgPSBub2RlO1xuXHRcdFx0Y2xvc2VzdERpc3QgPSBkaXN0O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gY2xvc2VzdDtcbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuZ2V0Tm9kZXNJbnNpZGUgPSBmdW5jdGlvbiAoJHBvaW50cylcbntcblx0dmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL1BvbHlnb24nKTtcblx0dmFyIHRvUmV0dXJuID0gW107XG5cdHZhciBwb2x5Z29uID0gUG9seWdvbi5pbml0KCRwb2ludHMpO1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5ub2Rlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBub2RlID0gdGhpcy5ub2Rlc1tpXTtcblx0XHRpZiAocG9seWdvbi5pc0luc2lkZShbbm9kZS5vWCwgbm9kZS5vWV0pKVxuXHRcdHtcblx0XHRcdHRvUmV0dXJuLnB1c2gobm9kZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0b1JldHVybjtcbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKVxue1xuXHR2YXIgbWluWDtcblx0dmFyIG1heFg7XG5cdHZhciBtaW5ZO1xuXHR2YXIgbWF4WTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMubm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZXNbaV07XG5cdFx0bWluWCA9IG1pblggPiBub2RlLm9YIHx8IG1pblggPT09IHVuZGVmaW5lZCA/IG5vZGUub1ggOiBtaW5YO1xuXHRcdG1heFggPSBtYXhYIDwgbm9kZS5vWCB8fCBtYXhYID09PSB1bmRlZmluZWQgPyBub2RlLm9YIDogbWF4WDtcblx0XHRtaW5ZID0gbWluWSA+IG5vZGUub1kgfHwgbWluWSA9PT0gdW5kZWZpbmVkID8gbm9kZS5vWSA6IG1pblk7XG5cdFx0bWF4WSA9IG1heFkgPCBub2RlLm9ZIHx8IG1heFkgPT09IHVuZGVmaW5lZCA/IG5vZGUub1kgOiBtYXhZO1xuXHR9XG5cdHJldHVybiBbW21pblgsIG1pblldLCBbbWF4WCwgbWF4WV1dO1xufTtcblxuLy9UT0RPIDogdG8gcmVtb3ZlXG5TVkplbGx5R3JvdXAucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbiAoJHBvaW50KVxue1xuXHR2YXIgY3VyclggPSAkcG9pbnRbMF07XG5cdHZhciBjdXJyWSA9ICRwb2ludFsxXTtcblx0dmFyIGJvdW5kaW5nID0gdGhpcy5nZXRCb3VuZGluZ0JveCgpO1xuXHRpZiAoY3VyclggPj0gYm91bmRpbmdbMF1bMF0gJiYgY3VyclggPD0gYm91bmRpbmdbMV1bMF0gJiZcblx0XHRjdXJyWSA+PSBib3VuZGluZ1swXVsxXSAmJiBjdXJyWSA8PSBib3VuZGluZ1sxXVsxXSlcblx0e1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuY3JlYXRlSm9pbnQgPSBmdW5jdGlvbiAoJG5vZGUxLCAkbm9kZTIpXG57XG5cdGZvciAodmFyIGkgPSAwLCBqb2ludHNMZW5ndGggPSB0aGlzLmpvaW50cy5sZW5ndGg7IGkgPCBqb2ludHNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJySm9pbnQgPSB0aGlzLmpvaW50c1tpXTtcblx0XHRpZiAoKGN1cnJKb2ludC5ub2RlMSA9PT0gJG5vZGUxICYmIGN1cnJKb2ludC5ub2RlMiA9PT0gJG5vZGUyKSB8fCAoY3VyckpvaW50Lm5vZGUyID09PSAkbm9kZTEgJiYgY3VyckpvaW50Lm5vZGUxID09PSAkbm9kZTIpKVxuXHRcdHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHR2YXIgam9pbnQgPSBuZXcgU1ZKZWxseUpvaW50KCRub2RlMSwgJG5vZGUyKTtcblxuXHR0aGlzLmpvaW50cy5wdXNoKGpvaW50KTtcblxuXHQvL3RoaXMucGh5c2ljc01hbmFnZXIuYWRkSm9pbnRUb1dvcmxkKGpvaW50KTtcbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuYWRkTm9kZXNUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0dGhpcy5waHlzaWNzTWFuYWdlci5hZGROb2Rlc1RvV29ybGQoKTtcbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuYWRkSm9pbnRzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdHRoaXMucGh5c2ljc01hbmFnZXIuYWRkSm9pbnRzVG9Xb3JsZCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkplbGx5R3JvdXA7XG5cbiIsInZhciBTVkplbGx5Sm9pbnQgPSBmdW5jdGlvbiAoJG5vZGUxLCAkbm9kZTIpXG57XG5cdHRoaXMubm9kZTEgPSAkbm9kZTE7XG5cdHRoaXMubm9kZTIgPSAkbm9kZTI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWSmVsbHlKb2ludDtcblxuIiwidmFyIFNWSmVsbHlOb2RlID0gZnVuY3Rpb24gKCRvWCwgJG9ZLCAkb3B0aW9ucylcbntcblx0dGhpcy5qb2ludHNBcnJheSA9IFtdO1xuXHR0aGlzLm9YID0gJG9YO1xuXHR0aGlzLm9ZID0gJG9ZO1xuXHR0aGlzLmRyYXdpbmcgPSB1bmRlZmluZWQ7XG5cdHRoaXMuZml4ZWQgPSBmYWxzZTtcblx0dGhpcy5pc1N0YXJ0ID0gZmFsc2U7XG5cdHRoaXMuZW5kTm9kZSA9IHVuZGVmaW5lZDtcblx0dGhpcy5zZXRPcHRpb25zKCRvcHRpb25zKTtcbn07XG5cbi8vcmFjY291cmNpXG5TVkplbGx5Tm9kZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgkb3B0aW9ucylcbntcblx0aWYgKCRvcHRpb25zKVxuXHR7XG5cdFx0Ly8gdmFyID0gJCA9PT0gdW5kZWZpbmVkID8ge30gOiAkb3B0aW9ucztcblx0XHRpZiAoJG9wdGlvbnMuZml4ZWQgIT09IHVuZGVmaW5lZCkgeyB0aGlzLmZpeGVkID0gJG9wdGlvbnMuZml4ZWQ7IH1cblx0fVxufTtcblxuU1ZKZWxseU5vZGUucHJvdG90eXBlLnNldEZpeGVkID0gZnVuY3Rpb24gKCRmaXhlZClcbntcblx0dGhpcy5maXhlZCA9ICRmaXhlZDtcblx0dGhpcy5waHlzaWNzTWFuYWdlci5zZXRGaXhlZCgkZml4ZWQpO1xufTtcblxuU1ZKZWxseU5vZGUucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5waHlzaWNzTWFuYWdlci5nZXRYKCk7XG59O1xuXG4vL3JhY2NvdXJjaVxuU1ZKZWxseU5vZGUucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5waHlzaWNzTWFuYWdlci5nZXRZKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWSmVsbHlOb2RlO1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0ZXh0ZW5kOiBmdW5jdGlvbiAoJHRvRXh0ZW5kLCAkZXh0ZW5zaW9uKVxuXHR7XG5cdFx0dmFyIHJlY3VyID0gZnVuY3Rpb24gKCRvYmplY3QsICRleHRlbmQpXG5cdFx0e1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiAkZXh0ZW5kKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodHlwZW9mICRleHRlbmRbbmFtZV0gPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KCRleHRlbmRbbmFtZV0pICYmICRleHRlbmRbbmFtZV0gIT09IG51bGwpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoJG9iamVjdFtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7ICRvYmplY3RbbmFtZV0gPSB7fTsgfVxuXHRcdFx0XHRcdHJlY3VyKCRvYmplY3RbbmFtZV0sICRleHRlbmRbbmFtZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdCRvYmplY3RbbmFtZV0gPSAkZXh0ZW5kW25hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZWN1cigkdG9FeHRlbmQsICRleHRlbnNpb24pO1xuXG5cdFx0cmV0dXJuICR0b0V4dGVuZDtcblx0fVxufTtcblxuIiwidmFyIFNWSmVsbHlHcm91cCA9IHJlcXVpcmUoJy4vU1ZKZWxseUdyb3VwJyk7XG52YXIgU3RydWN0dXJlID0gcmVxdWlyZSgnLi9TdHJ1Y3R1cmUnKTtcblxudmFyIFNWSmVsbHlXb3JsZCA9IGZ1bmN0aW9uICgkcGh5c2ljc01hbmFnZXIsICRjb25mKVxue1xuXHR0aGlzLnBoeXNpY3NNYW5hZ2VyID0gJHBoeXNpY3NNYW5hZ2VyO1xuXHR0aGlzLmdyb3VwcyA9IFtdO1xuXHR0aGlzLmNvbmYgPSAkY29uZjtcblx0dGhpcy53b3JsZE5vZGVzID0gW107XG5cdHRoaXMuZ3JvdXBDb25zdHJhaW50cyA9IFtdO1xuXHR0aGlzLndvcmxkV2lkdGggPSB0aGlzLnBoeXNpY3NNYW5hZ2VyLndvcmxkV2lkdGggPSAkY29uZi53b3JsZFdpZHRoO1xufTtcblxuU1ZKZWxseVdvcmxkLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoJGhlaWdodClcbntcblx0dGhpcy53b3JsZEhlaWdodCA9IHRoaXMucGh5c2ljc01hbmFnZXIud29ybGRIZWlnaHQgPSAkaGVpZ2h0O1xufTtcblxuU1ZKZWxseVdvcmxkLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLndvcmxkV2lkdGg7XG59O1xuXG5TVkplbGx5V29ybGQucHJvdG90eXBlLmdldEdyb3VwQnlJRCA9IGZ1bmN0aW9uICgkSUQpXG57XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmdyb3Vwcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyR3JvdXAgPSB0aGlzLmdyb3Vwc1tpXTtcblx0XHRpZiAoY3Vyckdyb3VwLklEID09PSAkSUQpIHsgcmV0dXJuIGN1cnJHcm91cDsgfVxuXHR9XG59O1xuXG5TVkplbGx5V29ybGQucHJvdG90eXBlLmNyZWF0ZUdyb3VwID0gZnVuY3Rpb24gKCR0eXBlLCAkSUQpXG57XG5cdHZhciBjb25mID0gdGhpcy5jb25mLmdyb3Vwc1skdHlwZV0gfHwgdGhpcy5jb25mLmdyb3Vwcy5kZWZhdWx0O1xuXHR2YXIgZ3JvdXAgPSBuZXcgU1ZKZWxseUdyb3VwKCR0eXBlLCBjb25mLCAkSUQpO1xuXHRncm91cC5waHlzaWNzTWFuYWdlciA9IHRoaXMucGh5c2ljc01hbmFnZXIuZ2V0R3JvdXBQaHlzaWNzTWFuYWdlcihncm91cCk7XG5cdGdyb3VwLnN0cnVjdHVyZSA9IG5ldyBTdHJ1Y3R1cmUoZ3JvdXAsIHRoaXMpO1xuXHR0aGlzLmdyb3Vwcy5wdXNoKGdyb3VwKTtcblx0cmV0dXJuIGdyb3VwO1xufTtcblxuU1ZKZWxseVdvcmxkLnByb3RvdHlwZS5jb25zdHJhaW5Hcm91cHMgPSBmdW5jdGlvbiAoJGdyb3VwQSwgJGdyb3VwQiwgJHBvaW50cylcbntcblx0dmFyIHBvaW50cyA9ICRwb2ludHM7XG5cdHZhciBncm91cEEgPSAkZ3JvdXBBO1xuXHR2YXIgZ3JvdXBCID0gJGdyb3VwQjtcblxuXHRpZiAocG9pbnRzLmxlbmd0aCA8IDMpXG5cdHtcblx0XHR2YXIgYW5jaG9yQSA9IGdyb3VwQS5waHlzaWNzTWFuYWdlci5jcmVhdGVBbmNob3JGcm9tTGluZShwb2ludHMpO1xuXHRcdHBvaW50cy5zcGxpY2UocG9pbnRzLmluZGV4T2YoYW5jaG9yQS5wb2ludCksIDEpO1xuXHRcdHZhciBhbmNob3JCID0gZ3JvdXBCID8gZ3JvdXBCLnBoeXNpY3NNYW5hZ2VyLmNyZWF0ZUFuY2hvckZyb21Qb2ludChwb2ludHNbMF0pIDogdGhpcy5waHlzaWNzTWFuYWdlci5jcmVhdGVHaG9zdEFuY2hvckZyb21Qb2ludChwb2ludHNbMF0pO1xuXHRcdHRoaXMuZ3JvdXBDb25zdHJhaW50cy5wdXNoKHsgYW5jaG9yQTogYW5jaG9yQSwgYW5jaG9yQjogYW5jaG9yQiB9KTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHR2YXIgYW5jaG9yc0EgPSBncm91cEEucGh5c2ljc01hbmFnZXIuY3JlYXRlQW5jaG9ycyhwb2ludHMpO1xuXHRcdC8vY29uc29sZS5sb2coJ0EnLCBncm91cEEuSUQsIGFuY2hvcnNBLmxlbmd0aCwgJ0InLCBncm91cEIgPyBncm91cEIuSUQgOiBncm91cEIpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBub2Rlc0xlbmd0aCA9IGFuY2hvcnNBLmxlbmd0aDsgaSA8IG5vZGVzTGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJBbmNob3JBID0gYW5jaG9yc0FbaV07XG5cdFx0XHRpZiAoIWdyb3VwQilcblx0XHRcdHtcblx0XHRcdFx0Y3VyckFuY2hvckEuc2V0Rml4ZWQodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBhbmNob3JzQiA9IGdyb3VwQi5waHlzaWNzTWFuYWdlci5jcmVhdGVBbmNob3JzKHBvaW50cyk7XG5cdFx0XHRcdGZvciAodmFyIGsgPSAwLCBhbmNob3JzQkxlbmd0aCA9IGFuY2hvcnNCLmxlbmd0aDsgayA8IGFuY2hvcnNCTGVuZ3RoOyBrICs9IDEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgY3VyckFuY2hvckIgPSBhbmNob3JzQltrXTtcblx0XHRcdFx0XHR0aGlzLmdyb3VwQ29uc3RyYWludHMucHVzaCh7IGFuY2hvckE6IGN1cnJBbmNob3JBLCBhbmNob3JCOiBjdXJyQW5jaG9yQiB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuU1ZKZWxseVdvcmxkLnByb3RvdHlwZS5hZGRHcm91cHNUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0Zm9yICh2YXIgaSA9IDAsIGdyb3Vwc0xlbmd0aCA9IHRoaXMuZ3JvdXBzLmxlbmd0aDsgaSA8IGdyb3Vwc0xlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJHcm91cCA9IHRoaXMuZ3JvdXBzW2ldO1xuXHRcdGN1cnJHcm91cC5hZGROb2Rlc1RvV29ybGQoKTtcblx0XHRjdXJyR3JvdXAuYWRkSm9pbnRzVG9Xb3JsZCgpO1xuXHRcdHRoaXMud29ybGROb2RlcyA9IHRoaXMud29ybGROb2Rlcy5jb25jYXQoY3Vyckdyb3VwLm5vZGVzKTtcblx0fVxuXG5cdHZhciB0b0NvbnN0cmFpbkxlbmd0aCA9IHRoaXMuZ3JvdXBDb25zdHJhaW50cy5sZW5ndGg7XG5cdGZvciAoaSA9IDA7IGkgPCB0b0NvbnN0cmFpbkxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJUb0NvbnN0cmFpbiA9IHRoaXMuZ3JvdXBDb25zdHJhaW50c1tpXTtcblx0XHR0aGlzLnBoeXNpY3NNYW5hZ2VyLmNvbnN0cmFpbkdyb3VwcyhjdXJyVG9Db25zdHJhaW4uYW5jaG9yQSwgY3VyclRvQ29uc3RyYWluLmFuY2hvckIpO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWSmVsbHlXb3JsZDtcblxuIiwidmFyIFRyaWFuZ3VsYXRvciA9IHJlcXVpcmUoJy4vVHJpYW5ndWxhdG9yJyk7XG52YXIgUG9seWdvbiA9IHJlcXVpcmUoJy4vUG9seWdvbicpO1xudmFyIEdyaWQgPSByZXF1aXJlKCcuL0dyaWQnKTtcbnZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4vQ29tbWFuZHMnKTtcblxudmFyIFN0cnVjdHVyZSA9IGZ1bmN0aW9uICgkZ3JvdXAsICR3b3JsZClcbntcblx0dGhpcy53b3JsZCA9ICR3b3JsZDtcblx0dGhpcy5ncm91cCA9ICRncm91cDtcblx0dGhpcy5pbm5lclN0cnVjdHVyZSA9IHVuZGVmaW5lZDtcbn07XG5cblN0cnVjdHVyZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCRkcmF3aW5nQ29tbWFuZHMpXG57XG5cdHZhciBub2Rlc1RvRHJhdztcblxuXHR0aGlzLnBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCRkcmF3aW5nQ29tbWFuZHMpO1xuXHR0aGlzLmRyYXdpbmdDb21tYW5kcyA9ICRkcmF3aW5nQ29tbWFuZHM7XG5cblx0Ly8gY29uc29sZS5sb2coJ3BvaW50cycsIHBvaW50cy5sZW5ndGgsIHRoaXMuZ3JvdXAuY29uZi5zdHJ1Y3R1cmUpO1xuXG5cdHRoaXMuYXJlYSA9IHRoaXMuY2FsY3VsYXRlQXJlYSh0aGlzLnBvaW50cywgJGRyYXdpbmdDb21tYW5kcyk7XG5cdHRoaXMucmFkaXVzWCA9ICRkcmF3aW5nQ29tbWFuZHMucmFkaXVzWDtcblx0dGhpcy5yYWRpdXNZID0gJGRyYXdpbmdDb21tYW5kcy5yYWRpdXNZO1xuXG5cdHN3aXRjaCAodGhpcy5ncm91cC5jb25mLnN0cnVjdHVyZSlcblx0e1xuXHRcdGNhc2UgJ3RyaWFuZ3VsYXRlJzpcblx0XHRcdHRoaXMucmVtb3ZlRHVwbGljYXRlcyh0aGlzLmRyYXdpbmdDb21tYW5kcyk7XG5cdFx0XHR2YXIgdHJpUG9pbnRzID0gdGhpcy5nZXRQb2ludHModGhpcy5kcmF3aW5nQ29tbWFuZHMpO1xuXHRcdFx0bm9kZXNUb0RyYXcgPSB0aGlzLmNyZWF0ZU5vZGVzRnJvbVBvaW50cyh0cmlQb2ludHMpO1xuXHRcdFx0dGhpcy5zZXROb2RlRHJhd2luZ0NvbW1hbmRzKG5vZGVzVG9EcmF3KTtcblx0XHRcdHRoaXMuY3JlYXRlSm9pbnRzRnJvbVRyaWFuZ2xlcyh0cmlQb2ludHMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbGluZSc6XG5cdFx0XHRub2Rlc1RvRHJhdyA9IHRoaXMuY3JlYXRlTm9kZXNGcm9tUG9pbnRzKHRoaXMucG9pbnRzKTtcblx0XHRcdHRoaXMuc2V0Tm9kZURyYXdpbmdDb21tYW5kcyhub2Rlc1RvRHJhdyk7XG5cdFx0XHR0aGlzLmNyZWF0ZUpvaW50c0Zyb21Qb2ludHModGhpcy5wb2ludHMsIHRydWUpO1xuXHRcdFx0Ly9ub2Rlc1RvRHJhd1swXS5maXhlZCA9IHRydWU7Ly90byByZW1vdmUgbGF0ZXIgbWF5YmUgP1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAncHJlY2lzZUhleGFGaWxsJzpcblx0XHRcdG5vZGVzVG9EcmF3ID0gdGhpcy5jcmVhdGVQcmVjaXNlSGV4YUZpbGxTdHJ1Y3R1cmUodGhpcy5wb2ludHMpO1xuXHRcdFx0Ly8gc3RydWN0dXJlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoJGVsZW1lbnQpIHsgJGVsZW1lbnQuZHJhd2luZyA9IHsgbm90VG9EcmF3OiB0cnVlIH07IH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnaGV4YUZpbGwnOlxuXHRcdFx0bm9kZXNUb0RyYXcgPSB0aGlzLmNyZWF0ZUhleGFGaWxsU3RydWN0dXJlKHRoaXMucG9pbnRzKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRub2Rlc1RvRHJhdyA9IHRoaXMuY3JlYXRlTm9kZXNGcm9tUG9pbnRzKHRoaXMucG9pbnRzKTtcblx0XHRcdHRoaXMuc2V0Tm9kZURyYXdpbmdDb21tYW5kcyhub2Rlc1RvRHJhdyk7XG5cdFx0XHRicmVhaztcblx0fVxuXG5cdHJldHVybiBub2Rlc1RvRHJhdztcbn07XG5cblN0cnVjdHVyZS5wcm90b3R5cGUuY2FsY3VsYXRlQXJlYSA9IGZ1bmN0aW9uICgkcG9pbnRzLCAkZHJhd2luZ0NvbW1hbmRzKVxue1xuXHRpZiAoJGRyYXdpbmdDb21tYW5kcy50eXBlID09PSAnZWxsaXBzZScpXG5cdHtcblx0XHRyZXR1cm4gTWF0aC5wb3coTWF0aC5QSSAqICRkcmF3aW5nQ29tbWFuZHMucmFkaXVzWCwgMik7XG5cdH1cblx0aWYgKHRoaXMuZ3JvdXAuY29uZi5zdHJ1Y3R1cmUgIT09ICdsaW5lJylcblx0e1xuXHRcdHZhciBwb2x5Z29uID0gUG9seWdvbi5pbml0KCRwb2ludHMpO1xuXHRcdHJldHVybiBwb2x5Z29uLmdldEFyZWEoKTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHR2YXIgYXJlYSA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9ICRwb2ludHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJQb2ludCA9ICRwb2ludHNbaV07XG5cdFx0XHR2YXIgbGFzdFBvaW50ID0gJHBvaW50c1tpIC0gMV07XG5cdFx0XHR2YXIgZFggPSBNYXRoLmFicyhjdXJyUG9pbnRbMF0gLSBsYXN0UG9pbnRbMF0pO1xuXHRcdFx0dmFyIGRZID0gTWF0aC5hYnMoY3VyclBvaW50WzFdIC0gbGFzdFBvaW50WzFdKTtcblx0XHRcdGFyZWEgKz0gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcblx0XHR9XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH1cbn07XG5cblN0cnVjdHVyZS5wcm90b3R5cGUuY3JlYXRlSGV4YUZpbGxTdHJ1Y3R1cmUgPSBmdW5jdGlvbiAoJHBvaW50cylcbntcblx0dGhpcy5jcmVhdGVJbm5lclN0cnVjdHVyZSgkcG9pbnRzKTtcblx0dmFyIHBhdGggPSB0aGlzLmlubmVyU3RydWN0dXJlLmdldFNoYXBlUGF0aCgpO1xuXHR2YXIgbm9kZXNUb0RyYXcgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHBhdGgubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IHRoaXMuZ3JvdXAuZ2V0Tm9kZUF0UG9pbnQocGF0aFtpXVswXSwgcGF0aFtpXVsxXSk7XG5cdFx0bm9kZXNUb0RyYXcucHVzaChub2RlKTtcblx0XHRub2RlLmRyYXdpbmcgPSB7fTtcblx0XHRub2RlLmRyYXdpbmcuY29tbWFuZCA9IGkgPT09IDAgPyBDb21tYW5kcy5NT1ZFX1RPIDogQ29tbWFuZHMuTElORV9UTztcblx0XHRub2RlLmRyYXdpbmcucG9pbnQgPSBbcGF0aFtpXVswXSwgcGF0aFtpXVsxXV07XG5cdFx0bm9kZS5kcmF3aW5nLm9wdGlvbnMgPSBbXTtcblx0fVxuXHRyZXR1cm4gbm9kZXNUb0RyYXc7XG59O1xuXG5TdHJ1Y3R1cmUucHJvdG90eXBlLnNldE5vZGVEcmF3aW5nQ29tbWFuZHMgPSBmdW5jdGlvbiAoJG5vZGVzKVxue1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gJG5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIG5vZGUgPSAkbm9kZXNbaV07XG5cdFx0bm9kZS5kcmF3aW5nID0gdGhpcy5kcmF3aW5nQ29tbWFuZHMucG9pbnRDb21tYW5kc1tpXTtcblx0fVxufTtcblxuU3RydWN0dXJlLnByb3RvdHlwZS5jcmVhdGVQcmVjaXNlSGV4YUZpbGxTdHJ1Y3R1cmUgPSBmdW5jdGlvbiAoJHBvaW50cylcbntcblx0dmFyIG5vZGVzVG9EcmF3ID0gdGhpcy5jcmVhdGVOb2Rlc0Zyb21Qb2ludHMoJHBvaW50cyk7XG5cdHRoaXMuc2V0Tm9kZURyYXdpbmdDb21tYW5kcyhub2Rlc1RvRHJhdyk7XG5cdHRoaXMuY3JlYXRlSW5uZXJTdHJ1Y3R1cmUoJHBvaW50cyk7XG5cblx0dGhpcy5jcmVhdGVKb2ludHNGcm9tUG9pbnRzKCRwb2ludHMsIGZhbHNlKTtcblx0dmFyIGkgPSAwO1xuXHR2YXIgbGVuZ3RoID0gJHBvaW50cy5sZW5ndGg7XG5cdGZvciAoaTsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJQb2ludCA9ICRwb2ludHNbaV07XG5cdFx0dmFyIGNsb3Nlc3QgPSB0aGlzLmlubmVyU3RydWN0dXJlLmdldENsb3Nlc3QoY3VyclBvaW50WzBdLCBjdXJyUG9pbnRbMV0sIDIpO1xuXHRcdGZvciAodmFyIGsgPSAwLCBjbG9zZXN0TGVuZ3RoID0gY2xvc2VzdC5sZW5ndGg7IGsgPCBjbG9zZXN0TGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJDbG9zZXN0ID0gY2xvc2VzdFtrXTtcblx0XHRcdHZhciBuMSA9IHRoaXMuZ3JvdXAuZ2V0Tm9kZUF0UG9pbnQoY3VyclBvaW50WzBdLCBjdXJyUG9pbnRbMV0pO1xuXHRcdFx0dmFyIG4yID0gdGhpcy5ncm91cC5nZXROb2RlQXRQb2ludChjdXJyQ2xvc2VzdFswXSwgY3VyckNsb3Nlc3RbMV0pO1xuXHRcdFx0dGhpcy5ncm91cC5jcmVhdGVKb2ludChuMSwgbjIpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbm9kZXNUb0RyYXc7XG59O1xuXG5TdHJ1Y3R1cmUucHJvdG90eXBlLmNyZWF0ZUpvaW50c0Zyb21UcmlhbmdsZXMgPSBmdW5jdGlvbiAoJHBvaW50cylcbntcblx0dmFyIHRyaWFuZ3VsYXRvciA9IG5ldyBUcmlhbmd1bGF0b3IoKTtcblx0dmFyIHRyaWFuZ2xlcyA9IHRyaWFuZ3VsYXRvci50cmlhbmd1bGF0ZSgkcG9pbnRzKTtcblxuXHR2YXIgdHJpYW5nbGVzTGVuZ3RoID0gdHJpYW5nbGVzLmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0cmlhbmdsZXNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyVHJpYW5nbGUgPSB0cmlhbmdsZXNbaV07XG5cdFx0dmFyIG4wID0gdGhpcy5ncm91cC5nZXROb2RlQXRQb2ludChjdXJyVHJpYW5nbGVbMF0ueCwgY3VyclRyaWFuZ2xlWzBdLnkpO1xuXHRcdHZhciBuMSA9IHRoaXMuZ3JvdXAuZ2V0Tm9kZUF0UG9pbnQoY3VyclRyaWFuZ2xlWzFdLngsIGN1cnJUcmlhbmdsZVsxXS55KTtcblx0XHR2YXIgbjIgPSB0aGlzLmdyb3VwLmdldE5vZGVBdFBvaW50KGN1cnJUcmlhbmdsZVsyXS54LCBjdXJyVHJpYW5nbGVbMl0ueSk7XG5cdFx0dGhpcy5ncm91cC5jcmVhdGVKb2ludChuMCwgbjEpO1xuXHRcdHRoaXMuZ3JvdXAuY3JlYXRlSm9pbnQobjEsIG4yKTtcblx0XHR0aGlzLmdyb3VwLmNyZWF0ZUpvaW50KG4yLCBuMCk7XG5cdH1cbn07XG5cblN0cnVjdHVyZS5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gKCRkcmF3aW5nQ29tbWFuZHMpXG57XG5cdHZhciBwb2ludHMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICRkcmF3aW5nQ29tbWFuZHMucG9pbnRDb21tYW5kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyID0gJGRyYXdpbmdDb21tYW5kcy5wb2ludENvbW1hbmRzW2ldO1xuXHRcdHBvaW50cy5wdXNoKGN1cnIucG9pbnQpO1xuXHR9XG5cdHJldHVybiBwb2ludHM7XG59O1xuXG5TdHJ1Y3R1cmUucHJvdG90eXBlLmNyZWF0ZU5vZGVzRnJvbVBvaW50cyA9IGZ1bmN0aW9uICgkcG9pbnRzKVxue1xuXHR2YXIgcG9pbnRzTGVuZ3RoID0gJHBvaW50cy5sZW5ndGg7XG5cdHZhciB0b1JldHVybiA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50c0xlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJQb2ludCA9ICRwb2ludHNbaV07XG5cdFx0dmFyIG5vZGUgPSB0aGlzLmdyb3VwLmNyZWF0ZU5vZGUoY3VyclBvaW50WzBdLCBjdXJyUG9pbnRbMV0sIHVuZGVmaW5lZCwgZmFsc2UpO1xuXHRcdHRvUmV0dXJuLnB1c2gobm9kZSk7XG5cdH1cblx0cmV0dXJuIHRvUmV0dXJuO1xufTtcblxuU3RydWN0dXJlLnByb3RvdHlwZS5yZW1vdmVEdXBsaWNhdGVzID0gZnVuY3Rpb24gKCRkcmF3aW5nQ29tbWFuZHMpXG57XG5cdHZhciB2aXNpdGVkUG9pbnRzID0gW107XG5cdHZhciBjb21tYW5kcyA9ICRkcmF3aW5nQ29tbWFuZHMucG9pbnRDb21tYW5kcztcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBwb2ludCA9IGNvbW1hbmRzW2ldLnBvaW50O1xuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgdmlzaXRlZFBvaW50cy5sZW5ndGg7IGsgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgdmlzaXRlZCA9IHZpc2l0ZWRQb2ludHNba107XG5cdFx0XHRpZiAodmlzaXRlZFswXSA9PT0gcG9pbnRbMF0gJiYgdmlzaXRlZFsxXSA9PT0gcG9pbnRbMV0pXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGksICdkdXBsaWNhdGUgZm91bmQgIScsIHZpc2l0ZWRbMF0sIHZpc2l0ZWRbMV0sIHBvaW50WzBdLCBwb2ludFsxXSk7XG5cdFx0XHRcdGNvbW1hbmRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0aSA9IGkgLSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2aXNpdGVkUG9pbnRzLnB1c2gocG9pbnQpO1xuXHR9XG59O1xuXG5TdHJ1Y3R1cmUucHJvdG90eXBlLmNyZWF0ZUlubmVyU3RydWN0dXJlID0gZnVuY3Rpb24gKCRwb2ludHMpXG57XG5cdHZhciBwb2x5Z29uID0gUG9seWdvbi5pbml0KCRwb2ludHMpO1xuXHR2YXIgZGlhbSA9IHRoaXMud29ybGQuZ2V0V2lkdGgoKSAqIHRoaXMuZ3JvdXAuY29uZi5pbm5lclN0cnVjdHVyZURlZjsvL3dpZHRoIC8gMTA7Ly90aGlzLndvcmxkLmdldFdpZHRoKCkgLyAzMDtcblx0dGhpcy5pbm5lclJhZGl1cyA9IHRoaXMuZ3JvdXAuY29uZi5ub2RlUmFkaXVzIHx8IGRpYW0gLyAyO1xuXHR0aGlzLmlubmVyU3RydWN0dXJlID0gR3JpZC5jcmVhdGVGcm9tUG9seWdvbihwb2x5Z29uLCBkaWFtLCB0cnVlKTtcblx0dGhpcy5zdHJ1Y3R1cmVOb2RlcyA9IHRoaXMuY3JlYXRlTm9kZXNGcm9tUG9pbnRzKHRoaXMuaW5uZXJTdHJ1Y3R1cmUuZ2V0Tm9kZXNBcnJheSgpKTtcblxuXHR2YXIgbmV0d29yayA9IHRoaXMuaW5uZXJTdHJ1Y3R1cmUuZ2V0TmV0d29yaygpO1xuXHR2YXIgaSA9IDA7XG5cdHZhciBsZW5ndGggPSBuZXR3b3JrLmxlbmd0aDtcblx0Zm9yIChpOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyckxpbmsgPSBuZXR3b3JrW2ldO1xuXHRcdHZhciBuMSA9IHRoaXMuZ3JvdXAuZ2V0Tm9kZUF0UG9pbnQoY3VyckxpbmtbMF1bMF0sIGN1cnJMaW5rWzBdWzFdKTtcblx0XHR2YXIgbjIgPSB0aGlzLmdyb3VwLmdldE5vZGVBdFBvaW50KGN1cnJMaW5rWzFdWzBdLCBjdXJyTGlua1sxXVsxXSk7XG5cdFx0dGhpcy5ncm91cC5jcmVhdGVKb2ludChuMSwgbjIpO1xuXHR9XG5cdHJldHVybiB0aGlzLnN0cnVjdHVyZU5vZGVzO1xufTtcblxuU3RydWN0dXJlLnByb3RvdHlwZS5jcmVhdGVKb2ludHNGcm9tUG9pbnRzID0gZnVuY3Rpb24gKCRwb2ludHMsICRub0Nsb3NlKVxue1xuXHR2YXIgcG9pbnRzTGVuZ3RoID0gJHBvaW50cy5sZW5ndGg7XG5cdGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyclBvaW50ID0gJHBvaW50c1tpXTtcblx0XHR2YXIgbGFzdFBvaW50ID0gJHBvaW50c1tpIC0gMV07XG5cdFx0dmFyIGxhc3ROb2RlID0gdGhpcy5ncm91cC5nZXROb2RlQXRQb2ludChsYXN0UG9pbnRbMF0sIGxhc3RQb2ludFsxXSk7XG5cdFx0dmFyIGN1cnJOb2RlID0gdGhpcy5ncm91cC5nZXROb2RlQXRQb2ludChjdXJyUG9pbnRbMF0sIGN1cnJQb2ludFsxXSk7XG5cdFx0dGhpcy5ncm91cC5jcmVhdGVKb2ludChsYXN0Tm9kZSwgY3Vyck5vZGUpO1xuXHRcdGlmIChpID09PSBwb2ludHNMZW5ndGggLSAxICYmICRub0Nsb3NlICE9PSB0cnVlKVxuXHRcdHtcblx0XHRcdHZhciBmaXJzdE5vZGUgPSB0aGlzLmdyb3VwLmdldE5vZGVBdFBvaW50KCRwb2ludHNbMF1bMF0sICRwb2ludHNbMF1bMV0pO1xuXHRcdFx0dGhpcy5ncm91cC5jcmVhdGVKb2ludChjdXJyTm9kZSwgZmlyc3ROb2RlKTtcblx0XHR9XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RydWN0dXJlO1xuXG4iLCJ2YXIgcG9seTJ0cmkgPSByZXF1aXJlKCcuLi8uLi9saWJzL3BvbHkydHJpL2Rpc3QvcG9seTJ0cmknKTtcblxudmFyIFRyaWFuZ3VsYXRvciA9IGZ1bmN0aW9uICgpXG57XG59O1xuXG5Ucmlhbmd1bGF0b3IucHJvdG90eXBlLnRyaWFuZ3VsYXRlID0gZnVuY3Rpb24gKCRjb29yZHMpXG57XG5cdHZhciBwb2x5MnRyaUNvbnRvdXIgPSBbXTtcblx0Ly9kZWJ1Z2dlcjtcblxuXHRmb3IgKHZhciBpID0gMCwgcG9pbnRzTGVuZ3RoID0gJGNvb3Jkcy5sZW5ndGg7IGkgPCBwb2ludHNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBwb2ludCA9ICRjb29yZHNbaV07XG5cdFx0cG9seTJ0cmlDb250b3VyLnB1c2gobmV3IHBvbHkydHJpLlBvaW50KHBvaW50WzBdLCBwb2ludFsxXSkpO1xuXHR9XG5cblx0dmFyIHN3Y3R4O1xuXHR0cnlcblx0e1xuXHRcdC8vIHByZXBhcmUgU3dlZXBDb250ZXh0XG5cdFx0c3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KHBvbHkydHJpQ29udG91ciwgeyBjbG9uZUFycmF5czogdHJ1ZSB9KTtcblxuXHRcdC8vIHRyaWFuZ3VsYXRlXG5cdFx0c3djdHgudHJpYW5ndWxhdGUoKTtcblx0fVxuXHRjYXRjaCAoZSlcblx0e1xuXHRcdHRocm93IGU7XG5cdFx0Ly8gY29uc29sZS5sb2coZSk7XG5cdFx0Ly8gY29uc29sZS5sb2coZS5wb2ludHMpO1xuXHR9XG5cdHZhciB0cmlhbmdsZXMgPSBzd2N0eC5nZXRUcmlhbmdsZXMoKTtcblxuXHR2YXIgcG9pbnRzQXJyYXkgPSBbXTtcblxuXHR2YXIgdHJpYW5nbGVzTGVuZ3RoID0gdHJpYW5nbGVzLmxlbmd0aDtcblx0Zm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlc0xlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJUcmlhbmdsZSA9IHRyaWFuZ2xlc1tpXTtcblx0XHQvKmpzaGludCBjYW1lbGNhc2U6ZmFsc2UqL1xuXHRcdC8vanNjczpkaXNhYmxlIGRpc2FsbG93RGFuZ2xpbmdVbmRlcnNjb3Jlc1xuXHRcdHBvaW50c0FycmF5LnB1c2goY3VyclRyaWFuZ2xlLnBvaW50c18pO1xuXHRcdC8vanNjczplbmFibGUgZGlzYWxsb3dEYW5nbGluZ1VuZGVyc2NvcmVzXG5cdFx0Lypqc2hpbnQgY2FtZWxjYXNlOnRydWUqL1xuXHR9XG5cblx0cmV0dXJuIHBvaW50c0FycmF5O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmlhbmd1bGF0b3I7XG5cbiIsInZhciBBbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJHAyLCAkcDJXb3JsZCwgJHdvcmxkSGVpZ2h0KVxue1xuXHR0aGlzLnAyID0gJHAyO1xuXHR0aGlzLnAyV29ybGQgPSAkcDJXb3JsZDtcblx0dGhpcy5vZmZzZXQgPSBbMCwgMF07XG5cdHRoaXMud29ybGRIZWlnaHQgPSAkd29ybGRIZWlnaHQ7XG59O1xuXG5BbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldEZyb21Qb2ludCA9IGZ1bmN0aW9uICgkcG9pbnQpXG57XG5cdHRoaXMucG9pbnQgPSAkcG9pbnQ7XG59O1xuXG5BbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbiAoKVxue1xuXHR0aGlzLmJvZHkgPSBuZXcgdGhpcy5wMi5Cb2R5KHtcblx0XHRwb3NpdGlvbjogW3RoaXMucG9pbnRbMF0sIHRoaXMud29ybGRIZWlnaHQgLSB0aGlzLnBvaW50WzFdXVxuXHR9KTtcblx0dGhpcy5wMldvcmxkLmFkZEJvZHkodGhpcy5ib2R5KTtcbn07XG5cbkFuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmJvZHkucG9zaXRpb25bMF07XG59O1xuXG5BbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy53b3JsZEhlaWdodCAtIHRoaXMuYm9keS5wb3NpdGlvblsxXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyO1xuIiwidmFyIEFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKCRncm91cCkgeyB0aGlzLmdyb3VwID0gJGdyb3VwOyB9O1xuXG5BbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuc2V0RnJvbVBvaW50ID0gZnVuY3Rpb24gKCRwb2ludClcbntcblx0dGhpcy5wb2ludCA9ICRwb2ludDtcbn07XG5cbkFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hZGRUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0dGhpcy5ib2R5ID0gdGhpcy5ncm91cC5waHlzaWNzTWFuYWdlci5ib2R5O1xuXHR0aGlzLndvcmxkSGVpZ2h0ID0gdGhpcy5ncm91cC5waHlzaWNzTWFuYWdlci53b3JsZEhlaWdodDtcblx0dGhpcy5vZmZzZXQgPSBbdGhpcy5wb2ludFswXSAtIHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXSwgKHRoaXMud29ybGRIZWlnaHQgLSB0aGlzLnBvaW50WzFdKSAtIHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblsxXV07XG5cdHZhciBkWCA9IHRoaXMub2Zmc2V0WzBdO1xuXHR2YXIgZFkgPSB0aGlzLm9mZnNldFsxXTtcblx0dGhpcy5hbmdsZSA9IE1hdGguYXRhbjIoZFksIGRYKTtcblx0dGhpcy5oeXAgPSBNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpO1xufTtcblxuQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldEZpeGVkID0gZnVuY3Rpb24gKCRmaXhlZClcbntcblx0dGhpcy5ncm91cC5maXhlZCA9ICRmaXhlZDtcbn07XG5cbkFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXSArIHRoaXMuaHlwICogTWF0aC5jb3ModGhpcy5ib2R5LmFuZ2xlICsgdGhpcy5hbmdsZSk7XG59O1xuXG5BbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLndvcmxkSGVpZ2h0IC0gKHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblsxXSArIHRoaXMuaHlwICogTWF0aC5zaW4odGhpcy5ib2R5LmFuZ2xlICsgdGhpcy5hbmdsZSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlcjtcbiIsInZhciBBbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkZ3JvdXApIHsgdGhpcy5ncm91cCA9ICRncm91cDsgfTtcblxuQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldEZyb21Qb2ludCA9IGZ1bmN0aW9uICgkcG9pbnQpXG57XG5cdHRoaXMucG9pbnQgPSAkcG9pbnQ7XG5cdHRoaXMubm9kZSA9IHRoaXMuZ3JvdXAuZ2V0Q2xvc2VzdE5vZGUoJHBvaW50KTtcblx0dGhpcy53b3JsZEhlaWdodCA9IHRoaXMuZ3JvdXAucGh5c2ljc01hbmFnZXIud29ybGRIZWlnaHQ7XG5cdHRoaXMub2Zmc2V0ID0gWzAsIDBdO1xufTtcblxuQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbiAoKVxue1xuXHR0aGlzLmJvZHkgPSB0aGlzLm5vZGUucGh5c2ljc01hbmFnZXIuYm9keTtcbn07XG5cbkFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zZXRGaXhlZCA9IGZ1bmN0aW9uICgkZml4ZWQpXG57XG5cdHRoaXMubm9kZS5maXhlZCA9ICRmaXhlZDtcbn07XG5cbkFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXTtcbn07XG5cbkFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMud29ybGRIZWlnaHQgLSB0aGlzLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyO1xuIiwidmFyIEdyb3VwR2hvc3RQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkZ3JvdXApXG57XG5cdHRoaXMuZ3JvdXAgPSAkZ3JvdXA7XG59O1xuXG5Hcm91cEdob3N0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZEpvaW50c1RvV29ybGQgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gbnVsbDtcbn07XG5cbkdyb3VwR2hvc3RQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkTm9kZXNUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0dmFyIGdldFggPSBmdW5jdGlvbiAoJG5vZGVPWCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gJG5vZGVPWDsgfTsgfTtcblx0dmFyIGdldFkgPSBmdW5jdGlvbiAoJG5vZGVPWSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gJG5vZGVPWTsgfTsgfTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IHRoaXMuZ3JvdXAubm9kZXNbaV07XG5cdFx0dmFyIG1hbmFnZXIgPSB7fTtcblx0XHRtYW5hZ2VyLmdldFggPSBnZXRYKG5vZGUub1gpO1xuXHRcdG1hbmFnZXIuZ2V0WSA9IGdldFkobm9kZS5vWSk7XG5cdFx0bm9kZS5waHlzaWNzTWFuYWdlciA9IG1hbmFnZXI7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyO1xuXG4iLCIvLyBqc2NzOmRpc2FibGUgcmVxdWlyZUNhbWVsQ2FzZU9yVXBwZXJDYXNlSWRlbnRpZmllcnNcbi8qanNoaW50IGNhbWVsY2FzZTpmYWxzZSovXG5cbnZhciBwMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYnMvcDInKTtcbnZhciBOb2RlUDJIYXJkUGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL05vZGVQMkhhcmRQaHlzaWNzTWFuYWdlcicpO1xudmFyIEFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi9BbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlcicpO1xuXG52YXIgR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkUDJXb3JsZCwgJHdvcmxkSGVpZ2h0LCAkZ3JvdXAsICRjb25mKVxue1xuXHR0aGlzLmdyb3VwID0gJGdyb3VwO1xuXHR0aGlzLndvcmxkSGVpZ2h0ID0gJHdvcmxkSGVpZ2h0O1xuXHR0aGlzLlAyV29ybGQgPSAkUDJXb3JsZDtcblx0dGhpcy5jb25mID0gJGNvbmY7XG59O1xuXG5Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmNob3JGcm9tUG9pbnQgPSBmdW5jdGlvbiAoJHBvaW50KVxue1xuXHR2YXIgYW5jaG9yID0gbmV3IEFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyKHRoaXMuZ3JvdXApO1xuXHRhbmNob3Iuc2V0RnJvbVBvaW50KCRwb2ludCk7XG5cdHJldHVybiBhbmNob3I7XG59O1xuXG5Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmNob3JGcm9tTGluZSA9IGZ1bmN0aW9uICgkbGluZVBvaW50cylcbntcblx0dmFyIGNsb3Nlc3RQb2ludCA9IHRoaXMuZ3JvdXAuZ2V0Q2xvc2VzdFBvaW50KCRsaW5lUG9pbnRzKTtcblx0dmFyIGFuY2hvciA9IG5ldyBBbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlcih0aGlzLmdyb3VwKTtcblx0YW5jaG9yLnNldEZyb21Qb2ludChjbG9zZXN0UG9pbnQpO1xuXHRyZXR1cm4gYW5jaG9yO1xufTtcblxuR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlQW5jaG9ycyA9IGZ1bmN0aW9uICgkcG9pbnRzKVxue1xuXHR2YXIgdG9SZXR1cm4gPSBbXTtcblx0dmFyIG5vZGVzID0gdGhpcy5ncm91cC5nZXROb2Rlc0luc2lkZSgkcG9pbnRzKTtcblx0aWYgKCFub2Rlcy5sZW5ndGgpXG5cdHtcblx0XHR2YXIgZGVmYXVsdEFuY2hvciA9IG5ldyBBbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlcih0aGlzLmdyb3VwKTtcblx0XHR2YXIgY2xvc2VzdCA9IHRoaXMuZ3JvdXAuZ2V0Q2xvc2VzdFBvaW50KCRwb2ludHMpO1xuXHRcdGRlZmF1bHRBbmNob3Iuc2V0RnJvbVBvaW50KGNsb3Nlc3QpO1xuXHRcdHJldHVybiBbZGVmYXVsdEFuY2hvcl07XG5cdH1cblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIG5vZGUgPSBub2Rlc1tpXTtcblx0XHR2YXIgY3VyckFuY2hvckEgPSBuZXcgQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIodGhpcy5ncm91cCk7XG5cdFx0Y3VyckFuY2hvckEuc2V0RnJvbVBvaW50KFtub2RlLm9YLCBub2RlLm9ZXSk7XG5cdFx0dG9SZXR1cm4ucHVzaChjdXJyQW5jaG9yQSk7XG5cdH1cblx0cmV0dXJuIHRvUmV0dXJuO1xufTtcblxuR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkSm9pbnRzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xuXG5Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hZGROb2Rlc1RvV29ybGQgPSBmdW5jdGlvbiAoKVxue1xuXHR2YXIgcGF0aCA9IFtdO1xuXHR2YXIgYm91bmRpbmdCb3ggPSB0aGlzLmdyb3VwLmdldEJvdW5kaW5nQm94KCk7XG5cdHZhciB3aWR0aCA9IGJvdW5kaW5nQm94WzFdWzBdIC0gYm91bmRpbmdCb3hbMF1bMF07XG5cdHZhciBoZWlnaHQgPSBib3VuZGluZ0JveFsxXVsxXSAtIGJvdW5kaW5nQm94WzBdWzFdO1xuXHR2YXIgc3RhcnRYID0gYm91bmRpbmdCb3hbMF1bMF0gKyB3aWR0aCAqIDAuNTtcblx0dmFyIHN0YXJ0WSA9IGJvdW5kaW5nQm94WzBdWzFdICsgaGVpZ2h0ICogMC41O1xuXG5cdC8vc3RhcnRYID0gdGhpcy5ncm91cC5ub2Rlc1swXS5vWDtcblx0Ly9zdGFydFkgPSB0aGlzLmdyb3VwLm5vZGVzWzBdLm9ZO1xuXHR2YXIgaW5pdFggPSBzdGFydFg7XG5cdHZhciBpbml0WSA9IHRoaXMud29ybGRIZWlnaHQgLSBzdGFydFk7XG5cblx0dGhpcy5ib2R5ID0gbmV3IHAyLkJvZHkoe1xuXHRcdG1hc3M6IHRoaXMuZ3JvdXAuZml4ZWQgPyAwIDogMSxcblx0XHRwb3NpdGlvbjogW3N0YXJ0WCwgdGhpcy53b3JsZEhlaWdodCAtIHN0YXJ0WV1cblx0fSk7XG5cdHZhciBub2RlO1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5ncm91cC5ub2Rlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdG5vZGUgPSB0aGlzLmdyb3VwLm5vZGVzW2ldO1xuXHRcdHZhciBwb3MgPSBbbm9kZS5vWCAtIHN0YXJ0WCwgLShub2RlLm9ZIC0gc3RhcnRZKV07XG5cdFx0bm9kZS5waHlzaWNzTWFuYWdlciA9IG5ldyBOb2RlUDJIYXJkUGh5c2ljc01hbmFnZXIodGhpcy5ib2R5LCBwb3MsIHRoaXMud29ybGRIZWlnaHQpO1xuXHRcdHBhdGgucHVzaChwb3MpO1xuXHR9XG5cblx0aWYgKGxlbmd0aCA+IDEpXG5cdHtcblx0XHR0aGlzLmJvZHkuZnJvbVBvbHlnb24ocGF0aCk7XG5cdFx0dmFyIG9mZnNldCA9IFtpbml0WCAtIHRoaXMuYm9keS5wb3NpdGlvblswXSwgdGhpcy5ib2R5LnBvc2l0aW9uWzFdIC0gaW5pdFldO1xuXHRcdGkgPSAwO1xuXHRcdGZvciAoaTsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdG5vZGUgPSB0aGlzLmdyb3VwLm5vZGVzW2ldO1xuXHRcdFx0bm9kZS5waHlzaWNzTWFuYWdlci5zZXRPZmZzZXQob2Zmc2V0KTtcblx0XHR9XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMuZ3JvdXAuc3RydWN0dXJlLnJhZGl1c1g7XG5cdFx0dmFyIGNpcmNsZVNoYXBlID0gbmV3IHAyLkNpcmNsZShyYWRpdXMpO1xuXHRcdHRoaXMuYm9keS5hZGRTaGFwZShjaXJjbGVTaGFwZSk7XG5cdH1cblxuXHR0aGlzLmJvZHkuZ3Jhdml0eVNjYWxlID0gdGhpcy5jb25mLmdyYXZpdHlTY2FsZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5jb25mLmdyYXZpdHlTY2FsZSA6IDE7XG5cdC8vIGNvbnNvbGUubG9nKHN0YXJ0WCwgdGhpcy53b3JsZEhlaWdodCAtIHN0YXJ0WSwgdGhpcy5ib2R5LnBvc2l0aW9uWzBdLCB0aGlzLmJvZHkucG9zaXRpb25bMV0pO1xuXHQvL3RoaXMuYm9keS5tYXNzID0gdGhpcy5jb25mLm1hc3M7XG5cdC8vaWYgKHRoaXMuZ3JvdXAuY29uZi5maXhlZCkgeyBub2RlLnBoeXNpY3NNYW5hZ2VyLnNldEZpeGVkKHRoaXMuZ3JvdXAuY29uZi5maXhlZCk7IH1cblx0Ly90aGlzLmJvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcblx0dGhpcy5QMldvcmxkLmFkZEJvZHkodGhpcy5ib2R5KTtcblx0dGhpcy5ib2R5Lm1hc3MgPSB0aGlzLmJvZHkuZ2V0QXJlYSgpICogdGhpcy5jb25mLm1hc3M7XG5cdHRoaXMuYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuXHR0aGlzLmJvZHkuY29sbGlzaW9uUmVzcG9uc2UgPSAhdGhpcy5jb25mLm5vQ29sbGlkZTtcblxuXHRpZiAodGhpcy5ncm91cC5JRCA9PT0gJ2dyb3VuZCcpXG5cdHtcblx0XHRjb25zb2xlLmxvZyh0aGlzLmJvZHkpO1xuXHR9XG5cblx0dGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdID0gdGhpcy5ib2R5LnBvc2l0aW9uWzBdO1xuXHR0aGlzLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMV0gPSB0aGlzLmJvZHkucG9zaXRpb25bMV07XG5cdC8vbm9kZS5waHlzaWNzTWFuYWdlci5zZXRGaXhlZCh0aGlzLmdyb3VwLmNvbmYuZml4ZWQpO1xuXHQvLyBjb25zb2xlLmxvZyh0aGlzLmJvZHkuc2hhcGVzKTtcblx0Ly8gZGVidWdnZXI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXI7XG5cbiIsIi8vIGpzY3M6ZGlzYWJsZSByZXF1aXJlQ2FtZWxDYXNlT3JVcHBlckNhc2VJZGVudGlmaWVyc1xuLypqc2hpbnQgY2FtZWxjYXNlOmZhbHNlKi9cblxudmFyIHAyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGlicy9wMicpO1xudmFyIE5vZGVQMlNvZnRQaHlzaWNzTWFuYWdlciA9IHJlcXVpcmUoJy4vTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL0FuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyJyk7XG5cbnZhciBHcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKCR3b3JsZCwgJHdvcmxkSGVpZ2h0LCAkZ3JvdXAsICRjb25mKVxue1xuXHR0aGlzLmdyb3VwID0gJGdyb3VwO1xuXHR0aGlzLndvcmxkID0gJHdvcmxkO1xuXHR0aGlzLndvcmxkSGVpZ2h0ID0gJHdvcmxkSGVpZ2h0O1xuXHR0aGlzLmNvbmYgPSAkY29uZjtcblx0Ly90aGlzLm5vZGVzRGlhbWV0ZXIgPSB0aGlzLmNvbmYubm9kZXNEaWFtZXRlcjtcbn07XG5cbkdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUFuY2hvckZyb21Qb2ludCA9IGZ1bmN0aW9uICgkcG9pbnQpXG57XG5cdHZhciBhbmNob3IgPSBuZXcgQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIodGhpcy5ncm91cCk7XG5cdGFuY2hvci5zZXRGcm9tUG9pbnQoJHBvaW50KTtcblx0cmV0dXJuIGFuY2hvcjtcbn07XG5cbkdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUFuY2hvckZyb21MaW5lID0gZnVuY3Rpb24gKCRsaW5lUG9pbnRzKVxue1xuXHR2YXIgY2xvc2VzdFBvaW50ID0gdGhpcy5ncm91cC5nZXRDbG9zZXN0UG9pbnQoJGxpbmVQb2ludHMpO1xuXHR2YXIgYW5jaG9yID0gbmV3IEFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyKHRoaXMuZ3JvdXApO1xuXHRhbmNob3Iuc2V0RnJvbVBvaW50KGNsb3Nlc3RQb2ludCk7XG5cdHJldHVybiBhbmNob3I7XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmNob3JzID0gZnVuY3Rpb24gKCRwb2ludHMpXG57XG5cdHZhciB0b1JldHVybiA9IFtdO1xuXHR2YXIgbm9kZXMgPSB0aGlzLmdyb3VwLmdldE5vZGVzSW5zaWRlKCRwb2ludHMpO1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdHZhciBjdXJyQW5jaG9yQSA9IG5ldyBBbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlcih0aGlzLmdyb3VwKTtcblx0XHRjdXJyQW5jaG9yQS5zZXRGcm9tUG9pbnQoW25vZGUub1gsIG5vZGUub1ldKTtcblx0XHR0b1JldHVybi5wdXNoKGN1cnJBbmNob3JBKTtcblx0fVxuXHRyZXR1cm4gdG9SZXR1cm47XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hZGRKb2ludHNUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZ3JvdXAuam9pbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGpvaW50ID0gdGhpcy5ncm91cC5qb2ludHNbaV07XG5cdFx0dmFyIGxvY2sgPSB0aGlzLmNvbmYubG9ja0NvbnN0cmFpbnQ7XG5cdFx0dmFyIGRpc3RhbmNlID0gdGhpcy5jb25mLmRpc3RhbmNlQ29uc3RyYWludDtcblx0XHR2YXIgbGluZWFyU3ByaW5nID0gdGhpcy5jb25mLmxpbmVhclNwcmluZztcblx0XHR2YXIgcm90YXRpb25hbFNwcmluZyA9IHRoaXMuY29uZi5yb3RhdGlvbmFsU3ByaW5nO1xuXG5cdFx0aWYgKGxvY2spXG5cdFx0e1xuXHRcdFx0dmFyIGNvbnN0cmFpbnQxID0gbmV3IHAyLkxvY2tDb25zdHJhaW50KGpvaW50Lm5vZGUxLnBoeXNpY3NNYW5hZ2VyLmJvZHksIGpvaW50Lm5vZGUyLnBoeXNpY3NNYW5hZ2VyLmJvZHkpO1xuXHRcdFx0aWYgKGxvY2suc3RpZmZuZXNzKSB7IGNvbnN0cmFpbnQxLnNldFN0aWZmbmVzcyhsb2NrLnN0aWZmbmVzcyk7IH0gLy9kZWZhdWx0IDIwXG5cdFx0XHRpZiAobG9jay5yZWxheGF0aW9uKSB7IGNvbnN0cmFpbnQxLnNldFJlbGF4YXRpb24obG9jay5yZWxheGF0aW9uKTsgfVxuXHRcdFx0dGhpcy53b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQxKTtcblx0XHR9XG5cdFx0aWYgKGRpc3RhbmNlKVxuXHRcdHtcblx0XHRcdHZhciBjb25zdHJhaW50MiA9IG5ldyBwMi5EaXN0YW5jZUNvbnN0cmFpbnQoam9pbnQubm9kZTEucGh5c2ljc01hbmFnZXIuYm9keSwgam9pbnQubm9kZTIucGh5c2ljc01hbmFnZXIuYm9keSk7XG5cdFx0XHRpZiAoZGlzdGFuY2Uuc3RpZmZuZXNzKSB7IGNvbnN0cmFpbnQyLnNldFN0aWZmbmVzcyhkaXN0YW5jZS5zdGlmZm5lc3MpOyB9IC8vIGRlZmF1bHQgNTAwXG5cdFx0XHRpZiAoZGlzdGFuY2UucmVsYXhhdGlvbikgeyBjb25zdHJhaW50Mi5zZXRSZWxheGF0aW9uKGRpc3RhbmNlLnJlbGF4YXRpb24pOyB9Ly8gZGVmYXVsdCAwLjFcblx0XHRcdHRoaXMud29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50Mik7XG5cdFx0fVxuXHRcdGlmIChsaW5lYXJTcHJpbmcpXG5cdFx0e1xuXHRcdFx0dmFyIGNvbnN0cmFpbnQzID0gbmV3IHAyLkxpbmVhclNwcmluZyhqb2ludC5ub2RlMS5waHlzaWNzTWFuYWdlci5ib2R5LCBqb2ludC5ub2RlMi5waHlzaWNzTWFuYWdlci5ib2R5KTtcblx0XHRcdGlmIChsaW5lYXJTcHJpbmcuc3RpZmZuZXNzKSB7IGNvbnN0cmFpbnQzLnN0aWZmbmVzcyA9IGxpbmVhclNwcmluZy5zdGlmZm5lc3M7IH1cblx0XHRcdGlmIChsaW5lYXJTcHJpbmcuZGFtcGluZykgeyBjb25zdHJhaW50My5kYW1waW5nID0gbGluZWFyU3ByaW5nLmRhbXBpbmc7IH1cblx0XHRcdHRoaXMud29ybGQuYWRkU3ByaW5nKGNvbnN0cmFpbnQzKTtcblx0XHR9XG5cdFx0aWYgKHJvdGF0aW9uYWxTcHJpbmcpXG5cdFx0e1xuXHRcdFx0dmFyIGNvbnN0cmFpbnQ0ID0gbmV3IHAyLlJvdGF0aW9uYWxTcHJpbmcoam9pbnQubm9kZTEucGh5c2ljc01hbmFnZXIuYm9keSwgam9pbnQubm9kZTIucGh5c2ljc01hbmFnZXIuYm9keSk7XG5cdFx0XHRpZiAocm90YXRpb25hbFNwcmluZy5zdGlmZm5lc3MpIHsgY29uc3RyYWludDQuc3RpZmZuZXNzID0gcm90YXRpb25hbFNwcmluZy5zdGlmZm5lc3M7IH1cblx0XHRcdGlmIChyb3RhdGlvbmFsU3ByaW5nLmRhbXBpbmcpIHsgY29uc3RyYWludDQuZGFtcGluZyA9IHJvdGF0aW9uYWxTcHJpbmcuZGFtcGluZzsgfVxuXHRcdFx0Ly90aGlzLndvcmxkLmFkZFNwcmluZyhjb25zdHJhaW50NCk7XG5cdFx0fVxuXHR9XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zZXROb2Rlc01hc3NGcm9tSm9pbnRzID0gZnVuY3Rpb24gKClcbntcblx0dmFyIE5vZGVHcmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvTm9kZUdyYXBoJyk7XG5cdHZhciBub2RlR3JhcGggPSBuZXcgTm9kZUdyYXBoKCk7XG5cdHZhciBpO1xuXHR2YXIgc3RhcnRpbmdWZXJ0aWNlcyA9IFtdO1xuXHR2YXIgbm9kZXNMZW5ndGggPSB0aGlzLmdyb3VwLm5vZGVzLmxlbmd0aDtcblx0dmFyIGpvaW50c0xlbmd0aCA9IHRoaXMuZ3JvdXAuam9pbnRzLmxlbmd0aDtcblx0Zm9yIChpID0gMDsgaSA8IGpvaW50c0xlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJKb2ludCA9IHRoaXMuZ3JvdXAuam9pbnRzW2ldO1xuXHRcdG5vZGVHcmFwaC5jb25uZWN0KGN1cnJKb2ludC5ub2RlMSwgY3VyckpvaW50Lm5vZGUyKTtcblx0fVxuXHRmb3IgKGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBub2RlID0gdGhpcy5ncm91cC5ub2Rlc1tpXTtcblx0XHRpZiAobm9kZS5maXhlZClcblx0XHR7XG5cdFx0XHRzdGFydGluZ1ZlcnRpY2VzLnB1c2gobm9kZUdyYXBoLmdldFZlcnRleChub2RlKSk7XG5cdFx0fVxuXHR9XG5cdGlmIChzdGFydGluZ1ZlcnRpY2VzLmxlbmd0aCA9PT0gMClcblx0e1xuXHRcdHJldHVybjtcblx0fVxuXHRub2RlR3JhcGgudHJhdmVyc2Uoc3RhcnRpbmdWZXJ0aWNlcyk7XG5cdHZhciB2ZXJ0aWNlc0xlbmd0aCA9IG5vZGVHcmFwaC52ZXJ0aWNlcy5sZW5ndGg7XG5cdGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlc0xlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIHZlcnRleCA9IG5vZGVHcmFwaC52ZXJ0aWNlc1tpXTtcblx0XHR2YXIgZGVjYXkgPSBOdW1iZXIodGhpcy5ncm91cC5jb25mLnBoeXNpY3Muc3RydWN0dXJhbE1hc3NEZWNheSk7XG5cdFx0dmFyIHZhbHVlID0gTWF0aC5wb3coZGVjYXksIHZlcnRleC5tYXBWYWx1ZSAvIDUpOy8vTWF0aC5wb3coMiwgdmVydGV4Lm1hcFZhbHVlIC8gNy4zMyk7XG5cdFx0dmFyIGJvZHkgPSB2ZXJ0ZXgubm9kZS5waHlzaWNzTWFuYWdlci5ib2R5O1xuXHRcdGlmICghdmVydGV4Lm5vZGUuZml4ZWQpXG5cdFx0e1xuXHRcdFx0Ly9ib2R5Lm1hc3MgPSB0aGlzLmNvbmYubWFzcyAvIHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoIC8gdmFsdWUgKiBib2R5LmdldEFyZWEoKTtcblx0XHRcdC8vdmVydGV4Lm5vZGUuZGVidWdUZXh0ID0gYm9keS5tYXNzO1xuXHRcdFx0Ly9ib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG5cdFx0XHR2YXIgbWFzc1ZhcmlhbmNlID0gdGhpcy5jb25mLm1hc3NWYXJpYW5jZSB8fCAwO1xuXHRcdFx0dmFyIHJhbmRvbSA9IC1tYXNzVmFyaWFuY2UgKyBNYXRoLnJhbmRvbSgpICogbWFzc1ZhcmlhbmNlICogMjtcblx0XHRcdHZhciBiYXNlTWFzcyA9IHRoaXMuZ3JvdXAuc3RydWN0dXJlLmFyZWEgKiB0aGlzLmNvbmYubWFzcztcblx0XHRcdHZhciBtYXNzID0gYmFzZU1hc3MgKyBiYXNlTWFzcyAqIHJhbmRvbTtcblx0XHRcdGJvZHkubWFzcyA9IG1hc3MgLyB2YWx1ZTtcblx0XHRcdGJvZHkuaW52TWFzcyA9IDEgLyBib2R5Lm1hc3M7XG5cdFx0XHRib2R5LmluZXJ0aWEgPSBib2R5Lm1hc3MgLyAyO1xuXHRcdFx0Ym9keS5pbnZJbmVydGlhID0gMSAvIGJvZHkuaW5lcnRpYTtcblx0XHR9XG5cdH1cbn07XG5cbkdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZE5vZGVzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmdyb3VwLm5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIG5vZGUgPSB0aGlzLmdyb3VwLm5vZGVzW2ldO1xuXHRcdC8vdmFyIGZyYWN0aW9uTWFzcyA9IHRoaXMuY29uZi5tYXNzIC8gdGhpcy5ncm91cC5ub2Rlcy5sZW5ndGg7XG5cdFx0dmFyIGFyZWEgPSB0aGlzLmdyb3VwLnN0cnVjdHVyZS5hcmVhO1xuXHRcdHZhciBub2RlTWFzcyA9IGFyZWEgKiB0aGlzLmNvbmYubWFzcyAvIHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoO1xuXHRcdC8vdmFyIG1hc3MgPSA1MDA7XG5cdFx0Ly92YXIgbWFzcyA9IHRoaXMuY29uZi5tYXNzOy8vTWF0aC5yYW5kb20oKSAqIDEwICsgMTtcblx0XHR2YXIgYm9keSA9IG5ldyBwMi5Cb2R5KHtcblx0XHRcdG1hc3M6IG5vZGUuZml4ZWQgPyAwIDogbm9kZU1hc3MsXG5cdFx0XHRwb3NpdGlvbjogW25vZGUub1gsIHRoaXMud29ybGRIZWlnaHQgLSBub2RlLm9ZXVxuXHRcdH0pO1xuXHRcdGJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMF0gPSBib2R5LnBvc2l0aW9uWzBdO1xuXHRcdGJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMV0gPSBib2R5LnBvc2l0aW9uWzFdO1xuXG5cdFx0Ly9pZiAobm9kZS5maXhlZCkgeyBib2R5LnR5cGUgPSBwMi5Cb2R5LlNUQVRJQzsgfVxuXHRcdC8vY29uc29sZS5sb2cobm9kZS5vWCwgbm9kZS5vWSk7XG5cdFx0Ly90aGlzLmJvZHkuZml4ZWRSb3RhdGlvbiA9IHRydWU7XG5cdFx0Ym9keS5ncmF2aXR5U2NhbGUgPSB0aGlzLmNvbmYuZ3Jhdml0eVNjYWxlIHx8IDE7Ly8wOy8vIC0xO1xuXG5cdFx0Ly8gdmFyIHJhZGl1cyA9IHRoaXMuY29uZi5ub2RlUmFkaXVzO1xuXHRcdC8vIHZhciBjaXJjbGVTaGFwZSA9IG5ldyBwMi5DaXJjbGUocmFkaXVzKTtcblx0XHQvLyBib2R5LmFkZFNoYXBlKGNpcmNsZVNoYXBlKTtcblx0XHRpZiAodGhpcy5ncm91cC5zdHJ1Y3R1cmUuaW5uZXJSYWRpdXMpXG5cdFx0e1xuXHRcdFx0dmFyIHJhZGl1cyA9IHRoaXMuZ3JvdXAuc3RydWN0dXJlLmlubmVyUmFkaXVzO1xuXHRcdFx0dmFyIGNpcmNsZVNoYXBlID0gbmV3IHAyLkNpcmNsZShyYWRpdXMpO1xuXHRcdFx0Ym9keS5hZGRTaGFwZShjaXJjbGVTaGFwZSk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvLyB2YXIgcGFydGljbGVTaGFwZSA9IG5ldyBwMi5QYXJ0aWNsZSgpO1xuXHRcdFx0Ly8gYm9keS5hZGRTaGFwZShwYXJ0aWNsZVNoYXBlKTtcblx0XHRcdHZhciBjaXJjbGVkU2hhcGUgPSBuZXcgcDIuQ2lyY2xlKHRoaXMuZ3JvdXAuY29uZi5ub2RlUmFkaXVzKTtcblx0XHRcdGJvZHkuYWRkU2hhcGUoY2lyY2xlZFNoYXBlKTtcblx0XHRcdC8vIGJvZHkubWFzcyA9IG5vZGVNYXNzO1xuXHRcdFx0Ly8gYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuXHRcdH1cblxuXHRcdC8vY29uc29sZS5sb2codGhpcy5ib2R5LmdldEFyZWEoKSk7XG5cblx0XHQvL3RoaXMuYm9keS5zZXREZW5zaXR5KG5vZGUudHlwZSA9PT0gJ2xpbmUnID8gMSA6IDUwMDApO1xuXG5cdFx0Ly9ib2R5LmRhbXBpbmcgPSAxO1xuXHRcdC8vYm9keS5tYXNzID0gbWFzcztcblx0XHRub2RlLnBoeXNpY3NNYW5hZ2VyID0gbmV3IE5vZGVQMlNvZnRQaHlzaWNzTWFuYWdlcihwMiwgYm9keSwgdGhpcy53b3JsZEhlaWdodCk7XG5cdFx0Ly9ub2RlLnBoeXNpY3NNYW5hZ2VyLnNldEZpeGVkKG5vZGUuZml4ZWQpO1xuXHRcdC8vYm9keS5zZXREZW5zaXR5KDAuMSk7XG5cdFx0dGhpcy53b3JsZC5hZGRCb2R5KGJvZHkpO1xuXG5cdFx0Ly9ib2R5Lm1hc3MgPSBib2R5LmdldEFyZWEoKSAqIHRoaXMuY29uZi5tYXNzO1xuXHRcdC8vYm9keS5ncmF2aXR5U2NhbGUgPSAwLjE7XG5cdFx0Ly9ib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG5cdFx0Ly8gYm9keS5tYXNzID0gMDtcblx0XHQvLyBib2R5LnNldERlbnNpdHkoMCk7XG5cdFx0Ly9ub2RlLnBoeXNpY3NNYW5hZ2VyLmFwcGx5Rm9yY2UoWzAsIDBdKTtcblx0XHQvLyBib2R5Lm1hc3MgPSAxMDtcblx0XHR2YXIgbWFzc1ZhcmlhbmNlID0gdGhpcy5jb25mLm1hc3NWYXJpYW5jZSB8fCAwO1xuXHRcdHZhciByYW5kb20gPSAtbWFzc1ZhcmlhbmNlICsgTWF0aC5yYW5kb20oKSAqIG1hc3NWYXJpYW5jZSAqIDI7XG5cdFx0Ym9keS5tYXNzID0gYm9keS5tYXNzICsgYm9keS5tYXNzICogcmFuZG9tO1xuXHRcdC8vYm9keS5tYXNzID0gYm9keS5tYXNzO1xuXHRcdGJvZHkuaW52TWFzcyA9IDEgLyBib2R5Lm1hc3M7XG5cdFx0Ym9keS5pbmVydGlhID0gYm9keS5tYXNzICogMC41O1xuXHRcdGJvZHkuaW52SW5lcnRpYSA9IDEgLyBib2R5LmluZXJ0aWE7XG5cdFx0XG5cdFx0Ym9keS5hbmd1bGFyRGFtcGluZyA9IHRoaXMuY29uZi5hbmd1bGFyRGFtcGluZyB8fCBib2R5LmFuZ3VsYXJEYW1waW5nO1xuXHRcdGJvZHkuZGFtcGluZyA9IHRoaXMuY29uZi5kYW1waW5nIHx8IGJvZHkuZGFtcGluZztcblx0fVxuXG5cdGlmICh0aGlzLmNvbmYuc3RydWN0dXJhbE1hc3NEZWNheSkgeyB0aGlzLnNldE5vZGVzTWFzc0Zyb21Kb2ludHMoKTsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyO1xuXG4iLCIvLyBqc2NzOmRpc2FibGUgcmVxdWlyZUNhbWVsQ2FzZU9yVXBwZXJDYXNlSWRlbnRpZmllcnNcbi8qanNoaW50IGNhbWVsY2FzZTpmYWxzZSovXG52YXIgcDIgPSByZXF1aXJlKCcuLi8uLi8uLi9saWJzL3AyJyk7XG5cbnZhciBOb2RlUDJIYXJkUGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJGJvZHksICRwb3NpdGlvbiwgJHdvcmxkSGVpZ2h0KVxue1xuXHR0aGlzLmJvZHkgPSAkYm9keTtcblx0dGhpcy5wb3NpdGlvbiA9ICRwb3NpdGlvbjtcblx0dGhpcy53b3JsZEhlaWdodCA9ICR3b3JsZEhlaWdodDtcblx0dGhpcy5vZmZzZXQgPSBbMCwgMF07XG5cdHRoaXMuZ2V0WCA9IHRoaXMuZ2V0WFNpbXBsZTtcblx0dGhpcy5nZXRZID0gdGhpcy5nZXRZU2ltcGxlO1xufTtcblxuTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zZXRGaXhlZCA9IGZ1bmN0aW9uICgkZml4ZWQpXG57XG5cdGlmICgkZml4ZWQpXG5cdHtcblx0XHR0aGlzLmJvZHkudHlwZSA9IHAyLkJvZHkuU1RBVElDO1xuXHRcdHRoaXMuYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuXHR9XG59O1xuXG5Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldE9mZnNldCA9IGZ1bmN0aW9uICgkb2Zmc2V0KVxue1xuXHR2YXIgZFggPSB0aGlzLnBvc2l0aW9uWzBdICsgJG9mZnNldFswXTtcblx0dmFyIGRZID0gdGhpcy5wb3NpdGlvblsxXSAtICRvZmZzZXRbMV07XG5cdHRoaXMuYW5nbGUgPSBNYXRoLmF0YW4yKGRZLCBkWCk7XG5cdHRoaXMuaHlwID0gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcblx0dGhpcy5nZXRYID0gdGhpcy5nZXRYT2Zmc2V0O1xuXHR0aGlzLmdldFkgPSB0aGlzLmdldFlPZmZzZXQ7XG59O1xuXG5Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFhTaW1wbGUgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdO1xufTtcblxuTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRZU2ltcGxlID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMud29ybGRIZWlnaHQgLSB0aGlzLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMV07XG59O1xuXG5Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFhPZmZzZXQgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdICsgdGhpcy5oeXAgKiBNYXRoLmNvcyh0aGlzLmJvZHkuaW50ZXJwb2xhdGVkQW5nbGUgKyB0aGlzLmFuZ2xlKTtcbn07XG5cbk5vZGVQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WU9mZnNldCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLndvcmxkSGVpZ2h0IC0gKHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblsxXSArIHRoaXMuaHlwICogTWF0aC5zaW4odGhpcy5ib2R5LmludGVycG9sYXRlZEFuZ2xlICsgdGhpcy5hbmdsZSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlUDJIYXJkUGh5c2ljc01hbmFnZXI7XG5cbiIsIi8vIGpzY3M6ZGlzYWJsZSByZXF1aXJlQ2FtZWxDYXNlT3JVcHBlckNhc2VJZGVudGlmaWVyc1xuLypqc2hpbnQgY2FtZWxjYXNlOmZhbHNlKi9cblxudmFyIE5vZGVQMlNvZnRQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkcDIsICRib2R5LCAkd29ybGRIZWlnaHQpXG57XG5cdHRoaXMucDIgPSAkcDI7XG5cdHRoaXMuYm9keSA9ICRib2R5O1xuXHR0aGlzLndvcmxkSGVpZ2h0ID0gJHdvcmxkSGVpZ2h0O1xufTtcblxuTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24gKCR2ZWMpXG57XG5cdC8vY29uc29sZS5sb2coJ25vcCcsIHRoaXMuYm9keS5hcHBseUZvcmNlTG9jYWwsICR2ZWMpO1xuXHR2YXIgbG9jID0gW107XG5cdHRoaXMuYm9keS50b1dvcmxkRnJhbWUobG9jLCBbMCwgMF0pO1xuXHR0aGlzLmJvZHkuYXBwbHlGb3JjZSgkdmVjLCBsb2MpO1xufTtcblxuTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zZXRGaXhlZCA9IGZ1bmN0aW9uICgkZml4ZWQpXG57XG5cdGlmICgkZml4ZWQpXG5cdHtcblx0XHR0aGlzLmJvZHkudHlwZSA9IHRoaXMucDIuQm9keS5TVEFUSUM7XG5cdH1cbn07XG5cbk5vZGVQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpXG57XG5cdC8vY29uc29sZS5sb2codGhpcy5ib2R5LkdldFdvcmxkQ2VudGVyKCkuZ2V0X3goKSk7XG5cdHJldHVybiB0aGlzLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMF07XG59O1xuXG5Ob2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy53b3JsZEhlaWdodCAtIHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblsxXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyO1xuXG4iLCIvLyBqc2NzOmRpc2FibGUgcmVxdWlyZUNhbWVsQ2FzZU9yVXBwZXJDYXNlSWRlbnRpZmllcnNcbi8qanNoaW50IGNhbWVsY2FzZTpmYWxzZSovXG5cbnZhciBwMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYnMvcDInKTtcbnZhciBHcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi9Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlciA9IHJlcXVpcmUoJy4vR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlcicpO1xudmFyIEdyb3VwR2hvc3RQaHlzaWNzTWFuYWdlciA9IHJlcXVpcmUoJy4vR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi9BbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXInKTtcblxudmFyIFAyUGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJGNvbmYpXG57XG5cdHRoaXMucDJXb3JsZCA9IG5ldyBwMi5Xb3JsZCgkY29uZik7XG5cdHRoaXMucDIgPSBwMjtcblx0dGhpcy5jb25mID0gJGNvbmY7XG5cdHRoaXMud29ybGRXaWR0aCA9IHVuZGVmaW5lZDtcblx0dGhpcy53b3JsZEhlaWdodCA9IHVuZGVmaW5lZDtcblx0dGhpcy5uZXdUaW1lID0gdW5kZWZpbmVkO1xuXHR0aGlzLmxhc3RUaW1lID0gdW5kZWZpbmVkO1xuXHQvL3RoaXMucDJXb3JsZC5ncmF2aXR5ID0gdGhpcy5jb25mLmdyYXZpdHk7XG59O1xuXG5QMlBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKCR0aW1lKVxue1xuXHR0aGlzLm5ld1RpbWUgPSAkdGltZSAtIHRoaXMubGFzdFRpbWUgfHwgMDtcblx0dGhpcy5sYXN0VGltZSA9ICR0aW1lO1xuXHR0aGlzLnAyV29ybGQuc3RlcCgxIC8gNjAsIHRoaXMubmV3VGltZSwgNSk7XG59O1xuXG5QMlBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJhaW5Hcm91cHMgPSBmdW5jdGlvbiAoJGFuY2hvckEsICRhbmNob3JCKVxue1xuXHQkYW5jaG9yQS5hZGRUb1dvcmxkKCk7XG5cdCRhbmNob3JCLmFkZFRvV29ybGQoKTtcblx0dmFyIGNvbnN0cmFpbnQgPSBuZXcgcDIuRGlzdGFuY2VDb25zdHJhaW50KCRhbmNob3JBLmJvZHksICRhbmNob3JCLmJvZHksXG5cdHtcblx0XHRsb2NhbEFuY2hvckE6ICRhbmNob3JBLm9mZnNldCwgLy8gUG9pbnQgb24gYm9keUFcblx0XHRsb2NhbEFuY2hvckI6ICRhbmNob3JCLm9mZnNldCAvLyBQb2ludCBvbiBib2R5QlxuXHR9KTtcblx0dGhpcy5wMldvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG59O1xuXG5QMlBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVHaG9zdEFuY2hvckZyb21Qb2ludCA9IGZ1bmN0aW9uICgkcG9pbnQpXG57XG5cdHZhciBhbmNob3IgPSBuZXcgQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyKHRoaXMucDIsIHRoaXMucDJXb3JsZCwgdGhpcy53b3JsZEhlaWdodCk7XG5cdGFuY2hvci5zZXRGcm9tUG9pbnQoJHBvaW50KTtcblx0cmV0dXJuIGFuY2hvcjtcbn07XG5cblAyUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldEdyb3VwUGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJGdyb3VwKVxue1xuXHRzd2l0Y2ggKCRncm91cC5jb25mLnBoeXNpY3MuYm9keVR5cGUpXG5cdHtcblx0XHRjYXNlICdnaG9zdCc6IHJldHVybiBuZXcgR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyKCRncm91cCk7XG5cdFx0Y2FzZSAnaGFyZCc6IHJldHVybiBuZXcgR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlcih0aGlzLnAyV29ybGQsIHRoaXMud29ybGRIZWlnaHQsICRncm91cCwgJGdyb3VwLmNvbmYucGh5c2ljcyk7XG5cdFx0Y2FzZSAnc29mdCc6IHJldHVybiBuZXcgR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlcih0aGlzLnAyV29ybGQsIHRoaXMud29ybGRIZWlnaHQsICRncm91cCwgJGdyb3VwLmNvbmYucGh5c2ljcyk7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUDJQaHlzaWNzTWFuYWdlcjtcblxuIiwidmFyIENvbW1hbmRzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9Db21tYW5kcycpO1xudmFyIEFSQyA9IENvbW1hbmRzLkFSQztcbnZhciBMSU5FX1RPID0gQ29tbWFuZHMuTElORV9UTztcbnZhciBNT1ZFX1RPID0gQ29tbWFuZHMuTU9WRV9UTztcbnZhciBCRVpJRVJfVE8gPSBDb21tYW5kcy5CRVpJRVJfVE87XG52YXIgUVVBRFJBX1RPID0gQ29tbWFuZHMuUVVBRFJBX1RPO1xudmFyIEVMTElQU0UgPSBDb21tYW5kcy5FTExJUFNFO1xuXG52YXIgU1ZKZWxseVJlbmRlcmVyID0vL2Z1bmN0aW9uICgkd29ybGQsICRjYW52YXMpXG57XG5cdGNyZWF0ZTogZnVuY3Rpb24gKCR3b3JsZCwgJGNhbnZhcylcblx0e1xuXHRcdHZhciBpbnN0ID0gT2JqZWN0LmNyZWF0ZShTVkplbGx5UmVuZGVyZXIpO1xuXG5cdFx0aW5zdC5tYWluQ29udGFpbmVyID0gaW5zdC5tYWluQ2FudmFzID0gJGNhbnZhcztcblx0XHRpbnN0LndvcmxkID0gJHdvcmxkO1xuXHRcdGluc3QubXVsdGlDYW52YXMgPSAkd29ybGQuY29uZi5tdWx0aUNhbnZhcztcblx0XHRpbnN0Lm1haW5Db250ZXh0ID0gaW5zdC5tYWluQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0aW5zdC5kZWJ1ZyA9ICR3b3JsZC5jb25mLmRlYnVnO1xuXHRcdGluc3Quc3RhdGljQ2FudmFzID0gW107XG5cdFx0aW5zdC5keW5hbWljQ2FudmFzID0gW107XG5cdFx0aW5zdC5jYWNoZWRIYXJkID0gW107XG5cdFx0aW5zdC5keW5hbWljR3JvdXBzID0gW107XG5cdFx0aW5zdC5keW5hbWljR3JvdXBzTGVuZ3RoID0gdW5kZWZpbmVkO1xuXG5cdFx0aW5zdC53aWR0aCA9IGluc3QubWFpbkNhbnZhcy53aWR0aDtcblx0XHRpbnN0LmhlaWdodCA9IGluc3QubWFpbkNhbnZhcy5oZWlnaHQ7XG5cblx0XHRpbnN0LnNjYWxlWCA9IGluc3Quc2NhbGVZID0gaW5zdC5tYWluQ2FudmFzLndpZHRoIC8gaW5zdC53b3JsZC5nZXRXaWR0aCgpO1xuXG5cdFx0aW5zdC5kcmF3aW5nR3JvdXBzID0gW107XG5cdFx0dmFyIGsgPSAwO1xuXHRcdHZhciBpO1xuXHRcdGZvciAodmFyIGdyb3Vwc0xlbmd0aCA9IGluc3Qud29ybGQuZ3JvdXBzLmxlbmd0aDsgayA8IGdyb3Vwc0xlbmd0aDsgayArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyR3JvdXAgPSBpbnN0LndvcmxkLmdyb3Vwc1trXTtcblx0XHRcdGluc3QuY3JlYXRlRHJhd2luZ0dyb3VwKGN1cnJHcm91cCk7XG5cdFx0fVxuXHRcdGluc3QuZHJhd2luZ0dyb3Vwc0xlbmd0aCA9IGluc3QuZHJhd2luZ0dyb3Vwcy5sZW5ndGg7XG5cblx0XHR2YXIgZHJhd2luZ0dyb3VwO1xuXG5cdFx0Ly9jYWNoaW5nIG5vbiBtb3ZpbmcgZ3JvdXBzXG5cdFx0aSA9IDA7XG5cdFx0dmFyIGNhbnZhcztcblx0XHR2YXIgY29udGV4dDtcblx0XHRmb3IgKGk7IGkgPCBpbnN0LmRyYXdpbmdHcm91cHNMZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHRkcmF3aW5nR3JvdXAgPSBpbnN0LmRyYXdpbmdHcm91cHNbaV07XG5cdFx0XHRpZiAoZHJhd2luZ0dyb3VwLmlzU3RhdGljKVxuXHRcdFx0e1xuXHRcdFx0XHQvL2lmIHNvbWUgc3RhdGljIGxheWVycyBhcmUgb24gdG9wIG9mIGVhY2ggb3RoZXIsIG5vIG5lZWQgdG8gY3JlYXRlXG5cdFx0XHRcdC8vYSBuZXcgY2FudmFzLCB5b3UgY2FuIGp1c3QgZHJhdyB0aGUgbGF5ZXJzIG9uIHRoZSBzYW1lIG9uZVxuXHRcdFx0XHRjYW52YXMgPSBpbnN0LnN0YXRpY0NhbnZhc1tpIC0gMV0gfHwgaW5zdC5jcmVhdGVDYW52YXMoKTtcblx0XHRcdFx0Y29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdFx0XHRpbnN0LnN0YXRpY0NhbnZhc1tpXSA9IGNhbnZhcztcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0Y2FudmFzID0gaW5zdC5keW5hbWljQ2FudmFzW2kgLSAxXSB8fCBpbnN0LmNyZWF0ZUNhbnZhcygpO1xuXHRcdFx0XHRjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0XHRcdGluc3QuZHluYW1pY0NhbnZhc1tpXSA9IGNhbnZhcztcblx0XHRcdFx0aW5zdC5keW5hbWljR3JvdXBzLnB1c2goZHJhd2luZ0dyb3VwKTtcblx0XHRcdH1cblx0XHRcdGRyYXdpbmdHcm91cC5jYW52YXMgPSBjYW52YXM7XG5cdFx0XHRkcmF3aW5nR3JvdXAuY29udGV4dCA9IGNvbnRleHQ7XG5cdFx0fVxuXHRcdGluc3QuZHluYW1pY0dyb3Vwc0xlbmd0aCA9IGluc3QuZHluYW1pY0dyb3Vwcy5sZW5ndGg7XG5cdFx0Ly9cblxuXHRcdC8vY2FjaGluZyBncmFkaWVudHMgYW5kIHByZWNhbGN1bGF0aW5nXG5cdFx0Zm9yIChpID0gMDsgaSA8IGluc3QuZHJhd2luZ0dyb3Vwc0xlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdGRyYXdpbmdHcm91cCA9IGluc3QuZHJhd2luZ0dyb3Vwc1tpXTtcblx0XHRcdC8vcHJlY2FsY3VsYXRpbmcgc29tZSBpbnN0cnVjdGlvbnNcblx0XHRcdGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmxpbmVXaWR0aCA9IGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmxpbmVXaWR0aCAqIGluc3Quc2NhbGVYO1xuXHRcdFx0ZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMucmFkaXVzWCA9IGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLnJhZGl1c1ggKiBpbnN0LnNjYWxlWDtcblx0XHRcdGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLnJhZGl1c1kgPSBkcmF3aW5nR3JvdXAucHJvcGVydGllcy5yYWRpdXNZICogaW5zdC5zY2FsZVk7XG5cdFx0XHR2YXIgbm9kZXNMZW5ndGggPSBkcmF3aW5nR3JvdXAubm9kZXMubGVuZ3RoO1xuXHRcdFx0Zm9yIChrID0gMDsgayA8IG5vZGVzTGVuZ3RoOyBrICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjdXJyTm9kZSA9IGRyYXdpbmdHcm91cC5ub2Rlc1trXTtcblx0XHRcdFx0dmFyIGNvbW1hbmQgPSBjdXJyTm9kZS5kcmF3aW5nLmNvbW1hbmQ7XG5cdFx0XHRcdHZhciBvcHRpb25zID0gY3Vyck5vZGUuZHJhd2luZy5vcHRpb25zO1xuXHRcdFx0XHRpZiAoZHJhd2luZ0dyb3VwLmlzU2ltcGxlRHJhd2luZyAmJiAoY29tbWFuZCA9PT0gQkVaSUVSX1RPIHx8IGNvbW1hbmQgPT09IFFVQURSQV9UTykpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kID0gTElORV9UTztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHJhd2luZ0dyb3VwLmlzU2ltcGxlRHJhd2luZyAmJiAoY29tbWFuZCA9PT0gRUxMSVBTRSkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kID0gQVJDO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vcHJlY2FsY3VsYXRpb25nIGNvbnRyb2wgcG9pbnRzIGFuZCByYWRpeDtcblx0XHRcdFx0aWYgKGNvbW1hbmQgPT09IEJFWklFUl9UTyB8fCBjb21tYW5kID09PSBRVUFEUkFfVE8pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKHZhciBtID0gMCwgbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGg7IG0gPCBsZW5ndGg7IG0gKz0gMSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgY3Vyck9wdGlvbiA9IG9wdGlvbnNbbV07XG5cdFx0XHRcdFx0XHRjdXJyT3B0aW9uWzBdID0gY3Vyck9wdGlvblswXSAqIGluc3Quc2NhbGVYO1xuXHRcdFx0XHRcdFx0Y3Vyck9wdGlvblsxXSA9IGN1cnJPcHRpb25bMV0gKiBpbnN0LnNjYWxlWTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoY29tbWFuZCA9PT0gRUxMSVBTRSB8fCBjb21tYW5kID09PSBBUkMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRvcHRpb25zWzBdID0gb3B0aW9uc1swXSAqIGluc3Quc2NhbGVYO1xuXHRcdFx0XHRcdG9wdGlvbnNbMV0gPSBvcHRpb25zWzFdICogaW5zdC5zY2FsZVg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRyYXdpbmdHcm91cC5ub2Rlc0xlbmd0aCA9IGRyYXdpbmdHcm91cC5ub2Rlcy5sZW5ndGg7XG5cdFx0XHQvL1xuXHRcdFx0aWYgKGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLnN0cm9rZUdyYWRpZW50KVxuXHRcdFx0e1xuXHRcdFx0XHRkcmF3aW5nR3JvdXAucHJvcGVydGllcy5zdHJva2UgPSBpbnN0LmNyZWF0ZUdyYWRpZW50KGRyYXdpbmdHcm91cC5jb250ZXh0LCBkcmF3aW5nR3JvdXAucHJvcGVydGllcy5zdHJva2VHcmFkaWVudCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuZmlsbEdyYWRpZW50KVxuXHRcdFx0e1xuXHRcdFx0XHRkcmF3aW5nR3JvdXAucHJvcGVydGllcy5maWxsID0gaW5zdC5jcmVhdGVHcmFkaWVudChkcmF3aW5nR3JvdXAuY29udGV4dCwgZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuZmlsbEdyYWRpZW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBtdWx0aSBjYW52YXNcblx0XHRpZiAoaW5zdC5tdWx0aUNhbnZhcylcblx0XHR7XG5cdFx0XHRpbnN0LmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0aW5zdC5tYWluQ29udGFpbmVyID0gaW5zdC5jb250YWluZXI7XG5cdFx0XHRpbnN0LmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdFx0XHRpbnN0LmNvbnRhaW5lci5jbGFzc05hbWUgPSBpbnN0Lm1haW5DYW52YXMuY2xhc3NOYW1lO1xuXHRcdFx0aW5zdC5tYWluQ2FudmFzLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGluc3QuY29udGFpbmVyLCBpbnN0Lm1haW5DYW52YXMpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgaW5zdC5kcmF3aW5nR3JvdXBzTGVuZ3RoOyBpICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdGRyYXdpbmdHcm91cCA9IGluc3QuZHJhd2luZ0dyb3Vwc1tpXTtcblx0XHRcdFx0aW5zdC5hZGRMYXllcihpbnN0LmNvbnRhaW5lciwgZHJhd2luZ0dyb3VwLmNhbnZhcywgIWRyYXdpbmdHcm91cC5pc1N0YXRpYyk7XG5cdFx0XHRcdC8vIGlmICghY29udGFpbmVyLmNvbnRhaW5zKGRyYXdpbmdHcm91cC5jYW52YXMpKSB7IGNvbnRhaW5lci5hcHBlbmRDaGlsZChkcmF3aW5nR3JvdXAuY2FudmFzKTsgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpbnN0LmRyYXcgPSBpbnN0Lm11bHRpQ2FudmFzID8gaW5zdC5kcmF3TXVsdGlDYW52YXMgOiBpbnN0LmRyYXdTaW5nbGVDYW52YXM7XG5cdFx0Ly9cblxuXHRcdC8vZHJhd2luZ0dyb3VwcyBvbmNlXG5cdFx0Zm9yIChpID0gMDsgaSA8IGluc3QuZHJhd2luZ0dyb3Vwc0xlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdGRyYXdpbmdHcm91cCA9IGluc3QuZHJhd2luZ0dyb3Vwc1tpXTtcblx0XHRcdGluc3QuZHJhd0dyb3VwKGRyYXdpbmdHcm91cCwgZHJhd2luZ0dyb3VwLmNvbnRleHQpO1xuXHRcdH1cblxuXHRcdGlmIChpbnN0LmRlYnVnKVxuXHRcdHtcblx0XHRcdGluc3QuZGVidWdDYW52YXMgPSBpbnN0LmNyZWF0ZUNhbnZhcygpO1xuXHRcdFx0aW5zdC5kZWJ1Z0NvbnRleHQgPSBpbnN0LmRlYnVnQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0XHRpbnN0LmFkZExheWVyKGluc3QubXVsdGlDYW52YXMgPyBpbnN0LmNvbnRhaW5lciA6IGluc3QubWFpbkNhbnZhcy5wYXJlbnROb2RlLCBpbnN0LmRlYnVnQ2FudmFzLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFpbnN0Lm11bHRpQ2FudmFzKSB7IGluc3QuY29udGFpbmVyID0gaW5zdC5tYWluQ2FudmFzOyB9XG5cblx0XHRyZXR1cm4gaW5zdDtcblx0XHQvL2NhY2hpbmcgaGFyZCBzdHVmZiAtIG5vdCBpbnRlcmVzdGluZyBwZXJmb3JtYW5jZS13aXNlIHlldFxuXHRcdC8vIGZvciAoaSA9IDA7IGkgPCBpbnN0LmRyYXdpbmdHcm91cHNMZW5ndGg7IGkgKz0gMSlcblx0XHQvLyB7XG5cdFx0Ly8gXHRkcmF3aW5nR3JvdXAgPSBpbnN0LmRyYXdpbmdHcm91cHNbaV07XG5cdFx0Ly8gXHRpZiAoZHJhd2luZ0dyb3VwLmJvZHlUeXBlID09PSAnaGFyZCcgJiYgIWRyYXdpbmdHcm91cC5maXhlZClcblx0XHQvLyBcdHtcblx0XHQvLyBcdFx0Y2FudmFzID0gaW5zdC5jcmVhdGVDYW52YXMoKTtcblx0XHQvLyBcdFx0aW5zdC5kcmF3R3JvdXAoZHJhd2luZ0dyb3VwLCBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSk7XG5cdFx0Ly8gXHRcdGluc3QuY2FjaGVkSGFyZFtpXSA9IGNhbnZhcztcblx0XHQvLyBcdH1cblx0XHQvLyB9XG5cdH0sXG5cblx0YWRkTGF5ZXI6IGZ1bmN0aW9uICgkcGFyZW50LCAkY2FudmFzLCAkcG9pbnRlckV2ZW50cylcblx0e1xuXHRcdGlmICgkcGFyZW50LmNvbnRhaW5zKCRjYW52YXMpKSB7IHJldHVybjsgfVxuXHRcdCRwYXJlbnQuYXBwZW5kQ2hpbGQoJGNhbnZhcyk7XG5cdFx0JGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0JGNhbnZhcy5zdHlsZS50b3AgPSB0aGlzLm1haW5DYW52YXMub2Zmc2V0VG9wICsgJ3B4Jztcblx0XHQkY2FudmFzLnN0eWxlLmxlZnQgPSB0aGlzLm1haW5DYW52YXMub2Zmc2V0TGVmdCArICdweCc7XG5cdFx0JGNhbnZhcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJHBvaW50ZXJFdmVudHMgPyAnYXV0bycgOiAnbm9uZSc7XG5cdH0sXG5cdGNyZWF0ZUNhbnZhczogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciBjYW52YXMgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0Y2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cdFx0Y2FudmFzLmlkID0gTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwO1xuXHRcdHJldHVybiBjYW52YXM7XG5cdH0sXG5cblx0Y3JlYXRlR3JhZGllbnQ6IGZ1bmN0aW9uICgkY29udGV4dCwgJHByb3BlcnRpZXMpXG5cdHtcblx0XHR2YXIgeDEgPSAkcHJvcGVydGllcy54MSAqIHRoaXMuc2NhbGVYO1xuXHRcdHZhciB5MSA9ICRwcm9wZXJ0aWVzLnkxICogdGhpcy5zY2FsZVk7XG5cdFx0dmFyIHgyID0gJHByb3BlcnRpZXMueDIgKiB0aGlzLnNjYWxlWDtcblx0XHR2YXIgeTIgPSAkcHJvcGVydGllcy55MiAqIHRoaXMuc2NhbGVZO1xuXG5cdFx0dmFyIGN4ID0gJHByb3BlcnRpZXMuY3ggKiB0aGlzLnNjYWxlWDtcblx0XHR2YXIgY3kgPSAkcHJvcGVydGllcy5jeSAqIHRoaXMuc2NhbGVZO1xuXHRcdHZhciBmeCA9ICRwcm9wZXJ0aWVzLmZ4ICogdGhpcy5zY2FsZVggfHwgY3g7XG5cdFx0dmFyIGZ5ID0gJHByb3BlcnRpZXMuZnkgKiB0aGlzLnNjYWxlWSB8fCBjeTtcblx0XHR2YXIgciA9ICRwcm9wZXJ0aWVzLnIgKiB0aGlzLnNjYWxlWDtcblxuXHRcdHZhciBncmFkaWVudCA9ICRwcm9wZXJ0aWVzLnR5cGUgPT09ICdsaW5lYXJHcmFkaWVudCcgPyAkY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5MikgOiAkY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChjeCwgY3ksIDAsIGZ4LCBmeSwgcik7XG5cblx0XHRmb3IgKHZhciBzdG9wTiA9IDAsIHN0b3BMZW5ndGggPSAkcHJvcGVydGllcy5zdG9wcy5sZW5ndGg7IHN0b3BOIDwgc3RvcExlbmd0aDsgc3RvcE4gKz0gMSlcblx0XHR7XG5cdFx0XHRncmFkaWVudC5hZGRDb2xvclN0b3AoJHByb3BlcnRpZXMuc3RvcHNbc3RvcE5dLm9mZnNldCwgJHByb3BlcnRpZXMuc3RvcHNbc3RvcE5dLmNvbG9yKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZ3JhZGllbnQ7XG5cdH0sXG5cblx0Y3JlYXRlRHJhd2luZ0dyb3VwOiBmdW5jdGlvbiAoJGdyb3VwKVxuXHR7XG5cdFx0dmFyIGRyYXdpbmdHcm91cDtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy53b3JsZC5ncm91cHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJHcm91cCA9IHRoaXMud29ybGQuZ3JvdXBzW2ldO1xuXHRcdFx0aWYgKCFjdXJyR3JvdXAuZHJhd2luZ0dyb3VwKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRpZiAodGhpcy5jb21wYXJlUHJvcGVydGllcyhjdXJyR3JvdXAuZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMsICRncm91cC5kcmF3aW5nLnByb3BlcnRpZXMpICYmXG5cdFx0XHRcdHRoaXMud2lsbE5vdEludGVyc2VjdChjdXJyR3JvdXAsICRncm91cCkgJiZcblx0XHRcdFx0IXRoaXMuaXNTdGF0aWMoJGdyb3VwKSAmJlxuXHRcdFx0XHR0aGlzLmlzU2ltcGxlRHJhd2luZygkZ3JvdXApID09PSB0aGlzLmlzU2ltcGxlRHJhd2luZyhjdXJyR3JvdXApKVxuXHRcdFx0e1xuXHRcdFx0XHRkcmF3aW5nR3JvdXAgPSAkZ3JvdXAuZHJhd2luZ0dyb3VwID0gY3Vyckdyb3VwLmRyYXdpbmdHcm91cDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFkcmF3aW5nR3JvdXApXG5cdFx0e1xuXHRcdFx0ZHJhd2luZ0dyb3VwID1cblx0XHRcdHtcblx0XHRcdFx0cHJvcGVydGllczogJGdyb3VwLmRyYXdpbmcucHJvcGVydGllcyxcblx0XHRcdFx0aXNTdGF0aWM6IHRoaXMuaXNTdGF0aWMoJGdyb3VwKSxcblx0XHRcdFx0aXNTaW1wbGVEcmF3aW5nOiB0aGlzLmlzU2ltcGxlRHJhd2luZygkZ3JvdXApLFxuXHRcdFx0XHRub2RlczogW11cblx0XHRcdH07XG5cdFx0XHQkZ3JvdXAuZHJhd2luZ0dyb3VwID0gZHJhd2luZ0dyb3VwO1xuXHRcdFx0dGhpcy5kcmF3aW5nR3JvdXBzLnB1c2goZHJhd2luZ0dyb3VwKTtcblx0XHR9XG5cdFx0ZHJhd2luZ0dyb3VwLm5vZGVzID0gZHJhd2luZ0dyb3VwLm5vZGVzLmNvbmNhdCgkZ3JvdXAuZHJhd2luZy5ub2Rlcyk7XG5cdFx0cmV0dXJuIGRyYXdpbmdHcm91cDtcblx0fSxcblxuXHRpc1N0YXRpYzogZnVuY3Rpb24gKCRncm91cClcblx0e1xuXHRcdHJldHVybiAkZ3JvdXAuY29uZi5maXhlZCA9PT0gdHJ1ZTtcblx0fSxcblxuXHRnZXRDb2xsaXNpb25Hcm91cDogZnVuY3Rpb24gKCRncm91cClcblx0e1xuXHRcdHJldHVybiAkZ3JvdXAuY29uZi5waHlzaWNzLmJvZHlUeXBlO1xuXHR9LFxuXG5cdHdpbGxOb3RJbnRlcnNlY3Q6IGZ1bmN0aW9uICgkZ3JvdXBBLCAkZ3JvdXBCKVxuXHR7XG5cdFx0aWYgKCRncm91cEEuY29uZi5waHlzaWNzLmJvZHlUeXBlID09PSAnaGFyZCcgfHwgJGdyb3VwQi5jb25mLnBoeXNpY3MuYm9keVR5cGUgPT09ICdoYXJkJylcblx0XHR7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRpc1NpbXBsZURyYXdpbmc6IGZ1bmN0aW9uICgkZ3JvdXApXG5cdHtcblx0XHRpZiAoJGdyb3VwLmNvbmYucGh5c2ljcy5ib2R5VHlwZSA9PT0gJ2hhcmQnIHx8ICRncm91cC5jb25mLnBoeXNpY3MuYm9keVR5cGUgPT09ICdzb2Z0Jylcblx0XHR7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGNvbXBhcmVQcm9wZXJ0aWVzOiBmdW5jdGlvbiAoJG9uZSwgJHR3bylcblx0e1xuXHRcdHZhciBjb21wYXJpc29uID0gdHJ1ZTtcblx0XHRmb3IgKHZhciBuYW1lIGluICR0d28pXG5cdFx0e1xuXHRcdFx0aWYgKCRvbmVbbmFtZV0gIT09ICR0d29bbmFtZV0pIHsgY29tcGFyaXNvbiA9IGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiBjb21wYXJpc29uO1xuXHR9LFxuXG5cdGRyYXdNdWx0aUNhbnZhczogZnVuY3Rpb24gKClcblx0e1xuXHRcdC8vdGhpcy5tYWluQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHRcdHZhciBwcmV2aW91cztcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHluYW1pY0dyb3Vwc0xlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBkcmF3aW5nR3JvdXAgPSB0aGlzLmR5bmFtaWNHcm91cHNbaV07XG5cdFx0XHRpZiAocHJldmlvdXMgIT09IGRyYXdpbmdHcm91cC5jb250ZXh0KSB7IGRyYXdpbmdHcm91cC5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7IH1cblx0XHRcdHByZXZpb3VzID0gZHJhd2luZ0dyb3VwLmNvbnRleHQ7XG5cdFx0XHR0aGlzLmRyYXdHcm91cChkcmF3aW5nR3JvdXAsIGRyYXdpbmdHcm91cC5jb250ZXh0KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5kZWJ1ZykgeyB0aGlzLmRlYnVnRHJhdyh0cnVlKTsgfVxuXHR9LFxuXG5cdGRyYXdTaW5nbGVDYW52YXM6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR0aGlzLm1haW5Db250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0Ly90aGlzLmNvbnRleHQubWl0ZXJMaW1pdCA9IDE7XG5cdFx0dmFyIHByZXZpb3VzQ2FjaGVkO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kcmF3aW5nR3JvdXBzTGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGRyYXdpbmdHcm91cCA9IHRoaXMuZHJhd2luZ0dyb3Vwc1tpXTtcblx0XHRcdGlmICh0aGlzLnN0YXRpY0NhbnZhc1tpXSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKHRoaXMuc3RhdGljQ2FudmFzW2ldID09PSBwcmV2aW91c0NhY2hlZCkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHR0aGlzLm1haW5Db250ZXh0LmRyYXdJbWFnZSh0aGlzLnN0YXRpY0NhbnZhc1tpXSwgMCwgMCk7XG5cdFx0XHRcdHByZXZpb3VzQ2FjaGVkID0gdGhpcy5zdGF0aWNDYW52YXNbaV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuZHJhd0dyb3VwKGRyYXdpbmdHcm91cCwgdGhpcy5tYWluQ29udGV4dCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuZGVidWcpIHsgdGhpcy5kZWJ1Z0RyYXcodHJ1ZSk7IH1cblx0fSxcblxuXHRkcmF3R3JvdXA6IGZ1bmN0aW9uIChkcmF3aW5nLCBjb250ZXh0KVxuXHR7XG5cdFx0Y29udGV4dC5iZWdpblBhdGgoKTtcblxuXHRcdGlmIChjb250ZXh0LmZpbGxTdHlsZSAhPT0gZHJhd2luZy5wcm9wZXJ0aWVzLmZpbGwpIHsgY29udGV4dC5maWxsU3R5bGUgPSBkcmF3aW5nLnByb3BlcnRpZXMuZmlsbDsgfVxuXHRcdGlmIChjb250ZXh0LnN0cm9rZVN0eWxlICE9PSBkcmF3aW5nLnByb3BlcnRpZXMuc3Ryb2tlKSB7IGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBkcmF3aW5nLnByb3BlcnRpZXMuc3Ryb2tlOyB9XG5cdFx0aWYgKGNvbnRleHQubGluZVdpZHRoICE9PSBkcmF3aW5nLnByb3BlcnRpZXMubGluZVdpZHRoKSB7IGNvbnRleHQubGluZVdpZHRoID0gZHJhd2luZy5wcm9wZXJ0aWVzLmxpbmVXaWR0aDsgfVxuXHRcdGlmIChjb250ZXh0LmxpbmVDYXAgIT09IGRyYXdpbmcucHJvcGVydGllcy5saW5lQ2FwKSB7IGNvbnRleHQubGluZUNhcCA9IGRyYXdpbmcucHJvcGVydGllcy5saW5lQ2FwOyB9XG5cdFx0aWYgKGNvbnRleHQubGluZUpvaW4gIT09IGRyYXdpbmcucHJvcGVydGllcy5saW5lSm9pbikgeyBjb250ZXh0LmxpbmVKb2luID0gZHJhd2luZy5wcm9wZXJ0aWVzLmxpbmVKb2luOyB9XG5cdFx0aWYgKGNvbnRleHQuZ2xvYmFsQWxwaGEgIT09IGRyYXdpbmcucHJvcGVydGllcy5vcGFjaXR5KSB7IGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkcmF3aW5nLnByb3BlcnRpZXMub3BhY2l0eTsgfVxuXG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkcmF3aW5nLm5vZGVzTGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJOb2RlID0gZHJhd2luZy5ub2Rlc1trXTtcblx0XHRcdGlmIChjdXJyTm9kZS5kcmF3aW5nLmNvbW1hbmQgPT09IE1PVkVfVE8pXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnRleHQubW92ZVRvKGN1cnJOb2RlLmdldFgoKSAqIHRoaXMuc2NhbGVYLCBjdXJyTm9kZS5nZXRZKCkgKiB0aGlzLnNjYWxlWSk7XG5cblx0XHRcdFx0Ly9zcGVjaWFsIGNhc2UgZm9yIGxpbmVzIHdpdGggbmljZSBkeW5hbWljIGdyYWRpZW50c1xuXHRcdFx0XHRpZiAoZHJhd2luZy5wcm9wZXJ0aWVzLmR5bmFtaWNHcmFkaWVudClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciB4MSA9IGN1cnJOb2RlLmdldFgoKSAqIHRoaXMuc2NhbGVYO1xuXHRcdFx0XHRcdHZhciB5MSA9IGN1cnJOb2RlLmdldFkoKSAqIHRoaXMuc2NhbGVZO1xuXHRcdFx0XHRcdHZhciB4MiA9IGN1cnJOb2RlLmRyYXdpbmcuZW5kTm9kZS5nZXRYKCkgKiB0aGlzLnNjYWxlWDtcblx0XHRcdFx0XHR2YXIgeTIgPSBjdXJyTm9kZS5kcmF3aW5nLmVuZE5vZGUuZ2V0WSgpICogdGhpcy5zY2FsZVk7XG5cdFx0XHRcdFx0dmFyIGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5Mik7XG5cdFx0XHRcdFx0Zm9yICh2YXIgc3RvcE4gPSAwLCBzdG9wTGVuZ3RoID0gZHJhd2luZy5wcm9wZXJ0aWVzLnN0cm9rZUdyYWRpZW50LnN0b3BzLmxlbmd0aDsgc3RvcE4gPCBzdG9wTGVuZ3RoOyBzdG9wTiArPSAxKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGdyYWRpZW50LmFkZENvbG9yU3RvcCgxIC0gZHJhd2luZy5wcm9wZXJ0aWVzLnN0cm9rZUdyYWRpZW50LnN0b3BzW3N0b3BOXS5vZmZzZXQsIGRyYXdpbmcucHJvcGVydGllcy5zdHJva2VHcmFkaWVudC5zdG9wc1tzdG9wTl0uY29sb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250ZXh0LnN0cm9rZVN0eWxlID0gZ3JhZGllbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGN1cnJOb2RlLmRyYXdpbmcuY29tbWFuZCA9PT0gTElORV9UTylcblx0XHRcdHtcblx0XHRcdFx0Y29udGV4dC5saW5lVG8oY3Vyck5vZGUuZ2V0WCgpICogdGhpcy5zY2FsZVgsIGN1cnJOb2RlLmdldFkoKSAqIHRoaXMuc2NhbGVZKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChjdXJyTm9kZS5kcmF3aW5nLmNvbW1hbmQgPT09IEFSQylcblx0XHRcdHtcblx0XHRcdFx0Y29udGV4dC5tb3ZlVG8oY3Vyck5vZGUuZ2V0WCgpICogdGhpcy5zY2FsZVgsIGN1cnJOb2RlLmdldFkoKSAqIHRoaXMuc2NhbGVZKTtcblx0XHRcdFx0Y29udGV4dC5hcmMoY3Vyck5vZGUuZ2V0WCgpICogdGhpcy5zY2FsZVgsIGN1cnJOb2RlLmdldFkoKSAqIHRoaXMuc2NhbGVZLCBjdXJyTm9kZS5kcmF3aW5nLm9wdGlvbnNbMF0sIDAsIE1hdGguUEkgKiAyKTtcblx0XHRcdH1cblx0XHRcdGlmICghZHJhd2luZy5pc1NpbXBsZURyYXdpbmcpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBvcHRpb25zID0gY3Vyck5vZGUuZHJhd2luZy5vcHRpb25zO1xuXHRcdFx0XHR2YXIgYmFzZVggPSBjdXJyTm9kZS5nZXRYKCkgKiB0aGlzLnNjYWxlWDtcblx0XHRcdFx0dmFyIGJhc2VZID0gY3Vyck5vZGUuZ2V0WSgpICogdGhpcy5zY2FsZVk7XG5cdFx0XHRcdHZhciBjcDF4O1xuXHRcdFx0XHR2YXIgY3AxeTtcblxuXHRcdFx0XHRpZiAoY3Vyck5vZGUuZHJhd2luZy5jb21tYW5kID09PSBCRVpJRVJfVE8gfHwgY3Vyck5vZGUuZHJhd2luZy5jb21tYW5kID09PSBRVUFEUkFfVE8pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjcDF4ID0gYmFzZVggKyBvcHRpb25zWzBdWzBdO1xuXHRcdFx0XHRcdGNwMXkgPSBiYXNlWSArIG9wdGlvbnNbMF1bMV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3Vyck5vZGUuZHJhd2luZy5jb21tYW5kID09PSBCRVpJRVJfVE8pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgY3AyeCA9IGJhc2VYICsgb3B0aW9uc1sxXVswXTtcblx0XHRcdFx0XHR2YXIgY3AyeSA9IGJhc2VZICsgb3B0aW9uc1sxXVsxXTtcblx0XHRcdFx0XHRjb250ZXh0LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgYmFzZVgsIGJhc2VZKTtcblx0XHRcdFx0XHQvL2NvbnRleHQubGluZVRvKGJhc2VYLCBiYXNlWSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoY3Vyck5vZGUuZHJhd2luZy5jb21tYW5kID09PSBRVUFEUkFfVE8pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY3AxeCwgY3AxeSwgYmFzZVgsIGJhc2VZKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChjdXJyTm9kZS5kcmF3aW5nLmNvbW1hbmQgPT09IE1PVkVfVE8pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb250ZXh0Lm1vdmVUbyhjdXJyTm9kZS5nZXRYKCkgKiB0aGlzLnNjYWxlWCwgY3Vyck5vZGUuZ2V0WSgpICogdGhpcy5zY2FsZVkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKGN1cnJOb2RlLmRyYXdpbmcuY29tbWFuZCA9PT0gRUxMSVBTRSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnRleHQubW92ZVRvKGN1cnJOb2RlLmdldFgoKSAqIHRoaXMuc2NhbGVYLCBjdXJyTm9kZS5nZXRZKCkgKiB0aGlzLnNjYWxlWSk7XG5cdFx0XHRcdFx0Y29udGV4dC5lbGxpcHNlKGN1cnJOb2RlLmdldFgoKSAqIHRoaXMuc2NhbGVYLCBjdXJyTm9kZS5nZXRZKCkgKiB0aGlzLnNjYWxlWSwgY3Vyck5vZGUuZHJhd2luZy5vcHRpb25zWzBdLCBjdXJyTm9kZS5kcmF3aW5nLm9wdGlvbnNbMV0sIGN1cnJOb2RlLmRyYXdpbmcub3B0aW9uc1syXSwgMCwgTWF0aC5QSSAqIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGRyYXdpbmcucHJvcGVydGllcy5jbG9zZVBhdGgpIHsgY29udGV4dC5jbG9zZVBhdGgoKTsgfVxuXHRcdGlmIChkcmF3aW5nLnByb3BlcnRpZXMuZmlsbCAhPT0gJ25vbmUnKSB7IGNvbnRleHQuZmlsbCgpOyB9XG5cdFx0aWYgKGRyYXdpbmcucHJvcGVydGllcy5zdHJva2UgIT09ICdub25lJykgeyBjb250ZXh0LnN0cm9rZSgpOyB9XG5cdFx0aWYgKGRyYXdpbmcucHJvcGVydGllcy5vcGFjaXR5ICE9PSAxKSB7IGNvbnRleHQuZ2xvYmFsQWxwaGEgPSAxOyB9XG5cdH0sXG5cblx0ZGVidWdEcmF3OiBmdW5jdGlvbiAoJGNsZWFyKVxuXHR7XG5cdFx0aWYgKCRjbGVhciAhPT0gdW5kZWZpbmVkKSB7IHRoaXMuZGVidWdDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7IH1cblxuXHRcdHRoaXMuZGVidWdDb250ZXh0LnN0cm9rZVN0eWxlID0gJ3llbGxvdyc7XG5cdFx0dGhpcy5kZWJ1Z0NvbnRleHQubGluZUNhcCA9ICdidXR0Jztcblx0XHR0aGlzLmRlYnVnQ29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7XG5cdFx0dGhpcy5kZWJ1Z0NvbnRleHQubGluZVdpZHRoID0gMTtcblx0XHR0aGlzLmRlYnVnQ29udGV4dC5iZWdpblBhdGgoKTtcblx0XHR2YXIgY3Vyckdyb3VwO1xuXHRcdHZhciBpO1xuXHRcdHZhciBrO1xuXHRcdHZhciBncm91cHNMZW5ndGggPSB0aGlzLndvcmxkLmdyb3Vwcy5sZW5ndGg7XG5cdFx0dmFyIG5vZGVzTGVuZ3RoO1xuXHRcdGZvciAoayA9IDA7IGsgPCBncm91cHNMZW5ndGg7IGsgKz0gMSlcblx0XHR7XG5cdFx0XHRjdXJyR3JvdXAgPSB0aGlzLndvcmxkLmdyb3Vwc1trXTtcblxuXHRcdFx0bm9kZXNMZW5ndGggPSBjdXJyR3JvdXAubm9kZXMubGVuZ3RoO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjdXJyTm9kZSA9IGN1cnJHcm91cC5ub2Rlc1tpXTtcblx0XHRcdFx0dGhpcy5kZWJ1Z0NvbnRleHQubW92ZVRvKGN1cnJOb2RlLmdldFgoKSAqIHRoaXMuc2NhbGVYLCBjdXJyTm9kZS5nZXRZKCkgKiB0aGlzLnNjYWxlWSk7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBjdXJyR3JvdXAuc3RydWN0dXJlLmlubmVyUmFkaXVzIHx8IGN1cnJHcm91cC5jb25mLm5vZGVSYWRpdXMgfHwgY3Vyckdyb3VwLnN0cnVjdHVyZS5yYWRpdXNYIHx8IDAuMDE7XG5cdFx0XHRcdHJhZGl1cyAqPSB0aGlzLnNjYWxlWDtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coY3Vyckdyb3VwLnN0cnVjdHVyZS5pbm5lclJhZGl1cywgY3Vyckdyb3VwLmNvbmYubm9kZVJhZGl1cywgY3Vyckdyb3VwLnN0cnVjdHVyZS5yYWRpdXNYKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cocmFkaXVzKTtcblx0XHRcdFx0Ly8gZGVidWdnZXI7XG5cdFx0XHRcdHRoaXMuZGVidWdDb250ZXh0LmFyYyhjdXJyTm9kZS5nZXRYKCkgKiB0aGlzLnNjYWxlWCwgY3Vyck5vZGUuZ2V0WSgpICogdGhpcy5zY2FsZVksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmRlYnVnQ29udGV4dC5zdHJva2UoKTtcblxuXHRcdHRoaXMuZGVidWdDb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDEsMSwxKSc7XG5cdFx0dGhpcy5kZWJ1Z0NvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0Zm9yIChrID0gMDsgayA8IGdyb3Vwc0xlbmd0aDsgayArPSAxKVxuXHRcdHtcblx0XHRcdGN1cnJHcm91cCA9IHRoaXMud29ybGQuZ3JvdXBzW2tdO1xuXHRcdFx0dmFyIGpvaW50c0xlbmd0aCA9IGN1cnJHcm91cC5qb2ludHMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgam9pbnRzTGVuZ3RoOyBpICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjdXJySm9pbnQgPSBjdXJyR3JvdXAuam9pbnRzW2ldO1xuXHRcdFx0XHR0aGlzLmRlYnVnQ29udGV4dC5tb3ZlVG8oY3VyckpvaW50Lm5vZGUxLmdldFgoKSAqIHRoaXMuc2NhbGVYLCBjdXJySm9pbnQubm9kZTEuZ2V0WSgpICogdGhpcy5zY2FsZVkpO1xuXHRcdFx0XHR0aGlzLmRlYnVnQ29udGV4dC5saW5lVG8oY3VyckpvaW50Lm5vZGUyLmdldFgoKSAqIHRoaXMuc2NhbGVYLCBjdXJySm9pbnQubm9kZTIuZ2V0WSgpICogdGhpcy5zY2FsZVkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmRlYnVnQ29udGV4dC5zdHJva2UoKTtcblxuXHRcdHRoaXMuZGVidWdDb250ZXh0LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuXHRcdHRoaXMuZGVidWdDb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLndvcmxkLmdyb3VwQ29uc3RyYWludHMubGVuZ3RoO1xuXHRcdGZvciAoayA9IDA7IGsgPCBsZW5ndGg7IGsgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3VyckxvY2sgPSB0aGlzLndvcmxkLmdyb3VwQ29uc3RyYWludHNba107XG5cdFx0XHR0aGlzLmRlYnVnQ29udGV4dC5tb3ZlVG8oY3VyckxvY2suYW5jaG9yQS5nZXRYKCkgKiB0aGlzLnNjYWxlWCwgY3VyckxvY2suYW5jaG9yQS5nZXRZKCkgKiB0aGlzLnNjYWxlWSk7XG5cdFx0XHR0aGlzLmRlYnVnQ29udGV4dC5saW5lVG8oY3VyckxvY2suYW5jaG9yQi5nZXRYKCkgKiB0aGlzLnNjYWxlWCwgY3VyckxvY2suYW5jaG9yQi5nZXRZKCkgKiB0aGlzLnNjYWxlWSk7XG5cdFx0fVxuXHRcdHRoaXMuZGVidWdDb250ZXh0LnN0cm9rZSgpO1xuXG5cdFx0dGhpcy5kZWJ1Z0NvbnRleHQuZmlsbFN0eWxlID0gJ2JsYWNrJztcblx0XHRmb3IgKGsgPSAwOyBrIDwgZ3JvdXBzTGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGdyb3VwID0gdGhpcy53b3JsZC5ncm91cHNba107XG5cdFx0XHRub2Rlc0xlbmd0aCA9IGdyb3VwLm5vZGVzLmxlbmd0aDtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSArPSAxKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgbm9kZSA9IGdyb3VwLm5vZGVzW2ldO1xuXHRcdFx0XHRpZiAobm9kZS5kZWJ1Z1RleHQpIHsgdGhpcy5kZWJ1Z0NvbnRleHQuZmlsbFRleHQobm9kZS5kZWJ1Z1RleHQsIG5vZGUuZ2V0WCgpICogdGhpcy5zY2FsZVgsIG5vZGUuZ2V0WSgpICogdGhpcy5zY2FsZVkpOyB9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWSmVsbHlSZW5kZXJlcjtcblxuIiwidmFyIFNWSmVsbHlXb3JsZCA9IHJlcXVpcmUoJy4vY29yZS9TVkplbGx5V29ybGQnKTtcbnZhciBTVkplbGx5UmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVyL3N2amVsbHkvU1ZKZWxseVJlbmRlcmVyJyk7XG52YXIgU1ZHUGFyc2VyID0gcmVxdWlyZSgnLi9jb3JlL1NWR1BhcnNlcicpO1xudmFyIFAyUGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL3BoeXNpY3MvcDJwaHlzaWNzL1AyUGh5c2ljc01hbmFnZXInKTtcbnZhciBTVkplbGx5VXRpbHMgPSByZXF1aXJlKCcuL2NvcmUvU1ZKZWxseVV0aWxzJyk7XG52YXIgY29uZk9iamVjdCA9IHJlcXVpcmUoJy4vY29yZS9Db25mT2JqZWN0Jyk7XG5cbnZhciByZXF1ZXN0QW5pbUZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0XHRcdFx0d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0XHRcdFx0d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxudmFyIGNhbmNlbEFuaW1GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0XHRcdFx0d2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHRcdFx0XHR3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cbi8vVE9ETyBwcm9taXNlIHBvbHlmaWxsXG52YXIgU1ZKZWxseU1ha2VyID1cbntcblx0Y3JlYXRlRnJvbVVSTDogZnVuY3Rpb24gKCRjYW52YXMsICRVUkwsICRwaHlzaWNzTWFuYWdlciwgJFJlbmRlcmVyKVxuXHR7XG5cdFx0dmFyIHN2amVsbHlNYWtlciA9IE9iamVjdC5jcmVhdGUoU1ZKZWxseU1ha2VyKTtcblx0XHRzdmplbGx5TWFrZXIuY2FudmFzID0gJGNhbnZhcztcblx0XHRzdmplbGx5TWFrZXIuUmVuZGVyZXIgPSAkUmVuZGVyZXI7XG5cdFx0c3ZqZWxseU1ha2VyLnBoeXNpY3NNYW5hZ2VyID0gJHBoeXNpY3NNYW5hZ2VyO1xuXHRcdHN2amVsbHlNYWtlci5wcm9taXNlID0gbmV3IHdpbmRvdy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKVxuXHRcdHtcblx0XHRcdHN2amVsbHlNYWtlci5sb2FkRmlsZSgkVVJMLCBmdW5jdGlvbiAoJFNWRylcblx0XHRcdHtcblx0XHRcdFx0c3ZqZWxseU1ha2VyLmNyZWF0ZSgkY2FudmFzLCAkU1ZHKTtcblx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0fSwgdHJ1ZSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHN2amVsbHlNYWtlcjtcblx0fSxcblx0Y3JlYXRlRnJvbUNvbmZpZzogZnVuY3Rpb24gKCRjYW52YXMsICRjb25maWdVUkwsICRwaHlzaWNzTWFuYWdlciwgJFJlbmRlcmVyKVxuXHR7XG5cdFx0dmFyIHN2amVsbHlNYWtlciA9IE9iamVjdC5jcmVhdGUoU1ZKZWxseU1ha2VyKTtcblx0XHRzdmplbGx5TWFrZXIuY2FudmFzID0gJGNhbnZhcztcblx0XHRzdmplbGx5TWFrZXIuUmVuZGVyZXIgPSAkUmVuZGVyZXI7XG5cdFx0c3ZqZWxseU1ha2VyLnBoeXNpY3NNYW5hZ2VyID0gJHBoeXNpY3NNYW5hZ2VyO1xuXG5cdFx0c3ZqZWxseU1ha2VyLnByb21pc2UgPSBuZXcgd2luZG93LlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpXG5cdFx0e1xuXHRcdFx0dmFyIGxvYWRDb25maWdDb21wbGV0ZSA9IGZ1bmN0aW9uICgkY29uZmlnRGF0YSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIEpTT05Db25maWcgPSBKU09OLnBhcnNlKCRjb25maWdEYXRhKTtcblx0XHRcdFx0c3ZqZWxseU1ha2VyLmNvbmYgPSBTVkplbGx5VXRpbHMuZXh0ZW5kKGNvbmZPYmplY3QsIEpTT05Db25maWcpO1xuXG5cdFx0XHRcdFNWSmVsbHlNYWtlci5sb2FkRmlsZShzdmplbGx5TWFrZXIuY29uZi5zb3VyY2UsIGZ1bmN0aW9uICgkU1ZHKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3ZqZWxseU1ha2VyLmNyZWF0ZSgkY2FudmFzLCAkU1ZHKTtcblx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdH0sIHRydWUpO1xuXHRcdFx0fTtcblx0XHRcdFNWSmVsbHlNYWtlci5sb2FkRmlsZSgkY29uZmlnVVJMLCBsb2FkQ29uZmlnQ29tcGxldGUpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHN2amVsbHlNYWtlcjtcblx0fSxcblx0Y3JlYXRlRnJvbVN0cmluZzogZnVuY3Rpb24gKCRjYW52YXMsICRzdHJpbmcpXG5cdHtcblx0XHR2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdHZhciBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKCRzdHJpbmcsICdpbWFnZS9zdmcreG1sJyk7XG5cdFx0dmFyIHN2amVsbHlNYWtlciA9IE9iamVjdC5jcmVhdGUoU1ZKZWxseU1ha2VyKTtcblx0XHRzdmplbGx5TWFrZXIucHJvbWlzZSA9IG5ldyB3aW5kb3cuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSlcblx0XHR7XG5cdFx0XHRzdmplbGx5TWFrZXIuY3JlYXRlKCRjYW52YXMsIGRvYyk7XG5cdFx0XHRyZXNvbHZlKCk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHN2amVsbHlNYWtlcjtcblx0fSxcblx0Y3JlYXRlRnJvbVBhZ2VTVkc6IGZ1bmN0aW9uICgkcGh5c2ljc01hbmFnZXIsICRSZW5kZXJlcilcblx0e1xuXHRcdHZhciBzdmplbGxpZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zdmplbGx5XScpO1xuXG5cdFx0dmFyIGNyZWF0ZVZpZXdlciA9IGZ1bmN0aW9uICgkZWxlbWVudClcblx0XHR7XG5cdFx0XHR2YXIgc3ZqZWxseU1ha2VyID0gT2JqZWN0LmNyZWF0ZShTVkplbGx5TWFrZXIpO1xuXHRcdFx0dmFyIGN1cnJTVkcgPSAkZWxlbWVudDtcblx0XHRcdHZhciBhcHBlbmRDYW52YXMgPSBmdW5jdGlvbiAoJGNvbmZpZylcblx0XHRcdHtcblx0XHRcdFx0c3ZqZWxseU1ha2VyLmNvbmYgPSAkY29uZmlnO1xuXHRcdFx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IGN1cnJTVkcuY2xpZW50V2lkdGg7XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBjdXJyU1ZHLmNsaWVudEhlaWdodDtcblx0XHRcdFx0Y3VyclNWRy5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShjYW52YXMsIGN1cnJTVkcpO1xuXHRcdFx0XHRjdXJyU1ZHLnJlbW92ZSgpO1xuXHRcdFx0XHRzdmplbGx5TWFrZXIuY2FudmFzID0gY2FudmFzO1xuXHRcdFx0XHRzdmplbGx5TWFrZXIuUmVuZGVyZXIgPSAkUmVuZGVyZXI7XG5cdFx0XHRcdHN2amVsbHlNYWtlci5waHlzaWNzTWFuYWdlciA9ICRwaHlzaWNzTWFuYWdlcjtcblx0XHRcdFx0dmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdFx0d3JhcHBlci5hcHBlbmRDaGlsZChjdXJyU1ZHKTtcblx0XHRcdFx0c3ZqZWxseU1ha2VyLmNyZWF0ZShjYW52YXMsIHdyYXBwZXIpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBjb25maWdVUkwgPSBjdXJyU1ZHLmdldEF0dHJpYnV0ZSgnZGF0YS1zdmplbGx5Jyk7XG5cdFx0XHRpZiAoY29uZmlnVVJMKVxuXHRcdFx0e1xuXHRcdFx0XHRTVkplbGx5TWFrZXIubG9hZEZpbGUoY29uZmlnVVJMLCBmdW5jdGlvbiAoJGNvbmZpZ0RhdGEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgSlNPTkNvbmZpZyA9IEpTT04ucGFyc2UoJGNvbmZpZ0RhdGEpO1xuXHRcdFx0XHRcdGFwcGVuZENhbnZhcyhTVkplbGx5VXRpbHMuZXh0ZW5kKGNvbmZPYmplY3QsIEpTT05Db25maWcpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGFwcGVuZENhbnZhcygpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3ZqZWxsaWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyU1ZHID0gc3ZqZWxsaWVzW2ldO1xuXHRcdFx0Y3JlYXRlVmlld2VyKGN1cnJTVkcpO1xuXHRcdH1cblx0fSxcblxuXHRjcmVhdGU6IGZ1bmN0aW9uICgkY2FudmFzLCAkU1ZHKVxuXHR7XG5cdFx0dmFyIGNvbmYgPSB0aGlzLmNvbmYgfHwgY29uZk9iamVjdDtcblx0XHR0aGlzLmNhbnZhcyA9ICRjYW52YXM7XG5cblx0XHR0aGlzLnBoeXNpY3NNYW5hZ2VyID0gdGhpcy5waHlzaWNzTWFuYWdlciB8fCBuZXcgUDJQaHlzaWNzTWFuYWdlcihjb25mKTtcblx0XHR2YXIgc3ZqZWxseVdvcmxkID0gdGhpcy5zdmplbGx5V29ybGQgPSBuZXcgU1ZKZWxseVdvcmxkKHRoaXMucGh5c2ljc01hbmFnZXIsIGNvbmYpO1xuXG5cdFx0dmFyIGNhbnZhc0RlZmluaXRpb24gPSBjb25mLmRlZmluaXRpb247XG5cdFx0dmFyIHN2Z0RlZiA9ICRTVkcucXVlcnlTZWxlY3Rvcignc3ZnJyk7XG5cdFx0dmFyIHBhcnNlciA9IG5ldyBTVkdQYXJzZXIoKTtcblx0XHRwYXJzZXIucGFyc2Uoc3ZqZWxseVdvcmxkLCBzdmdEZWYpO1xuXHRcdHZhciBjYW52YXNXaWR0aCA9IHRoaXMuY2FudmFzLmNsaWVudFdpZHRoICogY2FudmFzRGVmaW5pdGlvbjtcblx0XHR2YXIgY2FudmFzSGVpZ2h0ID0gdGhpcy5jYW52YXMuY2xpZW50V2lkdGggKiAocGFyc2VyLnZpZXdCb3hIZWlnaHQgLyBwYXJzZXIudmlld0JveFdpZHRoKSAqIGNhbnZhc0RlZmluaXRpb247XG5cblx0XHR0aGlzLmNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuXHRcdHRoaXMuY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcblx0XHR0aGlzLmNhbnZhcy5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAwJztcblx0XHR0aGlzLmNhbnZhcy5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoJyArIDEgLyBjYW52YXNEZWZpbml0aW9uICsgJyknO1xuXG5cdFx0dGhpcy5yZW5kZXJlciA9IHRoaXMuUmVuZGVyZXIgPyB0aGlzLlJlbmRlcmVyLmNyZWF0ZShzdmplbGx5V29ybGQsIHRoaXMuY2FudmFzKSA6IFNWSmVsbHlSZW5kZXJlci5jcmVhdGUoc3ZqZWxseVdvcmxkLCB0aGlzLmNhbnZhcyk7XG5cblx0XHR2YXIgcmVxdWVzdElEID0gJyc7XG5cdFx0dmFyIGxhc3RSZW5kZXIgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0dmFyIGRpZmZSZW5kZXI7XG5cdFx0dmFyIHJlbmRlclRhcmdldEZQUyA9IDA7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dmFyIHVwZGF0ZSA9IGZ1bmN0aW9uICgkbm93KVxuXHRcdHtcblx0XHRcdGlmICh0aGF0LnVwZGF0ZUNhbGxiYWNrKSB7IHRoYXQudXBkYXRlQ2FsbGJhY2soJG5vdyk7IH1cblxuXHRcdFx0ZGlmZlJlbmRlciA9ICRub3cgLSBsYXN0UmVuZGVyO1xuXG5cdFx0XHR0aGF0LnN2amVsbHlXb3JsZC5waHlzaWNzTWFuYWdlci5zdGVwKCRub3cpO1xuXHRcdFx0aWYgKGRpZmZSZW5kZXIgPj0gcmVuZGVyVGFyZ2V0RlBTKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGF0LnJlbmRlcmVyLmRyYXcoKTtcblx0XHRcdFx0bGFzdFJlbmRlciA9ICRub3c7XG5cdFx0XHR9XG5cdFx0XHRyZXF1ZXN0SUQgPSByZXF1ZXN0QW5pbUZyYW1lKHVwZGF0ZSk7XG5cdFx0fTtcblxuXHRcdHZhciBhZGRBbmltUmVxdWVzdCA9IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHJlcXVlc3RJRCk7XG5cdFx0XHRyZXF1ZXN0SUQgPSByZXF1ZXN0QW5pbUZyYW1lKHVwZGF0ZSk7XG5cdFx0fTtcblx0XHR2YXIgY2FuY2VsQW5pbVJlcXVlc3QgPSBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdGNhbmNlbEFuaW1GcmFtZShyZXF1ZXN0SUQpO1xuXHRcdH07XG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBhZGRBbmltUmVxdWVzdCk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBjYW5jZWxBbmltUmVxdWVzdCk7XG5cdFx0YWRkQW5pbVJlcXVlc3QoKTtcblxuXHRcdHRoaXMucmVtb3ZlID0gZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRjYW5jZWxBbmltUmVxdWVzdCgpO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgYWRkQW5pbVJlcXVlc3QpO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBjYW5jZWxBbmltUmVxdWVzdCk7XG5cdFx0fTtcblx0fSxcblxuXHRsb2FkRmlsZTogZnVuY3Rpb24gKCRVUkwsICRzdWNjZXNzQ2FsbGJhY2ssICRYTUwpXG5cdHtcblx0XHR2YXIgZXJyb3IgPSBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdGNvbnNvbGUubG9nKCdlcnJvcicsICRVUkwpO1xuXHRcdH07XG5cblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0JHN1Y2Nlc3NDYWxsYmFjaygkWE1MID8gdGhpcy5yZXNwb25zZVhNTCA6IHRoaXMucmVzcG9uc2VUZXh0KTtcblx0XHR9O1xuXG5cdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVyKTtcblx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuXHRcdHJlcXVlc3Qub3BlbignZ2V0JywgJFVSTCwgdHJ1ZSk7XG5cdFx0cmVxdWVzdC5zZW5kKCk7XG5cdH0sXG5cblx0YWRkQmFzaWNNb3VzZUNvbnRyb2xzOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIHdvcmxkID0gdGhpcy5zdmplbGx5V29ybGQ7XG5cdFx0dmFyIHAyID0gd29ybGQucGh5c2ljc01hbmFnZXIucDI7XG5cdFx0dmFyIHAyV29ybGQgPSB3b3JsZC5waHlzaWNzTWFuYWdlci5wMldvcmxkO1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLnJlbmRlcmVyLmNvbnRhaW5lcjtcblxuXHRcdC8vTU9VU0Vcblx0XHR2YXIgbW91c2VCb2R5ID0gbmV3IHAyLkJvZHkoKTtcblx0XHRwMldvcmxkLmFkZEJvZHkobW91c2VCb2R5KTtcblxuXHRcdHZhciBtb3VzZUNvbnN0cmFpbnQ7XG5cdFx0dmFyIGJvZGllcyA9IHAyV29ybGQuYm9kaWVzLmNvbmNhdCgpO1xuXHRcdHZhciBib2R5O1xuXHRcdHZhciBzY2FsZSA9IHRoaXMucmVuZGVyZXIuc2NhbGVYO1xuXHRcdHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cblx0XHR2YXIgZ2V0UGh5c2ljc0Nvb3JkID0gZnVuY3Rpb24gKG1vdXNlRXZlbnQpXG5cdFx0e1xuXHRcdFx0dmFyIHggPSBtb3VzZUV2ZW50LmNsaWVudFggLSBjb250YWluZXIub2Zmc2V0TGVmdDtcblx0XHRcdHZhciB5ID0gbW91c2VFdmVudC5jbGllbnRZIC0gY29udGFpbmVyLm9mZnNldFRvcDtcblxuXHRcdFx0eCA9IHggLyBzY2FsZTtcblx0XHRcdC8vIGNvbnNvbGUubG9nKGNvbnRhaW5lci5vZmZzZXRMZWZ0LCBjb250YWluZXIub2Zmc2V0VG9wLCBtb3VzZUV2ZW50LmNsaWVudFgsIG1vdXNlRXZlbnQuY2xpZW50WSwgc2NhbGUpO1xuXHRcdFx0eSA9IChyZW5kZXJlci5oZWlnaHQgLSB5KSAvIHNjYWxlO1xuXHRcdFx0cmV0dXJuIFt4LCB5XTtcblx0XHR9O1xuXG5cdFx0dmFyIG1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudClcblx0XHR7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRQaHlzaWNzQ29vcmQoZXZlbnQpO1xuXHRcdFx0bW91c2VCb2R5LnBvc2l0aW9uWzBdID0gcG9zaXRpb25bMF07XG5cdFx0XHRtb3VzZUJvZHkucG9zaXRpb25bMV0gPSBwb3NpdGlvblsxXTtcblx0XHR9O1xuXG5cdFx0dmFyIG1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudClcblx0XHR7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRQaHlzaWNzQ29vcmQoZXZlbnQpO1xuXG5cdFx0XHQvLyBDaGVjayBpZiB0aGUgY3Vyc29yIGlzIGluc2lkZSB0aGUgYm94XG5cdFx0XHR2YXIgaGl0Qm9kaWVzID0gcDJXb3JsZC5oaXRUZXN0KHBvc2l0aW9uLCBib2RpZXMpO1xuXG5cdFx0XHRpZiAoaGl0Qm9kaWVzLmxlbmd0aClcblx0XHRcdHtcblx0XHRcdFx0Ym9keSA9IGhpdEJvZGllc1swXTtcblx0XHRcdFx0Ly8gTW92ZSB0aGUgbW91c2UgYm9keSB0byB0aGUgY3Vyc29yIHBvc2l0aW9uXG5cblx0XHRcdFx0bW91c2VCb2R5LnBvc2l0aW9uWzBdID0gcG9zaXRpb25bMF07XG5cdFx0XHRcdG1vdXNlQm9keS5wb3NpdGlvblsxXSA9IHBvc2l0aW9uWzFdO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSBhIFJldm9sdXRlQ29uc3RyYWludC5cblx0XHRcdFx0Ly8gVGhpcyBjb25zdHJhaW50IGxldHMgdGhlIGJvZGllcyByb3RhdGUgYXJvdW5kIGEgY29tbW9uIHBvaW50XG5cdFx0XHRcdG1vdXNlQ29uc3RyYWludCA9IG5ldyBwMi5SZXZvbHV0ZUNvbnN0cmFpbnQobW91c2VCb2R5LCBib2R5LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0d29ybGRQaXZvdDogcG9zaXRpb24sXG5cdFx0XHRcdFx0Y29sbGlkZUNvbm5lY3RlZDogZmFsc2Vcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHAyV29ybGQuYWRkQ29uc3RyYWludChtb3VzZUNvbnN0cmFpbnQpO1xuXHRcdFx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VNb3ZlKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIG1vdXNlVXAgPSBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHAyV29ybGQucmVtb3ZlQ29uc3RyYWludChtb3VzZUNvbnN0cmFpbnQpO1xuXHRcdFx0bW91c2VDb25zdHJhaW50ID0gbnVsbDtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZU1vdmUpO1xuXHRcdH07XG5cblx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duKTtcblx0XHQvLyBSZW1vdmUgdGhlIG1vdXNlIGNvbnN0cmFpbnQgb24gbW91c2UgdXBcblx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlVXApO1xuXG5cdFx0dGhpcy5yZW1vdmVCYXNpY01vdXNlQ29udHJvbHMgPSBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZU1vdmUpO1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bik7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlVXApO1xuXHRcdH07XG5cdH1cbn07XG5cbmlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zdmplbGx5LWF1dG9dJykpXG57XG5cdHZhciB3aW5kb3dMb2FkSGFuZGxlciA9IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRTVkplbGx5TWFrZXIuY3JlYXRlRnJvbVBhZ2VTVkcoKTtcblx0fTtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB3aW5kb3dMb2FkSGFuZGxlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZKZWxseU1ha2VyO1xuIl19

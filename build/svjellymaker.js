(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.svjellymaker = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/Lau/www/svjelly/libs/p2.js":[function(require,module,exports){
(function (global){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 p2.js authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&false)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.p2=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
var Scalar = _dereq_('./Scalar');

module.exports = Line;

/**
 * Container for line-related functions
 * @class Line
 */
function Line(){};

/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
Line.lineInt = function(l1,l2,precision){
    precision = precision || 0;
    var i = [0,0]; // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2*b1;
    if (!Scalar.eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
};

/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
Line.segmentsIntersect = function(p1, p2, q1, q2){
   var dx = p2[0] - p1[0];
   var dy = p2[1] - p1[1];
   var da = q2[0] - q1[0];
   var db = q2[1] - q1[1];

   // segments are parallel
   if(da*dy - db*dx == 0)
      return false;

   var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx)
   var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy)

   return (s>=0 && s<=1 && t>=0 && t<=1);
};


},{"./Scalar":4}],2:[function(_dereq_,module,exports){
module.exports = Point;

/**
 * Point related functions
 * @class Point
 */
function Point(){};

/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
Point.area = function(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));
};

Point.left = function(a,b,c){
    return Point.area(a,b,c) > 0;
};

Point.leftOn = function(a,b,c) {
    return Point.area(a, b, c) >= 0;
};

Point.right = function(a,b,c) {
    return Point.area(a, b, c) < 0;
};

Point.rightOn = function(a,b,c) {
    return Point.area(a, b, c) <= 0;
};

var tmpPoint1 = [],
    tmpPoint2 = [];

/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
Point.collinear = function(a,b,c,thresholdAngle) {
    if(!thresholdAngle)
        return Point.area(a, b, c) == 0;
    else {
        var ab = tmpPoint1,
            bc = tmpPoint2;

        ab[0] = b[0]-a[0];
        ab[1] = b[1]-a[1];
        bc[0] = c[0]-b[0];
        bc[1] = c[1]-b[1];

        var dot = ab[0]*bc[0] + ab[1]*bc[1],
            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),
            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),
            angle = Math.acos(dot/(magA*magB));
        return angle < thresholdAngle;
    }
};

Point.sqdist = function(a,b){
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
};

},{}],3:[function(_dereq_,module,exports){
var Line = _dereq_("./Line")
,   Point = _dereq_("./Point")
,   Scalar = _dereq_("./Scalar")

module.exports = Polygon;

/**
 * Polygon class.
 * @class Polygon
 * @constructor
 */
function Polygon(){

    /**
     * Vertices that this polygon consists of. An array of array of numbers, example: [[0,0],[1,0],..]
     * @property vertices
     * @type {Array}
     */
    this.vertices = [];
}

/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
Polygon.prototype.at = function(i){
    var v = this.vertices,
        s = v.length;
    return v[i < 0 ? i % s + s : i % s];
};

/**
 * Get first vertex
 * @method first
 * @return {Array}
 */
Polygon.prototype.first = function(){
    return this.vertices[0];
};

/**
 * Get last vertex
 * @method last
 * @return {Array}
 */
Polygon.prototype.last = function(){
    return this.vertices[this.vertices.length-1];
};

/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
Polygon.prototype.clear = function(){
    this.vertices.length = 0;
};

/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
Polygon.prototype.append = function(poly,from,to){
    if(typeof(from) == "undefined") throw new Error("From is not given!");
    if(typeof(to) == "undefined")   throw new Error("To is not given!");

    if(to-1 < from)                 throw new Error("lol1");
    if(to > poly.vertices.length)   throw new Error("lol2");
    if(from < 0)                    throw new Error("lol3");

    for(var i=from; i<to; i++){
        this.vertices.push(poly.vertices[i]);
    }
};

/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
Polygon.prototype.makeCCW = function(){
    var br = 0,
        v = this.vertices;

    // find bottom right point
    for (var i = 1; i < this.vertices.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] == v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }

    // reverse poly if clockwise
    if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {
        this.reverse();
    }
};

/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
Polygon.prototype.reverse = function(){
    var tmp = [];
    for(var i=0, N=this.vertices.length; i!==N; i++){
        tmp.push(this.vertices.pop());
    }
    this.vertices = tmp;
};

/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
Polygon.prototype.isReflex = function(i){
    return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));
};

var tmpLine1=[],
    tmpLine2=[];

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
Polygon.prototype.canSee = function(a,b) {
    var p, dist, l1=tmpLine1, l2=tmpLine2;

    if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {
        return false;
    }
    dist = Point.sqdist(this.at(a), this.at(b));
    for (var i = 0; i !== this.vertices.length; ++i) { // for each edge
        if ((i + 1) % this.vertices.length === a || i === a) // ignore incident edges
            continue;
        if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) { // if diag intersects an edge
            l1[0] = this.at(a);
            l1[1] = this.at(b);
            l2[0] = this.at(i);
            l2[1] = this.at(i + 1);
            p = Line.lineInt(l1,l2);
            if (Point.sqdist(this.at(a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }

    return true;
};

/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
Polygon.prototype.copy = function(i,j,targetPoly){
    var p = targetPoly || new Polygon();
    p.clear();
    if (i < j) {
        // Insert all vertices from i to j
        for(var k=i; k<=j; k++)
            p.vertices.push(this.vertices[k]);

    } else {

        // Insert vertices 0 to j
        for(var k=0; k<=j; k++)
            p.vertices.push(this.vertices[k]);

        // Insert vertices i to end
        for(var k=i; k<this.vertices.length; k++)
            p.vertices.push(this.vertices[k]);
    }

    return p;
};

/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
Polygon.prototype.getCutEdges = function() {
    var min=[], tmp1=[], tmp2=[], tmpPoly = new Polygon();
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < this.vertices.length; ++i) {
        if (this.isReflex(i)) {
            for (var j = 0; j < this.vertices.length; ++j) {
                if (this.canSee(i, j)) {
                    tmp1 = this.copy(i, j, tmpPoly).getCutEdges();
                    tmp2 = this.copy(j, i, tmpPoly).getCutEdges();

                    for(var k=0; k<tmp2.length; k++)
                        tmp1.push(tmp2[k]);

                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        min.push([this.at(i), this.at(j)]);
                    }
                }
            }
        }
    }

    return min;
};

/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
Polygon.prototype.decomp = function(){
    var edges = this.getCutEdges();
    if(edges.length > 0)
        return this.slice(edges);
    else
        return [this];
};

/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
Polygon.prototype.slice = function(cutEdges){
    if(cutEdges.length == 0) return [this];
    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length==2 && cutEdges[0][0] instanceof Array){

        var polys = [this];

        for(var i=0; i<cutEdges.length; i++){
            var cutEdge = cutEdges[i];
            // Cut all polys
            for(var j=0; j<polys.length; j++){
                var poly = polys[j];
                var result = poly.slice(cutEdge);
                if(result){
                    // Found poly! Cut and quit
                    polys.splice(j,1);
                    polys.push(result[0],result[1]);
                    break;
                }
            }
        }

        return polys;
    } else {

        // Was given one edge
        var cutEdge = cutEdges;
        var i = this.vertices.indexOf(cutEdge[0]);
        var j = this.vertices.indexOf(cutEdge[1]);

        if(i != -1 && j != -1){
            return [this.copy(i,j),
                    this.copy(j,i)];
        } else {
            return false;
        }
    }
};

/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
Polygon.prototype.isSimple = function(){
    var path = this.vertices;
    // Check
    for(var i=0; i<path.length-1; i++){
        for(var j=0; j<i-1; j++){
            if(Line.segmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){
                return false;
            }
        }
    }

    // Check the segment between the last and the first point to all others
    for(var i=1; i<path.length-2; i++){
        if(Line.segmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){
            return false;
        }
    }

    return true;
};

function getIntersectionPoint(p1, p2, q1, q2, delta){
    delta = delta || 0;
   var a1 = p2[1] - p1[1];
   var b1 = p1[0] - p2[0];
   var c1 = (a1 * p1[0]) + (b1 * p1[1]);
   var a2 = q2[1] - q1[1];
   var b2 = q1[0] - q2[0];
   var c2 = (a2 * q1[0]) + (b2 * q1[1]);
   var det = (a1 * b2) - (a2 * b1);

   if(!Scalar.eq(det,0,delta))
      return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det]
   else
      return [0,0]
}

/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
Polygon.prototype.quickDecomp = function(result,reflexVertices,steinerPoints,delta,maxlevel,level){
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof(result)!="undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];

    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points
    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars
    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers
    var lowerPoly=new Polygon(), upperPoly=new Polygon(); // polygons
    var poly = this,
        v = this.vertices;

    if(v.length < 3) return result;

    level++;
    if(level > maxlevel){
        console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }

    for (var i = 0; i < this.vertices.length; ++i) {
        if (poly.isReflex(i)) {
            reflexVertices.push(poly.vertices[i]);
            upperDist = lowerDist = Number.MAX_VALUE;


            for (var j = 0; j < this.vertices.length; ++j) {
                if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j))
                        && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1)); // find the point of intersection
                    if (Point.right(poly.at(i + 1), poly.at(i), p)) { // make sure it's inside the poly
                        d = Point.sqdist(poly.vertices[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1))
                        && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                    p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));
                    if (Point.left(poly.at(i - 1), poly.at(i), p)) {
                        d = Point.sqdist(poly.vertices[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }

            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex == (upperIndex + 1) % this.vertices.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+this.vertices.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);

                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    lowerPoly.append(poly, i, upperIndex+1);
                    lowerPoly.vertices.push(p);
                    upperPoly.vertices.push(p);
                    if (lowerIndex != 0){
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        upperPoly.append(poly,lowerIndex,poly.vertices.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    upperPoly.append(poly,0,i+1);
                } else {
                    if (i != 0){
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        lowerPoly.append(poly,i,poly.vertices.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    lowerPoly.append(poly,0,upperIndex+1);
                    lowerPoly.vertices.push(p);
                    upperPoly.vertices.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    upperPoly.append(poly,lowerIndex,i+1);
                }
            } else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+this.vertices.length+")\n");

                if (lowerIndex > upperIndex) {
                    upperIndex += this.vertices.length;
                }
                closestDist = Number.MAX_VALUE;

                if(upperIndex < lowerIndex){
                    return result;
                }

                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j))
                            && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                        d = Point.sqdist(poly.at(i), poly.at(j));
                        if (d < closestDist) {
                            closestDist = d;
                            closestIndex = j % this.vertices.length;
                        }
                    }
                }

                if (i < closestIndex) {
                    lowerPoly.append(poly,i,closestIndex+1);
                    if (closestIndex != 0){
                        upperPoly.append(poly,closestIndex,v.length);
                    }
                    upperPoly.append(poly,0,i+1);
                } else {
                    if (i != 0){
                        lowerPoly.append(poly,i,v.length);
                    }
                    lowerPoly.append(poly,0,closestIndex+1);
                    upperPoly.append(poly,closestIndex,i+1);
                }
            }

            // solve smallest poly first
            if (lowerPoly.vertices.length < upperPoly.vertices.length) {
                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
            } else {
                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
            }

            return result;
        }
    }
    result.push(this);

    return result;
};

/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
Polygon.prototype.removeCollinearPoints = function(precision){
    var num = 0;
    for(var i=this.vertices.length-1; this.vertices.length>3 && i>=0; --i){
        if(Point.collinear(this.at(i-1),this.at(i),this.at(i+1),precision)){
            // Remove the middle point
            this.vertices.splice(i%this.vertices.length,1);
            i--; // Jump one point forward. Otherwise we may get a chain removal
            num++;
        }
    }
    return num;
};

},{"./Line":1,"./Point":2,"./Scalar":4}],4:[function(_dereq_,module,exports){
module.exports = Scalar;

/**
 * Scalar functions
 * @class Scalar
 */
function Scalar(){}

/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
Scalar.eq = function(a,b,precision){
    precision = precision || 0;
    return Math.abs(a-b) < precision;
};

},{}],5:[function(_dereq_,module,exports){
module.exports = {
    Polygon : _dereq_("./Polygon"),
    Point : _dereq_("./Point"),
};

},{"./Point":2,"./Polygon":3}],6:[function(_dereq_,module,exports){
module.exports={
  "name": "p2",
  "version": "0.6.1",
  "description": "A JavaScript 2D physics engine.",
  "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
  "keywords": [
    "p2.js",
    "p2",
    "physics",
    "engine",
    "2d"
  ],
  "main": "./src/p2.js",
  "engines": {
    "node": "*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/schteppe/p2.js.git"
  },
  "bugs": {
    "url": "https://github.com/schteppe/p2.js/issues"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "devDependencies": {
    "grunt": "~0.4.0",
    "grunt-contrib-jshint": "~0.9.2",
    "grunt-contrib-nodeunit": "~0.1.2",
    "grunt-contrib-uglify": "~0.4.0",
    "grunt-contrib-watch": "~0.5.0",
    "grunt-browserify": "~2.0.1",
    "grunt-contrib-concat": "^0.4.0"
  },
  "dependencies": {
    "poly-decomp": "0.1.0"
  }
}

},{}],7:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = AABB;

/**
 * Axis aligned bounding box class.
 * @class AABB
 * @constructor
 * @param {Object}  [options]
 * @param {Array}   [options.upperBound]
 * @param {Array}   [options.lowerBound]
 */
function AABB(options){

    /**
     * The lower bound of the bounding box.
     * @property lowerBound
     * @type {Array}
     */
    this.lowerBound = vec2.create();
    if(options && options.lowerBound){
        vec2.copy(this.lowerBound, options.lowerBound);
    }

    /**
     * The upper bound of the bounding box.
     * @property upperBound
     * @type {Array}
     */
    this.upperBound = vec2.create();
    if(options && options.upperBound){
        vec2.copy(this.upperBound, options.upperBound);
    }
}

var tmp = vec2.create();

/**
 * Set the AABB bounds from a set of points.
 * @method setFromPoints
 * @param {Array} points An array of vec2's.
 */
AABB.prototype.setFromPoints = function(points, position, angle, skinSize){
    var l = this.lowerBound,
        u = this.upperBound;

    if(typeof(angle) !== "number"){
        angle = 0;
    }

    // Set to the first point
    if(angle !== 0){
        vec2.rotate(l, points[0], angle);
    } else {
        vec2.copy(l, points[0]);
    }
    vec2.copy(u, l);

    // Compute cosines and sines just once
    var cosAngle = Math.cos(angle),
        sinAngle = Math.sin(angle);
    for(var i = 1; i<points.length; i++){
        var p = points[i];

        if(angle !== 0){
            var x = p[0],
                y = p[1];
            tmp[0] = cosAngle * x -sinAngle * y;
            tmp[1] = sinAngle * x +cosAngle * y;
            p = tmp;
        }

        for(var j=0; j<2; j++){
            if(p[j] > u[j]){
                u[j] = p[j];
            }
            if(p[j] < l[j]){
                l[j] = p[j];
            }
        }
    }

    // Add offset
    if(position){
        vec2.add(this.lowerBound, this.lowerBound, position);
        vec2.add(this.upperBound, this.upperBound, position);
    }

    if(skinSize){
        this.lowerBound[0] -= skinSize;
        this.lowerBound[1] -= skinSize;
        this.upperBound[0] += skinSize;
        this.upperBound[1] += skinSize;
    }
};

/**
 * Copy bounds from an AABB to this AABB
 * @method copy
 * @param  {AABB} aabb
 */
AABB.prototype.copy = function(aabb){
    vec2.copy(this.lowerBound, aabb.lowerBound);
    vec2.copy(this.upperBound, aabb.upperBound);
};

/**
 * Extend this AABB so that it covers the given AABB too.
 * @method extend
 * @param  {AABB} aabb
 */
AABB.prototype.extend = function(aabb){
    // Loop over x and y
    var i = 2;
    while(i--){
        // Extend lower bound
        var l = aabb.lowerBound[i];
        if(this.lowerBound[i] > l){
            this.lowerBound[i] = l;
        }

        // Upper
        var u = aabb.upperBound[i];
        if(this.upperBound[i] < u){
            this.upperBound[i] = u;
        }
    }
};

/**
 * Returns true if the given AABB overlaps this AABB.
 * @method overlaps
 * @param  {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.overlaps = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&
           ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));
};

},{"../math/vec2":31,"../utils/Utils":50}],8:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Body = _dereq_('../objects/Body');

module.exports = Broadphase;

/**
 * Base class for broadphase implementations.
 * @class Broadphase
 * @constructor
 */
function Broadphase(type){

    this.type = type;

    /**
     * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().
     * @property result
     * @type {Array}
     */
    this.result = [];

    /**
     * The world to search for collision pairs in. To change it, use .setWorld()
     * @property world
     * @type {World}
     * @readOnly
     */
    this.world = null;

    /**
     * The bounding volume type to use in the broadphase algorithms.
     * @property {Number} boundingVolumeType
     */
    this.boundingVolumeType = Broadphase.AABB;
}

/**
 * Axis aligned bounding box type.
 * @static
 * @property {Number} AABB
 */
Broadphase.AABB = 1;

/**
 * Bounding circle type.
 * @static
 * @property {Number} BOUNDING_CIRCLE
 */
Broadphase.BOUNDING_CIRCLE = 2;

/**
 * Set the world that we are searching for collision pairs in
 * @method setWorld
 * @param  {World} world
 */
Broadphase.prototype.setWorld = function(world){
    this.world = world;
};

/**
 * Get all potential intersecting body pairs.
 * @method getCollisionPairs
 * @param  {World} world The world to search in.
 * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).
 */
Broadphase.prototype.getCollisionPairs = function(world){
    throw new Error("getCollisionPairs must be implemented in a subclass!");
};

var dist = vec2.create();

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.boundingRadiusCheck = function(bodyA, bodyB){
    vec2.sub(dist, bodyA.position, bodyB.position);
    var d2 = vec2.squaredLength(dist),
        r = bodyA.boundingRadius + bodyB.boundingRadius;
    return d2 <= r*r;
};

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.aabbCheck = function(bodyA, bodyB){
    return bodyA.getAABB().overlaps(bodyB.getAABB());
};

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB){
    var result;

    switch(this.boundingVolumeType){
    case Broadphase.BOUNDING_CIRCLE:
        result =  Broadphase.boundingRadiusCheck(bodyA,bodyB);
        break;
    case Broadphase.AABB:
        result = Broadphase.aabbCheck(bodyA,bodyB);
        break;
    default:
        throw new Error('Bounding volume type not recognized: '+this.boundingVolumeType);
    }
    return result;
};

/**
 * Check whether two bodies are allowed to collide at all.
 * @method  canCollide
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.canCollide = function(bodyA, bodyB){

    // Cannot collide static bodies
    if(bodyA.type === Body.STATIC && bodyB.type === Body.STATIC){
        return false;
    }

    // Cannot collide static vs kinematic bodies
    if( (bodyA.type === Body.KINEMATIC && bodyB.type === Body.STATIC) ||
        (bodyA.type === Body.STATIC    && bodyB.type === Body.KINEMATIC)){
        return false;
    }

    // Cannot collide kinematic vs kinematic
    if(bodyA.type === Body.KINEMATIC && bodyB.type === Body.KINEMATIC){
        return false;
    }

    // Cannot collide both sleeping bodies
    if(bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING){
        return false;
    }

    // Cannot collide if one is static and the other is sleeping
    if( (bodyA.sleepState === Body.SLEEPING && bodyB.type === Body.STATIC) ||
        (bodyB.sleepState === Body.SLEEPING && bodyA.type === Body.STATIC)){
        return false;
    }

    return true;
};

Broadphase.NAIVE = 1;
Broadphase.SAP = 2;

},{"../math/vec2":31,"../objects/Body":32}],9:[function(_dereq_,module,exports){
var Circle = _dereq_('../shapes/Circle')
,   Plane = _dereq_('../shapes/Plane')
,   Particle = _dereq_('../shapes/Particle')
,   Broadphase = _dereq_('../collision/Broadphase')
,   vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = GridBroadphase;

/**
 * Broadphase that uses axis-aligned bins.
 * @class GridBroadphase
 * @constructor
 * @extends Broadphase
 * @param {object} [options]
 * @param {number} [options.xmin]   Lower x bound of the grid
 * @param {number} [options.xmax]   Upper x bound
 * @param {number} [options.ymin]   Lower y bound
 * @param {number} [options.ymax]   Upper y bound
 * @param {number} [options.nx]     Number of bins along x axis
 * @param {number} [options.ny]     Number of bins along y axis
 * @todo Should have an option for dynamic scene size
 */
function GridBroadphase(options){
    Broadphase.apply(this);

    options = Utils.defaults(options,{
        xmin:   -100,
        xmax:   100,
        ymin:   -100,
        ymax:   100,
        nx:     10,
        ny:     10
    });

    this.xmin = options.xmin;
    this.ymin = options.ymin;
    this.xmax = options.xmax;
    this.ymax = options.ymax;
    this.nx = options.nx;
    this.ny = options.ny;

    this.binsizeX = (this.xmax-this.xmin) / this.nx;
    this.binsizeY = (this.ymax-this.ymin) / this.ny;
}
GridBroadphase.prototype = new Broadphase();
GridBroadphase.prototype.constructor = GridBroadphase;

/**
 * Get collision pairs.
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
GridBroadphase.prototype.getCollisionPairs = function(world){
    var result = [],
        bodies = world.bodies,
        Ncolliding = bodies.length,
        binsizeX = this.binsizeX,
        binsizeY = this.binsizeY,
        nx = this.nx,
        ny = this.ny,
        xmin = this.xmin,
        ymin = this.ymin,
        xmax = this.xmax,
        ymax = this.ymax;

    // Todo: make garbage free
    var bins=[], Nbins=nx*ny;
    for(var i=0; i<Nbins; i++){
        bins.push([]);
    }

    var xmult = nx / (xmax-xmin);
    var ymult = ny / (ymax-ymin);

    // Put all bodies into bins
    for(var i=0; i!==Ncolliding; i++){
        var bi = bodies[i];
        var aabb = bi.aabb;
        var lowerX = Math.max(aabb.lowerBound[0], xmin);
        var lowerY = Math.max(aabb.lowerBound[1], ymin);
        var upperX = Math.min(aabb.upperBound[0], xmax);
        var upperY = Math.min(aabb.upperBound[1], ymax);
        var xi1 = Math.floor(xmult * (lowerX - xmin));
        var yi1 = Math.floor(ymult * (lowerY - ymin));
        var xi2 = Math.floor(xmult * (upperX - xmin));
        var yi2 = Math.floor(ymult * (upperY - ymin));

        // Put in bin
        for(var j=xi1; j<=xi2; j++){
            for(var k=yi1; k<=yi2; k++){
                var xi = j;
                var yi = k;
                var idx = xi*(ny-1) + yi;
                if(idx >= 0 && idx < Nbins){
                    bins[ idx ].push(bi);
                }
            }
        }
    }

    // Check each bin
    for(var i=0; i!==Nbins; i++){
        var bin = bins[i];

        for(var j=0, NbodiesInBin=bin.length; j!==NbodiesInBin; j++){
            var bi = bin[j];
            for(var k=0; k!==j; k++){
                var bj = bin[k];
                if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                    result.push(bi,bj);
                }
            }
        }
    }
    return result;
};

},{"../collision/Broadphase":8,"../math/vec2":31,"../shapes/Circle":38,"../shapes/Particle":42,"../shapes/Plane":43,"../utils/Utils":50}],10:[function(_dereq_,module,exports){
var Circle = _dereq_('../shapes/Circle'),
    Plane = _dereq_('../shapes/Plane'),
    Shape = _dereq_('../shapes/Shape'),
    Particle = _dereq_('../shapes/Particle'),
    Broadphase = _dereq_('../collision/Broadphase'),
    vec2 = _dereq_('../math/vec2');

module.exports = NaiveBroadphase;

/**
 * Naive broadphase implementation. Does N^2 tests.
 *
 * @class NaiveBroadphase
 * @constructor
 * @extends Broadphase
 */
function NaiveBroadphase(){
    Broadphase.call(this, Broadphase.NAIVE);
}
NaiveBroadphase.prototype = new Broadphase();
NaiveBroadphase.prototype.constructor = NaiveBroadphase;

/**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
NaiveBroadphase.prototype.getCollisionPairs = function(world){
    var bodies = world.bodies,
        result = this.result;

    result.length = 0;

    for(var i=0, Ncolliding=bodies.length; i!==Ncolliding; i++){
        var bi = bodies[i];

        for(var j=0; j<i; j++){
            var bj = bodies[j];

            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                result.push(bi,bj);
            }
        }
    }

    return result;
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    var bodies = world.bodies;
    for(var i = 0; i < bodies.length; i++){
        var b = bodies[i];

        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":8,"../math/vec2":31,"../shapes/Circle":38,"../shapes/Particle":42,"../shapes/Plane":43,"../shapes/Shape":45}],11:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   sub = vec2.sub
,   add = vec2.add
,   dot = vec2.dot
,   Utils = _dereq_('../utils/Utils')
,   TupleDictionary = _dereq_('../utils/TupleDictionary')
,   Equation = _dereq_('../equations/Equation')
,   ContactEquation = _dereq_('../equations/ContactEquation')
,   FrictionEquation = _dereq_('../equations/FrictionEquation')
,   Circle = _dereq_('../shapes/Circle')
,   Convex = _dereq_('../shapes/Convex')
,   Shape = _dereq_('../shapes/Shape')
,   Body = _dereq_('../objects/Body')
,   Rectangle = _dereq_('../shapes/Rectangle');

module.exports = Narrowphase;

// Temp things
var yAxis = vec2.fromValues(0,1);

var tmp1 = vec2.fromValues(0,0)
,   tmp2 = vec2.fromValues(0,0)
,   tmp3 = vec2.fromValues(0,0)
,   tmp4 = vec2.fromValues(0,0)
,   tmp5 = vec2.fromValues(0,0)
,   tmp6 = vec2.fromValues(0,0)
,   tmp7 = vec2.fromValues(0,0)
,   tmp8 = vec2.fromValues(0,0)
,   tmp9 = vec2.fromValues(0,0)
,   tmp10 = vec2.fromValues(0,0)
,   tmp11 = vec2.fromValues(0,0)
,   tmp12 = vec2.fromValues(0,0)
,   tmp13 = vec2.fromValues(0,0)
,   tmp14 = vec2.fromValues(0,0)
,   tmp15 = vec2.fromValues(0,0)
,   tmp16 = vec2.fromValues(0,0)
,   tmp17 = vec2.fromValues(0,0)
,   tmp18 = vec2.fromValues(0,0)
,   tmpArray = [];

/**
 * Narrowphase. Creates contacts and friction given shapes and transforms.
 * @class Narrowphase
 * @constructor
 */
function Narrowphase(){

    /**
     * @property contactEquations
     * @type {Array}
     */
    this.contactEquations = [];

    /**
     * @property frictionEquations
     * @type {Array}
     */
    this.frictionEquations = [];

    /**
     * Whether to make friction equations in the upcoming contacts.
     * @property enableFriction
     * @type {Boolean}
     */
    this.enableFriction = true;

    /**
     * Whether to make equations enabled in upcoming contacts.
     * @property enabledEquations
     * @type {Boolean}
     */
    this.enabledEquations = true;

    /**
     * The friction slip force to use when creating friction equations.
     * @property slipForce
     * @type {Number}
     */
    this.slipForce = 10.0;

    /**
     * The friction value to use in the upcoming friction equations.
     * @property frictionCoefficient
     * @type {Number}
     */
    this.frictionCoefficient = 0.3;

    /**
     * Will be the .relativeVelocity in each produced FrictionEquation.
     * @property {Number} surfaceVelocity
     */
    this.surfaceVelocity = 0;

    this.reuseObjects = true;
    this.reusableContactEquations = [];
    this.reusableFrictionEquations = [];

    /**
     * The restitution value to use in the next contact equations.
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0;

    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */
    this.stiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */
    this.relaxation = Equation.DEFAULT_RELAXATION;

    /**
     * The stiffness value to use in the next friction equations.
     * @property frictionStiffness
     * @type {Number}
     */
    this.frictionStiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The relaxation value to use in the next friction equations.
     * @property frictionRelaxation
     * @type {Number}
     */
    this.frictionRelaxation = Equation.DEFAULT_RELAXATION;

    /**
     * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.
     * @property enableFrictionReduction
     * @type {Boolean}
     * @deprecated This flag will be removed when the feature is stable enough.
     * @default true
     */
    this.enableFrictionReduction = true;

    /**
     * Keeps track of the colliding bodies last step.
     * @private
     * @property collidingBodiesLastStep
     * @type {TupleDictionary}
     */
    this.collidingBodiesLastStep = new TupleDictionary();

    /**
     * Contact skin size value to use in the next contact equations.
     * @property {Number} contactSkinSize
     * @default 0.01
     */
    this.contactSkinSize = 0.01;
}

var bodiesOverlap_shapePositionA = vec2.create();
var bodiesOverlap_shapePositionB = vec2.create();

/**
 * @method bodiesOverlap
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Narrowphase.prototype.bodiesOverlap = function(bodyA, bodyB){
    var shapePositionA = bodiesOverlap_shapePositionA;
    var shapePositionB = bodiesOverlap_shapePositionB;

    // Loop over all shapes of bodyA
    for(var k=0, Nshapesi=bodyA.shapes.length; k!==Nshapesi; k++){
        var shapeA = bodyA.shapes[k],
            positionA = bodyA.shapeOffsets[k],
            angleA = bodyA.shapeAngles[k];

        bodyA.toWorldFrame(shapePositionA, positionA);

        // All shapes of body j
        for(var l=0, Nshapesj=bodyB.shapes.length; l!==Nshapesj; l++){
            var shapeB = bodyB.shapes[l],
                positionB = bodyB.shapeOffsets[l],
                angleB = bodyB.shapeAngles[l];

            bodyB.toWorldFrame(shapePositionB, positionB);

            if(this[shapeA.type | shapeB.type](
                bodyA,
                shapeA,
                shapePositionA,
                shapeA.angle + bodyA.angle,
                bodyB,
                shapeB,
                shapePositionB,
                shapeB.angle + bodyB.angle,
                true
            )){
                return true;
            }
        }
    }

    return false;
};

/**
 * Check if the bodies were in contact since the last reset().
 * @method collidedLastStep
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Narrowphase.prototype.collidedLastStep = function(bodyA, bodyB){
    var id1 = bodyA.id|0,
        id2 = bodyB.id|0;
    return !!this.collidingBodiesLastStep.get(id1, id2);
};

/**
 * Throws away the old equations and gets ready to create new
 * @method reset
 */
Narrowphase.prototype.reset = function(){
    this.collidingBodiesLastStep.reset();

    var eqs = this.contactEquations;
    var l = eqs.length;
    while(l--){
        var eq = eqs[l],
            id1 = eq.bodyA.id,
            id2 = eq.bodyB.id;
        this.collidingBodiesLastStep.set(id1, id2, true);
    }

    if(this.reuseObjects){
        var ce = this.contactEquations,
            fe = this.frictionEquations,
            rfe = this.reusableFrictionEquations,
            rce = this.reusableContactEquations;
        Utils.appendArray(rce,ce);
        Utils.appendArray(rfe,fe);
    }

    // Reset
    this.contactEquations.length = this.frictionEquations.length = 0;
};

/**
 * Creates a ContactEquation, either by reusing an existing object or creating a new one.
 * @method createContactEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {ContactEquation}
 */
Narrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB){
    var c = this.reusableContactEquations.length ? this.reusableContactEquations.pop() : new ContactEquation(bodyA,bodyB);
    c.bodyA = bodyA;
    c.bodyB = bodyB;
    c.shapeA = shapeA;
    c.shapeB = shapeB;
    c.restitution = this.restitution;
    c.firstImpact = !this.collidedLastStep(bodyA,bodyB);
    c.stiffness = this.stiffness;
    c.relaxation = this.relaxation;
    c.needsUpdate = true;
    c.enabled = this.enabledEquations;
    c.offset = this.contactSkinSize;

    return c;
};

/**
 * Creates a FrictionEquation, either by reusing an existing object or creating a new one.
 * @method createFrictionEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {FrictionEquation}
 */
Narrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB){
    var c = this.reusableFrictionEquations.length ? this.reusableFrictionEquations.pop() : new FrictionEquation(bodyA,bodyB);
    c.bodyA = bodyA;
    c.bodyB = bodyB;
    c.shapeA = shapeA;
    c.shapeB = shapeB;
    c.setSlipForce(this.slipForce);
    c.frictionCoefficient = this.frictionCoefficient;
    c.relativeVelocity = this.surfaceVelocity;
    c.enabled = this.enabledEquations;
    c.needsUpdate = true;
    c.stiffness = this.frictionStiffness;
    c.relaxation = this.frictionRelaxation;
    c.contactEquations.length = 0;
    return c;
};

/**
 * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.
 * @method createFrictionFromContact
 * @param  {ContactEquation} contactEquation
 * @return {FrictionEquation}
 */
Narrowphase.prototype.createFrictionFromContact = function(c){
    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
    vec2.copy(eq.contactPointA, c.contactPointA);
    vec2.copy(eq.contactPointB, c.contactPointB);
    vec2.rotate90cw(eq.t, c.normalA);
    eq.contactEquations.push(c);
    return eq;
};

// Take the average N latest contact point on the plane.
Narrowphase.prototype.createFrictionFromAverage = function(numContacts){
    var c = this.contactEquations[this.contactEquations.length - 1];
    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    vec2.set(eq.contactPointA, 0, 0);
    vec2.set(eq.contactPointB, 0, 0);
    vec2.set(eq.t, 0, 0);
    for(var i=0; i!==numContacts; i++){
        c = this.contactEquations[this.contactEquations.length - 1 - i];
        if(c.bodyA === bodyA){
            vec2.add(eq.t, eq.t, c.normalA);
            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);
        } else {
            vec2.sub(eq.t, eq.t, c.normalA);
            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);
            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);
        }
        eq.contactEquations.push(c);
    }

    var invNumContacts = 1/numContacts;
    vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
    vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
    vec2.normalize(eq.t, eq.t);
    vec2.rotate90cw(eq.t, eq.t);
    return eq;
};

/**
 * Convex/line narrowphase
 * @method convexLine
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexOffset
 * @param  {Number}     convexAngle
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param {boolean}     justTest
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.CONVEX] =
Narrowphase.prototype.convexLine = function(
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

/**
 * Line/rectangle narrowphase
 * @method lineRectangle
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param  {Body}       rectangleBody
 * @param  {Rectangle}  rectangleShape
 * @param  {Array}      rectangleOffset
 * @param  {Number}     rectangleAngle
 * @param  {Boolean}    justTest
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.RECTANGLE] =
Narrowphase.prototype.lineRectangle = function(
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    rectangleBody,
    rectangleShape,
    rectangleOffset,
    rectangleAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape){
    vec2.set(convexShape.vertices[0], -capsuleShape.length * 0.5, -capsuleShape.radius);
    vec2.set(convexShape.vertices[1],  capsuleShape.length * 0.5, -capsuleShape.radius);
    vec2.set(convexShape.vertices[2],  capsuleShape.length * 0.5,  capsuleShape.radius);
    vec2.set(convexShape.vertices[3], -capsuleShape.length * 0.5,  capsuleShape.radius);
}

var convexCapsule_tempRect = new Rectangle(1,1),
    convexCapsule_tempVec = vec2.create();

/**
 * Convex/capsule narrowphase
 * @method convexCapsule
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexPosition
 * @param  {Number}     convexAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] =
Narrowphase.prototype[Shape.CAPSULE | Shape.RECTANGLE] =
Narrowphase.prototype.convexCapsule = function(
    convexBody,
    convexShape,
    convexPosition,
    convexAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){

    // Check the circles
    // Add offsets!
    var circlePos = convexCapsule_tempVec;
    vec2.set(circlePos, capsuleShape.length/2,0);
    vec2.rotate(circlePos,circlePos,capsuleAngle);
    vec2.add(circlePos,circlePos,capsulePosition);
    var result1 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);

    vec2.set(circlePos,-capsuleShape.length/2, 0);
    vec2.rotate(circlePos,circlePos,capsuleAngle);
    vec2.add(circlePos,circlePos,capsulePosition);
    var result2 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);

    if(justTest && (result1 || result2)){
        return true;
    }

    // Check center rect
    var r = convexCapsule_tempRect;
    setConvexToCapsuleShapeMiddle(r,capsuleShape);
    var result = this.convexConvex(convexBody,convexShape,convexPosition,convexAngle, capsuleBody,r,capsulePosition,capsuleAngle, justTest);

    return result + result1 + result2;
};

/**
 * Capsule/line narrowphase
 * @method lineCapsule
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      linePosition
 * @param  {Number}     lineAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.LINE] =
Narrowphase.prototype.lineCapsule = function(
    lineBody,
    lineShape,
    linePosition,
    lineAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

var capsuleCapsule_tempVec1 = vec2.create();
var capsuleCapsule_tempVec2 = vec2.create();
var capsuleCapsule_tempRect1 = new Rectangle(1,1);

/**
 * Capsule/capsule narrowphase
 * @method capsuleCapsule
 * @param  {Body}       bi
 * @param  {Capsule}    si
 * @param  {Array}      xi
 * @param  {Number}     ai
 * @param  {Body}       bj
 * @param  {Capsule}    sj
 * @param  {Array}      xj
 * @param  {Number}     aj
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] =
Narrowphase.prototype.capsuleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){

    var enableFrictionBefore;

    // Check the circles
    // Add offsets!
    var circlePosi = capsuleCapsule_tempVec1,
        circlePosj = capsuleCapsule_tempVec2;

    var numContacts = 0;


    // Need 4 circle checks, between all
    for(var i=0; i<2; i++){

        vec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);
        vec2.rotate(circlePosi,circlePosi,ai);
        vec2.add(circlePosi,circlePosi,xi);

        for(var j=0; j<2; j++){

            vec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);
            vec2.rotate(circlePosj,circlePosj,aj);
            vec2.add(circlePosj,circlePosj,xj);

            // Temporarily turn off friction
            if(this.enableFrictionReduction){
                enableFrictionBefore = this.enableFriction;
                this.enableFriction = false;
            }

            var result = this.circleCircle(bi,si,circlePosi,ai, bj,sj,circlePosj,aj, justTest, si.radius, sj.radius);

            if(this.enableFrictionReduction){
                this.enableFriction = enableFrictionBefore;
            }

            if(justTest && result){
                return true;
            }

            numContacts += result;
        }
    }

    if(this.enableFrictionReduction){
        // Temporarily turn off friction
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    // Check circles against the center rectangles
    var rect = capsuleCapsule_tempRect1;
    setConvexToCapsuleShapeMiddle(rect,si);
    var result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);

    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest && result1){
        return true;
    }
    numContacts += result1;

    if(this.enableFrictionReduction){
        // Temporarily turn off friction
        var enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    setConvexToCapsuleShapeMiddle(rect,sj);
    var result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);

    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest && result2){
        return true;
    }
    numContacts += result2;

    if(this.enableFrictionReduction){
        if(numContacts && this.enableFriction){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

/**
 * Line/line narrowphase
 * @method lineLine
 * @param  {Body}       bodyA
 * @param  {Line}       shapeA
 * @param  {Array}      positionA
 * @param  {Number}     angleA
 * @param  {Body}       bodyB
 * @param  {Line}       shapeB
 * @param  {Array}      positionB
 * @param  {Number}     angleB
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.LINE] =
Narrowphase.prototype.lineLine = function(
    bodyA,
    shapeA,
    positionA,
    angleA,
    bodyB,
    shapeB,
    positionB,
    angleB,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

/**
 * Plane/line Narrowphase
 * @method planeLine
 * @param  {Body}   planeBody
 * @param  {Plane}  planeShape
 * @param  {Array}  planeOffset
 * @param  {Number} planeAngle
 * @param  {Body}   lineBody
 * @param  {Line}   lineShape
 * @param  {Array}  lineOffset
 * @param  {Number} lineAngle
 */
Narrowphase.prototype[Shape.PLANE | Shape.LINE] =
Narrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle,
                                           lineBody,  lineShape,  lineOffset,  lineAngle, justTest){
    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldVertex01 = tmp3,
        worldVertex11 = tmp4,
        worldEdge = tmp5,
        worldEdgeUnit = tmp6,
        dist = tmp7,
        worldNormal = tmp8,
        worldTangent = tmp9,
        verts = tmpArray,
        numContacts = 0;

    // Get start and end points
    vec2.set(worldVertex0, -lineShape.length/2, 0);
    vec2.set(worldVertex1,  lineShape.length/2, 0);

    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
    vec2.rotate(worldVertex11, worldVertex1, lineAngle);

    add(worldVertex01, worldVertex01, lineOffset);
    add(worldVertex11, worldVertex11, lineOffset);

    vec2.copy(worldVertex0,worldVertex01);
    vec2.copy(worldVertex1,worldVertex11);

    // Get vector along the line
    sub(worldEdge, worldVertex1, worldVertex0);
    vec2.normalize(worldEdgeUnit, worldEdge);

    // Get tangent to the edge.
    vec2.rotate90cw(worldTangent, worldEdgeUnit);

    vec2.rotate(worldNormal, yAxis, planeAngle);

    // Check line ends
    verts[0] = worldVertex0;
    verts[1] = worldVertex1;
    for(var i=0; i<verts.length; i++){
        var v = verts[i];

        sub(dist, v, planeOffset);

        var d = dot(dist,worldNormal);

        if(d < 0){

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(planeBody,lineBody,planeShape,lineShape);
            numContacts++;

            vec2.copy(c.normalA, worldNormal);
            vec2.normalize(c.normalA,c.normalA);

            // distance vector along plane normal
            vec2.scale(dist, worldNormal, d);

            // Vector from plane center to contact
            sub(c.contactPointA, v, dist);
            sub(c.contactPointA, c.contactPointA, planeBody.position);

            // From line center to contact
            sub(c.contactPointB, v,    lineOffset);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(!this.enableFrictionReduction){
                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(justTest){
        return false;
    }

    if(!this.enableFrictionReduction){
        if(numContacts && this.enableFriction){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =
Narrowphase.prototype.particleCapsule = function(
    particleBody,
    particleShape,
    particlePosition,
    particleAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){
    return this.circleLine(particleBody,particleShape,particlePosition,particleAngle, capsuleBody,capsuleShape,capsulePosition,capsuleAngle, justTest, capsuleShape.radius, 0);
};

/**
 * Circle/line Narrowphase
 * @method circleLine
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} lineBody
 * @param  {Line} lineShape
 * @param  {Array} lineOffset
 * @param  {Number} lineAngle
 * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.
 * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.
 * @param {Number} circleRadius If set, this value overrides the circle shape radius.
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] =
Narrowphase.prototype.circleLine = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest,
    lineRadius,
    circleRadius
){
    var lineRadius = lineRadius || 0,
        circleRadius = typeof(circleRadius)!=="undefined" ? circleRadius : circleShape.radius,

        orthoDist = tmp1,
        lineToCircleOrthoUnit = tmp2,
        projectedPoint = tmp3,
        centerDist = tmp4,
        worldTangent = tmp5,
        worldEdge = tmp6,
        worldEdgeUnit = tmp7,
        worldVertex0 = tmp8,
        worldVertex1 = tmp9,
        worldVertex01 = tmp10,
        worldVertex11 = tmp11,
        dist = tmp12,
        lineToCircle = tmp13,
        lineEndToLineRadius = tmp14,

        verts = tmpArray;

    // Get start and end points
    vec2.set(worldVertex0, -lineShape.length/2, 0);
    vec2.set(worldVertex1,  lineShape.length/2, 0);

    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
    vec2.rotate(worldVertex11, worldVertex1, lineAngle);

    add(worldVertex01, worldVertex01, lineOffset);
    add(worldVertex11, worldVertex11, lineOffset);

    vec2.copy(worldVertex0,worldVertex01);
    vec2.copy(worldVertex1,worldVertex11);

    // Get vector along the line
    sub(worldEdge, worldVertex1, worldVertex0);
    vec2.normalize(worldEdgeUnit, worldEdge);

    // Get tangent to the edge.
    vec2.rotate90cw(worldTangent, worldEdgeUnit);

    // Check distance from the plane spanned by the edge vs the circle
    sub(dist, circleOffset, worldVertex0);
    var d = dot(dist, worldTangent); // Distance from center of line to circle center
    sub(centerDist, worldVertex0, lineOffset);

    sub(lineToCircle, circleOffset, lineOffset);

    var radiusSum = circleRadius + lineRadius;

    if(Math.abs(d) < radiusSum){

        // Now project the circle onto the edge
        vec2.scale(orthoDist, worldTangent, d);
        sub(projectedPoint, circleOffset, orthoDist);

        // Add the missing line radius
        vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
        vec2.normalize(lineToCircleOrthoUnit,lineToCircleOrthoUnit);
        vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
        add(projectedPoint,projectedPoint,lineToCircleOrthoUnit);

        // Check if the point is within the edge span
        var pos =  dot(worldEdgeUnit, projectedPoint);
        var pos0 = dot(worldEdgeUnit, worldVertex0);
        var pos1 = dot(worldEdgeUnit, worldVertex1);

        if(pos > pos0 && pos < pos1){
            // We got contact!

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);

            vec2.scale(c.normalA, orthoDist, -1);
            vec2.normalize(c.normalA, c.normalA);

            vec2.scale( c.contactPointA, c.normalA,  circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);

            sub(c.contactPointB, projectedPoint, lineOffset);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }

            return 1;
        }
    }

    // Add corner
    verts[0] = worldVertex0;
    verts[1] = worldVertex1;

    for(var i=0; i<verts.length; i++){
        var v = verts[i];

        sub(dist, v, circleOffset);

        if(vec2.squaredLength(dist) < Math.pow(radiusSum, 2)){

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);

            vec2.copy(c.normalA, dist);
            vec2.normalize(c.normalA,c.normalA);

            // Vector from circle to contact point is the normal times the circle radius
            vec2.scale(c.contactPointA, c.normalA, circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);

            sub(c.contactPointB, v, lineOffset);
            vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);
            add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }

            return 1;
        }
    }

    return 0;
};

/**
 * Circle/capsule Narrowphase
 * @method circleCapsule
 * @param  {Body}   bi
 * @param  {Circle} si
 * @param  {Array}  xi
 * @param  {Number} ai
 * @param  {Body}   bj
 * @param  {Line}   sj
 * @param  {Array}  xj
 * @param  {Number} aj
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =
Narrowphase.prototype.circleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){
    return this.circleLine(bi,si,xi,ai, bj,sj,xj,aj, justTest, sj.radius);
};

/**
 * Circle/convex Narrowphase.
 * @method circleConvex
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Boolean} justTest
 * @param  {Number} circleRadius
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =
Narrowphase.prototype[Shape.CIRCLE | Shape.RECTANGLE] =
Narrowphase.prototype.circleConvex = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest,
    circleRadius
){
    var circleRadius = typeof(circleRadius)==="number" ? circleRadius : circleShape.radius;

    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldEdge = tmp3,
        worldEdgeUnit = tmp4,
        worldNormal = tmp5,
        centerDist = tmp6,
        convexToCircle = tmp7,
        orthoDist = tmp8,
        projectedPoint = tmp9,
        dist = tmp10,
        worldVertex = tmp11,

        closestEdge = -1,
        closestEdgeDistance = null,
        closestEdgeOrthoDist = tmp12,
        closestEdgeProjectedPoint = tmp13,
        candidate = tmp14,
        candidateDist = tmp15,
        minCandidate = tmp16,

        found = false,
        minCandidateDistance = Number.MAX_VALUE;

    var numReported = 0;

    // New algorithm:
    // 1. Check so center of circle is not inside the polygon. If it is, this wont work...
    // 2. For each edge
    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
    // 2. 2. Check if point is inside.

    var verts = convexShape.vertices;

    // Check all edges first
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);
        sub(worldEdge, worldVertex1, worldVertex0);

        vec2.normalize(worldEdgeUnit, worldEdge);

        // Get tangent to the edge. Points out of the Convex
        vec2.rotate90cw(worldNormal, worldEdgeUnit);

        // Get point on circle, closest to the polygon
        vec2.scale(candidate,worldNormal,-circleShape.radius);
        add(candidate,candidate,circleOffset);

        if(pointInConvex(candidate,convexShape,convexOffset,convexAngle)){

            vec2.sub(candidateDist,worldVertex0,candidate);
            var candidateDistance = Math.abs(vec2.dot(candidateDist,worldNormal));

            if(candidateDistance < minCandidateDistance){
                vec2.copy(minCandidate,candidate);
                minCandidateDistance = candidateDistance;
                vec2.scale(closestEdgeProjectedPoint,worldNormal,candidateDistance);
                vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,candidate);
                found = true;
            }
        }
    }

    if(found){

        if(justTest){
            return true;
        }

        var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);
        vec2.sub(c.normalA, minCandidate, circleOffset);
        vec2.normalize(c.normalA, c.normalA);

        vec2.scale(c.contactPointA,  c.normalA, circleRadius);
        add(c.contactPointA, c.contactPointA, circleOffset);
        sub(c.contactPointA, c.contactPointA, circleBody.position);

        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c.contactPointB, c.contactPointB, convexOffset);
        sub(c.contactPointB, c.contactPointB, convexBody.position);

        this.contactEquations.push(c);

        if(this.enableFriction){
            this.frictionEquations.push( this.createFrictionFromContact(c) );
        }

        return 1;
    }

    // Check all vertices
    if(circleRadius > 0){
        for(var i=0; i<verts.length; i++){
            var localVertex = verts[i];
            vec2.rotate(worldVertex, localVertex, convexAngle);
            add(worldVertex, worldVertex, convexOffset);

            sub(dist, worldVertex, circleOffset);
            if(vec2.squaredLength(dist) < Math.pow(circleRadius, 2)){

                if(justTest){
                    return true;
                }

                var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);

                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA,c.normalA);

                // Vector from circle to contact point is the normal times the circle radius
                vec2.scale(c.contactPointA, c.normalA, circleRadius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);

                sub(c.contactPointB, worldVertex, convexOffset);
                add(c.contactPointB, c.contactPointB, convexOffset);
                sub(c.contactPointB, c.contactPointB, convexBody.position);

                this.contactEquations.push(c);

                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }

                return 1;
            }
        }
    }

    return 0;
};

var pic_worldVertex0 = vec2.create(),
    pic_worldVertex1 = vec2.create(),
    pic_r0 = vec2.create(),
    pic_r1 = vec2.create();

/*
 * Check if a point is in a polygon
 */
function pointInConvex(worldPoint,convexShape,convexOffset,convexAngle){
    var worldVertex0 = pic_worldVertex0,
        worldVertex1 = pic_worldVertex1,
        r0 = pic_r0,
        r1 = pic_r1,
        point = worldPoint,
        verts = convexShape.vertices,
        lastCross = null;
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        // Transform vertices to world
        // @todo The point should be transformed to local coordinates in the convex, no need to transform each vertex
        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);

        sub(r0, worldVertex0, point);
        sub(r1, worldVertex1, point);
        var cross = vec2.crossLength(r0,r1);

        if(lastCross===null){
            lastCross = cross;
        }

        // If we got a different sign of the distance vector, the point is out of the polygon
        if(cross*lastCross <= 0){
            return false;
        }
        lastCross = cross;
    }
    return true;
}

/**
 * Particle/convex Narrowphase
 * @method particleConvex
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 * @todo use pointInConvex and code more similar to circleConvex
 * @todo don't transform each vertex, but transform the particle position to convex-local instead
 */
Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =
Narrowphase.prototype[Shape.PARTICLE | Shape.RECTANGLE] =
Narrowphase.prototype.particleConvex = function(
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest
){
    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldEdge = tmp3,
        worldEdgeUnit = tmp4,
        worldTangent = tmp5,
        centerDist = tmp6,
        convexToparticle = tmp7,
        orthoDist = tmp8,
        projectedPoint = tmp9,
        dist = tmp10,
        worldVertex = tmp11,
        closestEdge = -1,
        closestEdgeDistance = null,
        closestEdgeOrthoDist = tmp12,
        closestEdgeProjectedPoint = tmp13,
        r0 = tmp14, // vector from particle to vertex0
        r1 = tmp15,
        localPoint = tmp16,
        candidateDist = tmp17,
        minEdgeNormal = tmp18,
        minCandidateDistance = Number.MAX_VALUE;

    var numReported = 0,
        found = false,
        verts = convexShape.vertices;

    // Check if the particle is in the polygon at all
    if(!pointInConvex(particleOffset,convexShape,convexOffset,convexAngle)){
        return 0;
    }

    if(justTest){
        return true;
    }

    // Check edges first
    var lastCross = null;
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        // Transform vertices to world
        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);

        // Get world edge
        sub(worldEdge, worldVertex1, worldVertex0);
        vec2.normalize(worldEdgeUnit, worldEdge);

        // Get tangent to the edge. Points out of the Convex
        vec2.rotate90cw(worldTangent, worldEdgeUnit);

        // Check distance from the infinite line (spanned by the edge) to the particle
        sub(dist, particleOffset, worldVertex0);
        var d = dot(dist, worldTangent);
        sub(centerDist, worldVertex0, convexOffset);

        sub(convexToparticle, particleOffset, convexOffset);

        vec2.sub(candidateDist,worldVertex0,particleOffset);
        var candidateDistance = Math.abs(vec2.dot(candidateDist,worldTangent));

        if(candidateDistance < minCandidateDistance){
            minCandidateDistance = candidateDistance;
            vec2.scale(closestEdgeProjectedPoint,worldTangent,candidateDistance);
            vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,particleOffset);
            vec2.copy(minEdgeNormal,worldTangent);
            found = true;
        }
    }

    if(found){
        var c = this.createContactEquation(particleBody,convexBody,particleShape,convexShape);

        vec2.scale(c.normalA, minEdgeNormal, -1);
        vec2.normalize(c.normalA, c.normalA);

        // Particle has no extent to the contact point
        vec2.set(c.contactPointA,  0, 0);
        add(c.contactPointA, c.contactPointA, particleOffset);
        sub(c.contactPointA, c.contactPointA, particleBody.position);

        // From convex center to point
        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c.contactPointB, c.contactPointB, convexOffset);
        sub(c.contactPointB, c.contactPointB, convexBody.position);

        this.contactEquations.push(c);

        if(this.enableFriction){
            this.frictionEquations.push( this.createFrictionFromContact(c) );
        }

        return 1;
    }


    return 0;
};

/**
 * Circle/circle Narrowphase
 * @method circleCircle
 * @param  {Body} bodyA
 * @param  {Circle} shapeA
 * @param  {Array} offsetA
 * @param  {Number} angleA
 * @param  {Body} bodyB
 * @param  {Circle} shapeB
 * @param  {Array} offsetB
 * @param  {Number} angleB
 * @param {Boolean} justTest
 * @param {Number} [radiusA] Optional radius to use for shapeA
 * @param {Number} [radiusB] Optional radius to use for shapeB
 */
Narrowphase.prototype[Shape.CIRCLE] =
Narrowphase.prototype.circleCircle = function(
    bodyA,
    shapeA,
    offsetA,
    angleA,
    bodyB,
    shapeB,
    offsetB,
    angleB,
    justTest,
    radiusA,
    radiusB
){

    var dist = tmp1,
        radiusA = radiusA || shapeA.radius,
        radiusB = radiusB || shapeB.radius;

    sub(dist,offsetA,offsetB);
    var r = radiusA + radiusB;
    if(vec2.squaredLength(dist) > Math.pow(r,2)){
        return 0;
    }

    if(justTest){
        return true;
    }

    var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
    sub(c.normalA, offsetB, offsetA);
    vec2.normalize(c.normalA,c.normalA);

    vec2.scale( c.contactPointA, c.normalA,  radiusA);
    vec2.scale( c.contactPointB, c.normalA, -radiusB);

    add(c.contactPointA, c.contactPointA, offsetA);
    sub(c.contactPointA, c.contactPointA, bodyA.position);

    add(c.contactPointB, c.contactPointB, offsetB);
    sub(c.contactPointB, c.contactPointB, bodyB.position);

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }
    return 1;
};

/**
 * Plane/Convex Narrowphase
 * @method planeConvex
 * @param  {Body} planeBody
 * @param  {Plane} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 */
Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] =
Narrowphase.prototype[Shape.PLANE | Shape.RECTANGLE] =
Narrowphase.prototype.planeConvex = function(
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest
){
    var worldVertex = tmp1,
        worldNormal = tmp2,
        dist = tmp3;

    var numReported = 0;
    vec2.rotate(worldNormal, yAxis, planeAngle);

    for(var i=0; i!==convexShape.vertices.length; i++){
        var v = convexShape.vertices[i];
        vec2.rotate(worldVertex, v, convexAngle);
        add(worldVertex, worldVertex, convexOffset);

        sub(dist, worldVertex, planeOffset);

        if(dot(dist,worldNormal) <= 0){

            if(justTest){
                return true;
            }

            // Found vertex
            numReported++;

            var c = this.createContactEquation(planeBody,convexBody,planeShape,convexShape);

            sub(dist, worldVertex, planeOffset);

            vec2.copy(c.normalA, worldNormal);

            var d = dot(dist, c.normalA);
            vec2.scale(dist, c.normalA, d);

            // rj is from convex center to contact
            sub(c.contactPointB, worldVertex, convexBody.position);


            // ri is from plane center to contact
            sub( c.contactPointA, worldVertex, dist);
            sub( c.contactPointA, c.contactPointA, planeBody.position);

            this.contactEquations.push(c);

            if(!this.enableFrictionReduction){
                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(this.enableFrictionReduction){
        if(this.enableFriction && numReported){
            this.frictionEquations.push(this.createFrictionFromAverage(numReported));
        }
    }

    return numReported;
};

/**
 * Narrowphase for particle vs plane
 * @method particlePlane
 * @param  {Body}       particleBody
 * @param  {Particle}   particleShape
 * @param  {Array}      particleOffset
 * @param  {Number}     particleAngle
 * @param  {Body}       planeBody
 * @param  {Plane}      planeShape
 * @param  {Array}      planeOffset
 * @param  {Number}     planeAngle
 * @param {Boolean}     justTest
 */
Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =
Narrowphase.prototype.particlePlane = function(
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    justTest
){
    var dist = tmp1,
        worldNormal = tmp2;

    planeAngle = planeAngle || 0;

    sub(dist, particleOffset, planeOffset);
    vec2.rotate(worldNormal, yAxis, planeAngle);

    var d = dot(dist, worldNormal);

    if(d > 0){
        return 0;
    }
    if(justTest){
        return true;
    }

    var c = this.createContactEquation(planeBody,particleBody,planeShape,particleShape);

    vec2.copy(c.normalA, worldNormal);
    vec2.scale( dist, c.normalA, d );
    // dist is now the distance vector in the normal direction

    // ri is the particle position projected down onto the plane, from the plane center
    sub( c.contactPointA, particleOffset, dist);
    sub( c.contactPointA, c.contactPointA, planeBody.position);

    // rj is from the body center to the particle center
    sub( c.contactPointB, particleOffset, particleBody.position );

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }
    return 1;
};

/**
 * Circle/Particle Narrowphase
 * @method circleParticle
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Boolean} justTest
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =
Narrowphase.prototype.circleParticle = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    justTest
){
    var dist = tmp1;

    sub(dist, particleOffset, circleOffset);
    if(vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)){
        return 0;
    }
    if(justTest){
        return true;
    }

    var c = this.createContactEquation(circleBody,particleBody,circleShape,particleShape);
    vec2.copy(c.normalA, dist);
    vec2.normalize(c.normalA,c.normalA);

    // Vector from circle to contact point is the normal times the circle radius
    vec2.scale(c.contactPointA, c.normalA, circleShape.radius);
    add(c.contactPointA, c.contactPointA, circleOffset);
    sub(c.contactPointA, c.contactPointA, circleBody.position);

    // Vector from particle center to contact point is zero
    sub(c.contactPointB, particleOffset, particleBody.position);

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }

    return 1;
};

var planeCapsule_tmpCircle = new Circle(1),
    planeCapsule_tmp1 = vec2.create(),
    planeCapsule_tmp2 = vec2.create(),
    planeCapsule_tmp3 = vec2.create();

/**
 * @method planeCapsule
 * @param  {Body} planeBody
 * @param  {Circle} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} capsuleBody
 * @param  {Particle} capsuleShape
 * @param  {Array} capsuleOffset
 * @param  {Number} capsuleAngle
 * @param {Boolean} justTest
 */
Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =
Narrowphase.prototype.planeCapsule = function(
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    capsuleBody,
    capsuleShape,
    capsuleOffset,
    capsuleAngle,
    justTest
){
    var end1 = planeCapsule_tmp1,
        end2 = planeCapsule_tmp2,
        circle = planeCapsule_tmpCircle,
        dst = planeCapsule_tmp3;

    // Compute world end positions
    vec2.set(end1, -capsuleShape.length/2, 0);
    vec2.rotate(end1,end1,capsuleAngle);
    add(end1,end1,capsuleOffset);

    vec2.set(end2,  capsuleShape.length/2, 0);
    vec2.rotate(end2,end2,capsuleAngle);
    add(end2,end2,capsuleOffset);

    circle.radius = capsuleShape.radius;

    var enableFrictionBefore;

    // Temporarily turn off friction
    if(this.enableFrictionReduction){
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    // Do Narrowphase as two circles
    var numContacts1 = this.circlePlane(capsuleBody,circle,end1,0, planeBody,planeShape,planeOffset,planeAngle, justTest),
        numContacts2 = this.circlePlane(capsuleBody,circle,end2,0, planeBody,planeShape,planeOffset,planeAngle, justTest);

    // Restore friction
    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest){
        return numContacts1 || numContacts2;
    } else {
        var numTotal = numContacts1 + numContacts2;
        if(this.enableFrictionReduction){
            if(numTotal){
                this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
            }
        }
        return numTotal;
    }
};

/**
 * Creates ContactEquations and FrictionEquations for a collision.
 * @method circlePlane
 * @param  {Body}    bi     The first body that should be connected to the equations.
 * @param  {Circle}  si     The circle shape participating in the collision.
 * @param  {Array}   xi     Extra offset to take into account for the Shape, in addition to the one in circleBody.position. Will *not* be rotated by circleBody.angle (maybe it should, for sake of homogenity?). Set to null if none.
 * @param  {Body}    bj     The second body that should be connected to the equations.
 * @param  {Plane}   sj     The Plane shape that is participating
 * @param  {Array}   xj     Extra offset for the plane shape.
 * @param  {Number}  aj     Extra angle to apply to the plane
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =
Narrowphase.prototype.circlePlane = function(   bi,si,xi,ai, bj,sj,xj,aj, justTest ){
    var circleBody = bi,
        circleShape = si,
        circleOffset = xi, // Offset from body center, rotated!
        planeBody = bj,
        shapeB = sj,
        planeOffset = xj,
        planeAngle = aj;

    planeAngle = planeAngle || 0;

    // Vector from plane to circle
    var planeToCircle = tmp1,
        worldNormal = tmp2,
        temp = tmp3;

    sub(planeToCircle, circleOffset, planeOffset);

    // World plane normal
    vec2.rotate(worldNormal, yAxis, planeAngle);

    // Normal direction distance
    var d = dot(worldNormal, planeToCircle);

    if(d > circleShape.radius){
        return 0; // No overlap. Abort.
    }

    if(justTest){
        return true;
    }

    // Create contact
    var contact = this.createContactEquation(planeBody,circleBody,sj,si);

    // ni is the plane world normal
    vec2.copy(contact.normalA, worldNormal);

    // rj is the vector from circle center to the contact point
    vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);
    add(contact.contactPointB, contact.contactPointB, circleOffset);
    sub(contact.contactPointB, contact.contactPointB, circleBody.position);

    // ri is the distance from plane center to contact.
    vec2.scale(temp, contact.normalA, d);
    sub(contact.contactPointA, planeToCircle, temp ); // Subtract normal distance vector from the distance vector
    add(contact.contactPointA, contact.contactPointA, planeOffset);
    sub(contact.contactPointA, contact.contactPointA, planeBody.position);

    this.contactEquations.push(contact);

    if(this.enableFriction){
        this.frictionEquations.push( this.createFrictionFromContact(contact) );
    }

    return 1;
};

/**
 * Convex/convex Narrowphase.See <a href="http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/">this article</a> for more info.
 * @method convexConvex
 * @param  {Body} bi
 * @param  {Convex} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Convex} sj
 * @param  {Array} xj
 * @param  {Number} aj
 */
Narrowphase.prototype[Shape.CONVEX] =
Narrowphase.prototype[Shape.CONVEX | Shape.RECTANGLE] =
Narrowphase.prototype[Shape.RECTANGLE] =
Narrowphase.prototype.convexConvex = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest, precision ){
    var sepAxis = tmp1,
        worldPoint = tmp2,
        worldPoint0 = tmp3,
        worldPoint1 = tmp4,
        worldEdge = tmp5,
        projected = tmp6,
        penetrationVec = tmp7,
        dist = tmp8,
        worldNormal = tmp9,
        numContacts = 0,
        precision = typeof(precision) === 'number' ? precision : 0;

    var found = Narrowphase.findSeparatingAxis(si,xi,ai,sj,xj,aj,sepAxis);
    if(!found){
        return 0;
    }

    // Make sure the separating axis is directed from shape i to shape j
    sub(dist,xj,xi);
    if(dot(sepAxis,dist) > 0){
        vec2.scale(sepAxis,sepAxis,-1);
    }

    // Find edges with normals closest to the separating axis
    var closestEdge1 = Narrowphase.getClosestEdge(si,ai,sepAxis,true), // Flipped axis
        closestEdge2 = Narrowphase.getClosestEdge(sj,aj,sepAxis);

    if(closestEdge1 === -1 || closestEdge2 === -1){
        return 0;
    }

    // Loop over the shapes
    for(var k=0; k<2; k++){

        var closestEdgeA = closestEdge1,
            closestEdgeB = closestEdge2,
            shapeA =  si, shapeB =  sj,
            offsetA = xi, offsetB = xj,
            angleA = ai, angleB = aj,
            bodyA = bi, bodyB = bj;

        if(k === 0){
            // Swap!
            var tmp;
            tmp = closestEdgeA;
            closestEdgeA = closestEdgeB;
            closestEdgeB = tmp;

            tmp = shapeA;
            shapeA = shapeB;
            shapeB = tmp;

            tmp = offsetA;
            offsetA = offsetB;
            offsetB = tmp;

            tmp = angleA;
            angleA = angleB;
            angleB = tmp;

            tmp = bodyA;
            bodyA = bodyB;
            bodyB = tmp;
        }

        // Loop over 2 points in convex B
        for(var j=closestEdgeB; j<closestEdgeB+2; j++){

            // Get world point
            var v = shapeB.vertices[(j+shapeB.vertices.length)%shapeB.vertices.length];
            vec2.rotate(worldPoint, v, angleB);
            add(worldPoint, worldPoint, offsetB);

            var insideNumEdges = 0;

            // Loop over the 3 closest edges in convex A
            for(var i=closestEdgeA-1; i<closestEdgeA+2; i++){

                var v0 = shapeA.vertices[(i  +shapeA.vertices.length)%shapeA.vertices.length],
                    v1 = shapeA.vertices[(i+1+shapeA.vertices.length)%shapeA.vertices.length];

                // Construct the edge
                vec2.rotate(worldPoint0, v0, angleA);
                vec2.rotate(worldPoint1, v1, angleA);
                add(worldPoint0, worldPoint0, offsetA);
                add(worldPoint1, worldPoint1, offsetA);

                sub(worldEdge, worldPoint1, worldPoint0);

                vec2.rotate90cw(worldNormal, worldEdge); // Normal points out of convex 1
                vec2.normalize(worldNormal,worldNormal);

                sub(dist, worldPoint, worldPoint0);

                var d = dot(worldNormal,dist);

                if((i === closestEdgeA && d <= precision) || (i !== closestEdgeA && d <= 0)){
                    insideNumEdges++;
                }
            }

            if(insideNumEdges >= 3){

                if(justTest){
                    return true;
                }

                // worldPoint was on the "inside" side of each of the 3 checked edges.
                // Project it to the center edge and use the projection direction as normal

                // Create contact
                var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
                numContacts++;

                // Get center edge from body A
                var v0 = shapeA.vertices[(closestEdgeA)   % shapeA.vertices.length],
                    v1 = shapeA.vertices[(closestEdgeA+1) % shapeA.vertices.length];

                // Construct the edge
                vec2.rotate(worldPoint0, v0, angleA);
                vec2.rotate(worldPoint1, v1, angleA);
                add(worldPoint0, worldPoint0, offsetA);
                add(worldPoint1, worldPoint1, offsetA);

                sub(worldEdge, worldPoint1, worldPoint0);

                vec2.rotate90cw(c.normalA, worldEdge); // Normal points out of convex A
                vec2.normalize(c.normalA,c.normalA);

                sub(dist, worldPoint, worldPoint0); // From edge point to the penetrating point
                var d = dot(c.normalA,dist);             // Penetration
                vec2.scale(penetrationVec, c.normalA, d);     // Vector penetration

                sub(c.contactPointA, worldPoint, offsetA);
                sub(c.contactPointA, c.contactPointA, penetrationVec);
                add(c.contactPointA, c.contactPointA, offsetA);
                sub(c.contactPointA, c.contactPointA, bodyA.position);

                sub(c.contactPointB, worldPoint, offsetB);
                add(c.contactPointB, c.contactPointB, offsetB);
                sub(c.contactPointB, c.contactPointB, bodyB.position);

                this.contactEquations.push(c);

                // Todo reduce to 1 friction equation if we have 2 contact points
                if(!this.enableFrictionReduction){
                    if(this.enableFriction){
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
    }

    if(this.enableFrictionReduction){
        if(this.enableFriction && numContacts){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

// .projectConvex is called by other functions, need local tmp vectors
var pcoa_tmp1 = vec2.fromValues(0,0);

/**
 * Project a Convex onto a world-oriented axis
 * @method projectConvexOntoAxis
 * @static
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Array} worldAxis
 * @param  {Array} result
 */
Narrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result){
    var max=null,
        min=null,
        v,
        value,
        localAxis = pcoa_tmp1;

    // Convert the axis to local coords of the body
    vec2.rotate(localAxis, worldAxis, -convexAngle);

    // Get projected position of all vertices
    for(var i=0; i<convexShape.vertices.length; i++){
        v = convexShape.vertices[i];
        value = dot(v,localAxis);
        if(max === null || value > max){
            max = value;
        }
        if(min === null || value < min){
            min = value;
        }
    }

    if(min > max){
        var t = min;
        min = max;
        max = t;
    }

    // Project the position of the body onto the axis - need to add this to the result
    var offset = dot(convexOffset, worldAxis);

    vec2.set( result, min + offset, max + offset);
};

// .findSeparatingAxis is called by other functions, need local tmp vectors
var fsa_tmp1 = vec2.fromValues(0,0)
,   fsa_tmp2 = vec2.fromValues(0,0)
,   fsa_tmp3 = vec2.fromValues(0,0)
,   fsa_tmp4 = vec2.fromValues(0,0)
,   fsa_tmp5 = vec2.fromValues(0,0)
,   fsa_tmp6 = vec2.fromValues(0,0);

/**
 * Find a separating axis between the shapes, that maximizes the separating distance between them.
 * @method findSeparatingAxis
 * @static
 * @param  {Convex}     c1
 * @param  {Array}      offset1
 * @param  {Number}     angle1
 * @param  {Convex}     c2
 * @param  {Array}      offset2
 * @param  {Number}     angle2
 * @param  {Array}      sepAxis     The resulting axis
 * @return {Boolean}                Whether the axis could be found.
 */
Narrowphase.findSeparatingAxis = function(c1,offset1,angle1,c2,offset2,angle2,sepAxis){
    var maxDist = null,
        overlap = false,
        found = false,
        edge = fsa_tmp1,
        worldPoint0 = fsa_tmp2,
        worldPoint1 = fsa_tmp3,
        normal = fsa_tmp4,
        span1 = fsa_tmp5,
        span2 = fsa_tmp6;

    if(c1 instanceof Rectangle && c2 instanceof Rectangle){

        for(var j=0; j!==2; j++){
            var c = c1,
                angle = angle1;
            if(j===1){
                c = c2;
                angle = angle2;
            }

            for(var i=0; i!==2; i++){

                // Get the world edge
                if(i === 0){
                    vec2.set(normal, 0, 1);
                } else if(i === 1) {
                    vec2.set(normal, 1, 0);
                }
                if(angle !== 0){
                    vec2.rotate(normal, normal, angle);
                }

                // Project hulls onto that normal
                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);

                // Order by span position
                var a=span1,
                    b=span2,
                    swapped = false;
                if(span1[0] > span2[0]){
                    b=span1;
                    a=span2;
                    swapped = true;
                }

                // Get separating distance
                var dist = b[0] - a[1];
                overlap = (dist <= 0);

                if(maxDist===null || dist > maxDist){
                    vec2.copy(sepAxis, normal);
                    maxDist = dist;
                    found = overlap;
                }
            }
        }

    } else {

        for(var j=0; j!==2; j++){
            var c = c1,
                angle = angle1;
            if(j===1){
                c = c2;
                angle = angle2;
            }

            for(var i=0; i!==c.vertices.length; i++){
                // Get the world edge
                vec2.rotate(worldPoint0, c.vertices[i], angle);
                vec2.rotate(worldPoint1, c.vertices[(i+1)%c.vertices.length], angle);

                sub(edge, worldPoint1, worldPoint0);

                // Get normal - just rotate 90 degrees since vertices are given in CCW
                vec2.rotate90cw(normal, edge);
                vec2.normalize(normal,normal);

                // Project hulls onto that normal
                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);

                // Order by span position
                var a=span1,
                    b=span2,
                    swapped = false;
                if(span1[0] > span2[0]){
                    b=span1;
                    a=span2;
                    swapped = true;
                }

                // Get separating distance
                var dist = b[0] - a[1];
                overlap = (dist <= 0);

                if(maxDist===null || dist > maxDist){
                    vec2.copy(sepAxis, normal);
                    maxDist = dist;
                    found = overlap;
                }
            }
        }
    }


    /*
    // Needs to be tested some more
    for(var j=0; j!==2; j++){
        var c = c1,
            angle = angle1;
        if(j===1){
            c = c2;
            angle = angle2;
        }

        for(var i=0; i!==c.axes.length; i++){

            var normal = c.axes[i];

            // Project hulls onto that normal
            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);

            // Order by span position
            var a=span1,
                b=span2,
                swapped = false;
            if(span1[0] > span2[0]){
                b=span1;
                a=span2;
                swapped = true;
            }

            // Get separating distance
            var dist = b[0] - a[1];
            overlap = (dist <= Narrowphase.convexPrecision);

            if(maxDist===null || dist > maxDist){
                vec2.copy(sepAxis, normal);
                maxDist = dist;
                found = overlap;
            }
        }
    }
    */

    return found;
};

// .getClosestEdge is called by other functions, need local tmp vectors
var gce_tmp1 = vec2.fromValues(0,0)
,   gce_tmp2 = vec2.fromValues(0,0)
,   gce_tmp3 = vec2.fromValues(0,0);

/**
 * Get the edge that has a normal closest to an axis.
 * @method getClosestEdge
 * @static
 * @param  {Convex}     c
 * @param  {Number}     angle
 * @param  {Array}      axis
 * @param  {Boolean}    flip
 * @return {Number}             Index of the edge that is closest. This index and the next spans the resulting edge. Returns -1 if failed.
 */
Narrowphase.getClosestEdge = function(c,angle,axis,flip){
    var localAxis = gce_tmp1,
        edge = gce_tmp2,
        normal = gce_tmp3;

    // Convert the axis to local coords of the body
    vec2.rotate(localAxis, axis, -angle);
    if(flip){
        vec2.scale(localAxis,localAxis,-1);
    }

    var closestEdge = -1,
        N = c.vertices.length,
        maxDot = -1;
    for(var i=0; i!==N; i++){
        // Get the edge
        sub(edge, c.vertices[(i+1)%N], c.vertices[i%N]);

        // Get normal - just rotate 90 degrees since vertices are given in CCW
        vec2.rotate90cw(normal, edge);
        vec2.normalize(normal,normal);

        var d = dot(normal,localAxis);
        if(closestEdge === -1 || d > maxDot){
            closestEdge = i % N;
            maxDot = d;
        }
    }

    return closestEdge;
};

var circleHeightfield_candidate = vec2.create(),
    circleHeightfield_dist = vec2.create(),
    circleHeightfield_v0 = vec2.create(),
    circleHeightfield_v1 = vec2.create(),
    circleHeightfield_minCandidate = vec2.create(),
    circleHeightfield_worldNormal = vec2.create(),
    circleHeightfield_minCandidateNormal = vec2.create();

/**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =
Narrowphase.prototype.circleHeightfield = function( circleBody,circleShape,circlePos,circleAngle,
                                                    hfBody,hfShape,hfPos,hfAngle, justTest, radius ){
    var data = hfShape.data,
        radius = radius || circleShape.radius,
        w = hfShape.elementWidth,
        dist = circleHeightfield_dist,
        candidate = circleHeightfield_candidate,
        minCandidate = circleHeightfield_minCandidate,
        minCandidateNormal = circleHeightfield_minCandidateNormal,
        worldNormal = circleHeightfield_worldNormal,
        v0 = circleHeightfield_v0,
        v1 = circleHeightfield_v1;

    // Get the index of the points to test against
    var idxA = Math.floor( (circlePos[0] - radius - hfPos[0]) / w ),
        idxB = Math.ceil(  (circlePos[0] + radius - hfPos[0]) / w );

    /*if(idxB < 0 || idxA >= data.length)
        return justTest ? false : 0;*/

    if(idxA < 0){
        idxA = 0;
    }
    if(idxB >= data.length){
        idxB = data.length-1;
    }

    // Get max and min
    var max = data[idxA],
        min = data[idxB];
    for(var i=idxA; i<idxB; i++){
        if(data[i] < min){
            min = data[i];
        }
        if(data[i] > max){
            max = data[i];
        }
    }

    if(circlePos[1]-radius > max){
        return justTest ? false : 0;
    }

    /*
    if(circlePos[1]+radius < min){
        // Below the minimum point... We can just guess.
        // TODO
    }
    */

    // 1. Check so center of circle is not inside the field. If it is, this wont work...
    // 2. For each edge
    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
    // 2. 2. Check if point is inside.

    var found = false;

    // Check all edges first
    for(var i=idxA; i<idxB; i++){

        // Get points
        vec2.set(v0,     i*w, data[i]  );
        vec2.set(v1, (i+1)*w, data[i+1]);
        vec2.add(v0,v0,hfPos);
        vec2.add(v1,v1,hfPos);

        // Get normal
        vec2.sub(worldNormal, v1, v0);
        vec2.rotate(worldNormal, worldNormal, Math.PI/2);
        vec2.normalize(worldNormal,worldNormal);

        // Get point on circle, closest to the edge
        vec2.scale(candidate,worldNormal,-radius);
        vec2.add(candidate,candidate,circlePos);

        // Distance from v0 to the candidate point
        vec2.sub(dist,candidate,v0);

        // Check if it is in the element "stick"
        var d = vec2.dot(dist,worldNormal);
        if(candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0){

            if(justTest){
                return true;
            }

            found = true;

            // Store the candidate point, projected to the edge
            vec2.scale(dist,worldNormal,-d);
            vec2.add(minCandidate,candidate,dist);
            vec2.copy(minCandidateNormal,worldNormal);

            var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);

            // Normal is out of the heightfield
            vec2.copy(c.normalA, minCandidateNormal);

            // Vector from circle to heightfield
            vec2.scale(c.contactPointB,  c.normalA, -radius);
            add(c.contactPointB, c.contactPointB, circlePos);
            sub(c.contactPointB, c.contactPointB, circleBody.position);

            vec2.copy(c.contactPointA, minCandidate);
            vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push( this.createFrictionFromContact(c) );
            }
        }
    }

    // Check all vertices
    found = false;
    if(radius > 0){
        for(var i=idxA; i<=idxB; i++){

            // Get point
            vec2.set(v0, i*w, data[i]);
            vec2.add(v0,v0,hfPos);

            vec2.sub(dist, circlePos, v0);

            if(vec2.squaredLength(dist) < Math.pow(radius, 2)){

                if(justTest){
                    return true;
                }

                found = true;

                var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);

                // Construct normal - out of heightfield
                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA,c.normalA);

                vec2.scale(c.contactPointB, c.normalA, -radius);
                add(c.contactPointB, c.contactPointB, circlePos);
                sub(c.contactPointB, c.contactPointB, circleBody.position);

                sub(c.contactPointA, v0, hfPos);
                add(c.contactPointA, c.contactPointA, hfPos);
                sub(c.contactPointA, c.contactPointA, hfBody.position);

                this.contactEquations.push(c);

                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(found){
        return 1;
    }

    return 0;

};

var convexHeightfield_v0 = vec2.create(),
    convexHeightfield_v1 = vec2.create(),
    convexHeightfield_tilePos = vec2.create(),
    convexHeightfield_tempConvexShape = new Convex([vec2.create(),vec2.create(),vec2.create(),vec2.create()]);
/**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */
Narrowphase.prototype[Shape.RECTANGLE | Shape.HEIGHTFIELD] =
Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =
Narrowphase.prototype.convexHeightfield = function( convexBody,convexShape,convexPos,convexAngle,
                                                    hfBody,hfShape,hfPos,hfAngle, justTest ){
    var data = hfShape.data,
        w = hfShape.elementWidth,
        v0 = convexHeightfield_v0,
        v1 = convexHeightfield_v1,
        tilePos = convexHeightfield_tilePos,
        tileConvex = convexHeightfield_tempConvexShape;

    // Get the index of the points to test against
    var idxA = Math.floor( (convexBody.aabb.lowerBound[0] - hfPos[0]) / w ),
        idxB = Math.ceil(  (convexBody.aabb.upperBound[0] - hfPos[0]) / w );

    if(idxA < 0){
        idxA = 0;
    }
    if(idxB >= data.length){
        idxB = data.length-1;
    }

    // Get max and min
    var max = data[idxA],
        min = data[idxB];
    for(var i=idxA; i<idxB; i++){
        if(data[i] < min){
            min = data[i];
        }
        if(data[i] > max){
            max = data[i];
        }
    }

    if(convexBody.aabb.lowerBound[1] > max){
        return justTest ? false : 0;
    }

    var found = false;
    var numContacts = 0;

    // Loop over all edges
    // TODO: If possible, construct a convex from several data points (need o check if the points make a convex shape)
    for(var i=idxA; i<idxB; i++){

        // Get points
        vec2.set(v0,     i*w, data[i]  );
        vec2.set(v1, (i+1)*w, data[i+1]);
        vec2.add(v0,v0,hfPos);
        vec2.add(v1,v1,hfPos);

        // Construct a convex
        var tileHeight = 100; // todo
        vec2.set(tilePos, (v1[0] + v0[0])*0.5, (v1[1] + v0[1] - tileHeight)*0.5);

        vec2.sub(tileConvex.vertices[0], v1, tilePos);
        vec2.sub(tileConvex.vertices[1], v0, tilePos);
        vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);
        vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);
        tileConvex.vertices[2][1] -= tileHeight;
        tileConvex.vertices[3][1] -= tileHeight;

        // Do convex collision
        numContacts += this.convexConvex(   convexBody, convexShape, convexPos, convexAngle,
                                            hfBody, tileConvex, tilePos, 0, justTest);
    }

    return numContacts;
};
},{"../equations/ContactEquation":22,"../equations/Equation":23,"../equations/FrictionEquation":24,"../math/vec2":31,"../objects/Body":32,"../shapes/Circle":38,"../shapes/Convex":39,"../shapes/Rectangle":44,"../shapes/Shape":45,"../utils/TupleDictionary":49,"../utils/Utils":50}],12:[function(_dereq_,module,exports){
module.exports = Ray;

var vec2 = _dereq_('../math/vec2');
var RaycastResult = _dereq_('../collision/RaycastResult');
var Shape = _dereq_('../shapes/Shape');
var AABB = _dereq_('../collision/AABB');

/**
 * A line with a start and end point that is used to intersect shapes.
 * @class Ray
 * @constructor
 */
function Ray(options){
    options = options || {};

    /**
     * @property {array} from
     */
    this.from = options.from ? vec2.fromValues(options.from[0], options.from[1]) : vec2.create();

    /**
     * @property {array} to
     */
    this.to = options.to ? vec2.fromValues(options.to[0], options.to[1]) : vec2.create();

    /**
     * @private
     * @property {array} _direction
     */
    this._direction = vec2.create();

    /**
     * The precision of the ray. Used when checking parallelity etc.
     * @property {Number} precision
     */
    this.precision = 0.0001;

    /**
     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
     * @property {Boolean} checkCollisionResponse
     */
    this.checkCollisionResponse = true;

    /**
     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
     * @property {Boolean} skipBackfaces
     */
    this.skipBackfaces = false;

    /**
     * @property {number} collisionMask
     * @default -1
     */
    this.collisionMask = -1;

    /**
     * @property {number} collisionGroup
     * @default -1
     */
    this.collisionGroup = -1;

    /**
     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
     * @property {number} mode
     */
    this.mode = Ray.ANY;

    /**
     * Current result object.
     * @property {RaycastResult} result
     */
    this.result = new RaycastResult();

    /**
     * Will be set to true during intersectWorld() if the ray hit anything.
     * @property {Boolean} hasHit
     */
    this.hasHit = false;

    /**
     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
     * @property {Function} callback
     */
    this.callback = function(result){};
}
Ray.prototype.constructor = Ray;

Ray.CLOSEST = 1;
Ray.ANY = 2;
Ray.ALL = 4;

var tmpAABB = new AABB();
var tmpArray = [];

/**
 * Do itersection against all bodies in the given World.
 * @method intersectWorld
 * @param  {World} world
 * @param  {object} options
 * @return {Boolean} True if the ray hit anything, otherwise false.
 */
Ray.prototype.intersectWorld = function (world, options) {
    this.mode = options.mode || Ray.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionMask = typeof(options.collisionMask) !== 'undefined' ? options.collisionMask : -1;
    this.collisionGroup = typeof(options.collisionGroup) !== 'undefined' ? options.collisionGroup : -1;
    if(options.from){
        vec2.copy(this.from, options.from);
    }
    if(options.to){
        vec2.copy(this.to, options.to);
    }
    this.callback = options.callback || function(){};
    this.hasHit = false;

    this.result.reset();
    this._updateDirection();

    this.getAABB(tmpAABB);
    tmpArray.length = 0;
    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
    this.intersectBodies(tmpArray);

    return this.hasHit;
};

var v1 = vec2.create(),
    v2 = vec2.create();

var intersectBody_worldPosition = vec2.create();

/**
 * Shoot a ray at a body, get back information about the hit.
 * @method intersectBody
 * @private
 * @param {Body} body
 * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
 */
Ray.prototype.intersectBody = function (body, result) {

    if(result){
        this.result = result;
        this._updateDirection();
    }
    var checkCollisionResponse = this.checkCollisionResponse;

    if(checkCollisionResponse && !body.collisionResponse){
        return;
    }

    // if((this.collisionGroup & body.collisionMask)===0 || (body.collisionGroup & this.collisionMask)===0){
    //     return;
    // }

    var worldPosition = intersectBody_worldPosition;

    for (var i = 0, N = body.shapes.length; i < N; i++) {
        var shape = body.shapes[i];

        if(checkCollisionResponse && !shape.collisionResponse){
            continue; // Skip
        }

        // Get world angle and position of the shape
        vec2.copy(worldPosition, body.shapeOffsets[i]);
        vec2.rotate(worldPosition, worldPosition, body.angle);
        vec2.add(worldPosition, worldPosition, body.position);
        var worldAngle = body.shapeAngles[i] + body.angle;

        this.intersectShape(
            shape,
            worldAngle,
            worldPosition,
            body
        );

        if(this.result._shouldStop){
            break;
        }
    }
};

/**
 * @method intersectBodies
 * @param {Array} bodies An array of Body objects.
 * @param {RaycastResult} [result] Deprecated
 */
Ray.prototype.intersectBodies = function (bodies, result) {
    if(result){
        this.result = result;
        this._updateDirection();
    }

    for ( var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i ++ ) {
        this.intersectBody(bodies[i]);
    }
};

/**
 * Updates the _direction vector.
 * @private
 * @method _updateDirection
 */
Ray.prototype._updateDirection = function(){
    var d = this._direction;
    vec2.sub(d, this.to, this.from); // this.to.vsub(this.from, this._direction);
    vec2.normalize(d, d); // this._direction.normalize();
};

/**
 * @method intersectShape
 * @private
 * @param {Shape} shape
 * @param {number} angle
 * @param {array} position
 * @param {Body} body
 */
Ray.prototype.intersectShape = function(shape, angle, position, body){
    var from = this.from;


    // Checking boundingSphere
    var distance = distanceFromIntersection(from, this._direction, position);
    if ( distance > shape.boundingSphereRadius ) {
        return;
    }

    var method = this[shape.type];
    if(method){
        method.call(this, shape, angle, position, body);
    }
};

var vector = vec2.create();
var normal = vec2.create();
var intersectPoint = vec2.create();

var a = vec2.create();
var b = vec2.create();
var c = vec2.create();
var d = vec2.create();

var tmpRaycastResult = new RaycastResult();
var intersectRectangle_direction = vec2.create();
var intersectRectangle_rayStart = vec2.create();
var intersectRectangle_worldNormalMin = vec2.create();
var intersectRectangle_worldNormalMax = vec2.create();
var intersectRectangle_hitPointWorld = vec2.create();
var intersectRectangle_boxMin = vec2.create();
var intersectRectangle_boxMax = vec2.create();

/**
 * @method intersectRectangle
 * @private
 * @param  {Shape} shape
 * @param  {number} angle
 * @param  {array} position
 * @param  {Body} body
 */
Ray.prototype.intersectRectangle = function(shape, angle, position, body){
    var tmin = -Number.MAX_VALUE;
    var tmax = Number.MAX_VALUE;

    var direction = intersectRectangle_direction;
    var rayStart = intersectRectangle_rayStart;
    var worldNormalMin = intersectRectangle_worldNormalMin;
    var worldNormalMax = intersectRectangle_worldNormalMax;
    var hitPointWorld = intersectRectangle_hitPointWorld;
    var boxMin = intersectRectangle_boxMin;
    var boxMax = intersectRectangle_boxMax;

    vec2.set(boxMin, -shape.width * 0.5, -shape.height * 0.5);
    vec2.set(boxMax, shape.width * 0.5, shape.height * 0.5);

    // Transform the ray direction and start to local space
    vec2.rotate(direction, this._direction, -angle);
    body.toLocalFrame(rayStart, this.from);

    if (direction[0] !== 0) {
        var tx1 = (boxMin[0] - rayStart[0]) / direction[0];
        var tx2 = (boxMax[0] - rayStart[0]) / direction[0];

        var tminOld = tmin;
        tmin = Math.max(tmin, Math.min(tx1, tx2));
        if(tmin !== tminOld){
            vec2.set(worldNormalMin, tx1 > tx2 ? 1 : -1, 0);
        }

        var tmaxOld = tmax;
        tmax = Math.min(tmax, Math.max(tx1, tx2));
        if(tmax !== tmaxOld){
            vec2.set(worldNormalMax, tx1 < tx2 ? 1 : -1, 0);
        }
    }

    if (direction[1] !== 0) {
        var ty1 = (boxMin[1] - rayStart[1]) / direction[1];
        var ty2 = (boxMax[1] - rayStart[1]) / direction[1];

        var tminOld = tmin;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        if(tmin !== tminOld){
            vec2.set(worldNormalMin, 0, ty1 > ty2 ? 1 : -1);
        }

        var tmaxOld = tmax;
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        if(tmax !== tmaxOld){
            vec2.set(worldNormalMax, 0, ty1 < ty2 ? 1 : -1);
        }
    }

    if(tmax >= tmin){
        // Hit point
        vec2.set(
            hitPointWorld,
            rayStart[0] + direction[0] * tmin,
            rayStart[1] + direction[1] * tmin
        );

        vec2.rotate(worldNormalMin, worldNormalMin, angle);

        body.toWorldFrame(hitPointWorld, hitPointWorld);

        this.reportIntersection(worldNormalMin, hitPointWorld, shape, body, -1);
        if(this._shouldStop){
            return;
        }

        vec2.rotate(worldNormalMax, worldNormalMax, angle);

        // Hit point
        vec2.set(
            hitPointWorld,
            rayStart[0] + direction[0] * tmax,
            rayStart[1] + direction[1] * tmax
        );
        body.toWorldFrame(hitPointWorld, hitPointWorld);

        this.reportIntersection(worldNormalMax, hitPointWorld, shape, body, -1);
    }
};
Ray.prototype[Shape.RECTANGLE] = Ray.prototype.intersectRectangle;

var intersectPlane_planePointToFrom = vec2.create();
var intersectPlane_dir_scaled_with_t = vec2.create();
var intersectPlane_hitPointWorld = vec2.create();
var intersectPlane_worldNormal = vec2.create();
var intersectPlane_len = vec2.create();

/**
 * @method intersectPlane
 * @private
 * @param  {Shape} shape
 * @param  {number} angle
 * @param  {array} position
 * @param  {Body} body
 */
Ray.prototype.intersectPlane = function(shape, angle, position, body){
    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    var planePointToFrom = intersectPlane_planePointToFrom;
    var dir_scaled_with_t = intersectPlane_dir_scaled_with_t;
    var hitPointWorld = intersectPlane_hitPointWorld;
    var worldNormal = intersectPlane_worldNormal;
    var len = intersectPlane_len;

    // Get plane normal
    vec2.set(worldNormal, 0, 1);
    vec2.rotate(worldNormal, worldNormal, angle);

    vec2.sub(len, from, position); //from.vsub(position, len);
    var planeToFrom = vec2.dot(len, worldNormal); // len.dot(worldNormal);
    vec2.sub(len, to, position); // to.vsub(position, len);
    var planeToTo = vec2.dot(len, worldNormal); // len.dot(worldNormal);

    if(planeToFrom * planeToTo > 0){
        // "from" and "to" are on the same side of the plane... bail out
        return;
    }

    if(vec2.distance(from, to) /* from.distanceTo(to) */ < planeToFrom){
        return;
    }

    var n_dot_dir = vec2.dot(worldNormal, direction); // worldNormal.dot(direction);

    // if (Math.abs(n_dot_dir) < this.precision) {
    //     // No intersection
    //     return;
    // }

    vec2.sub(planePointToFrom, from, position); // from.vsub(position, planePointToFrom);
    var t = -vec2.dot(worldNormal, planePointToFrom) / n_dot_dir; // - worldNormal.dot(planePointToFrom) / n_dot_dir;
    vec2.scale(dir_scaled_with_t, direction, t); // direction.scale(t, dir_scaled_with_t);
    vec2.add(hitPointWorld, from, dir_scaled_with_t); // from.vadd(dir_scaled_with_t, hitPointWorld);

    this.reportIntersection(worldNormal, hitPointWorld, shape, body, -1);
};
Ray.prototype[Shape.PLANE] = Ray.prototype.intersectPlane;

var Ray_intersectSphere_intersectionPoint = vec2.create();
var Ray_intersectSphere_normal = vec2.create();
Ray.prototype.intersectCircle = function(shape, angle, position, body){
    var from = this.from,
        to = this.to,
        r = shape.radius;

    var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
    var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
    var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);

    var delta = Math.pow(b, 2) - 4 * a * c;

    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
    var normal = Ray_intersectSphere_normal;

    if(delta < 0){
        // No intersection
        return;

    } else if(delta === 0){
        // single intersection point
        vec2.lerp(intersectionPoint, from, to, delta); // from.lerp(to, delta, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

    } else {
        var d1 = (- b - Math.sqrt(delta)) / (2 * a);
        var d2 = (- b + Math.sqrt(delta)) / (2 * a);

        vec2.lerp(intersectionPoint, from, to, d1); // from.lerp(to, d1, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

        if(this.result._shouldStop){
            return;
        }

        vec2.lerp(intersectionPoint, from, to, d2); // from.lerp(to, d2, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);
    }
};
Ray.prototype[Shape.CIRCLE] = Ray.prototype.intersectCircle;

/**
 * Get the AABB of the ray.
 * @method getAABB
 * @param  {AABB} aabb
 */
Ray.prototype.getAABB = function(result){
    var to = this.to;
    var from = this.from;
    result.lowerBound[0] = Math.min(to[0], from[0]);
    result.lowerBound[1] = Math.min(to[1], from[1]);
    result.upperBound[0] = Math.max(to[0], from[0]);
    result.upperBound[1] = Math.max(to[1], from[1]);
};

/**
 * @method reportIntersection
 * @private
 * @param  {array} normal
 * @param  {array} hitPointWorld
 * @param  {Shape} shape
 * @param  {Body} body
 * @return {boolean} True if the intersections should continue
 */
Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex){
    var from = this.from;
    var to = this.to;
    var distance = vec2.distance(from, hitPointWorld); // from.distanceTo(hitPointWorld);
    var result = this.result;

    // Skip back faces?
    if(this.skipBackfaces && /* normal.dot(this._direction) */ vec2.dot(normal, this._direction) > 0){
        return;
    }

    result.hitFaceIndex = typeof(hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;

    switch(this.mode){
    case Ray.ALL:
        this.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result.hasHit = true;
        this.callback(result);
        break;

    case Ray.CLOSEST:

        // Store if closer than current closest
        if(distance < result.distance || !result.hasHit){
            this.hasHit = true;
            result.hasHit = true;
            result.set(
                from,
                to,
                normal,
                hitPointWorld,
                shape,
                body,
                distance
            );
        }
        break;

    case Ray.ANY:

        // Report and stop.
        this.hasHit = true;
        result.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result._shouldStop = true;
        break;
    }
};

var v0 = vec2.create(),
    intersect = vec2.create();
function distanceFromIntersection(from, direction, position) {

    // v0 is vector from from to position
    vec2.sub(v0, position, from); // position.vsub(from,v0);
    var dot = vec2.dot(v0, direction); // v0.dot(direction);

    // intersect = direction*dot + from
    vec2.scale(intersect, direction, dot); //direction.mult(dot,intersect);
    vec2.add(intersect, intersect, from); // intersect.vadd(from, intersect);

    var distance = vec2.distance(position, intersect); // position.distanceTo(intersect);

    return distance;
}


},{"../collision/AABB":7,"../collision/RaycastResult":13,"../math/vec2":31,"../shapes/Shape":45}],13:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');

module.exports = RaycastResult;

/**
 * Storage for Ray casting data.
 * @class RaycastResult
 * @constructor
 */
function RaycastResult(){

	/**
	 * @property {array} rayFromWorld
	 */
	this.rayFromWorld = vec2.create();

	/**
	 * @property {array} rayToWorld
	 */
	this.rayToWorld = vec2.create();

	/**
	 * @property {array} hitNormalWorld
	 */
	this.hitNormalWorld = vec2.create();

	/**
	 * @property {array} hitPointWorld
	 */
	this.hitPointWorld = vec2.create();

	/**
	 * @property {boolean} hasHit
	 */
	this.hasHit = false;

	/**
	 * The hit shape, or null.
	 * @property {Shape} shape
	 */
	this.shape = null;

	/**
	 * The hit body, or null.
	 * @property {Body} body
	 */
	this.body = null;

	/**
	 * The index of the hit triangle, if the hit shape was a trimesh.
	 * @property {number} hitFaceIndex
	 * @default -1
	 */
	this.hitFaceIndex = -1;

	/**
	 * Distance to the hit. Will be set to -1 if there was no hit.
	 * @property {number} distance
	 * @default -1
	 */
	this.distance = -1;

	/**
	 * If the ray should stop traversing the bodies.
	 * @private
	 * @property {Boolean} _shouldStop
	 * @default false
	 */
	this._shouldStop = false;
}

/**
 * Reset all result data.
 * @method reset
 */
RaycastResult.prototype.reset = function () {
	vec2.set(this.rayFromWorld, 0, 0);
	vec2.set(this.rayToWorld, 0, 0);
	vec2.set(this.hitNormalWorld, 0, 0);
	vec2.set(this.hitPointWorld, 0, 0);
	this.hasHit = false;
	this.shape = null;
	this.body = null;
	this.hitFaceIndex = -1;
	this.distance = -1;
	this._shouldStop = false;
};

/**
 * @method abort
 */
RaycastResult.prototype.abort = function(){
	this._shouldStop = true;
};

/**
 * @method set
 * @param {array} rayFromWorld
 * @param {array} rayToWorld
 * @param {array} hitNormalWorld
 * @param {array} hitPointWorld
 * @param {Shape} shape
 * @param {Body} body
 * @param {number} distance
 */
RaycastResult.prototype.set = function(
	rayFromWorld,
	rayToWorld,
	hitNormalWorld,
	hitPointWorld,
	shape,
	body,
	distance
){
	vec2.copy(this.rayFromWorld, rayFromWorld);
	vec2.copy(this.rayToWorld, rayToWorld);
	vec2.copy(this.hitNormalWorld, hitNormalWorld);
	vec2.copy(this.hitPointWorld, hitPointWorld);
	this.shape = shape;
	this.body = body;
	this.distance = distance;
};
},{"../math/vec2":31}],14:[function(_dereq_,module,exports){
var Utils = _dereq_('../utils/Utils')
,   Broadphase = _dereq_('../collision/Broadphase');

module.exports = SAPBroadphase;

/**
 * Sweep and prune broadphase along one axis.
 *
 * @class SAPBroadphase
 * @constructor
 * @extends Broadphase
 */
function SAPBroadphase(){
    Broadphase.call(this,Broadphase.SAP);

    /**
     * List of bodies currently in the broadphase.
     * @property axisList
     * @type {Array}
     */
    this.axisList = [];

    /**
     * The axis to sort along. 0 means x-axis and 1 y-axis. If your bodies are more spread out over the X axis, set axisIndex to 0, and you will gain some performance.
     * @property axisIndex
     * @type {Number}
     */
    this.axisIndex = 0;

    var that = this;
    this._addBodyHandler = function(e){
        that.axisList.push(e.body);
    };

    this._removeBodyHandler = function(e){
        // Remove from list
        var idx = that.axisList.indexOf(e.body);
        if(idx !== -1){
            that.axisList.splice(idx,1);
        }
    };
}
SAPBroadphase.prototype = new Broadphase();
SAPBroadphase.prototype.constructor = SAPBroadphase;

/**
 * Change the world
 * @method setWorld
 * @param {World} world
 */
SAPBroadphase.prototype.setWorld = function(world){
    // Clear the old axis array
    this.axisList.length = 0;

    // Add all bodies from the new world
    Utils.appendArray(this.axisList, world.bodies);

    // Remove old handlers, if any
    world
        .off("addBody",this._addBodyHandler)
        .off("removeBody",this._removeBodyHandler);

    // Add handlers to update the list of bodies.
    world.on("addBody",this._addBodyHandler).on("removeBody",this._removeBodyHandler);

    this.world = world;
};

/**
 * Sorts bodies along an axis.
 * @method sortAxisList
 * @param {Array} a
 * @param {number} axisIndex
 * @return {Array}
 */
SAPBroadphase.sortAxisList = function(a, axisIndex){
    axisIndex = axisIndex|0;
    for(var i=1,l=a.length; i<l; i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

SAPBroadphase.prototype.sortList = function(){
    var bodies = this.axisList,
    axisIndex = this.axisIndex;

    // Sort the lists
    SAPBroadphase.sortAxisList(bodies, axisIndex);
};

/**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
SAPBroadphase.prototype.getCollisionPairs = function(world){
    var bodies = this.axisList,
        result = this.result,
        axisIndex = this.axisIndex;

    result.length = 0;

    // Update all AABBs if needed
    var l = bodies.length;
    while(l--){
        var b = bodies[l];
        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }
    }

    // Sort the lists
    this.sortList();

    // Look through the X list
    for(var i=0, N=bodies.length|0; i!==N; i++){
        var bi = bodies[i];

        for(var j=i+1; j<N; j++){
            var bj = bodies[j];

            // Bounds overlap?
            var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);
            if(!overlaps){
                break;
            }

            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                result.push(bi,bj);
            }
        }
    }

    return result;
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    this.sortList();

    var axisIndex = this.axisIndex;
    var axis = 'x';
    if(axisIndex === 1){ axis = 'y'; }
    if(axisIndex === 2){ axis = 'z'; }

    var axisList = this.axisList;
    var lower = aabb.lowerBound[axis];
    var upper = aabb.upperBound[axis];
    for(var i = 0; i < axisList.length; i++){
        var b = axisList[i];

        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":8,"../utils/Utils":50}],15:[function(_dereq_,module,exports){
module.exports = Constraint;

var Utils = _dereq_('../utils/Utils');

/**
 * Base constraint class.
 *
 * @class Constraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} type
 * @param {Object} [options]
 * @param {Object} [options.collideConnected=true]
 */
function Constraint(bodyA, bodyB, type, options){

    /**
     * The type of constraint. May be one of Constraint.DISTANCE, Constraint.GEAR, Constraint.LOCK, Constraint.PRISMATIC or Constraint.REVOLUTE.
     * @property {number} type
     */
    this.type = type;

    options = Utils.defaults(options,{
        collideConnected : true,
        wakeUpBodies : true,
    });

    /**
     * Equations to be solved in this constraint
     *
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * First body participating in the constraint.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second body participating in the constraint.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * Set to true if you want the connected bodies to collide.
     * @property collideConnected
     * @type {Boolean}
     * @default true
     */
    this.collideConnected = options.collideConnected;

    // Wake up bodies when connected
    if(options.wakeUpBodies){
        if(bodyA){
            bodyA.wakeUp();
        }
        if(bodyB){
            bodyB.wakeUp();
        }
    }
}

/**
 * Updates the internal constraint parameters before solve.
 * @method update
 */
Constraint.prototype.update = function(){
    throw new Error("method update() not implmemented in this Constraint subclass!");
};

/**
 * @static
 * @property {number} DISTANCE
 */
Constraint.DISTANCE = 1;

/**
 * @static
 * @property {number} GEAR
 */
Constraint.GEAR = 2;

/**
 * @static
 * @property {number} LOCK
 */
Constraint.LOCK = 3;

/**
 * @static
 * @property {number} PRISMATIC
 */
Constraint.PRISMATIC = 4;

/**
 * @static
 * @property {number} REVOLUTE
 */
Constraint.REVOLUTE = 5;

/**
 * Set stiffness for this constraint.
 * @method setStiffness
 * @param {Number} stiffness
 */
Constraint.prototype.setStiffness = function(stiffness){
    var eqs = this.equations;
    for(var i=0; i !== eqs.length; i++){
        var eq = eqs[i];
        eq.stiffness = stiffness;
        eq.needsUpdate = true;
    }
};

/**
 * Set relaxation for this constraint.
 * @method setRelaxation
 * @param {Number} relaxation
 */
Constraint.prototype.setRelaxation = function(relaxation){
    var eqs = this.equations;
    for(var i=0; i !== eqs.length; i++){
        var eq = eqs[i];
        eq.relaxation = relaxation;
        eq.needsUpdate = true;
    }
};

},{"../utils/Utils":50}],16:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = DistanceConstraint;

/**
 * Constraint that tries to keep the distance between two bodies constant.
 *
 * @class DistanceConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.
 * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
 * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
 * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.
 * @extends Constraint
 *
 * @example
 *     // If distance is not given as an option, then the current distance between the bodies is used.
 *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new DistanceConstraint(bodyA, bodyB);
 *
 * @example
 *     var constraint = new DistanceConstraint(bodyA, bodyB, {
 *         distance: 1,          // Distance to keep between the points
 *         localAnchorA: [1, 0], // Point on bodyA
 *         localAnchorB: [-1, 0] // Point on bodyB
 *     });
 */
function DistanceConstraint(bodyA,bodyB,options){
    options = Utils.defaults(options,{
        localAnchorA:[0,0],
        localAnchorB:[0,0]
    });

    Constraint.call(this,bodyA,bodyB,Constraint.DISTANCE,options);

    /**
     * Local anchor in body A.
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);

    /**
     * Local anchor in body B.
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);

    var localAnchorA = this.localAnchorA;
    var localAnchorB = this.localAnchorB;

    /**
     * The distance to keep.
     * @property distance
     * @type {Number}
     */
    this.distance = 0;

    if(typeof(options.distance) === 'number'){
        this.distance = options.distance;
    } else {
        // Use the current world distance between the world anchor points.
        var worldAnchorA = vec2.create(),
            worldAnchorB = vec2.create(),
            r = vec2.create();

        // Transform local anchors to world
        vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);
        vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);

        vec2.add(r, bodyB.position, worldAnchorB);
        vec2.sub(r, r, worldAnchorA);
        vec2.sub(r, r, bodyA.position);

        this.distance = vec2.length(r);
    }

    var maxForce;
    if(typeof(options.maxForce)==="undefined" ){
        maxForce = Number.MAX_VALUE;
    } else {
        maxForce = options.maxForce;
    }

    var normal = new Equation(bodyA,bodyB,-maxForce,maxForce); // Just in the normal direction
    this.equations = [ normal ];

    /**
     * Max force to apply.
     * @property {number} maxForce
     */
    this.maxForce = maxForce;

    // g = (xi - xj).dot(n)
    // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'

    // ...and if we were to include offset points (TODO for now):
    // g =
    //      (xj + rj - xi - ri).dot(n) - distance
    //
    // dg/dt =
    //      (vj + wj x rj - vi - wi x ri).dot(n) =
    //      { term 2 is near zero } =
    //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =
    //      G * W
    //
    // => G = [-n -rixn n rjxn]

    var r = vec2.create();
    var ri = vec2.create(); // worldAnchorA
    var rj = vec2.create(); // worldAnchorB
    var that = this;
    normal.computeGq = function(){
        var bodyA = this.bodyA,
            bodyB = this.bodyB,
            xi = bodyA.position,
            xj = bodyB.position;

        // Transform local anchors to world
        vec2.rotate(ri, localAnchorA, bodyA.angle);
        vec2.rotate(rj, localAnchorB, bodyB.angle);

        vec2.add(r, xj, rj);
        vec2.sub(r, r, ri);
        vec2.sub(r, r, xi);

        //vec2.sub(r, bodyB.position, bodyA.position);
        return vec2.length(r) - that.distance;
    };

    // Make the contact constraint bilateral
    this.setMaxForce(maxForce);

    /**
     * If the upper limit is enabled or not.
     * @property {Boolean} upperLimitEnabled
     */
    this.upperLimitEnabled = false;

    /**
     * The upper constraint limit.
     * @property {number} upperLimit
     */
    this.upperLimit = 1;

    /**
     * If the lower limit is enabled or not.
     * @property {Boolean} lowerLimitEnabled
     */
    this.lowerLimitEnabled = false;

    /**
     * The lower constraint limit.
     * @property {number} lowerLimit
     */
    this.lowerLimit = 0;

    /**
     * Current constraint position. This is equal to the current distance between the world anchor points.
     * @property {number} position
     */
    this.position = 0;
}
DistanceConstraint.prototype = new Constraint();
DistanceConstraint.prototype.constructor = DistanceConstraint;

/**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */
var n = vec2.create();
var ri = vec2.create(); // worldAnchorA
var rj = vec2.create(); // worldAnchorB
DistanceConstraint.prototype.update = function(){
    var normal = this.equations[0],
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        distance = this.distance,
        xi = bodyA.position,
        xj = bodyB.position,
        normalEquation = this.equations[0],
        G = normal.G;

    // Transform local anchors to world
    vec2.rotate(ri, this.localAnchorA, bodyA.angle);
    vec2.rotate(rj, this.localAnchorB, bodyB.angle);

    // Get world anchor points and normal
    vec2.add(n, xj, rj);
    vec2.sub(n, n, ri);
    vec2.sub(n, n, xi);
    this.position = vec2.length(n);

    var violating = false;
    if(this.upperLimitEnabled){
        if(this.position > this.upperLimit){
            normalEquation.maxForce = 0;
            normalEquation.minForce = -this.maxForce;
            this.distance = this.upperLimit;
            violating = true;
        }
    }

    if(this.lowerLimitEnabled){
        if(this.position < this.lowerLimit){
            normalEquation.maxForce = this.maxForce;
            normalEquation.minForce = 0;
            this.distance = this.lowerLimit;
            violating = true;
        }
    }

    if((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating){
        // No constraint needed.
        normalEquation.enabled = false;
        return;
    }

    normalEquation.enabled = true;

    vec2.normalize(n,n);

    // Caluclate cross products
    var rixn = vec2.crossLength(ri, n),
        rjxn = vec2.crossLength(rj, n);

    // G = [-n -rixn n rjxn]
    G[0] = -n[0];
    G[1] = -n[1];
    G[2] = -rixn;
    G[3] = n[0];
    G[4] = n[1];
    G[5] = rjxn;
};

/**
 * Set the max force to be used
 * @method setMaxForce
 * @param {Number} f
 */
DistanceConstraint.prototype.setMaxForce = function(f){
    var normal = this.equations[0];
    normal.minForce = -f;
    normal.maxForce =  f;
};

/**
 * Get the max force
 * @method getMaxForce
 * @return {Number}
 */
DistanceConstraint.prototype.getMaxForce = function(f){
    var normal = this.equations[0];
    return normal.maxForce;
};

},{"../equations/Equation":23,"../math/vec2":31,"../utils/Utils":50,"./Constraint":15}],17:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   AngleLockEquation = _dereq_('../equations/AngleLockEquation')
,   vec2 = _dereq_('../math/vec2');

module.exports = GearConstraint;

/**
 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
 * @class GearConstraint
 * @constructor
 * @author schteppe
 * @param {Body}            bodyA
 * @param {Body}            bodyB
 * @param {Object}          [options]
 * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).
 * @param {Number}          [options.ratio=1] Gear ratio.
 * @param {Number}          [options.maxTorque] Maximum torque to apply.
 * @extends Constraint
 * @todo Ability to specify world points
 */
function GearConstraint(bodyA, bodyB, options){
    options = options || {};

    Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);

    /**
     * The gear ratio.
     * @property ratio
     * @type {Number}
     */
    this.ratio = typeof(options.ratio) === "number" ? options.ratio : 1;

    /**
     * The relative angle
     * @property angle
     * @type {Number}
     */
    this.angle = typeof(options.angle) === "number" ? options.angle : bodyB.angle - this.ratio * bodyA.angle;

    // Send same parameters to the equation
    options.angle = this.angle;
    options.ratio = this.ratio;

    this.equations = [
        new AngleLockEquation(bodyA,bodyB,options),
    ];

    // Set max torque
    if(typeof(options.maxTorque) === "number"){
        this.setMaxTorque(options.maxTorque);
    }
}
GearConstraint.prototype = new Constraint();
GearConstraint.prototype.constructor = GearConstraint;

GearConstraint.prototype.update = function(){
    var eq = this.equations[0];
    if(eq.ratio !== this.ratio){
        eq.setRatio(this.ratio);
    }
    eq.angle = this.angle;
};

/**
 * Set the max torque for the constraint.
 * @method setMaxTorque
 * @param {Number} torque
 */
GearConstraint.prototype.setMaxTorque = function(torque){
    this.equations[0].setMaxTorque(torque);
};

/**
 * Get the max torque for the constraint.
 * @method getMaxTorque
 * @return {Number}
 */
GearConstraint.prototype.getMaxTorque = function(torque){
    return this.equations[0].maxForce;
};
},{"../equations/AngleLockEquation":21,"../equations/Equation":23,"../math/vec2":31,"./Constraint":15}],18:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   vec2 = _dereq_('../math/vec2')
,   Equation = _dereq_('../equations/Equation');

module.exports = LockConstraint;

/**
 * Locks the relative position between two bodies.
 *
 * @class LockConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.
 * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.
 * @param {number} [options.maxForce]
 * @extends Constraint
 */
function LockConstraint(bodyA, bodyB, options){
    options = options || {};

    Constraint.call(this,bodyA,bodyB,Constraint.LOCK,options);

    var maxForce = ( typeof(options.maxForce)==="undefined" ? Number.MAX_VALUE : options.maxForce );

    var localAngleB = options.localAngleB || 0;

    // Use 3 equations:
    // gx =   (xj - xi - l) * xhat = 0
    // gy =   (xj - xi - l) * yhat = 0
    // gr =   (xi - xj + r) * that = 0
    //
    // ...where:
    //   l is the localOffsetB vector rotated to world in bodyA frame
    //   r is the same vector but reversed and rotated from bodyB frame
    //   xhat, yhat are world axis vectors
    //   that is the tangent of r
    //
    // For the first two constraints, we get
    // G*W = (vj - vi - ldot  ) * xhat
    //     = (vj - vi - wi x l) * xhat
    //
    // Since (wi x l) * xhat = (l x xhat) * wi, we get
    // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]
    //
    // The last constraint gives
    // GW = (vi - vj + wj x r) * that
    //    = [  that   0  -that  (r x t) ]

    var x =     new Equation(bodyA,bodyB,-maxForce,maxForce),
        y =     new Equation(bodyA,bodyB,-maxForce,maxForce),
        rot =   new Equation(bodyA,bodyB,-maxForce,maxForce);

    var l = vec2.create(),
        g = vec2.create(),
        that = this;
    x.computeGq = function(){
        vec2.rotate(l, that.localOffsetB, bodyA.angle);
        vec2.sub(g, bodyB.position, bodyA.position);
        vec2.sub(g, g, l);
        return g[0];
    };
    y.computeGq = function(){
        vec2.rotate(l, that.localOffsetB, bodyA.angle);
        vec2.sub(g, bodyB.position, bodyA.position);
        vec2.sub(g, g, l);
        return g[1];
    };
    var r = vec2.create(),
        t = vec2.create();
    rot.computeGq = function(){
        vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
        vec2.scale(r,r,-1);
        vec2.sub(g,bodyA.position,bodyB.position);
        vec2.add(g,g,r);
        vec2.rotate(t,r,-Math.PI/2);
        vec2.normalize(t,t);
        return vec2.dot(g,t);
    };

    /**
     * The offset of bodyB in bodyA's frame.
     * @property {Array} localOffsetB
     */
    this.localOffsetB = vec2.create();
    if(options.localOffsetB){
        vec2.copy(this.localOffsetB, options.localOffsetB);
    } else {
        // Construct from current positions
        vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);
        vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);
    }

    /**
     * The offset angle of bodyB in bodyA's frame.
     * @property {Number} localAngleB
     */
    this.localAngleB = 0;
    if(typeof(options.localAngleB) === 'number'){
        this.localAngleB = options.localAngleB;
    } else {
        // Construct
        this.localAngleB = bodyB.angle - bodyA.angle;
    }

    this.equations.push(x, y, rot);
    this.setMaxForce(maxForce);
}
LockConstraint.prototype = new Constraint();
LockConstraint.prototype.constructor = LockConstraint;

/**
 * Set the maximum force to be applied.
 * @method setMaxForce
 * @param {Number} force
 */
LockConstraint.prototype.setMaxForce = function(force){
    var eqs = this.equations;
    for(var i=0; i<this.equations.length; i++){
        eqs[i].maxForce =  force;
        eqs[i].minForce = -force;
    }
};

/**
 * Get the max force.
 * @method getMaxForce
 * @return {Number}
 */
LockConstraint.prototype.getMaxForce = function(){
    return this.equations[0].maxForce;
};

var l = vec2.create();
var r = vec2.create();
var t = vec2.create();
var xAxis = vec2.fromValues(1,0);
var yAxis = vec2.fromValues(0,1);
LockConstraint.prototype.update = function(){
    var x =   this.equations[0],
        y =   this.equations[1],
        rot = this.equations[2],
        bodyA = this.bodyA,
        bodyB = this.bodyB;

    vec2.rotate(l,this.localOffsetB,bodyA.angle);
    vec2.rotate(r,this.localOffsetB,bodyB.angle - this.localAngleB);
    vec2.scale(r,r,-1);

    vec2.rotate(t,r,Math.PI/2);
    vec2.normalize(t,t);

    x.G[0] = -1;
    x.G[1] =  0;
    x.G[2] = -vec2.crossLength(l,xAxis);
    x.G[3] =  1;

    y.G[0] =  0;
    y.G[1] = -1;
    y.G[2] = -vec2.crossLength(l,yAxis);
    y.G[4] =  1;

    rot.G[0] =  -t[0];
    rot.G[1] =  -t[1];
    rot.G[3] =  t[0];
    rot.G[4] =  t[1];
    rot.G[5] =  vec2.crossLength(r,t);
};

},{"../equations/Equation":23,"../math/vec2":31,"./Constraint":15}],19:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   ContactEquation = _dereq_('../equations/ContactEquation')
,   Equation = _dereq_('../equations/Equation')
,   vec2 = _dereq_('../math/vec2')
,   RotationalLockEquation = _dereq_('../equations/RotationalLockEquation');

module.exports = PrismaticConstraint;

/**
 * Constraint that only allows bodies to move along a line, relative to each other. See <a href="http://www.iforce2d.net/b2dtut/joints-prismatic">this tutorial</a>.
 *
 * @class PrismaticConstraint
 * @constructor
 * @extends Constraint
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Number}  [options.maxForce]                Max force to be applied by the constraint
 * @param {Array}   [options.localAnchorA]            Body A's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAnchorB]            Body B's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAxisA]              An axis, defined in body A frame, that body B's anchor point may slide along.
 * @param {Boolean} [options.disableRotationalLock]   If set to true, bodyB will be free to rotate around its anchor point.
 * @param {Number}  [options.upperLimit]
 * @param {Number}  [options.lowerLimit]
 * @todo Ability to create using only a point and a worldAxis
 */
function PrismaticConstraint(bodyA, bodyB, options){
    options = options || {};
    Constraint.call(this,bodyA,bodyB,Constraint.PRISMATIC,options);

    // Get anchors
    var localAnchorA = vec2.fromValues(0,0),
        localAxisA = vec2.fromValues(1,0),
        localAnchorB = vec2.fromValues(0,0);
    if(options.localAnchorA){ vec2.copy(localAnchorA, options.localAnchorA); }
    if(options.localAxisA){ vec2.copy(localAxisA,   options.localAxisA); }
    if(options.localAnchorB){ vec2.copy(localAnchorB, options.localAnchorB); }

    /**
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = localAnchorA;

    /**
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = localAnchorB;

    /**
     * @property localAxisA
     * @type {Array}
     */
    this.localAxisA = localAxisA;

    /*

    The constraint violation for the common axis point is

        g = ( xj + rj - xi - ri ) * t   :=  gg*t

    where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.

        gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )

    Note the use of the chain rule. Now we identify the jacobian

        G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]

    The rotational part is just a rotation lock.

     */

    var maxForce = this.maxForce = typeof(options.maxForce)!=="undefined" ? options.maxForce : Number.MAX_VALUE;

    // Translational part
    var trans = new Equation(bodyA,bodyB,-maxForce,maxForce);
    var ri = new vec2.create(),
        rj = new vec2.create(),
        gg = new vec2.create(),
        t =  new vec2.create();
    trans.computeGq = function(){
        // g = ( xj + rj - xi - ri ) * t
        return vec2.dot(gg,t);
    };
    trans.updateJacobian = function(){
        var G = this.G,
            xi = bodyA.position,
            xj = bodyB.position;
        vec2.rotate(ri,localAnchorA,bodyA.angle);
        vec2.rotate(rj,localAnchorB,bodyB.angle);
        vec2.add(gg,xj,rj);
        vec2.sub(gg,gg,xi);
        vec2.sub(gg,gg,ri);
        vec2.rotate(t,localAxisA,bodyA.angle+Math.PI/2);

        G[0] = -t[0];
        G[1] = -t[1];
        G[2] = -vec2.crossLength(ri,t) + vec2.crossLength(t,gg);
        G[3] = t[0];
        G[4] = t[1];
        G[5] = vec2.crossLength(rj,t);
    };
    this.equations.push(trans);

    // Rotational part
    if(!options.disableRotationalLock){
        var rot = new RotationalLockEquation(bodyA,bodyB,-maxForce,maxForce);
        this.equations.push(rot);
    }

    /**
     * The position of anchor A relative to anchor B, along the constraint axis.
     * @property position
     * @type {Number}
     */
    this.position = 0;

    // Is this one used at all?
    this.velocity = 0;

    /**
     * Set to true to enable lower limit.
     * @property lowerLimitEnabled
     * @type {Boolean}
     */
    this.lowerLimitEnabled = typeof(options.lowerLimit)!=="undefined" ? true : false;

    /**
     * Set to true to enable upper limit.
     * @property upperLimitEnabled
     * @type {Boolean}
     */
    this.upperLimitEnabled = typeof(options.upperLimit)!=="undefined" ? true : false;

    /**
     * Lower constraint limit. The constraint position is forced to be larger than this value.
     * @property lowerLimit
     * @type {Number}
     */
    this.lowerLimit = typeof(options.lowerLimit)!=="undefined" ? options.lowerLimit : 0;

    /**
     * Upper constraint limit. The constraint position is forced to be smaller than this value.
     * @property upperLimit
     * @type {Number}
     */
    this.upperLimit = typeof(options.upperLimit)!=="undefined" ? options.upperLimit : 1;

    // Equations used for limits
    this.upperLimitEquation = new ContactEquation(bodyA,bodyB);
    this.lowerLimitEquation = new ContactEquation(bodyA,bodyB);

    // Set max/min forces
    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;

    /**
     * Equation used for the motor.
     * @property motorEquation
     * @type {Equation}
     */
    this.motorEquation = new Equation(bodyA,bodyB);

    /**
     * The current motor state. Enable or disable the motor using .enableMotor
     * @property motorEnabled
     * @type {Boolean}
     */
    this.motorEnabled = false;

    /**
     * Set the target speed for the motor.
     * @property motorSpeed
     * @type {Number}
     */
    this.motorSpeed = 0;

    var that = this;
    var motorEquation = this.motorEquation;
    var old = motorEquation.computeGW;
    motorEquation.computeGq = function(){ return 0; };
    motorEquation.computeGW = function(){
        var G = this.G,
            bi = this.bodyA,
            bj = this.bodyB,
            vi = bi.velocity,
            vj = bj.velocity,
            wi = bi.angularVelocity,
            wj = bj.angularVelocity;
        return this.gmult(G,vi,wi,vj,wj) + that.motorSpeed;
    };
}

PrismaticConstraint.prototype = new Constraint();
PrismaticConstraint.prototype.constructor = PrismaticConstraint;

var worldAxisA = vec2.create(),
    worldAnchorA = vec2.create(),
    worldAnchorB = vec2.create(),
    orientedAnchorA = vec2.create(),
    orientedAnchorB = vec2.create(),
    tmp = vec2.create();

/**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */
PrismaticConstraint.prototype.update = function(){
    var eqs = this.equations,
        trans = eqs[0],
        upperLimit = this.upperLimit,
        lowerLimit = this.lowerLimit,
        upperLimitEquation = this.upperLimitEquation,
        lowerLimitEquation = this.lowerLimitEquation,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        localAxisA = this.localAxisA,
        localAnchorA = this.localAnchorA,
        localAnchorB = this.localAnchorB;

    trans.updateJacobian();

    // Transform local things to world
    vec2.rotate(worldAxisA,      localAxisA,      bodyA.angle);
    vec2.rotate(orientedAnchorA, localAnchorA,    bodyA.angle);
    vec2.add(worldAnchorA,       orientedAnchorA, bodyA.position);
    vec2.rotate(orientedAnchorB, localAnchorB,    bodyB.angle);
    vec2.add(worldAnchorB,       orientedAnchorB, bodyB.position);

    var relPosition = this.position = vec2.dot(worldAnchorB,worldAxisA) - vec2.dot(worldAnchorA,worldAxisA);

    // Motor
    if(this.motorEnabled){
        // G = [ a     a x ri   -a   -a x rj ]
        var G = this.motorEquation.G;
        G[0] = worldAxisA[0];
        G[1] = worldAxisA[1];
        G[2] = vec2.crossLength(worldAxisA,orientedAnchorB);
        G[3] = -worldAxisA[0];
        G[4] = -worldAxisA[1];
        G[5] = -vec2.crossLength(worldAxisA,orientedAnchorA);
    }

    /*
        Limits strategy:
        Add contact equation, with normal along the constraint axis.
        min/maxForce is set so the constraint is repulsive in the correct direction.
        Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.

                 ^
                 |
      upperLimit x
                 |    ------
         anchorB x<---|  B |
                 |    |    |
        ------   |    ------
        |    |   |
        |  A |-->x anchorA
        ------   |
                 x lowerLimit
                 |
                axis
     */


    if(this.upperLimitEnabled && relPosition > upperLimit){
        // Update contact constraint normal, etc
        vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);
        vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
        vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
        vec2.scale(tmp,worldAxisA,upperLimit);
        vec2.add(upperLimitEquation.contactPointA,upperLimitEquation.contactPointA,tmp);
        if(eqs.indexOf(upperLimitEquation) === -1){
            eqs.push(upperLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(upperLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    if(this.lowerLimitEnabled && relPosition < lowerLimit){
        // Update contact constraint normal, etc
        vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);
        vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
        vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
        vec2.scale(tmp,worldAxisA,lowerLimit);
        vec2.sub(lowerLimitEquation.contactPointB,lowerLimitEquation.contactPointB,tmp);
        if(eqs.indexOf(lowerLimitEquation) === -1){
            eqs.push(lowerLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(lowerLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }
};

/**
 * Enable the motor
 * @method enableMotor
 */
PrismaticConstraint.prototype.enableMotor = function(){
    if(this.motorEnabled){
        return;
    }
    this.equations.push(this.motorEquation);
    this.motorEnabled = true;
};

/**
 * Disable the rotational motor
 * @method disableMotor
 */
PrismaticConstraint.prototype.disableMotor = function(){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations.splice(i,1);
    this.motorEnabled = false;
};

/**
 * Set the constraint limits.
 * @method setLimits
 * @param {number} lower Lower limit.
 * @param {number} upper Upper limit.
 */
PrismaticConstraint.prototype.setLimits = function (lower, upper) {
    if(typeof(lower) === 'number'){
        this.lowerLimit = lower;
        this.lowerLimitEnabled = true;
    } else {
        this.lowerLimit = lower;
        this.lowerLimitEnabled = false;
    }

    if(typeof(upper) === 'number'){
        this.upperLimit = upper;
        this.upperLimitEnabled = true;
    } else {
        this.upperLimit = upper;
        this.upperLimitEnabled = false;
    }
};


},{"../equations/ContactEquation":22,"../equations/Equation":23,"../equations/RotationalLockEquation":25,"../math/vec2":31,"./Constraint":15}],20:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   RotationalVelocityEquation = _dereq_('../equations/RotationalVelocityEquation')
,   RotationalLockEquation = _dereq_('../equations/RotationalLockEquation')
,   vec2 = _dereq_('../math/vec2');

module.exports = RevoluteConstraint;

var worldPivotA = vec2.create(),
    worldPivotB = vec2.create(),
    xAxis = vec2.fromValues(1,0),
    yAxis = vec2.fromValues(0,1),
    g = vec2.create();

/**
 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
 * @class RevoluteConstraint
 * @constructor
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.
 * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.
 * @param {Array}   [options.localPivotB] See localPivotA.
 * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.
 * @extends Constraint
 *
 * @example
 *     // This will create a revolute constraint between two bodies with pivot point in between them.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         worldPivot: [0, 0]
 *     });
 *     world.addConstraint(constraint);
 *
 *     // Using body-local pivot points, the constraint could have been constructed like this:
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         localPivotA: [1, 0],
 *         localPivotB: [-1, 0]
 *     });
 */
function RevoluteConstraint(bodyA, bodyB, options){
    options = options || {};
    Constraint.call(this,bodyA,bodyB,Constraint.REVOLUTE,options);

    var maxForce = this.maxForce = typeof(options.maxForce) !== "undefined" ? options.maxForce : Number.MAX_VALUE;

    /**
     * @property {Array} pivotA
     */
    this.pivotA = vec2.create();

    /**
     * @property {Array} pivotB
     */
    this.pivotB = vec2.create();

    if(options.worldPivot){
        // Compute pivotA and pivotB
        vec2.sub(this.pivotA, options.worldPivot, bodyA.position);
        vec2.sub(this.pivotB, options.worldPivot, bodyB.position);
        // Rotate to local coordinate system
        vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);
        vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);
    } else {
        // Get pivotA and pivotB
        vec2.copy(this.pivotA, options.localPivotA);
        vec2.copy(this.pivotB, options.localPivotB);
    }

    // Equations to be fed to the solver
    var eqs = this.equations = [
        new Equation(bodyA,bodyB,-maxForce,maxForce),
        new Equation(bodyA,bodyB,-maxForce,maxForce),
    ];

    var x = eqs[0];
    var y = eqs[1];
    var that = this;

    x.computeGq = function(){
        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
        vec2.add(g, bodyB.position, worldPivotB);
        vec2.sub(g, g, bodyA.position);
        vec2.sub(g, g, worldPivotA);
        return vec2.dot(g,xAxis);
    };

    y.computeGq = function(){
        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
        vec2.add(g, bodyB.position, worldPivotB);
        vec2.sub(g, g, bodyA.position);
        vec2.sub(g, g, worldPivotA);
        return vec2.dot(g,yAxis);
    };

    y.minForce = x.minForce = -maxForce;
    y.maxForce = x.maxForce =  maxForce;

    this.motorEquation = new RotationalVelocityEquation(bodyA,bodyB);

    /**
     * Indicates whether the motor is enabled. Use .enableMotor() to enable the constraint motor.
     * @property {Boolean} motorEnabled
     * @readOnly
     */
    this.motorEnabled = false;

    /**
     * The constraint position.
     * @property angle
     * @type {Number}
     * @readOnly
     */
    this.angle = 0;

    /**
     * Set to true to enable lower limit
     * @property lowerLimitEnabled
     * @type {Boolean}
     */
    this.lowerLimitEnabled = false;

    /**
     * Set to true to enable upper limit
     * @property upperLimitEnabled
     * @type {Boolean}
     */
    this.upperLimitEnabled = false;

    /**
     * The lower limit on the constraint angle.
     * @property lowerLimit
     * @type {Boolean}
     */
    this.lowerLimit = 0;

    /**
     * The upper limit on the constraint angle.
     * @property upperLimit
     * @type {Boolean}
     */
    this.upperLimit = 0;

    this.upperLimitEquation = new RotationalLockEquation(bodyA,bodyB);
    this.lowerLimitEquation = new RotationalLockEquation(bodyA,bodyB);
    this.upperLimitEquation.minForce = 0;
    this.lowerLimitEquation.maxForce = 0;
}
RevoluteConstraint.prototype = new Constraint();
RevoluteConstraint.prototype.constructor = RevoluteConstraint;

/**
 * Set the constraint angle limits.
 * @method setLimits
 * @param {number} lower Lower angle limit.
 * @param {number} upper Upper angle limit.
 */
RevoluteConstraint.prototype.setLimits = function (lower, upper) {
    if(typeof(lower) === 'number'){
        this.lowerLimit = lower;
        this.lowerLimitEnabled = true;
    } else {
        this.lowerLimit = lower;
        this.lowerLimitEnabled = false;
    }

    if(typeof(upper) === 'number'){
        this.upperLimit = upper;
        this.upperLimitEnabled = true;
    } else {
        this.upperLimit = upper;
        this.upperLimitEnabled = false;
    }
};

RevoluteConstraint.prototype.update = function(){
    var bodyA =  this.bodyA,
        bodyB =  this.bodyB,
        pivotA = this.pivotA,
        pivotB = this.pivotB,
        eqs =    this.equations,
        normal = eqs[0],
        tangent= eqs[1],
        x = eqs[0],
        y = eqs[1],
        upperLimit = this.upperLimit,
        lowerLimit = this.lowerLimit,
        upperLimitEquation = this.upperLimitEquation,
        lowerLimitEquation = this.lowerLimitEquation;

    var relAngle = this.angle = bodyB.angle - bodyA.angle;

    if(this.upperLimitEnabled && relAngle > upperLimit){
        upperLimitEquation.angle = upperLimit;
        if(eqs.indexOf(upperLimitEquation) === -1){
            eqs.push(upperLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(upperLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    if(this.lowerLimitEnabled && relAngle < lowerLimit){
        lowerLimitEquation.angle = lowerLimit;
        if(eqs.indexOf(lowerLimitEquation) === -1){
            eqs.push(lowerLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(lowerLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    /*

    The constraint violation is

        g = xj + rj - xi - ri

    ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:

        gdot = vj + wj x rj - vi - wi x ri

    We split this into x and y directions. (let x and y be unit vectors along the respective axes)

        gdot * x = ( vj + wj x rj - vi - wi x ri ) * x
                 = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x
                 = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi
                 = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]
                 = G*W

    ...and similar for y. We have then identified the jacobian entries for x and y directions:

        Gx = [ x   (rj x x)   -x   -(ri x x)]
        Gy = [ y   (rj x y)   -y   -(ri x y)]

     */

    vec2.rotate(worldPivotA, pivotA, bodyA.angle);
    vec2.rotate(worldPivotB, pivotB, bodyB.angle);

    // todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc

    x.G[0] = -1;
    x.G[1] =  0;
    x.G[2] = -vec2.crossLength(worldPivotA,xAxis);
    x.G[3] =  1;
    x.G[4] =  0;
    x.G[5] =  vec2.crossLength(worldPivotB,xAxis);

    y.G[0] =  0;
    y.G[1] = -1;
    y.G[2] = -vec2.crossLength(worldPivotA,yAxis);
    y.G[3] =  0;
    y.G[4] =  1;
    y.G[5] =  vec2.crossLength(worldPivotB,yAxis);
};

/**
 * Enable the rotational motor
 * @method enableMotor
 */
RevoluteConstraint.prototype.enableMotor = function(){
    if(this.motorEnabled){
        return;
    }
    this.equations.push(this.motorEquation);
    this.motorEnabled = true;
};

/**
 * Disable the rotational motor
 * @method disableMotor
 */
RevoluteConstraint.prototype.disableMotor = function(){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations.splice(i,1);
    this.motorEnabled = false;
};

/**
 * Check if the motor is enabled.
 * @method motorIsEnabled
 * @deprecated use property motorEnabled instead.
 * @return {Boolean}
 */
RevoluteConstraint.prototype.motorIsEnabled = function(){
    return !!this.motorEnabled;
};

/**
 * Set the speed of the rotational constraint motor
 * @method setMotorSpeed
 * @param  {Number} speed
 */
RevoluteConstraint.prototype.setMotorSpeed = function(speed){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations[i].relativeVelocity = speed;
};

/**
 * Get the speed of the rotational constraint motor
 * @method getMotorSpeed
 * @return {Number} The current speed, or false if the motor is not enabled.
 */
RevoluteConstraint.prototype.getMotorSpeed = function(){
    if(!this.motorEnabled){
        return false;
    }
    return this.motorEquation.relativeVelocity;
};

},{"../equations/Equation":23,"../equations/RotationalLockEquation":25,"../equations/RotationalVelocityEquation":26,"../math/vec2":31,"./Constraint":15}],21:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = AngleLockEquation;

/**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class AngleLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in body A.
 * @param {Number} [options.ratio] Gear ratio
 */
function AngleLockEquation(bodyA, bodyB, options){
    options = options || {};
    Equation.call(this,bodyA,bodyB,-Number.MAX_VALUE,Number.MAX_VALUE);
    this.angle = options.angle || 0;

    /**
     * The gear ratio.
     * @property {Number} ratio
     * @private
     * @see setRatio
     */
    this.ratio = typeof(options.ratio)==="number" ? options.ratio : 1;

    this.setRatio(this.ratio);
}
AngleLockEquation.prototype = new Equation();
AngleLockEquation.prototype.constructor = AngleLockEquation;

AngleLockEquation.prototype.computeGq = function(){
    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
};

/**
 * Set the gear ratio for this equation
 * @method setRatio
 * @param {Number} ratio
 */
AngleLockEquation.prototype.setRatio = function(ratio){
    var G = this.G;
    G[2] =  ratio;
    G[5] = -1;
    this.ratio = ratio;
};

/**
 * Set the max force for the equation.
 * @method setMaxTorque
 * @param {Number} torque
 */
AngleLockEquation.prototype.setMaxTorque = function(torque){
    this.maxForce =  torque;
    this.minForce = -torque;
};

},{"../math/vec2":31,"./Equation":23}],22:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = ContactEquation;

/**
 * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.
 *
 * @class ContactEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function ContactEquation(bodyA, bodyB){
    Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);

    /**
     * Vector from body i center of mass to the contact point.
     * @property contactPointA
     * @type {Array}
     */
    this.contactPointA = vec2.create();
    this.penetrationVec = vec2.create();

    /**
     * World-oriented vector from body A center of mass to the contact point.
     * @property contactPointB
     * @type {Array}
     */
    this.contactPointB = vec2.create();

    /**
     * The normal vector, pointing out of body i
     * @property normalA
     * @type {Array}
     */
    this.normalA = vec2.create();

    /**
     * The restitution to use (0=no bounciness, 1=max bounciness).
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0;

    /**
     * This property is set to true if this is the first impact between the bodies (not persistant contact).
     * @property firstImpact
     * @type {Boolean}
     * @readOnly
     */
    this.firstImpact = false;

    /**
     * The shape in body i that triggered this contact.
     * @property shapeA
     * @type {Shape}
     */
    this.shapeA = null;

    /**
     * The shape in body j that triggered this contact.
     * @property shapeB
     * @type {Shape}
     */
    this.shapeB = null;
}
ContactEquation.prototype = new Equation();
ContactEquation.prototype.constructor = ContactEquation;
ContactEquation.prototype.computeB = function(a,b,h){
    var bi = this.bodyA,
        bj = this.bodyB,
        ri = this.contactPointA,
        rj = this.contactPointB,
        xi = bi.position,
        xj = bj.position;

    var penetrationVec = this.penetrationVec,
        n = this.normalA,
        G = this.G;

    // Caluclate cross products
    var rixn = vec2.crossLength(ri,n),
        rjxn = vec2.crossLength(rj,n);

    // G = [-n -rixn n rjxn]
    G[0] = -n[0];
    G[1] = -n[1];
    G[2] = -rixn;
    G[3] = n[0];
    G[4] = n[1];
    G[5] = rjxn;

    // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector
    vec2.add(penetrationVec,xj,rj);
    vec2.sub(penetrationVec,penetrationVec,xi);
    vec2.sub(penetrationVec,penetrationVec,ri);

    // Compute iteration
    var GW, Gq;
    if(this.firstImpact && this.restitution !== 0){
        Gq = 0;
        GW = (1/b)*(1+this.restitution) * this.computeGW();
    } else {
        Gq = vec2.dot(n,penetrationVec) + this.offset;
        GW = this.computeGW();
    }

    var GiMf = this.computeGiMf();
    var B = - Gq * a - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":31,"./Equation":23}],23:[function(_dereq_,module,exports){
module.exports = Equation;

var vec2 = _dereq_('../math/vec2'),
    Utils = _dereq_('../utils/Utils'),
    Body = _dereq_('../objects/Body');

/**
 * Base class for constraint equations.
 * @class Equation
 * @constructor
 * @param {Body} bodyA First body participating in the equation
 * @param {Body} bodyB Second body participating in the equation
 * @param {number} minForce Minimum force to apply. Default: -Number.MAX_VALUE
 * @param {number} maxForce Maximum force to apply. Default: Number.MAX_VALUE
 */
function Equation(bodyA, bodyB, minForce, maxForce){

    /**
     * Minimum force to apply when solving.
     * @property minForce
     * @type {Number}
     */
    this.minForce = typeof(minForce)==="undefined" ? -Number.MAX_VALUE : minForce;

    /**
     * Max force to apply when solving.
     * @property maxForce
     * @type {Number}
     */
    this.maxForce = typeof(maxForce)==="undefined" ? Number.MAX_VALUE : maxForce;

    /**
     * First body participating in the constraint
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second body participating in the constraint
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.
     * @property stiffness
     * @type {Number}
     */
    this.stiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.
     * @property relaxation
     * @type {Number}
     */
    this.relaxation = Equation.DEFAULT_RELAXATION;

    /**
     * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).
     * @property G
     * @type {Array}
     */
    this.G = new Utils.ARRAY_TYPE(6);
    for(var i=0; i<6; i++){
        this.G[i]=0;
    }

    this.offset = 0;

    this.a = 0;
    this.b = 0;
    this.epsilon = 0;
    this.timeStep = 1/60;

    /**
     * Indicates if stiffness or relaxation was changed.
     * @property {Boolean} needsUpdate
     */
    this.needsUpdate = true;

    /**
     * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.
     * @property multiplier
     * @type {Number}
     */
    this.multiplier = 0;

    /**
     * Relative velocity.
     * @property {Number} relativeVelocity
     */
    this.relativeVelocity = 0;

    /**
     * Whether this equation is enabled or not. If true, it will be added to the solver.
     * @property {Boolean} enabled
     */
    this.enabled = true;
}
Equation.prototype.constructor = Equation;

/**
 * The default stiffness when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_STIFFNESS
 * @default 1e6
 */
Equation.DEFAULT_STIFFNESS = 1e6;

/**
 * The default relaxation when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_RELAXATION
 * @default 4
 */
Equation.DEFAULT_RELAXATION = 4;

/**
 * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href="http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf">SPOOK notes</a>.
 * @method update
 */
Equation.prototype.update = function(){
    var k = this.stiffness,
        d = this.relaxation,
        h = this.timeStep;

    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = (4.0 * d) / (1 + 4 * d);
    this.epsilon = 4.0 / (h * h * k * (1 + 4 * d));

    this.needsUpdate = false;
};

/**
 * Multiply a jacobian entry with corresponding positions or velocities
 * @method gmult
 * @return {Number}
 */
Equation.prototype.gmult = function(G,vi,wi,vj,wj){
    return  G[0] * vi[0] +
            G[1] * vi[1] +
            G[2] * wi +
            G[3] * vj[0] +
            G[4] * vj[1] +
            G[5] * wj;
};

/**
 * Computes the RHS of the SPOOK equation
 * @method computeB
 * @return {Number}
 */
Equation.prototype.computeB = function(a,b,h){
    var GW = this.computeGW();
    var Gq = this.computeGq();
    var GiMf = this.computeGiMf();
    return - Gq * a - GW * b - GiMf*h;
};

/**
 * Computes G\*q, where q are the generalized body coordinates
 * @method computeGq
 * @return {Number}
 */
var qi = vec2.create(),
    qj = vec2.create();
Equation.prototype.computeGq = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        xi = bi.position,
        xj = bj.position,
        ai = bi.angle,
        aj = bj.angle;

    return this.gmult(G, qi, ai, qj, aj) + this.offset;
};

/**
 * Computes G\*W, where W are the body velocities
 * @method computeGW
 * @return {Number}
 */
Equation.prototype.computeGW = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        vi = bi.velocity,
        vj = bj.velocity,
        wi = bi.angularVelocity,
        wj = bj.angularVelocity;
    return this.gmult(G,vi,wi,vj,wj) + this.relativeVelocity;
};

/**
 * Computes G\*Wlambda, where W are the body velocities
 * @method computeGWlambda
 * @return {Number}
 */
Equation.prototype.computeGWlambda = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        vi = bi.vlambda,
        vj = bj.vlambda,
        wi = bi.wlambda,
        wj = bj.wlambda;
    return this.gmult(G,vi,wi,vj,wj);
};

/**
 * Computes G\*inv(M)\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
 * @method computeGiMf
 * @return {Number}
 */
var iMfi = vec2.create(),
    iMfj = vec2.create();
Equation.prototype.computeGiMf = function(){
    var bi = this.bodyA,
        bj = this.bodyB,
        fi = bi.force,
        ti = bi.angularForce,
        fj = bj.force,
        tj = bj.angularForce,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        G = this.G;

    vec2.scale(iMfi, fi,invMassi);
    vec2.scale(iMfj, fj,invMassj);

    return this.gmult(G,iMfi,ti*invIi,iMfj,tj*invIj);
};

/**
 * Computes G\*inv(M)\*G'
 * @method computeGiMGt
 * @return {Number}
 */
Equation.prototype.computeGiMGt = function(){
    var bi = this.bodyA,
        bj = this.bodyB,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        G = this.G;

    return  G[0] * G[0] * invMassi +
            G[1] * G[1] * invMassi +
            G[2] * G[2] *    invIi +
            G[3] * G[3] * invMassj +
            G[4] * G[4] * invMassj +
            G[5] * G[5] *    invIj;
};

var addToWlambda_temp = vec2.create(),
    addToWlambda_Gi = vec2.create(),
    addToWlambda_Gj = vec2.create(),
    addToWlambda_ri = vec2.create(),
    addToWlambda_rj = vec2.create(),
    addToWlambda_Mdiag = vec2.create();

/**
 * Add constraint velocity to the bodies.
 * @method addToWlambda
 * @param {Number} deltalambda
 */
Equation.prototype.addToWlambda = function(deltalambda){
    var bi = this.bodyA,
        bj = this.bodyB,
        temp = addToWlambda_temp,
        Gi = addToWlambda_Gi,
        Gj = addToWlambda_Gj,
        ri = addToWlambda_ri,
        rj = addToWlambda_rj,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        Mdiag = addToWlambda_Mdiag,
        G = this.G;

    Gi[0] = G[0];
    Gi[1] = G[1];
    Gj[0] = G[3];
    Gj[1] = G[4];

    // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G
    vec2.scale(temp, Gi, invMassi*deltalambda);
    vec2.add( bi.vlambda, bi.vlambda, temp);
    // This impulse is in the offset frame
    // Also add contribution to angular
    //bi.wlambda -= vec2.crossLength(temp,ri);
    bi.wlambda += invIi * G[2] * deltalambda;


    vec2.scale(temp, Gj, invMassj*deltalambda);
    vec2.add( bj.vlambda, bj.vlambda, temp);
    //bj.wlambda -= vec2.crossLength(temp,rj);
    bj.wlambda += invIj * G[5] * deltalambda;
};

/**
 * Compute the denominator part of the SPOOK equation: C = G\*inv(M)\*G' + eps
 * @method computeInvC
 * @param  {Number} eps
 * @return {Number}
 */
Equation.prototype.computeInvC = function(eps){
    return 1.0 / (this.computeGiMGt() + eps);
};

},{"../math/vec2":31,"../objects/Body":32,"../utils/Utils":50}],24:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Equation = _dereq_('./Equation')
,   Utils = _dereq_('../utils/Utils');

module.exports = FrictionEquation;

/**
 * Constrains the slipping in a contact along a tangent
 *
 * @class FrictionEquation
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} slipForce
 * @extends Equation
 */
function FrictionEquation(bodyA, bodyB, slipForce){
    Equation.call(this, bodyA, bodyB, -slipForce, slipForce);

    /**
     * Relative vector from center of body A to the contact point, world oriented.
     * @property contactPointA
     * @type {Array}
     */
    this.contactPointA = vec2.create();

    /**
     * Relative vector from center of body B to the contact point, world oriented.
     * @property contactPointB
     * @type {Array}
     */
    this.contactPointB = vec2.create();

    /**
     * Tangent vector that the friction force will act along. World oriented.
     * @property t
     * @type {Array}
     */
    this.t = vec2.create();

    /**
     * A ContactEquation connected to this friction. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.
     * @property contactEquations
     * @type {ContactEquation}
     */
    this.contactEquations = [];

    /**
     * The shape in body i that triggered this friction.
     * @property shapeA
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeA...
     */
    this.shapeA = null;

    /**
     * The shape in body j that triggered this friction.
     * @property shapeB
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeB...
     */
    this.shapeB = null;

    /**
     * The friction coefficient to use.
     * @property frictionCoefficient
     * @type {Number}
     */
    this.frictionCoefficient = 0.3;
}
FrictionEquation.prototype = new Equation();
FrictionEquation.prototype.constructor = FrictionEquation;

/**
 * Set the slipping condition for the constraint. The friction force cannot be
 * larger than this value.
 * @method setSlipForce
 * @param  {Number} slipForce
 */
FrictionEquation.prototype.setSlipForce = function(slipForce){
    this.maxForce = slipForce;
    this.minForce = -slipForce;
};

/**
 * Get the max force for the constraint.
 * @method getSlipForce
 * @return {Number}
 */
FrictionEquation.prototype.getSlipForce = function(){
    return this.maxForce;
};

FrictionEquation.prototype.computeB = function(a,b,h){
    var bi = this.bodyA,
        bj = this.bodyB,
        ri = this.contactPointA,
        rj = this.contactPointB,
        t = this.t,
        G = this.G;

    // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!
    G[0] = -t[0];
    G[1] = -t[1];
    G[2] = -vec2.crossLength(ri,t);
    G[3] = t[0];
    G[4] = t[1];
    G[5] = vec2.crossLength(rj,t);

    var GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = /* - g * a  */ - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":31,"../utils/Utils":50,"./Equation":23}],25:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = RotationalLockEquation;

/**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class RotationalLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in bodyA.
 */
function RotationalLockEquation(bodyA, bodyB, options){
    options = options || {};
    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);

    /**
     * @property {number} angle
     */
    this.angle = options.angle || 0;

    var G = this.G;
    G[2] =  1;
    G[5] = -1;
}
RotationalLockEquation.prototype = new Equation();
RotationalLockEquation.prototype.constructor = RotationalLockEquation;

var worldVectorA = vec2.create(),
    worldVectorB = vec2.create(),
    xAxis = vec2.fromValues(1,0),
    yAxis = vec2.fromValues(0,1);
RotationalLockEquation.prototype.computeGq = function(){
    vec2.rotate(worldVectorA,xAxis,this.bodyA.angle+this.angle);
    vec2.rotate(worldVectorB,yAxis,this.bodyB.angle);
    return vec2.dot(worldVectorA,worldVectorB);
};

},{"../math/vec2":31,"./Equation":23}],26:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = RotationalVelocityEquation;

/**
 * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).
 *
 * @class RotationalVelocityEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function RotationalVelocityEquation(bodyA, bodyB){
    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
    this.relativeVelocity = 1;
    this.ratio = 1;
}
RotationalVelocityEquation.prototype = new Equation();
RotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;
RotationalVelocityEquation.prototype.computeB = function(a,b,h){
    var G = this.G;
    G[2] = -1;
    G[5] = this.ratio;

    var GiMf = this.computeGiMf();
    var GW = this.computeGW();
    var B = - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":31,"./Equation":23}],27:[function(_dereq_,module,exports){
/**
 * Base class for objects that dispatches events.
 * @class EventEmitter
 * @constructor
 */
var EventEmitter = function () {};

module.exports = EventEmitter;

EventEmitter.prototype = {
    constructor: EventEmitter,

    /**
     * Add an event listener
     * @method on
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */
    on: function ( type, listener, context ) {
        listener.context = context || this;
        if ( this._listeners === undefined ){
            this._listeners = {};
        }
        var listeners = this._listeners;
        if ( listeners[ type ] === undefined ) {
            listeners[ type ] = [];
        }
        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
            listeners[ type ].push( listener );
        }
        return this;
    },

    /**
     * Check if an event listener is added
     * @method has
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    has: function ( type, listener ) {
        if ( this._listeners === undefined ){
            return false;
        }
        var listeners = this._listeners;
        if(listener){
            if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
                return true;
            }
        } else {
            if ( listeners[ type ] !== undefined ) {
                return true;
            }
        }

        return false;
    },

    /**
     * Remove an event listener
     * @method off
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */
    off: function ( type, listener ) {
        if ( this._listeners === undefined ){
            return this;
        }
        var listeners = this._listeners;
        var index = listeners[ type ].indexOf( listener );
        if ( index !== - 1 ) {
            listeners[ type ].splice( index, 1 );
        }
        return this;
    },

    /**
     * Emit an event.
     * @method emit
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventEmitter} The self object, for chainability.
     */
    emit: function ( event ) {
        if ( this._listeners === undefined ){
            return this;
        }
        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];
        if ( listenerArray !== undefined ) {
            event.target = this;
            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
                var listener = listenerArray[ i ];
                listener.call( listener.context, event );
            }
        }
        return this;
    }
};

},{}],28:[function(_dereq_,module,exports){
var Material = _dereq_('./Material');
var Equation = _dereq_('../equations/Equation');

module.exports = ContactMaterial;

/**
 * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters.
 * @class ContactMaterial
 * @constructor
 * @param {Material} materialA
 * @param {Material} materialB
 * @param {Object}   [options]
 * @param {Number}   [options.friction=0.3]       Friction coefficient.
 * @param {Number}   [options.restitution=0]      Restitution coefficient aka "bounciness".
 * @param {Number}   [options.stiffness]          ContactEquation stiffness.
 * @param {Number}   [options.relaxation]         ContactEquation relaxation.
 * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.
 * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.
 * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.
 * @author schteppe
 */
function ContactMaterial(materialA, materialB, options){
    options = options || {};

    if(!(materialA instanceof Material) || !(materialB instanceof Material)){
        throw new Error("First two arguments must be Material instances.");
    }

    /**
     * The contact material identifier
     * @property id
     * @type {Number}
     */
    this.id = ContactMaterial.idCounter++;

    /**
     * First material participating in the contact material
     * @property materialA
     * @type {Material}
     */
    this.materialA = materialA;

    /**
     * Second material participating in the contact material
     * @property materialB
     * @type {Material}
     */
    this.materialB = materialB;

    /**
     * Friction to use in the contact of these two materials
     * @property friction
     * @type {Number}
     */
    this.friction    =  typeof(options.friction)    !== "undefined" ?   Number(options.friction)    : 0.3;

    /**
     * Restitution to use in the contact of these two materials
     * @property restitution
     * @type {Number}
     */
    this.restitution =  typeof(options.restitution) !== "undefined" ?   Number(options.restitution) : 0.0;

    /**
     * Stiffness of the resulting ContactEquation that this ContactMaterial generate
     * @property stiffness
     * @type {Number}
     */
    this.stiffness =            typeof(options.stiffness)           !== "undefined" ?   Number(options.stiffness)   : Equation.DEFAULT_STIFFNESS;

    /**
     * Relaxation of the resulting ContactEquation that this ContactMaterial generate
     * @property relaxation
     * @type {Number}
     */
    this.relaxation =           typeof(options.relaxation)          !== "undefined" ?   Number(options.relaxation)  : Equation.DEFAULT_RELAXATION;

    /**
     * Stiffness of the resulting FrictionEquation that this ContactMaterial generate
     * @property frictionStiffness
     * @type {Number}
     */
    this.frictionStiffness =    typeof(options.frictionStiffness)   !== "undefined" ?   Number(options.frictionStiffness)   : Equation.DEFAULT_STIFFNESS;

    /**
     * Relaxation of the resulting FrictionEquation that this ContactMaterial generate
     * @property frictionRelaxation
     * @type {Number}
     */
    this.frictionRelaxation =   typeof(options.frictionRelaxation)  !== "undefined" ?   Number(options.frictionRelaxation)  : Equation.DEFAULT_RELAXATION;

    /**
     * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.
     * @property {Number} surfaceVelocity
     */
    this.surfaceVelocity = typeof(options.surfaceVelocity)    !== "undefined" ?   Number(options.surfaceVelocity)    : 0;

    /**
     * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka "cure for nervous contacts".
     * @property contactSkinSize
     * @type {Number}
     */
    this.contactSkinSize = 0.005;
}

ContactMaterial.idCounter = 0;

},{"../equations/Equation":23,"./Material":29}],29:[function(_dereq_,module,exports){
module.exports = Material;

/**
 * Defines a physics material.
 * @class Material
 * @constructor
 * @param {number} id Material identifier
 * @author schteppe
 */
function Material(id){
    /**
     * The material identifier
     * @property id
     * @type {Number}
     */
    this.id = id || Material.idCounter++;
}

Material.idCounter = 0;

},{}],30:[function(_dereq_,module,exports){

    /*
        PolyK library
        url: http://polyk.ivank.net
        Released under MIT licence.

        Copyright (c) 2012 Ivan Kuckir

        Permission is hereby granted, free of charge, to any person
        obtaining a copy of this software and associated documentation
        files (the "Software"), to deal in the Software without
        restriction, including without limitation the rights to use,
        copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the
        Software is furnished to do so, subject to the following
        conditions:

        The above copyright notice and this permission notice shall be
        included in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
        OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
        OTHER DEALINGS IN THE SOFTWARE.
    */

    var PolyK = {};

    /*
        Is Polygon self-intersecting?

        O(n^2)
    */
    /*
    PolyK.IsSimple = function(p)
    {
        var n = p.length>>1;
        if(n<4) return true;
        var a1 = new PolyK._P(), a2 = new PolyK._P();
        var b1 = new PolyK._P(), b2 = new PolyK._P();
        var c = new PolyK._P();

        for(var i=0; i<n; i++)
        {
            a1.x = p[2*i  ];
            a1.y = p[2*i+1];
            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }
            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }

            for(var j=0; j<n; j++)
            {
                if(Math.abs(i-j) < 2) continue;
                if(j==n-1 && i==0) continue;
                if(i==n-1 && j==0) continue;

                b1.x = p[2*j  ];
                b1.y = p[2*j+1];
                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }
                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }

                if(PolyK._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;
            }
        }
        return true;
    }

    PolyK.IsConvex = function(p)
    {
        if(p.length<6) return true;
        var l = p.length - 4;
        for(var i=0; i<l; i+=2)
            if(!PolyK._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;
        if(!PolyK._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;
        if(!PolyK._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;
        return true;
    }
    */
    PolyK.GetArea = function(p)
    {
        if(p.length <6) return 0;
        var l = p.length - 2;
        var sum = 0;
        for(var i=0; i<l; i+=2)
            sum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);
        sum += (p[0]-p[l]) * (p[l+1]+p[1]);
        return - sum * 0.5;
    }
    /*
    PolyK.GetAABB = function(p)
    {
        var minx = Infinity;
        var miny = Infinity;
        var maxx = -minx;
        var maxy = -miny;
        for(var i=0; i<p.length; i+=2)
        {
            minx = Math.min(minx, p[i  ]);
            maxx = Math.max(maxx, p[i  ]);
            miny = Math.min(miny, p[i+1]);
            maxy = Math.max(maxy, p[i+1]);
        }
        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};
    }
    */

    PolyK.Triangulate = function(p)
    {
        var n = p.length>>1;
        if(n<3) return [];
        var tgs = [];
        var avl = [];
        for(var i=0; i<n; i++) avl.push(i);

        var i = 0;
        var al = n;
        while(al > 3)
        {
            var i0 = avl[(i+0)%al];
            var i1 = avl[(i+1)%al];
            var i2 = avl[(i+2)%al];

            var ax = p[2*i0],  ay = p[2*i0+1];
            var bx = p[2*i1],  by = p[2*i1+1];
            var cx = p[2*i2],  cy = p[2*i2+1];

            var earFound = false;
            if(PolyK._convex(ax, ay, bx, by, cx, cy))
            {
                earFound = true;
                for(var j=0; j<al; j++)
                {
                    var vi = avl[j];
                    if(vi==i0 || vi==i1 || vi==i2) continue;
                    if(PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}
                }
            }
            if(earFound)
            {
                tgs.push(i0, i1, i2);
                avl.splice((i+1)%al, 1);
                al--;
                i= 0;
            }
            else if(i++ > 3*al) break;      // no convex angles :(
        }
        tgs.push(avl[0], avl[1], avl[2]);
        return tgs;
    }
    /*
    PolyK.ContainsPoint = function(p, px, py)
    {
        var n = p.length>>1;
        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;
        var depth = 0;
        for(var i=0; i<n; i++)
        {
            ax = bx;  ay = by;
            bx = p[2*i  ] - px;
            by = p[2*i+1] - py;
            if(ay< 0 && by< 0) continue;    // both "up" or both "donw"
            if(ay>=0 && by>=0) continue;    // both "up" or both "donw"
            if(ax< 0 && bx< 0) continue;

            var lx = ax + (bx-ax)*(-ay)/(by-ay);
            if(lx>0) depth++;
        }
        return (depth & 1) == 1;
    }

    PolyK.Slice = function(p, ax, ay, bx, by)
    {
        if(PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by)) return [p.slice(0)];

        var a = new PolyK._P(ax, ay);
        var b = new PolyK._P(bx, by);
        var iscs = [];  // intersections
        var ps = [];    // points
        for(var i=0; i<p.length; i+=2) ps.push(new PolyK._P(p[i], p[i+1]));

        for(var i=0; i<ps.length; i++)
        {
            var isc = new PolyK._P(0,0);
            isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);

            if(isc)
            {
                isc.flag = true;
                iscs.push(isc);
                ps.splice(i+1,0,isc);
                i++;
            }
        }
        if(iscs.length == 0) return [p.slice(0)];
        var comp = function(u,v) {return PolyK._P.dist(a,u) - PolyK._P.dist(a,v); }
        iscs.sort(comp);

        var pgs = [];
        var dir = 0;
        while(iscs.length > 0)
        {
            var n = ps.length;
            var i0 = iscs[0];
            var i1 = iscs[1];
            var ind0 = ps.indexOf(i0);
            var ind1 = ps.indexOf(i1);
            var solved = false;

            if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            else
            {
                i0 = iscs[1];
                i1 = iscs[0];
                ind0 = ps.indexOf(i0);
                ind1 = ps.indexOf(i1);
                if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            }
            if(solved)
            {
                dir--;
                var pgn = PolyK._getPoints(ps, ind0, ind1);
                pgs.push(pgn);
                ps = PolyK._getPoints(ps, ind1, ind0);
                i0.flag = i1.flag = false;
                iscs.splice(0,2);
                if(iscs.length == 0) pgs.push(ps);
            }
            else { dir++; iscs.reverse(); }
            if(dir>1) break;
        }
        var result = [];
        for(var i=0; i<pgs.length; i++)
        {
            var pg = pgs[i];
            var npg = [];
            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);
            result.push(npg);
        }
        return result;
    }

    PolyK.Raycast = function(p, x, y, dx, dy, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0], a2 = tp[1],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;
        a2.x = x+dx; a2.y = y+dy;

        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
            if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
        if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);

        return (isc.dist != Infinity) ? isc : null;
    }

    PolyK.ClosestEdge = function(p, x, y, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;

        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            PolyK._pointLineDist(a1, b1, b2, i>>1, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        PolyK._pointLineDist(a1, b1, b2, l>>1, isc);

        var idst = 1/isc.dist;
        isc.norm.x = (x-isc.point.x)*idst;
        isc.norm.y = (y-isc.point.y)*idst;
        return isc;
    }

    PolyK._pointLineDist = function(p, a, b, edge, isc)
    {
        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;

        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;

        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var param = dot / len_sq;

        var xx, yy;

        if (param < 0 || (x1 == x2 && y1 == y2)) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        var dx = x - xx;
        var dy = y - yy;
        var dst = Math.sqrt(dx * dx + dy * dy);
        if(dst<isc.dist)
        {
            isc.dist = dst;
            isc.edge = edge;
            isc.point.x = xx;
            isc.point.y = yy;
        }
    }

    PolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)
    {
        var nrl = PolyK._P.dist(a1, c);
        if(nrl<isc.dist)
        {
            var ibl = 1/PolyK._P.dist(b1, b2);
            var nx = -(b2.y-b1.y)*ibl;
            var ny =  (b2.x-b1.x)*ibl;
            var ddot = 2*(dx*nx+dy*ny);
            isc.dist = nrl;
            isc.norm.x = nx;
            isc.norm.y = ny;
            isc.refl.x = -ddot*nx+dx;
            isc.refl.y = -ddot*ny+dy;
            isc.edge = edge;
        }
    }

    PolyK._getPoints = function(ps, ind0, ind1)
    {
        var n = ps.length;
        var nps = [];
        if(ind1<ind0) ind1 += n;
        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);
        return nps;
    }

    PolyK._firstWithFlag = function(ps, ind)
    {
        var n = ps.length;
        while(true)
        {
            ind = (ind+1)%n;
            if(ps[ind].flag) return ind;
        }
    }
    */
    PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)
    {
        var v0x = cx-ax;
        var v0y = cy-ay;
        var v1x = bx-ax;
        var v1y = by-ay;
        var v2x = px-ax;
        var v2y = py-ay;

        var dot00 = v0x*v0x+v0y*v0y;
        var dot01 = v0x*v1x+v0y*v1y;
        var dot02 = v0x*v2x+v0y*v2y;
        var dot11 = v1x*v1x+v1y*v1y;
        var dot12 = v1x*v2x+v1y*v2y;

        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

        // Check if point is in triangle
        return (u >= 0) && (v >= 0) && (u + v < 1);
    }
    /*
    PolyK._RayLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        var iDen = 1/Den;
        I.x = ( A*dbx - dax*B ) * iDen;
        I.y = ( A*dby - day*B ) * iDen;

        if(!PolyK._InRect(I, b1, b2)) return null;
        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;
        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;
        return I;
    }

    PolyK._GetLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        I.x = ( A*dbx - dax*B ) / Den;
        I.y = ( A*dby - day*B ) / Den;

        if(PolyK._InRect(I, a1, a2) && PolyK._InRect(I, b1, b2)) return I;
        return null;
    }

    PolyK._InRect = function(a, b, c)
    {
        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));
        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));

        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)
        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))
        return true;
        return false;
    }
    */
    PolyK._convex = function(ax, ay, bx, by, cx, cy)
    {
        return (ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0;
    }
    /*
    PolyK._P = function(x,y)
    {
        this.x = x;
        this.y = y;
        this.flag = false;
    }
    PolyK._P.prototype.toString = function()
    {
        return "Point ["+this.x+", "+this.y+"]";
    }
    PolyK._P.dist = function(a,b)
    {
        var dx = b.x-a.x;
        var dy = b.y-a.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    PolyK._tp = [];
    for(var i=0; i<10; i++) PolyK._tp.push(new PolyK._P(0,0));
        */

module.exports = PolyK;

},{}],31:[function(_dereq_,module,exports){
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.
 * @class vec2
 */

var vec2 = module.exports = {};

var Utils = _dereq_('../utils/Utils');

/**
 * Make a cross product and only return the z component
 * @method crossLength
 * @static
 * @param  {Array} a
 * @param  {Array} b
 * @return {Number}
 */
vec2.crossLength = function(a,b){
    return a[0] * b[1] - a[1] * b[0];
};

/**
 * Cross product between a vector and the Z component of a vector
 * @method crossVZ
 * @static
 * @param  {Array} out
 * @param  {Array} vec
 * @param  {Number} zcomp
 * @return {Number}
 */
vec2.crossVZ = function(out, vec, zcomp){
    vec2.rotate(out,vec,-Math.PI/2);// Rotate according to the right hand rule
    vec2.scale(out,out,zcomp);      // Scale with z
    return out;
};

/**
 * Cross product between a vector and the Z component of a vector
 * @method crossZV
 * @static
 * @param  {Array} out
 * @param  {Number} zcomp
 * @param  {Array} vec
 * @return {Number}
 */
vec2.crossZV = function(out, zcomp, vec){
    vec2.rotate(out,vec,Math.PI/2); // Rotate according to the right hand rule
    vec2.scale(out,out,zcomp);      // Scale with z
    return out;
};

/**
 * Rotate a vector by an angle
 * @method rotate
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */
vec2.rotate = function(out,a,angle){
    if(angle !== 0){
        var c = Math.cos(angle),
            s = Math.sin(angle),
            x = a[0],
            y = a[1];
        out[0] = c*x -s*y;
        out[1] = s*x +c*y;
    } else {
        out[0] = a[0];
        out[1] = a[1];
    }
};

/**
 * Rotate a vector 90 degrees clockwise
 * @method rotate90cw
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */
vec2.rotate90cw = function(out, a) {
    var x = a[0];
    var y = a[1];
    out[0] = y;
    out[1] = -x;
};

/**
 * Transform a point position to local frame.
 * @method toLocalFrame
 * @param  {Array} out
 * @param  {Array} worldPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */
vec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle){
    vec2.copy(out, worldPoint);
    vec2.sub(out, out, framePosition);
    vec2.rotate(out, out, -frameAngle);
};

/**
 * Transform a point position to global frame.
 * @method toGlobalFrame
 * @param  {Array} out
 * @param  {Array} localPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */
vec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle){
    vec2.copy(out, localPoint);
    vec2.rotate(out, out, frameAngle);
    vec2.add(out, out, framePosition);
};

/**
 * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php
 * @method centroid
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return  {Array} The out object
 */
vec2.centroid = function(out, a, b, c){
    vec2.add(out, a, b);
    vec2.add(out, out, c);
    vec2.scale(out, out, 1/3);
    return out;
};

/**
 * Creates a new, empty vec2
 * @static
 * @method create
 * @return {Array} a new 2D vector
 */
vec2.create = function() {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 * @static
 * @method clone
 * @param {Array} a vector to clone
 * @return {Array} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 * @static
 * @method fromValues
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 * @static
 * @method copy
 * @param {Array} out the receiving vector
 * @param {Array} a the source vector
 * @return {Array} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 * @static
 * @method set
 * @param {Array} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 * @static
 * @method add
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts two vec2's
 * @static
 * @method subtract
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for vec2.subtract
 * @static
 * @method sub
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 * @static
 * @method multiply
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for vec2.multiply
 * @static
 * @method mul
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 * @static
 * @method divide
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for vec2.divide
 * @static
 * @method div
 */
vec2.div = vec2.divide;

/**
 * Scales a vec2 by a scalar number
 * @static
 * @method scale
 * @param {Array} out the receiving vector
 * @param {Array} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @return {Array} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 * @static
 * @method distance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for vec2.distance
 * @static
 * @method dist
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 * @static
 * @method squaredDistance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for vec2.squaredDistance
 * @static
 * @method sqrDist
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 * @static
 * @method length
 * @param {Array} a vector to calculate length of
 * @return {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for vec2.length
 * @method len
 * @static
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 * @static
 * @method squaredLength
 * @param {Array} a vector to calculate squared length of
 * @return {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for vec2.squaredLength
 * @static
 * @method sqrLen
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 * @static
 * @method negate
 * @param {Array} out the receiving vector
 * @param {Array} a vector to negate
 * @return {Array} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 * @static
 * @method normalize
 * @param {Array} out the receiving vector
 * @param {Array} a vector to normalize
 * @return {Array} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 * @static
 * @method dot
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Returns a string representation of a vector
 * @static
 * @method str
 * @param {Array} vec vector to represent as a string
 * @return {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

},{"../utils/Utils":50}],32:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   decomp = _dereq_('poly-decomp')
,   Convex = _dereq_('../shapes/Convex')
,   AABB = _dereq_('../collision/AABB')
,   EventEmitter = _dereq_('../events/EventEmitter');

module.exports = Body;

/**
 * A rigid body. Has got a center of mass, position, velocity and a number of
 * shapes that are used for collisions.
 *
 * @class Body
 * @constructor
 * @extends EventEmitter
 * @param {Object}              [options]
 * @param {Number}              [options.mass=0]    A number >= 0. If zero, the .type will be set to Body.STATIC.
 * @param {Array}               [options.position]
 * @param {Array}               [options.velocity]
 * @param {Number}              [options.angle=0]
 * @param {Number}              [options.angularVelocity=0]
 * @param {Array}               [options.force]
 * @param {Number}              [options.angularForce=0]
 * @param {Number}              [options.fixedRotation=false]
 * @param {Number}              [options.ccdSpeedThreshold=-1]
 * @param {Number}              [options.ccdIterations=10]
 *
 * @example
 *
 *     // Create a typical dynamic body
 *     var body = new Body({
 *         mass: 1,
 *         position: [0, 0],
 *         angle: 0,
 *         velocity: [0, 0],
 *         angularVelocity: 0
 *     });
 *
 *     // Add a circular shape to the body
 *     body.addShape(new Circle(1));
 *
 *     // Add the body to the world
 *     world.addBody(body);
 */
function Body(options){
    options = options || {};

    EventEmitter.call(this);

    /**
     * The body identifyer
     * @property id
     * @type {Number}
     */
    this.id = ++Body._idCounter;

    /**
     * The world that this body is added to. This property is set to NULL if the body is not added to any world.
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * The shapes of the body. The local transform of the shape in .shapes[i] is
     * defined by .shapeOffsets[i] and .shapeAngles[i].
     *
     * @property shapes
     * @type {Array}
     */
    this.shapes = [];

    /**
     * The local shape offsets, relative to the body center of mass. This is an
     * array of Array.
     * @property shapeOffsets
     * @type {Array}
     */
    this.shapeOffsets = [];

    /**
     * The body-local shape angle transforms. This is an array of numbers (angles).
     * @property shapeAngles
     * @type {Array}
     */
    this.shapeAngles = [];

    /**
     * The mass of the body.
     * @property mass
     * @type {number}
     */
    this.mass = options.mass || 0;

    /**
     * The inverse mass of the body.
     * @property invMass
     * @type {number}
     */
    this.invMass = 0;

    /**
     * The inertia of the body around the Z axis.
     * @property inertia
     * @type {number}
     */
    this.inertia = 0;

    /**
     * The inverse inertia of the body.
     * @property invInertia
     * @type {number}
     */
    this.invInertia = 0;

    this.invMassSolve = 0;
    this.invInertiaSolve = 0;

    /**
     * Set to true if you want to fix the rotation of the body.
     * @property fixedRotation
     * @type {Boolean}
     */
    this.fixedRotation = !!options.fixedRotation;

    /**
     * The position of the body
     * @property position
     * @type {Array}
     */
    this.position = vec2.fromValues(0,0);
    if(options.position){
        vec2.copy(this.position, options.position);
    }

    /**
     * The interpolated position of the body.
     * @property interpolatedPosition
     * @type {Array}
     */
    this.interpolatedPosition = vec2.fromValues(0,0);

    /**
     * The interpolated angle of the body.
     * @property interpolatedAngle
     * @type {Number}
     */
    this.interpolatedAngle = 0;

    /**
     * The previous position of the body.
     * @property previousPosition
     * @type {Array}
     */
    this.previousPosition = vec2.fromValues(0,0);

    /**
     * The previous angle of the body.
     * @property previousAngle
     * @type {Number}
     */
    this.previousAngle = 0;

    /**
     * The velocity of the body
     * @property velocity
     * @type {Array}
     */
    this.velocity = vec2.fromValues(0,0);
    if(options.velocity){
        vec2.copy(this.velocity, options.velocity);
    }

    /**
     * Constraint velocity that was added to the body during the last step.
     * @property vlambda
     * @type {Array}
     */
    this.vlambda = vec2.fromValues(0,0);

    /**
     * Angular constraint velocity that was added to the body during last step.
     * @property wlambda
     * @type {Array}
     */
    this.wlambda = 0;

    /**
     * The angle of the body, in radians.
     * @property angle
     * @type {number}
     * @example
     *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.
     *     // If you need a value between 0 and 2*pi, use the following function to normalize it.
     *     function normalizeAngle(angle){
     *         angle = angle % (2*Math.PI);
     *         if(angle < 0){
     *             angle += (2*Math.PI);
     *         }
     *         return angle;
     *     }
     */
    this.angle = options.angle || 0;

    /**
     * The angular velocity of the body, in radians per second.
     * @property angularVelocity
     * @type {number}
     */
    this.angularVelocity = options.angularVelocity || 0;

    /**
     * The force acting on the body. Since the body force (and {{#crossLink "Body/angularForce:property"}}{{/crossLink}}) will be zeroed after each step, so you need to set the force before each step.
     * @property force
     * @type {Array}
     *
     * @example
     *     // This produces a forcefield of 1 Newton in the positive x direction.
     *     for(var i=0; i<numSteps; i++){
     *         body.force[0] = 1;
     *         world.step(1/60);
     *     }
     *
     * @example
     *     // This will apply a rotational force on the body
     *     for(var i=0; i<numSteps; i++){
     *         body.angularForce = -3;
     *         world.step(1/60);
     *     }
     */
    this.force = vec2.create();
    if(options.force){
        vec2.copy(this.force, options.force);
    }

    /**
     * The angular force acting on the body. See {{#crossLink "Body/force:property"}}{{/crossLink}}.
     * @property angularForce
     * @type {number}
     */
    this.angularForce = options.angularForce || 0;

    /**
     * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.
     * @property damping
     * @type {Number}
     * @default 0.1
     */
    this.damping = typeof(options.damping) === "number" ? options.damping : 0.1;

    /**
     * The angular force acting on the body. Should be a value between 0 and 1.
     * @property angularDamping
     * @type {Number}
     * @default 0.1
     */
    this.angularDamping = typeof(options.angularDamping) === "number" ? options.angularDamping : 0.1;

    /**
     * The type of motion this body has. Should be one of: {{#crossLink "Body/STATIC:property"}}Body.STATIC{{/crossLink}}, {{#crossLink "Body/DYNAMIC:property"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink "Body/KINEMATIC:property"}}Body.KINEMATIC{{/crossLink}}.
     *
     * * Static bodies do not move, and they do not respond to forces or collision.
     * * Dynamic bodies body can move and respond to collisions and forces.
     * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.
     *
     * @property type
     * @type {number}
     *
     * @example
     *     // Bodies are static by default. Static bodies will never move.
     *     var body = new Body();
     *     console.log(body.type == Body.STATIC); // true
     *
     * @example
     *     // By setting the mass of a body to a nonzero number, the body
     *     // will become dynamic and will move and interact with other bodies.
     *     var dynamicBody = new Body({
     *         mass : 1
     *     });
     *     console.log(dynamicBody.type == Body.DYNAMIC); // true
     *
     * @example
     *     // Kinematic bodies will only move if you change their velocity.
     *     var kinematicBody = new Body({
     *         type: Body.KINEMATIC // Type can be set via the options object.
     *     });
     */
    this.type = Body.STATIC;

    if(typeof(options.type) !== 'undefined'){
        this.type = options.type;
    } else if(!options.mass){
        this.type = Body.STATIC;
    } else {
        this.type = Body.DYNAMIC;
    }

    /**
     * Bounding circle radius.
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    /**
     * Bounding box of this body.
     * @property aabb
     * @type {AABB}
     */
    this.aabb = new AABB();

    /**
     * Indicates if the AABB needs update. Update it with {{#crossLink "Body/updateAABB:method"}}.updateAABB(){{/crossLink}}.
     * @property aabbNeedsUpdate
     * @type {Boolean}
     * @see updateAABB
     *
     * @example
     *     // Force update the AABB
     *     body.aabbNeedsUpdate = true;
     *     body.updateAABB();
     *     console.log(body.aabbNeedsUpdate); // false
     */
    this.aabbNeedsUpdate = true;

    /**
     * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink "World"}}{{/crossLink}} before anything will happen.
     * @property allowSleep
     * @type {Boolean}
     * @default true
     */
    this.allowSleep = true;

    this.wantsToSleep = false;

    /**
     * One of {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}}, {{#crossLink "Body/SLEEPY:property"}}Body.SLEEPY{{/crossLink}} and {{#crossLink "Body/SLEEPING:property"}}Body.SLEEPING{{/crossLink}}.
     *
     * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).
     *
     * @property sleepState
     * @type {Number}
     * @default Body.AWAKE
     */
    this.sleepState = Body.AWAKE;

    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @property sleepSpeedLimit
     * @type {Number}
     * @default 0.2
     */
    this.sleepSpeedLimit = 0.2;

    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @property sleepTimeLimit
     * @type {Number}
     * @default 1
     */
    this.sleepTimeLimit = 1;

    /**
     * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.
     * @property {Number} gravityScale
     * @default 1
     */
    this.gravityScale = 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * How long the body has been sleeping.
     * @property {Number} idleTime
     */
    this.idleTime = 0;

    /**
     * The last time when the body went to SLEEPY state.
     * @property {Number} timeLastSleepy
     * @private
     */
    this.timeLastSleepy = 0;

    /**
     * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.
     * @property {number} ccdSpeedThreshold
     * @default -1
     */
    this.ccdSpeedThreshold = options.ccdSpeedThreshold !== undefined ? options.ccdSpeedThreshold : -1;

    /**
     * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.
     * @property {number} ccdIterations
     * @default 10
     */
    this.ccdIterations = options.ccdIterations !== undefined ? options.ccdIterations : 10;

    this.concavePath = null;

    this._wakeUpAfterNarrowphase = false;

    this.updateMassProperties();
}
Body.prototype = new EventEmitter();
Body.prototype.constructor = Body;

Body._idCounter = 0;

Body.prototype.updateSolveMassProperties = function(){
    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
        this.invMassSolve = 0;
        this.invInertiaSolve = 0;
    } else {
        this.invMassSolve = this.invMass;
        this.invInertiaSolve = this.invInertia;
    }
};

/**
 * Set the total density of the body
 * @method setDensity
 */
Body.prototype.setDensity = function(density) {
    var totalArea = this.getArea();
    this.mass = totalArea * density;
    this.updateMassProperties();
};

/**
 * Get the total area of all shapes in the body
 * @method getArea
 * @return {Number}
 */
Body.prototype.getArea = function() {
    var totalArea = 0;
    for(var i=0; i<this.shapes.length; i++){
        totalArea += this.shapes[i].area;
    }
    return totalArea;
};

/**
 * Get the AABB from the body. The AABB is updated if necessary.
 * @method getAABB
 */
Body.prototype.getAABB = function(){
    if(this.aabbNeedsUpdate){
        this.updateAABB();
    }
    return this.aabb;
};

var shapeAABB = new AABB(),
    tmp = vec2.create();

/**
 * Updates the AABB of the Body
 * @method updateAABB
 */
Body.prototype.updateAABB = function() {
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        shapeAngles = this.shapeAngles,
        N = shapes.length,
        offset = tmp,
        bodyAngle = this.angle;

    for(var i=0; i!==N; i++){
        var shape = shapes[i],
            angle = shapeAngles[i] + bodyAngle;

        // Get shape world offset
        vec2.rotate(offset, shapeOffsets[i], bodyAngle);
        vec2.add(offset, offset, this.position);

        // Get shape AABB
        shape.computeAABB(shapeAABB, offset, angle);

        if(i===0){
            this.aabb.copy(shapeAABB);
        } else {
            this.aabb.extend(shapeAABB);
        }
    }

    this.aabbNeedsUpdate = false;
};

/**
 * Update the bounding radius of the body. Should be done if any of the shapes
 * are changed.
 * @method updateBoundingRadius
 */
Body.prototype.updateBoundingRadius = function(){
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        N = shapes.length,
        radius = 0;

    for(var i=0; i!==N; i++){
        var shape = shapes[i],
            offset = vec2.length(shapeOffsets[i]),
            r = shape.boundingRadius;
        if(offset + r > radius){
            radius = offset + r;
        }
    }

    this.boundingRadius = radius;
};

/**
 * Add a shape to the body. You can pass a local transform when adding a shape,
 * so that the shape gets an offset and angle relative to the body center of mass.
 * Will automatically update the mass properties and bounding radius.
 *
 * @method addShape
 * @param  {Shape}              shape
 * @param  {Array} [offset] Local body offset of the shape.
 * @param  {Number}             [angle]  Local body angle.
 *
 * @example
 *     var body = new Body(),
 *         shape = new Circle();
 *
 *     // Add the shape to the body, positioned in the center
 *     body.addShape(shape);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.
 *     body.addShape(shape,[1,0]);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.
 *     body.addShape(shape,[0,1],Math.PI/2);
 */
Body.prototype.addShape = function(shape,offset,angle){
    angle = angle || 0.0;

    // Copy the offset vector
    if(offset){
        offset = vec2.fromValues(offset[0],offset[1]);
    } else {
        offset = vec2.fromValues(0,0);
    }

    this.shapes      .push(shape);
    this.shapeOffsets.push(offset);
    this.shapeAngles .push(angle);
    this.updateMassProperties();
    this.updateBoundingRadius();

    this.aabbNeedsUpdate = true;
};

/**
 * Remove a shape
 * @method removeShape
 * @param  {Shape}  shape
 * @return {Boolean}       True if the shape was found and removed, else false.
 */
Body.prototype.removeShape = function(shape){
    var idx = this.shapes.indexOf(shape);

    if(idx !== -1){
        this.shapes.splice(idx,1);
        this.shapeOffsets.splice(idx,1);
        this.shapeAngles.splice(idx,1);
        this.aabbNeedsUpdate = true;
        return true;
    } else {
        return false;
    }
};

/**
 * Updates .inertia, .invMass, .invInertia for this Body. Should be called when
 * changing the structure or mass of the Body.
 *
 * @method updateMassProperties
 *
 * @example
 *     body.mass += 1;
 *     body.updateMassProperties();
 */
Body.prototype.updateMassProperties = function(){
    if(this.type === Body.STATIC || this.type === Body.KINEMATIC){

        this.mass = Number.MAX_VALUE;
        this.invMass = 0;
        this.inertia = Number.MAX_VALUE;
        this.invInertia = 0;

    } else {

        var shapes = this.shapes,
            N = shapes.length,
            m = this.mass / N,
            I = 0;

        if(!this.fixedRotation){
            for(var i=0; i<N; i++){
                var shape = shapes[i],
                    r2 = vec2.squaredLength(this.shapeOffsets[i]),
                    Icm = shape.computeMomentOfInertia(m);
                I += Icm + m*r2;
            }
            this.inertia = I;
            this.invInertia = I>0 ? 1/I : 0;

        } else {
            this.inertia = Number.MAX_VALUE;
            this.invInertia = 0;
        }

        // Inverse mass properties are easy
        this.invMass = 1/this.mass;// > 0 ? 1/this.mass : 0;
    }
};

var Body_applyForce_r = vec2.create();

/**
 * Apply force to a world point. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce.
 * @method applyForce
 * @param {Array} force The force to add.
 * @param {Array} worldPoint A world point to apply the force on.
 */
Body.prototype.applyForce = function(force,worldPoint){
    // Compute point position relative to the body center
    var r = Body_applyForce_r;
    vec2.sub(r,worldPoint,this.position);

    // Add linear force
    vec2.add(this.force,this.force,force);

    // Compute produced rotational force
    var rotForce = vec2.crossLength(r,force);

    // Add rotational force
    this.angularForce += rotForce;
};

/**
 * Transform a world point to local body frame.
 * @method toLocalFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} worldPoint   The input world vector
 */
Body.prototype.toLocalFrame = function(out, worldPoint){
    vec2.toLocalFrame(out, worldPoint, this.position, this.angle);
};

/**
 * Transform a local point to world frame.
 * @method toWorldFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} localPoint   The input local vector
 */
Body.prototype.toWorldFrame = function(out, localPoint){
    vec2.toGlobalFrame(out, localPoint, this.position, this.angle);
};

/**
 * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.
 * @method fromPolygon
 * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.
 * @param {Object} [options]
 * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
 * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.
 * @param {Boolean|Number} [options.removeCollinearPoints=false] Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
 * @return {Boolean} True on success, else false.
 */
Body.prototype.fromPolygon = function(path,options){
    options = options || {};

    // Remove all shapes
    for(var i=this.shapes.length; i>=0; --i){
        this.removeShape(this.shapes[i]);
    }

    var p = new decomp.Polygon();
    p.vertices = path;

    // Make it counter-clockwise
    p.makeCCW();

    if(typeof(options.removeCollinearPoints) === "number"){
        p.removeCollinearPoints(options.removeCollinearPoints);
    }

    // Check if any line segment intersects the path itself
    if(typeof(options.skipSimpleCheck) === "undefined"){
        if(!p.isSimple()){
            return false;
        }
    }

    // Save this path for later
    this.concavePath = p.vertices.slice(0);
    for(var i=0; i<this.concavePath.length; i++){
        var v = [0,0];
        vec2.copy(v,this.concavePath[i]);
        this.concavePath[i] = v;
    }

    // Slow or fast decomp?
    var convexes;
    if(options.optimalDecomp){
        convexes = p.decomp();
    } else {
        convexes = p.quickDecomp();
    }

    var cm = vec2.create();

    // Add convexes
    for(var i=0; i!==convexes.length; i++){
        // Create convex
        var c = new Convex(convexes[i].vertices);

        // Move all vertices so its center of mass is in the local center of the convex
        for(var j=0; j!==c.vertices.length; j++){
            var v = c.vertices[j];
            vec2.sub(v,v,c.centerOfMass);
        }

        vec2.scale(cm,c.centerOfMass,1);
        c.updateTriangles();
        c.updateCenterOfMass();
        c.updateBoundingRadius();

        // Add the shape
        this.addShape(c,cm);
    }

    this.adjustCenterOfMass();

    this.aabbNeedsUpdate = true;

    return true;
};

var adjustCenterOfMass_tmp1 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp2 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp3 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp4 = vec2.fromValues(0,0);

/**
 * Moves the shape offsets so their center of mass becomes the body center of mass.
 * @method adjustCenterOfMass
 */
Body.prototype.adjustCenterOfMass = function(){
    var offset_times_area = adjustCenterOfMass_tmp2,
        sum =               adjustCenterOfMass_tmp3,
        cm =                adjustCenterOfMass_tmp4,
        totalArea =         0;
    vec2.set(sum,0,0);

    for(var i=0; i!==this.shapes.length; i++){
        var s = this.shapes[i],
            offset = this.shapeOffsets[i];
        vec2.scale(offset_times_area,offset,s.area);
        vec2.add(sum,sum,offset_times_area);
        totalArea += s.area;
    }

    vec2.scale(cm,sum,1/totalArea);

    // Now move all shapes
    for(var i=0; i!==this.shapes.length; i++){
        var s = this.shapes[i],
            offset = this.shapeOffsets[i];

        // Offset may be undefined. Fix that.
        if(!offset){
            offset = this.shapeOffsets[i] = vec2.create();
        }

        vec2.sub(offset,offset,cm);
    }

    // Move the body position too
    vec2.add(this.position,this.position,cm);

    // And concave path
    for(var i=0; this.concavePath && i<this.concavePath.length; i++){
        vec2.sub(this.concavePath[i], this.concavePath[i], cm);
    }

    this.updateMassProperties();
    this.updateBoundingRadius();
};

/**
 * Sets the force on the body to zero.
 * @method setZeroForce
 */
Body.prototype.setZeroForce = function(){
    vec2.set(this.force,0.0,0.0);
    this.angularForce = 0.0;
};

Body.prototype.resetConstraintVelocity = function(){
    var b = this,
        vlambda = b.vlambda;
    vec2.set(vlambda,0,0);
    b.wlambda = 0;
};

Body.prototype.addConstraintVelocity = function(){
    var b = this,
        v = b.velocity;
    vec2.add( v, v, b.vlambda);
    b.angularVelocity += b.wlambda;
};

/**
 * Apply damping, see <a href="http://code.google.com/p/bullet/issues/detail?id=74">this</a> for details.
 * @method applyDamping
 * @param  {number} dt Current time step
 */
Body.prototype.applyDamping = function(dt){
    if(this.type === Body.DYNAMIC){ // Only for dynamic bodies
        var v = this.velocity;
        vec2.scale(v, v, Math.pow(1.0 - this.damping,dt));
        this.angularVelocity *= Math.pow(1.0 - this.angularDamping,dt);
    }
};

/**
 * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.
 * Sets the sleepState to {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.
 * @method wakeUp
 */
Body.prototype.wakeUp = function(){
    var s = this.sleepState;
    this.sleepState = Body.AWAKE;
    this.idleTime = 0;
    if(s !== Body.AWAKE){
        this.emit(Body.wakeUpEvent);
    }
};

/**
 * Force body sleep
 * @method sleep
 */
Body.prototype.sleep = function(){
    this.sleepState = Body.SLEEPING;
    this.angularVelocity = 0;
    this.angularForce = 0;
    vec2.set(this.velocity,0,0);
    vec2.set(this.force,0,0);
    this.emit(Body.sleepEvent);
};

/**
 * Called every timestep to update internal sleep timer and change sleep state if needed.
 * @method sleepTick
 * @param {number} time The world time in seconds
 * @param {boolean} dontSleep
 * @param {number} dt
 */
Body.prototype.sleepTick = function(time, dontSleep, dt){
    if(!this.allowSleep || this.type === Body.SLEEPING){
        return;
    }

    this.wantsToSleep = false;

    var sleepState = this.sleepState,
        speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity,2),
        speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);

    // Add to idle time
    if(speedSquared >= speedLimitSquared){
        this.idleTime = 0;
        this.sleepState = Body.AWAKE;
    } else {
        this.idleTime += dt;
        this.sleepState = Body.SLEEPY;
    }
    if(this.idleTime > this.sleepTimeLimit){
        if(!dontSleep){
            this.sleep();
        } else {
            this.wantsToSleep = true;
        }
    }

    /*
    if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){
        this.sleepState = Body.SLEEPY; // Sleepy
        this.timeLastSleepy = time;
        this.emit(Body.sleepyEvent);
    } else if(sleepState===Body.SLEEPY && speedSquared >= speedLimitSquared){
        this.wakeUp(); // Wake up
    } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){
        this.wantsToSleep = true;
        if(!dontSleep){
            this.sleep();
        }
    }
    */
};

Body.prototype.getVelocityFromPosition = function(store, timeStep){
    store = store || vec2.create();
    vec2.sub(store, this.position, this.previousPosition);
    vec2.scale(store, store, 1/timeStep);
    return store;
};

Body.prototype.getAngularVelocityFromPosition = function(timeStep){
    return (this.angle - this.previousAngle) / timeStep;
};

/**
 * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.
 * @method overlaps
 * @param  {Body} body
 * @return {boolean}
 */
Body.prototype.overlaps = function(body){
    return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
};

var integrate_fhMinv = vec2.create();
var integrate_velodt = vec2.create();

/**
 * Move the body forward in time given its current velocity.
 * @method integrate
 * @param  {Number} dt
 */
Body.prototype.integrate = function(dt){
    var minv = this.invMass,
        f = this.force,
        pos = this.position,
        velo = this.velocity;

    // Save old position
    vec2.copy(this.previousPosition, this.position);
    this.previousAngle = this.angle;

    // Velocity update
    if(!this.fixedRotation){
        this.angularVelocity += this.angularForce * this.invInertia * dt;
    }
    vec2.scale(integrate_fhMinv, f, dt * minv);
    vec2.add(velo, integrate_fhMinv, velo);

    // CCD
    if(!this.integrateToTimeOfImpact(dt)){

        // Regular position update
        vec2.scale(integrate_velodt, velo, dt);
        vec2.add(pos, pos, integrate_velodt);
        if(!this.fixedRotation){
            this.angle += this.angularVelocity * dt;
        }
    }

    this.aabbNeedsUpdate = true;
};

var direction = vec2.create();
var end = vec2.create();
var startToEnd = vec2.create();
var rememberPosition = vec2.create();
Body.prototype.integrateToTimeOfImpact = function(dt){

    if(this.ccdSpeedThreshold < 0 || vec2.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)){
        return false;
    }

    vec2.normalize(direction, this.velocity);

    vec2.scale(end, this.velocity, dt);
    vec2.add(end, end, this.position);

    vec2.sub(startToEnd, end, this.position);
    var startToEndAngle = this.angularVelocity * dt;
    var len = vec2.length(startToEnd);

    var timeOfImpact = 1;

    var hit;
    var that = this;
    this.world.raycastAll(this.position, end, {}, function (result) {
        if(result.body === that){
            return;
        }
        hit = result.body;
        vec2.copy(end, result.hitPointWorld);
        vec2.sub(startToEnd, result.hitPointWorld, that.position);
        timeOfImpact = vec2.length(startToEnd) / len;
        result.abort();
    });

    if(!hit){
        return false;
    }

    var rememberAngle = this.angle;
    vec2.copy(rememberPosition, this.position);

    // Got a start and end point. Approximate time of impact using binary search
    var iter = 0;
    var tmin = 0;
    var tmid = 0;
    var tmax = timeOfImpact;
    while (tmax >= tmin && iter < this.ccdIterations) {
        iter++;

        // calculate the midpoint
        tmid = (tmax - tmin) / 2;

        // Move the body to that point
        vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
        vec2.add(this.position, rememberPosition, integrate_velodt);
        this.angle = rememberAngle + startToEndAngle * timeOfImpact;
        this.updateAABB();

        // check overlap
        var overlaps = this.aabb.overlaps(hit.aabb) && this.world.narrowphase.bodiesOverlap(this, hit);

        if (overlaps) {
            // change min to search upper interval
            tmin = tmid;
        } else {
            // change max to search lower interval
            tmax = tmid;
        }
    }

    timeOfImpact = tmid;

    vec2.copy(this.position, rememberPosition);
    this.angle = rememberAngle;

    // move to TOI
    vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
    vec2.add(this.position, this.position, integrate_velodt);
    if(!this.fixedRotation){
        this.angle += startToEndAngle * timeOfImpact;
    }

    return true;
};

/**
 * @event sleepy
 */
Body.sleepyEvent = {
    type: "sleepy"
};

/**
 * @event sleep
 */
Body.sleepEvent = {
    type: "sleep"
};

/**
 * @event wakeup
 */
Body.wakeUpEvent = {
    type: "wakeup"
};

/**
 * Dynamic body.
 * @property DYNAMIC
 * @type {Number}
 * @static
 */
Body.DYNAMIC = 1;

/**
 * Static body.
 * @property STATIC
 * @type {Number}
 * @static
 */
Body.STATIC = 2;

/**
 * Kinematic body.
 * @property KINEMATIC
 * @type {Number}
 * @static
 */
Body.KINEMATIC = 4;

/**
 * @property AWAKE
 * @type {Number}
 * @static
 */
Body.AWAKE = 0;

/**
 * @property SLEEPY
 * @type {Number}
 * @static
 */
Body.SLEEPY = 1;

/**
 * @property SLEEPING
 * @type {Number}
 * @static
 */
Body.SLEEPING = 2;


},{"../collision/AABB":7,"../events/EventEmitter":27,"../math/vec2":31,"../shapes/Convex":39,"poly-decomp":5}],33:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Spring = _dereq_('./Spring');
var Utils = _dereq_('../utils/Utils');

module.exports = LinearSpring;

/**
 * A spring, connecting two bodies.
 *
 * The Spring explicitly adds force and angularForce to the bodies.
 *
 * @class LinearSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 */
function LinearSpring(bodyA,bodyB,options){
    options = options || {};

    Spring.call(this, bodyA, bodyB, options);

    /**
     * Anchor for bodyA in local bodyA coordinates.
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = vec2.fromValues(0,0);

    /**
     * Anchor for bodyB in local bodyB coordinates.
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = vec2.fromValues(0,0);

    if(options.localAnchorA){ vec2.copy(this.localAnchorA, options.localAnchorA); }
    if(options.localAnchorB){ vec2.copy(this.localAnchorB, options.localAnchorB); }
    if(options.worldAnchorA){ this.setWorldAnchorA(options.worldAnchorA); }
    if(options.worldAnchorB){ this.setWorldAnchorB(options.worldAnchorB); }

    var worldAnchorA = vec2.create();
    var worldAnchorB = vec2.create();
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);
    var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);

    /**
     * Rest length of the spring.
     * @property restLength
     * @type {number}
     */
    this.restLength = typeof(options.restLength) === "number" ? options.restLength : worldDistance;
}
LinearSpring.prototype = new Spring();
LinearSpring.prototype.constructor = LinearSpring;

/**
 * Set the anchor point on body A, using world coordinates.
 * @method setWorldAnchorA
 * @param {Array} worldAnchorA
 */
LinearSpring.prototype.setWorldAnchorA = function(worldAnchorA){
    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
};

/**
 * Set the anchor point on body B, using world coordinates.
 * @method setWorldAnchorB
 * @param {Array} worldAnchorB
 */
LinearSpring.prototype.setWorldAnchorB = function(worldAnchorB){
    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
};

/**
 * Get the anchor point on body A, in world coordinates.
 * @method getWorldAnchorA
 * @param {Array} result The vector to store the result in.
 */
LinearSpring.prototype.getWorldAnchorA = function(result){
    this.bodyA.toWorldFrame(result, this.localAnchorA);
};

/**
 * Get the anchor point on body B, in world coordinates.
 * @method getWorldAnchorB
 * @param {Array} result The vector to store the result in.
 */
LinearSpring.prototype.getWorldAnchorB = function(result){
    this.bodyB.toWorldFrame(result, this.localAnchorB);
};

var applyForce_r =              vec2.create(),
    applyForce_r_unit =         vec2.create(),
    applyForce_u =              vec2.create(),
    applyForce_f =              vec2.create(),
    applyForce_worldAnchorA =   vec2.create(),
    applyForce_worldAnchorB =   vec2.create(),
    applyForce_ri =             vec2.create(),
    applyForce_rj =             vec2.create(),
    applyForce_tmp =            vec2.create();

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
LinearSpring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restLength,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        r = applyForce_r,
        r_unit = applyForce_r_unit,
        u = applyForce_u,
        f = applyForce_f,
        tmp = applyForce_tmp;

    var worldAnchorA = applyForce_worldAnchorA,
        worldAnchorB = applyForce_worldAnchorB,
        ri = applyForce_ri,
        rj = applyForce_rj;

    // Get world anchors
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);

    // Get offset points
    vec2.sub(ri, worldAnchorA, bodyA.position);
    vec2.sub(rj, worldAnchorB, bodyB.position);

    // Compute distance vector between world anchor points
    vec2.sub(r, worldAnchorB, worldAnchorA);
    var rlen = vec2.len(r);
    vec2.normalize(r_unit,r);

    //console.log(rlen)
    //console.log("A",vec2.str(worldAnchorA),"B",vec2.str(worldAnchorB))

    // Compute relative velocity of the anchor points, u
    vec2.sub(u, bodyB.velocity, bodyA.velocity);
    vec2.crossZV(tmp, bodyB.angularVelocity, rj);
    vec2.add(u, u, tmp);
    vec2.crossZV(tmp, bodyA.angularVelocity, ri);
    vec2.sub(u, u, tmp);

    // F = - k * ( x - L ) - D * ( u )
    vec2.scale(f, r_unit, -k*(rlen-l) - d*vec2.dot(u,r_unit));

    // Add forces to bodies
    vec2.sub( bodyA.force, bodyA.force, f);
    vec2.add( bodyB.force, bodyB.force, f);

    // Angular force
    var ri_x_f = vec2.crossLength(ri, f);
    var rj_x_f = vec2.crossLength(rj, f);
    bodyA.angularForce -= ri_x_f;
    bodyB.angularForce += rj_x_f;
};

},{"../math/vec2":31,"../utils/Utils":50,"./Spring":35}],34:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Spring = _dereq_('./Spring');

module.exports = RotationalSpring;

/**
 * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.
 *
 * The spring can be combined with a {{#crossLink "RevoluteConstraint"}}{{/crossLink}} to make, for example, a mouse trap.
 *
 * @class RotationalSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.
 * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1] A number >= 0.
 */
function RotationalSpring(bodyA, bodyB, options){
    options = options || {};

    Spring.call(this, bodyA, bodyB, options);

    /**
     * Rest angle of the spring.
     * @property restAngle
     * @type {number}
     */
    this.restAngle = typeof(options.restAngle) === "number" ? options.restAngle : bodyB.angle - bodyA.angle;
}
RotationalSpring.prototype = new Spring();
RotationalSpring.prototype.constructor = RotationalSpring;

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
RotationalSpring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restAngle,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        x = bodyB.angle - bodyA.angle,
        u = bodyB.angularVelocity - bodyA.angularVelocity;

    var torque = - k * (x - l) - d * u * 0;

    bodyA.angularForce -= torque;
    bodyB.angularForce += torque;
};

},{"../math/vec2":31,"./Spring":35}],35:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Utils = _dereq_('../utils/Utils');

module.exports = Spring;

/**
 * A spring, connecting two bodies. The Spring explicitly adds force and angularForce to the bodies and does therefore not put load on the constraint solver.
 *
 * @class Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 */
function Spring(bodyA, bodyB, options){
    options = Utils.defaults(options,{
        stiffness: 100,
        damping: 1,
    });

    /**
     * Stiffness of the spring.
     * @property stiffness
     * @type {number}
     */
    this.stiffness = options.stiffness;

    /**
     * Damping of the spring.
     * @property damping
     * @type {number}
     */
    this.damping = options.damping;

    /**
     * First connected body.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second connected body.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;
}

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
Spring.prototype.applyForce = function(){
    // To be implemented by subclasses
};

},{"../math/vec2":31,"../utils/Utils":50}],36:[function(_dereq_,module,exports){
// Export p2 classes
module.exports = {
    AABB :                          _dereq_('./collision/AABB'),
    AngleLockEquation :             _dereq_('./equations/AngleLockEquation'),
    Body :                          _dereq_('./objects/Body'),
    Broadphase :                    _dereq_('./collision/Broadphase'),
    Capsule :                       _dereq_('./shapes/Capsule'),
    Circle :                        _dereq_('./shapes/Circle'),
    Constraint :                    _dereq_('./constraints/Constraint'),
    ContactEquation :               _dereq_('./equations/ContactEquation'),
    ContactMaterial :               _dereq_('./material/ContactMaterial'),
    Convex :                        _dereq_('./shapes/Convex'),
    DistanceConstraint :            _dereq_('./constraints/DistanceConstraint'),
    Equation :                      _dereq_('./equations/Equation'),
    EventEmitter :                  _dereq_('./events/EventEmitter'),
    FrictionEquation :              _dereq_('./equations/FrictionEquation'),
    GearConstraint :                _dereq_('./constraints/GearConstraint'),
    GridBroadphase :                _dereq_('./collision/GridBroadphase'),
    GSSolver :                      _dereq_('./solver/GSSolver'),
    Heightfield :                   _dereq_('./shapes/Heightfield'),
    Line :                          _dereq_('./shapes/Line'),
    LockConstraint :                _dereq_('./constraints/LockConstraint'),
    Material :                      _dereq_('./material/Material'),
    Narrowphase :                   _dereq_('./collision/Narrowphase'),
    NaiveBroadphase :               _dereq_('./collision/NaiveBroadphase'),
    Particle :                      _dereq_('./shapes/Particle'),
    Plane :                         _dereq_('./shapes/Plane'),
    RevoluteConstraint :            _dereq_('./constraints/RevoluteConstraint'),
    PrismaticConstraint :           _dereq_('./constraints/PrismaticConstraint'),
    Ray :                           _dereq_('./collision/Ray'),
    RaycastResult :                 _dereq_('./collision/RaycastResult'),
    Rectangle :                     _dereq_('./shapes/Rectangle'),
    RotationalVelocityEquation :    _dereq_('./equations/RotationalVelocityEquation'),
    SAPBroadphase :                 _dereq_('./collision/SAPBroadphase'),
    Shape :                         _dereq_('./shapes/Shape'),
    Solver :                        _dereq_('./solver/Solver'),
    Spring :                        _dereq_('./objects/Spring'),
    LinearSpring :                  _dereq_('./objects/LinearSpring'),
    RotationalSpring :              _dereq_('./objects/RotationalSpring'),
    Utils :                         _dereq_('./utils/Utils'),
    World :                         _dereq_('./world/World'),
    vec2 :                          _dereq_('./math/vec2'),
    version :                       _dereq_('../package.json').version,
};

},{"../package.json":6,"./collision/AABB":7,"./collision/Broadphase":8,"./collision/GridBroadphase":9,"./collision/NaiveBroadphase":10,"./collision/Narrowphase":11,"./collision/Ray":12,"./collision/RaycastResult":13,"./collision/SAPBroadphase":14,"./constraints/Constraint":15,"./constraints/DistanceConstraint":16,"./constraints/GearConstraint":17,"./constraints/LockConstraint":18,"./constraints/PrismaticConstraint":19,"./constraints/RevoluteConstraint":20,"./equations/AngleLockEquation":21,"./equations/ContactEquation":22,"./equations/Equation":23,"./equations/FrictionEquation":24,"./equations/RotationalVelocityEquation":26,"./events/EventEmitter":27,"./material/ContactMaterial":28,"./material/Material":29,"./math/vec2":31,"./objects/Body":32,"./objects/LinearSpring":33,"./objects/RotationalSpring":34,"./objects/Spring":35,"./shapes/Capsule":37,"./shapes/Circle":38,"./shapes/Convex":39,"./shapes/Heightfield":40,"./shapes/Line":41,"./shapes/Particle":42,"./shapes/Plane":43,"./shapes/Rectangle":44,"./shapes/Shape":45,"./solver/GSSolver":46,"./solver/Solver":47,"./utils/Utils":50,"./world/World":54}],37:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Capsule;

/**
 * Capsule shape class.
 * @class Capsule
 * @constructor
 * @extends Shape
 * @param {Number} [length=1] The distance between the end points
 * @param {Number} [radius=1] Radius of the capsule
 * @example
 *     var radius = 1;
 *     var length = 2;
 *     var capsuleShape = new Capsule(length, radius);
 *     body.addShape(capsuleShape);
 */
function Capsule(length, radius){

    /**
     * The distance between the end points.
     * @property {Number} length
     */
    this.length = length || 1;

    /**
     * The radius of the capsule.
     * @property {Number} radius
     */
    this.radius = radius || 1;

    Shape.call(this,Shape.CAPSULE);
}
Capsule.prototype = new Shape();
Capsule.prototype.constructor = Capsule;

/**
 * Compute the mass moment of inertia of the Capsule.
 * @method conputeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @todo
 */
Capsule.prototype.computeMomentOfInertia = function(mass){
    // Approximate with rectangle
    var r = this.radius,
        w = this.length + r, // 2*r is too much, 0 is too little
        h = r*2;
    return mass * (h*h + w*w) / 12;
};

/**
 * @method updateBoundingRadius
 */
Capsule.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.radius + this.length/2;
};

/**
 * @method updateArea
 */
Capsule.prototype.updateArea = function(){
    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
};

var r = vec2.create();

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Capsule.prototype.computeAABB = function(out, position, angle){
    var radius = this.radius;

    // Compute center position of one of the the circles, world oriented, but with local offset
    vec2.set(r,this.length / 2,0);
    if(angle !== 0){
        vec2.rotate(r,r,angle);
    }

    // Get bounds
    vec2.set(out.upperBound,  Math.max(r[0]+radius, -r[0]+radius),
                              Math.max(r[1]+radius, -r[1]+radius));
    vec2.set(out.lowerBound,  Math.min(r[0]-radius, -r[0]-radius),
                              Math.min(r[1]-radius, -r[1]-radius));

    // Add offset
    vec2.add(out.lowerBound, out.lowerBound, position);
    vec2.add(out.upperBound, out.upperBound, position);
};

},{"../math/vec2":31,"./Shape":45}],38:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,    vec2 = _dereq_('../math/vec2');

module.exports = Circle;

/**
 * Circle shape class.
 * @class Circle
 * @extends Shape
 * @constructor
 * @param {number} [radius=1] The radius of this circle
 *
 * @example
 *     var radius = 1;
 *     var circleShape = new Circle(radius);
 *     body.addShape(circleShape);
 */
function Circle(radius){

    /**
     * The radius of the circle.
     * @property radius
     * @type {number}
     */
    this.radius = radius || 1;

    Shape.call(this,Shape.CIRCLE);
}
Circle.prototype = new Shape();
Circle.prototype.constructor = Circle;

/**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Circle.prototype.computeMomentOfInertia = function(mass){
    var r = this.radius;
    return mass * r * r / 2;
};

/**
 * @method updateBoundingRadius
 * @return {Number}
 */
Circle.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.radius;
};

/**
 * @method updateArea
 * @return {Number}
 */
Circle.prototype.updateArea = function(){
    this.area = Math.PI * this.radius * this.radius;
};

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Circle.prototype.computeAABB = function(out, position, angle){
    var r = this.radius;
    vec2.set(out.upperBound,  r,  r);
    vec2.set(out.lowerBound, -r, -r);
    if(position){
        vec2.add(out.lowerBound, out.lowerBound, position);
        vec2.add(out.upperBound, out.upperBound, position);
    }
};

},{"../math/vec2":31,"./Shape":45}],39:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2')
,   polyk = _dereq_('../math/polyk')
,   decomp = _dereq_('poly-decomp');

module.exports = Convex;

/**
 * Convex shape class.
 * @class Convex
 * @constructor
 * @extends Shape
 * @param {Array} vertices An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.
 * @param {Array} [axes] An array of unit length vectors, representing the symmetry axes in the convex.
 * @example
 *     // Create a box
 *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];
 *     var convexShape = new Convex(vertices);
 *     body.addShape(convexShape);
 */
function Convex(vertices, axes){

    /**
     * Vertices defined in the local frame.
     * @property vertices
     * @type {Array}
     */
    this.vertices = [];

    /**
     * Axes defined in the local frame.
     * @property axes
     * @type {Array}
     */
    this.axes = [];

    // Copy the verts
    for(var i=0; i<vertices.length; i++){
        var v = vec2.create();
        vec2.copy(v,vertices[i]);
        this.vertices.push(v);
    }

    if(axes){
        // Copy the axes
        for(var i=0; i < axes.length; i++){
            var axis = vec2.create();
            vec2.copy(axis, axes[i]);
            this.axes.push(axis);
        }
    } else {
        // Construct axes from the vertex data
        for(var i = 0; i < vertices.length; i++){
            // Get the world edge
            var worldPoint0 = vertices[i];
            var worldPoint1 = vertices[(i+1) % vertices.length];

            var normal = vec2.create();
            vec2.sub(normal, worldPoint1, worldPoint0);

            // Get normal - just rotate 90 degrees since vertices are given in CCW
            vec2.rotate90cw(normal, normal);
            vec2.normalize(normal, normal);

            this.axes.push(normal);
        }
    }

    /**
     * The center of mass of the Convex
     * @property centerOfMass
     * @type {Array}
     */
    this.centerOfMass = vec2.fromValues(0,0);

    /**
     * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.
     * @property triangles
     * @type {Array}
     */
    this.triangles = [];

    if(this.vertices.length){
        this.updateTriangles();
        this.updateCenterOfMass();
    }

    /**
     * The bounding radius of the convex
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    Shape.call(this, Shape.CONVEX);

    this.updateBoundingRadius();
    this.updateArea();
    if(this.area < 0){
        throw new Error("Convex vertices must be given in conter-clockwise winding.");
    }
}
Convex.prototype = new Shape();
Convex.prototype.constructor = Convex;

var tmpVec1 = vec2.create();
var tmpVec2 = vec2.create();

/**
 * Project a Convex onto a world-oriented axis
 * @method projectOntoAxis
 * @static
 * @param  {Array} offset
 * @param  {Array} localAxis
 * @param  {Array} result
 */
Convex.prototype.projectOntoLocalAxis = function(localAxis, result){
    var max=null,
        min=null,
        v,
        value,
        localAxis = tmpVec1;

    // Get projected position of all vertices
    for(var i=0; i<this.vertices.length; i++){
        v = this.vertices[i];
        value = vec2.dot(v, localAxis);
        if(max === null || value > max){
            max = value;
        }
        if(min === null || value < min){
            min = value;
        }
    }

    if(min > max){
        var t = min;
        min = max;
        max = t;
    }

    vec2.set(result, min, max);
};

Convex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result){
    var worldAxis = tmpVec2;

    this.projectOntoLocalAxis(localAxis, result);

    // Project the position of the body onto the axis - need to add this to the result
    if(shapeAngle !== 0){
        vec2.rotate(worldAxis, localAxis, shapeAngle);
    } else {
        worldAxis = localAxis;
    }
    var offset = vec2.dot(shapeOffset, worldAxis);

    vec2.set(result, result[0] + offset, result[1] + offset);
};


/**
 * Update the .triangles property
 * @method updateTriangles
 */
Convex.prototype.updateTriangles = function(){

    this.triangles.length = 0;

    // Rewrite on polyk notation, array of numbers
    var polykVerts = [];
    for(var i=0; i<this.vertices.length; i++){
        var v = this.vertices[i];
        polykVerts.push(v[0],v[1]);
    }

    // Triangulate
    var triangles = polyk.Triangulate(polykVerts);

    // Loop over all triangles, add their inertia contributions to I
    for(var i=0; i<triangles.length; i+=3){
        var id1 = triangles[i],
            id2 = triangles[i+1],
            id3 = triangles[i+2];

        // Add to triangles
        this.triangles.push([id1,id2,id3]);
    }
};

var updateCenterOfMass_centroid = vec2.create(),
    updateCenterOfMass_centroid_times_mass = vec2.create(),
    updateCenterOfMass_a = vec2.create(),
    updateCenterOfMass_b = vec2.create(),
    updateCenterOfMass_c = vec2.create(),
    updateCenterOfMass_ac = vec2.create(),
    updateCenterOfMass_ca = vec2.create(),
    updateCenterOfMass_cb = vec2.create(),
    updateCenterOfMass_n = vec2.create();

/**
 * Update the .centerOfMass property.
 * @method updateCenterOfMass
 */
Convex.prototype.updateCenterOfMass = function(){
    var triangles = this.triangles,
        verts = this.vertices,
        cm = this.centerOfMass,
        centroid = updateCenterOfMass_centroid,
        n = updateCenterOfMass_n,
        a = updateCenterOfMass_a,
        b = updateCenterOfMass_b,
        c = updateCenterOfMass_c,
        ac = updateCenterOfMass_ac,
        ca = updateCenterOfMass_ca,
        cb = updateCenterOfMass_cb,
        centroid_times_mass = updateCenterOfMass_centroid_times_mass;

    vec2.set(cm,0,0);
    var totalArea = 0;

    for(var i=0; i!==triangles.length; i++){
        var t = triangles[i],
            a = verts[t[0]],
            b = verts[t[1]],
            c = verts[t[2]];

        vec2.centroid(centroid,a,b,c);

        // Get mass for the triangle (density=1 in this case)
        // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors
        var m = Convex.triangleArea(a,b,c);
        totalArea += m;

        // Add to center of mass
        vec2.scale(centroid_times_mass, centroid, m);
        vec2.add(cm, cm, centroid_times_mass);
    }

    vec2.scale(cm,cm,1/totalArea);
};

/**
 * Compute the mass moment of inertia of the Convex.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/
 */
Convex.prototype.computeMomentOfInertia = function(mass){
    var denom = 0.0,
        numer = 0.0,
        N = this.vertices.length;
    for(var j = N-1, i = 0; i < N; j = i, i ++){
        var p0 = this.vertices[j];
        var p1 = this.vertices[i];
        var a = Math.abs(vec2.crossLength(p0,p1));
        var b = vec2.dot(p1,p1) + vec2.dot(p1,p0) + vec2.dot(p0,p0);
        denom += a * b;
        numer += a;
    }
    return (mass / 6.0) * (denom / numer);
};

/**
 * Updates the .boundingRadius property
 * @method updateBoundingRadius
 */
Convex.prototype.updateBoundingRadius = function(){
    var verts = this.vertices,
        r2 = 0;

    for(var i=0; i!==verts.length; i++){
        var l2 = vec2.squaredLength(verts[i]);
        if(l2 > r2){
            r2 = l2;
        }
    }

    this.boundingRadius = Math.sqrt(r2);
};

/**
 * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.
 * @static
 * @method triangleArea
 * @param {Array} a
 * @param {Array} b
 * @param {Array} c
 * @return {Number}
 */
Convex.triangleArea = function(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1]))) * 0.5;
};

/**
 * Update the .area
 * @method updateArea
 */
Convex.prototype.updateArea = function(){
    this.updateTriangles();
    this.area = 0;

    var triangles = this.triangles,
        verts = this.vertices;
    for(var i=0; i!==triangles.length; i++){
        var t = triangles[i],
            a = verts[t[0]],
            b = verts[t[1]],
            c = verts[t[2]];

        // Get mass for the triangle (density=1 in this case)
        var m = Convex.triangleArea(a,b,c);
        this.area += m;
    }
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Convex.prototype.computeAABB = function(out, position, angle){
    out.setFromPoints(this.vertices, position, angle, 0);
};

},{"../math/polyk":30,"../math/vec2":31,"./Shape":45,"poly-decomp":5}],40:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,    vec2 = _dereq_('../math/vec2')
,    Utils = _dereq_('../utils/Utils');

module.exports = Heightfield;

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance "elementWidth".
 * @class Heightfield
 * @extends Shape
 * @constructor
 * @param {Array} data An array of Y values that will be used to construct the terrain.
 * @param {object} options
 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
 * @param {Number} [options.maxValue] Maximum value.
 * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.
 * @todo Should be possible to use along all axes, not just y
 *
 * @example
 *     // Generate some height data (y-values).
 *     var data = [];
 *     for(var i = 0; i < 1000; i++){
 *         var y = 0.5 * Math.cos(0.2 * i);
 *         data.push(y);
 *     }
 *
 *     // Create the heightfield shape
 *     var heightfieldShape = new Heightfield(data, {
 *         elementWidth: 1 // Distance between the data points in X direction
 *     });
 *     var heightfieldBody = new Body();
 *     heightfieldBody.addShape(heightfieldShape);
 *     world.addBody(heightfieldBody);
 */
function Heightfield(data, options){
    options = Utils.defaults(options, {
        maxValue : null,
        minValue : null,
        elementWidth : 0.1
    });

    if(options.minValue === null || options.maxValue === null){
        options.maxValue = data[0];
        options.minValue = data[0];
        for(var i=0; i !== data.length; i++){
            var v = data[i];
            if(v > options.maxValue){
                options.maxValue = v;
            }
            if(v < options.minValue){
                options.minValue = v;
            }
        }
    }

    /**
     * An array of numbers, or height values, that are spread out along the x axis.
     * @property {array} data
     */
    this.data = data;

    /**
     * Max value of the data
     * @property {number} maxValue
     */
    this.maxValue = options.maxValue;

    /**
     * Max value of the data
     * @property {number} minValue
     */
    this.minValue = options.minValue;

    /**
     * The width of each element
     * @property {number} elementWidth
     */
    this.elementWidth = options.elementWidth;

    Shape.call(this,Shape.HEIGHTFIELD);
}
Heightfield.prototype = new Shape();
Heightfield.prototype.constructor = Heightfield;

/**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Heightfield.prototype.computeMomentOfInertia = function(mass){
    return Number.MAX_VALUE;
};

Heightfield.prototype.updateBoundingRadius = function(){
    this.boundingRadius = Number.MAX_VALUE;
};

Heightfield.prototype.updateArea = function(){
    var data = this.data,
        area = 0;
    for(var i=0; i<data.length-1; i++){
        area += (data[i]+data[i+1]) / 2 * this.elementWidth;
    }
    this.area = area;
};

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Heightfield.prototype.computeAABB = function(out, position, angle){
    // Use the max data rectangle
    out.upperBound[0] = this.elementWidth * this.data.length + position[0];
    out.upperBound[1] = this.maxValue + position[1];
    out.lowerBound[0] = position[0];
    out.lowerBound[1] = -Number.MAX_VALUE; // Infinity
};

},{"../math/vec2":31,"../utils/Utils":50,"./Shape":45}],41:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Line;

/**
 * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
 * @class Line
 * @param {Number} [length=1] The total length of the line
 * @extends Shape
 * @constructor
 */
function Line(length){

    /**
     * Length of this line
     * @property length
     * @type {Number}
     */
    this.length = length || 1;

    Shape.call(this,Shape.LINE);
}
Line.prototype = new Shape();
Line.prototype.constructor = Line;

Line.prototype.computeMomentOfInertia = function(mass){
    return mass * Math.pow(this.length,2) / 12;
};

Line.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.length/2;
};

var points = [vec2.create(),vec2.create()];

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Line.prototype.computeAABB = function(out, position, angle){
    var l2 = this.length / 2;
    vec2.set(points[0], -l2,  0);
    vec2.set(points[1],  l2,  0);
    out.setFromPoints(points,position,angle,0);
};


},{"../math/vec2":31,"./Shape":45}],42:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Particle;

/**
 * Particle shape class.
 * @class Particle
 * @constructor
 * @extends Shape
 */
function Particle(){
    Shape.call(this,Shape.PARTICLE);
}
Particle.prototype = new Shape();
Particle.prototype.constructor = Particle;

Particle.prototype.computeMomentOfInertia = function(mass){
    return 0; // Can't rotate a particle
};

Particle.prototype.updateBoundingRadius = function(){
    this.boundingRadius = 0;
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Particle.prototype.computeAABB = function(out, position, angle){
    vec2.copy(out.lowerBound, position);
    vec2.copy(out.upperBound, position);
};

},{"../math/vec2":31,"./Shape":45}],43:[function(_dereq_,module,exports){
var Shape =  _dereq_('./Shape')
,    vec2 =  _dereq_('../math/vec2')
,    Utils = _dereq_('../utils/Utils');

module.exports = Plane;

/**
 * Plane shape class. The plane is facing in the Y direction.
 * @class Plane
 * @extends Shape
 * @constructor
 */
function Plane(){
    Shape.call(this,Shape.PLANE);
}
Plane.prototype = new Shape();
Plane.prototype.constructor = Plane;

/**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 */
Plane.prototype.computeMomentOfInertia = function(mass){
    return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here
};

/**
 * Update the bounding radius
 * @method updateBoundingRadius
 */
Plane.prototype.updateBoundingRadius = function(){
    this.boundingRadius = Number.MAX_VALUE;
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Plane.prototype.computeAABB = function(out, position, angle){
    var a = 0,
        set = vec2.set;
    if(typeof(angle) === "number"){
        a = angle % (2*Math.PI);
    }

    if(a === 0){
        // y goes from -inf to 0
        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
        set(out.upperBound,  Number.MAX_VALUE,  0);
    } else if(a === Math.PI / 2){
        // x goes from 0 to inf
        set(out.lowerBound, 0, -Number.MAX_VALUE);
        set(out.upperBound,      Number.MAX_VALUE,  Number.MAX_VALUE);
    } else if(a === Math.PI){
        // y goes from 0 to inf
        set(out.lowerBound, -Number.MAX_VALUE, 0);
        set(out.upperBound,  Number.MAX_VALUE, Number.MAX_VALUE);
    } else if(a === 3*Math.PI/2){
        // x goes from -inf to 0
        set(out.lowerBound, -Number.MAX_VALUE,     -Number.MAX_VALUE);
        set(out.upperBound,  0,  Number.MAX_VALUE);
    } else {
        // Set max bounds
        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
        set(out.upperBound,  Number.MAX_VALUE,  Number.MAX_VALUE);
    }

    vec2.add(out.lowerBound, out.lowerBound, position);
    vec2.add(out.upperBound, out.upperBound, position);
};

Plane.prototype.updateArea = function(){
    this.area = Number.MAX_VALUE;
};


},{"../math/vec2":31,"../utils/Utils":50,"./Shape":45}],44:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Shape = _dereq_('./Shape')
,   Convex = _dereq_('./Convex');

module.exports = Rectangle;

/**
 * Rectangle shape class.
 * @class Rectangle
 * @constructor
 * @param {Number} [width=1] Width
 * @param {Number} [height=1] Height
 * @extends Convex
 */
function Rectangle(width, height){

    /**
     * Total width of the rectangle
     * @property width
     * @type {Number}
     */
    this.width = width || 1;

    /**
     * Total height of the rectangle
     * @property height
     * @type {Number}
     */
    this.height = height || 1;

    var verts = [   vec2.fromValues(-width/2, -height/2),
                    vec2.fromValues( width/2, -height/2),
                    vec2.fromValues( width/2,  height/2),
                    vec2.fromValues(-width/2,  height/2)];
    var axes = [vec2.fromValues(1, 0), vec2.fromValues(0, 1)];

    Convex.call(this, verts, axes);

    this.type = Shape.RECTANGLE;
}
Rectangle.prototype = new Convex([]);
Rectangle.prototype.constructor = Rectangle;

/**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Rectangle.prototype.computeMomentOfInertia = function(mass){
    var w = this.width,
        h = this.height;
    return mass * (h*h + w*w) / 12;
};

/**
 * Update the bounding radius
 * @method updateBoundingRadius
 */
Rectangle.prototype.updateBoundingRadius = function(){
    var w = this.width,
        h = this.height;
    this.boundingRadius = Math.sqrt(w*w + h*h) / 2;
};

var corner1 = vec2.create(),
    corner2 = vec2.create(),
    corner3 = vec2.create(),
    corner4 = vec2.create();

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Rectangle.prototype.computeAABB = function(out, position, angle){
    out.setFromPoints(this.vertices,position,angle,0);
};

Rectangle.prototype.updateArea = function(){
    this.area = this.width * this.height;
};


},{"../math/vec2":31,"./Convex":39,"./Shape":45}],45:[function(_dereq_,module,exports){
module.exports = Shape;

/**
 * Base class for shapes.
 * @class Shape
 * @constructor
 * @param {Number} type
 */
function Shape(type){

    /**
     * The type of the shape. One of:
     *
     * * {{#crossLink "Shape/CIRCLE:property"}}Shape.CIRCLE{{/crossLink}}
     * * {{#crossLink "Shape/PARTICLE:property"}}Shape.PARTICLE{{/crossLink}}
     * * {{#crossLink "Shape/PLANE:property"}}Shape.PLANE{{/crossLink}}
     * * {{#crossLink "Shape/CONVEX:property"}}Shape.CONVEX{{/crossLink}}
     * * {{#crossLink "Shape/LINE:property"}}Shape.LINE{{/crossLink}}
     * * {{#crossLink "Shape/RECTANGLE:property"}}Shape.RECTANGLE{{/crossLink}}
     * * {{#crossLink "Shape/CAPSULE:property"}}Shape.CAPSULE{{/crossLink}}
     * * {{#crossLink "Shape/HEIGHTFIELD:property"}}Shape.HEIGHTFIELD{{/crossLink}}
     *
     * @property {number} type
     */
    this.type = type;

    /**
     * Shape object identifier.
     * @type {Number}
     * @property id
     */
    this.id = Shape.idCounter++;

    /**
     * Bounding circle radius of this shape
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    /**
     * Collision group that this shape belongs to (bit mask). See <a href="http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/">this tutorial</a>.
     * @property collisionGroup
     * @type {Number}
     * @example
     *     // Setup bits for each available group
     *     var PLAYER = Math.pow(2,0),
     *         ENEMY =  Math.pow(2,1),
     *         GROUND = Math.pow(2,2)
     *
     *     // Put shapes into their groups
     *     player1Shape.collisionGroup = PLAYER;
     *     player2Shape.collisionGroup = PLAYER;
     *     enemyShape  .collisionGroup = ENEMY;
     *     groundShape .collisionGroup = GROUND;
     *
     *     // Assign groups that each shape collide with.
     *     // Note that the players can collide with ground and enemies, but not with other players.
     *     player1Shape.collisionMask = ENEMY | GROUND;
     *     player2Shape.collisionMask = ENEMY | GROUND;
     *     enemyShape  .collisionMask = PLAYER | GROUND;
     *     groundShape .collisionMask = PLAYER | ENEMY;
     *
     * @example
     *     // How collision check is done
     *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){
     *         // The shapes will collide
     *     }
     */
    this.collisionGroup = 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this shape will move through other body shapes, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * Collision mask of this shape. See .collisionGroup.
     * @property collisionMask
     * @type {Number}
     */
    this.collisionMask =  1;
    if(type){
        this.updateBoundingRadius();
    }

    /**
     * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.
     * @property material
     * @type {Material}
     */
    this.material = null;

    /**
     * Area of this shape.
     * @property area
     * @type {Number}
     */
    this.area = 0;

    /**
     * Set to true if you want this shape to be a sensor. A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.
     * @property {Boolean} sensor
     */
    this.sensor = false;

    this.updateArea();
}

Shape.idCounter = 0;

/**
 * @static
 * @property {Number} CIRCLE
 */
Shape.CIRCLE =      1;

/**
 * @static
 * @property {Number} PARTICLE
 */
Shape.PARTICLE =    2;

/**
 * @static
 * @property {Number} PLANE
 */
Shape.PLANE =       4;

/**
 * @static
 * @property {Number} CONVEX
 */
Shape.CONVEX =      8;

/**
 * @static
 * @property {Number} LINE
 */
Shape.LINE =        16;

/**
 * @static
 * @property {Number} RECTANGLE
 */
Shape.RECTANGLE =   32;

/**
 * @static
 * @property {Number} CAPSULE
 */
Shape.CAPSULE =     64;

/**
 * @static
 * @property {Number} HEIGHTFIELD
 */
Shape.HEIGHTFIELD = 128;

/**
 * Should return the moment of inertia around the Z axis of the body given the total mass. See <a href="http://en.wikipedia.org/wiki/List_of_moments_of_inertia">Wikipedia's list of moments of inertia</a>.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number} If the inertia is infinity or if the object simply isn't possible to rotate, return 0.
 */
Shape.prototype.computeMomentOfInertia = function(mass){
    throw new Error("Shape.computeMomentOfInertia is not implemented in this Shape...");
};

/**
 * Returns the bounding circle radius of this shape.
 * @method updateBoundingRadius
 * @return {Number}
 */
Shape.prototype.updateBoundingRadius = function(){
    throw new Error("Shape.updateBoundingRadius is not implemented in this Shape...");
};

/**
 * Update the .area property of the shape.
 * @method updateArea
 */
Shape.prototype.updateArea = function(){
    // To be implemented in all subclasses
};

/**
 * Compute the world axis-aligned bounding box (AABB) of this shape.
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Shape.prototype.computeAABB = function(out, position, angle){
    // To be implemented in each subclass
};

},{}],46:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Solver = _dereq_('./Solver')
,   Utils = _dereq_('../utils/Utils')
,   FrictionEquation = _dereq_('../equations/FrictionEquation');

module.exports = GSSolver;

/**
 * Iterative Gauss-Seidel constraint equation solver.
 *
 * @class GSSolver
 * @constructor
 * @extends Solver
 * @param {Object} [options]
 * @param {Number} [options.iterations=10]
 * @param {Number} [options.tolerance=0]
 */
function GSSolver(options){
    Solver.call(this,options,Solver.GS);
    options = options || {};

    /**
     * The number of iterations to do when solving. More gives better results, but is more expensive.
     * @property iterations
     * @type {Number}
     */
    this.iterations = options.iterations || 10;

    /**
     * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.
     * @property tolerance
     * @type {Number}
     */
    this.tolerance = options.tolerance || 1e-10;

    this.arrayStep = 30;
    this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);
    this.Bs =     new Utils.ARRAY_TYPE(this.arrayStep);
    this.invCs =  new Utils.ARRAY_TYPE(this.arrayStep);

    /**
     * Set to true to set all right hand side terms to zero when solving. Can be handy for a few applications.
     * @property useZeroRHS
     * @type {Boolean}
     */
    this.useZeroRHS = false;

    /**
     * Number of solver iterations that are done to approximate normal forces. When these iterations are done, friction force will be computed from the contact normal forces. These friction forces will override any other friction forces set from the World for example.
     * The solver will use less iterations if the solution is below the .tolerance.
     * @property frictionIterations
     * @type {Number}
     */
    this.frictionIterations = 0;

    /**
     * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.
     * @property {Number} usedIterations
     */
    this.usedIterations = 0;
}
GSSolver.prototype = new Solver();
GSSolver.prototype.constructor = GSSolver;

function setArrayZero(array){
    var l = array.length;
    while(l--){
        array[l] = +0.0;
    }
}

/**
 * Solve the system of equations
 * @method solve
 * @param  {Number}  h       Time step
 * @param  {World}   world    World to solve
 */
GSSolver.prototype.solve = function(h, world){

    this.sortEquations();

    var iter = 0,
        maxIter = this.iterations,
        maxFrictionIter = this.frictionIterations,
        equations = this.equations,
        Neq = equations.length,
        tolSquared = Math.pow(this.tolerance*Neq, 2),
        bodies = world.bodies,
        Nbodies = world.bodies.length,
        add = vec2.add,
        set = vec2.set,
        useZeroRHS = this.useZeroRHS,
        lambda = this.lambda;

    this.usedIterations = 0;

    if(Neq){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i];

            // Update solve mass
            b.updateSolveMassProperties();
        }
    }

    // Things that does not change during iteration can be computed once
    if(lambda.length < Neq){
        lambda = this.lambda =  new Utils.ARRAY_TYPE(Neq + this.arrayStep);
        this.Bs =               new Utils.ARRAY_TYPE(Neq + this.arrayStep);
        this.invCs =            new Utils.ARRAY_TYPE(Neq + this.arrayStep);
    }
    setArrayZero(lambda);
    var invCs = this.invCs,
        Bs = this.Bs,
        lambda = this.lambda;

    for(var i=0; i!==equations.length; i++){
        var c = equations[i];
        if(c.timeStep !== h || c.needsUpdate){
            c.timeStep = h;
            c.update();
        }
        Bs[i] =     c.computeB(c.a,c.b,h);
        invCs[i] =  c.computeInvC(c.epsilon);
    }

    var q, B, c, deltalambdaTot,i,j;

    if(Neq !== 0){

        for(i=0; i!==Nbodies; i++){
            var b = bodies[i];

            // Reset vlambda
            b.resetConstraintVelocity();
        }

        if(maxFrictionIter){
            // Iterate over contact equations to get normal forces
            for(iter=0; iter!==maxFrictionIter; iter++){

                // Accumulate the total error for each iteration.
                deltalambdaTot = 0.0;

                for(j=0; j!==Neq; j++){
                    c = equations[j];

                    var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
                    deltalambdaTot += Math.abs(deltalambda);
                }

                this.usedIterations++;

                // If the total error is small enough - stop iterate
                if(deltalambdaTot*deltalambdaTot <= tolSquared){
                    break;
                }
            }

            GSSolver.updateMultipliers(equations, lambda, 1/h);

            // Set computed friction force
            for(j=0; j!==Neq; j++){
                var eq = equations[j];
                if(eq instanceof FrictionEquation){
                    var f = 0.0;
                    for(var k=0; k!==eq.contactEquations.length; k++){
                        f += eq.contactEquations[k].multiplier;
                    }
                    f *= eq.frictionCoefficient / eq.contactEquations.length;
                    eq.maxForce =  f;
                    eq.minForce = -f;
                }
            }
        }

        // Iterate over all equations
        for(iter=0; iter!==maxIter; iter++){

            // Accumulate the total error for each iteration.
            deltalambdaTot = 0.0;

            for(j=0; j!==Neq; j++){
                c = equations[j];

                var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
                deltalambdaTot += Math.abs(deltalambda);
            }

            this.usedIterations++;

            // If the total error is small enough - stop iterate
            if(deltalambdaTot*deltalambdaTot <= tolSquared){
                break;
            }
        }

        // Add result to velocity
        for(i=0; i!==Nbodies; i++){
            bodies[i].addConstraintVelocity();
        }

        GSSolver.updateMultipliers(equations, lambda, 1/h);
    }
};

// Sets the .multiplier property of each equation
GSSolver.updateMultipliers = function(equations, lambda, invDt){
    // Set the .multiplier property of each equation
    var l = equations.length;
    while(l--){
        equations[l].multiplier = lambda[l] * invDt;
    }
};

GSSolver.iterateEquation = function(j,eq,eps,Bs,invCs,lambda,useZeroRHS,dt,iter){
    // Compute iteration
    var B = Bs[j],
        invC = invCs[j],
        lambdaj = lambda[j],
        GWlambda = eq.computeGWlambda();

    var maxForce = eq.maxForce,
        minForce = eq.minForce;

    if(useZeroRHS){
        B = 0;
    }

    var deltalambda = invC * ( B - GWlambda - eps * lambdaj );

    // Clamp if we are not within the min/max interval
    var lambdaj_plus_deltalambda = lambdaj + deltalambda;
    if(lambdaj_plus_deltalambda < minForce*dt){
        deltalambda = minForce*dt - lambdaj;
    } else if(lambdaj_plus_deltalambda > maxForce*dt){
        deltalambda = maxForce*dt - lambdaj;
    }
    lambda[j] += deltalambda;
    eq.addToWlambda(deltalambda);

    return deltalambda;
};

},{"../equations/FrictionEquation":24,"../math/vec2":31,"../utils/Utils":50,"./Solver":47}],47:[function(_dereq_,module,exports){
var Utils = _dereq_('../utils/Utils')
,   EventEmitter = _dereq_('../events/EventEmitter');

module.exports = Solver;

/**
 * Base class for constraint solvers.
 * @class Solver
 * @constructor
 * @extends EventEmitter
 */
function Solver(options,type){
    options = options || {};

    EventEmitter.call(this);

    this.type = type;

    /**
     * Current equations in the solver.
     *
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * Function that is used to sort all equations before each solve.
     * @property equationSortFunction
     * @type {function|boolean}
     */
    this.equationSortFunction = options.equationSortFunction || false;
}
Solver.prototype = new EventEmitter();
Solver.prototype.constructor = Solver;

/**
 * Method to be implemented in each subclass
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
Solver.prototype.solve = function(dt,world){
    throw new Error("Solver.solve should be implemented by subclasses!");
};

var mockWorld = {bodies:[]};

/**
 * Solves all constraints in an island.
 * @method solveIsland
 * @param  {Number} dt
 * @param  {Island} island
 */
Solver.prototype.solveIsland = function(dt,island){

    this.removeAllEquations();

    if(island.equations.length){
        // Add equations to solver
        this.addEquations(island.equations);
        mockWorld.bodies.length = 0;
        island.getBodies(mockWorld.bodies);

        // Solve
        if(mockWorld.bodies.length){
            this.solve(dt,mockWorld);
        }
    }
};

/**
 * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.
 * @method sortEquations
 */
Solver.prototype.sortEquations = function(){
    if(this.equationSortFunction){
        this.equations.sort(this.equationSortFunction);
    }
};

/**
 * Add an equation to be solved.
 *
 * @method addEquation
 * @param {Equation} eq
 */
Solver.prototype.addEquation = function(eq){
    if(eq.enabled){
        this.equations.push(eq);
    }
};

/**
 * Add equations. Same as .addEquation, but this time the argument is an array of Equations
 *
 * @method addEquations
 * @param {Array} eqs
 */
Solver.prototype.addEquations = function(eqs){
    //Utils.appendArray(this.equations,eqs);
    for(var i=0, N=eqs.length; i!==N; i++){
        var eq = eqs[i];
        if(eq.enabled){
            this.equations.push(eq);
        }
    }
};

/**
 * Remove an equation.
 *
 * @method removeEquation
 * @param {Equation} eq
 */
Solver.prototype.removeEquation = function(eq){
    var i = this.equations.indexOf(eq);
    if(i !== -1){
        this.equations.splice(i,1);
    }
};

/**
 * Remove all currently added equations.
 *
 * @method removeAllEquations
 */
Solver.prototype.removeAllEquations = function(){
    this.equations.length=0;
};

Solver.GS = 1;
Solver.ISLAND = 2;

},{"../events/EventEmitter":27,"../utils/Utils":50}],48:[function(_dereq_,module,exports){
var TupleDictionary = _dereq_('./TupleDictionary');
var Utils = _dereq_('./Utils');

module.exports = OverlapKeeper;

/**
 * Keeps track of overlaps in the current state and the last step state.
 * @class OverlapKeeper
 * @constructor
 */
function OverlapKeeper() {
    this.overlappingShapesLastState = new TupleDictionary();
    this.overlappingShapesCurrentState = new TupleDictionary();
    this.recordPool = [];
    this.tmpDict = new TupleDictionary();
    this.tmpArray1 = [];
}

/**
 * Ticks one step forward in time. This will move the current overlap state to the "old" overlap state, and create a new one as current.
 * @method tick
 */
OverlapKeeper.prototype.tick = function() {
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;

    // Save old objects into pool
    var l = last.keys.length;
    while(l--){
        var key = last.keys[l];
        var lastObject = last.getByKey(key);
        var currentObject = current.getByKey(key);
        if(lastObject && !currentObject){
            // The record is only used in the "last" dict, and will be removed. We might as well pool it.
            this.recordPool.push(lastObject);
        }
    }

    // Clear last object
    last.reset();

    // Transfer from new object to old
    last.copy(current);

    // Clear current object
    current.reset();
};

/**
 * @method setOverlapping
 * @param {Body} bodyA
 * @param {Body} shapeA
 * @param {Body} bodyB
 * @param {Body} shapeB
 */
OverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;

    // Store current contact state
    if(!current.get(shapeA.id, shapeB.id)){

        var data;
        if(this.recordPool.length){
            data = this.recordPool.pop();
            data.set(bodyA, shapeA, bodyB, shapeB);
        } else {
            data = new OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB);
        }

        current.set(shapeA.id, shapeB.id, data);
    }
};

OverlapKeeper.prototype.getNewOverlaps = function(result){
    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
};

OverlapKeeper.prototype.getEndOverlaps = function(result){
    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
};

/**
 * Checks if two bodies are currently overlapping.
 * @method bodiesAreOverlapping
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {boolean}
 */
OverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB){
    var current = this.overlappingShapesCurrentState;
    var l = current.keys.length;
    while(l--){
        var key = current.keys[l];
        var data = current.data[key];
        if((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA){
            return true;
        }
    }
    return false;
};

OverlapKeeper.prototype.getDiff = function(dictA, dictB, result){
    var result = result || [];
    var last = dictA;
    var current = dictB;

    result.length = 0;

    var l = current.keys.length;
    while(l--){
        var key = current.keys[l];
        var data = current.data[key];

        if(!data){
            throw new Error('Key '+key+' had no data!');
        }

        var lastData = last.data[key];
        if(!lastData){
            // Not overlapping in last state, but in current.
            result.push(data);
        }
    }

    return result;
};

OverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB){
    var idA = shapeA.id|0,
        idB = shapeB.id|0;
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;
    // Not in last but in new
    return !!!last.get(idA, idB) && !!current.get(idA, idB);
};

OverlapKeeper.prototype.getNewBodyOverlaps = function(result){
    this.tmpArray1.length = 0;
    var overlaps = this.getNewOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
};

OverlapKeeper.prototype.getEndBodyOverlaps = function(result){
    this.tmpArray1.length = 0;
    var overlaps = this.getEndOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
};

OverlapKeeper.prototype.getBodyDiff = function(overlaps, result){
    result = result || [];
    var accumulator = this.tmpDict;

    var l = overlaps.length;

    while(l--){
        var data = overlaps[l];

        // Since we use body id's for the accumulator, these will be a subset of the original one
        accumulator.set(data.bodyA.id|0, data.bodyB.id|0, data);
    }

    l = accumulator.keys.length;
    while(l--){
        var data = accumulator.getByKey(accumulator.keys[l]);
        if(data){
            result.push(data.bodyA, data.bodyB);
        }
    }

    accumulator.reset();

    return result;
};

/**
 * Overlap data container for the OverlapKeeper
 * @class OverlapKeeperRecord
 * @constructor
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */
function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB){
    /**
     * @property {Shape} shapeA
     */
    this.shapeA = shapeA;
    /**
     * @property {Shape} shapeB
     */
    this.shapeB = shapeB;
    /**
     * @property {Body} bodyA
     */
    this.bodyA = bodyA;
    /**
     * @property {Body} bodyB
     */
    this.bodyB = bodyB;
}

/**
 * Set the data for the record
 * @method set
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */
OverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB){
    OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);
};

},{"./TupleDictionary":49,"./Utils":50}],49:[function(_dereq_,module,exports){
var Utils = _dereq_('./Utils');

module.exports = TupleDictionary;

/**
 * @class TupleDictionary
 * @constructor
 */
function TupleDictionary() {

    /**
     * The data storage
     * @property data
     * @type {Object}
     */
    this.data = {};

    /**
     * Keys that are currently used.
     * @property {Array} keys
     */
    this.keys = [];
}

/**
 * Generate a key given two integers
 * @method getKey
 * @param  {number} i
 * @param  {number} j
 * @return {string}
 */
TupleDictionary.prototype.getKey = function(id1, id2) {
    id1 = id1|0;
    id2 = id2|0;

    if ( (id1|0) === (id2|0) ){
        return -1;
    }

    // valid for values < 2^16
    return ((id1|0) > (id2|0) ?
        (id1 << 16) | (id2 & 0xFFFF) :
        (id2 << 16) | (id1 & 0xFFFF))|0
        ;
};

/**
 * @method getByKey
 * @param  {Number} key
 * @return {Object}
 */
TupleDictionary.prototype.getByKey = function(key) {
    key = key|0;
    return this.data[key];
};

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
TupleDictionary.prototype.get = function(i, j) {
    return this.data[this.getKey(i, j)];
};

/**
 * Set a value.
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
TupleDictionary.prototype.set = function(i, j, value) {
    if(!value){
        throw new Error("No data!");
    }

    var key = this.getKey(i, j);

    // Check if key already exists
    if(!this.data[key]){
        this.keys.push(key);
    }

    this.data[key] = value;

    return key;
};

/**
 * Remove all data.
 * @method reset
 */
TupleDictionary.prototype.reset = function() {
    var data = this.data,
        keys = this.keys;

    var l = keys.length;
    while(l--) {
        delete data[keys[l]];
    }

    keys.length = 0;
};

/**
 * Copy another TupleDictionary. Note that all data in this dictionary will be removed.
 * @method copy
 * @param {TupleDictionary} dict The TupleDictionary to copy into this one.
 */
TupleDictionary.prototype.copy = function(dict) {
    this.reset();
    Utils.appendArray(this.keys, dict.keys);
    var l = dict.keys.length;
    while(l--){
        var key = dict.keys[l];
        this.data[key] = dict.data[key];
    }
};

},{"./Utils":50}],50:[function(_dereq_,module,exports){
/* global P2_ARRAY_TYPE */

module.exports = Utils;

/**
 * Misc utility functions
 * @class Utils
 * @constructor
 */
function Utils(){}

/**
 * Append the values in array b to the array a. See <a href="http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131">this</a> for an explanation.
 * @method appendArray
 * @static
 * @param  {Array} a
 * @param  {Array} b
 */
Utils.appendArray = function(a,b){
    if (b.length < 150000) {
        a.push.apply(a, b);
    } else {
        for (var i = 0, len = b.length; i !== len; ++i) {
            a.push(b[i]);
        }
    }
};

/**
 * Garbage free Array.splice(). Does not allocate a new array.
 * @method splice
 * @static
 * @param  {Array} array
 * @param  {Number} index
 * @param  {Number} howmany
 */
Utils.splice = function(array,index,howmany){
    howmany = howmany || 1;
    for (var i=index, len=array.length-howmany; i < len; i++){
        array[i] = array[i + howmany];
    }
    array.length = len;
};

/**
 * The array type to use for internal numeric computations throughout the library. Float32Array is used if it is available, but falls back on Array. If you want to set array type manually, inject it via the global variable P2_ARRAY_TYPE. See example below.
 * @static
 * @property {function} ARRAY_TYPE
 * @example
 *     <script>
 *         <!-- Inject your preferred array type before loading p2.js -->
 *         P2_ARRAY_TYPE = Array;
 *     </script>
 *     <script src="p2.js"></script>
 */
if(typeof P2_ARRAY_TYPE !== 'undefined') {
    Utils.ARRAY_TYPE = P2_ARRAY_TYPE;
} else if (typeof Float32Array !== 'undefined'){
    Utils.ARRAY_TYPE = Float32Array;
} else {
    Utils.ARRAY_TYPE = Array;
}

/**
 * Extend an object with the properties of another
 * @static
 * @method extend
 * @param  {object} a
 * @param  {object} b
 */
Utils.extend = function(a,b){
    for(var key in b){
        a[key] = b[key];
    }
};

/**
 * Extend an options object with default values.
 * @static
 * @method defaults
 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
 * @param  {object} defaults An object containing default values.
 * @return {object} The modified options object.
 */
Utils.defaults = function(options, defaults){
    options = options || {};
    for(var key in defaults){
        if(!(key in options)){
            options[key] = defaults[key];
        }
    }
    return options;
};

},{}],51:[function(_dereq_,module,exports){
var Body = _dereq_('../objects/Body');

module.exports = Island;

/**
 * An island of bodies connected with equations.
 * @class Island
 * @constructor
 */
function Island(){

    /**
     * Current equations in this island.
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * Current bodies in this island.
     * @property bodies
     * @type {Array}
     */
    this.bodies = [];
}

/**
 * Clean this island from bodies and equations.
 * @method reset
 */
Island.prototype.reset = function(){
    this.equations.length = this.bodies.length = 0;
};

var bodyIds = [];

/**
 * Get all unique bodies in this island.
 * @method getBodies
 * @return {Array} An array of Body
 */
Island.prototype.getBodies = function(result){
    var bodies = result || [],
        eqs = this.equations;
    bodyIds.length = 0;
    for(var i=0; i!==eqs.length; i++){
        var eq = eqs[i];
        if(bodyIds.indexOf(eq.bodyA.id)===-1){
            bodies.push(eq.bodyA);
            bodyIds.push(eq.bodyA.id);
        }
        if(bodyIds.indexOf(eq.bodyB.id)===-1){
            bodies.push(eq.bodyB);
            bodyIds.push(eq.bodyB.id);
        }
    }
    return bodies;
};

/**
 * Check if the entire island wants to sleep.
 * @method wantsToSleep
 * @return {Boolean}
 */
Island.prototype.wantsToSleep = function(){
    for(var i=0; i<this.bodies.length; i++){
        var b = this.bodies[i];
        if(b.type === Body.DYNAMIC && !b.wantsToSleep){
            return false;
        }
    }
    return true;
};

/**
 * Make all bodies in the island sleep.
 * @method sleep
 */
Island.prototype.sleep = function(){
    for(var i=0; i<this.bodies.length; i++){
        var b = this.bodies[i];
        b.sleep();
    }
    return true;
};

},{"../objects/Body":32}],52:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Island = _dereq_('./Island')
,   IslandNode = _dereq_('./IslandNode')
,   Body = _dereq_('../objects/Body');

module.exports = IslandManager;

/**
 * Splits the system of bodies and equations into independent islands
 *
 * @class IslandManager
 * @constructor
 * @param {Object} [options]
 * @extends Solver
 */
function IslandManager(options){

    // Pooling of node objects saves some GC load
    this._nodePool = [];
    this._islandPool = [];

    /**
     * The equations to split. Manually fill this array before running .split().
     * @property {Array} equations
     */
    this.equations = [];

    /**
     * The resulting {{#crossLink "Island"}}{{/crossLink}}s.
     * @property {Array} islands
     */
    this.islands = [];

    /**
     * The resulting graph nodes.
     * @property {Array} nodes
     */
    this.nodes = [];

    /**
     * The node queue, used when traversing the graph of nodes.
     * @private
     * @property {Array} queue
     */
    this.queue = [];
}

/**
 * Get an unvisited node from a list of nodes.
 * @static
 * @method getUnvisitedNode
 * @param  {Array} nodes
 * @return {IslandNode|boolean} The node if found, else false.
 */
IslandManager.getUnvisitedNode = function(nodes){
    var Nnodes = nodes.length;
    for(var i=0; i!==Nnodes; i++){
        var node = nodes[i];
        if(!node.visited && node.body.type === Body.DYNAMIC){
            return node;
        }
    }
    return false;
};

/**
 * Visit a node.
 * @method visit
 * @param  {IslandNode} node
 * @param  {Array} bds
 * @param  {Array} eqs
 */
IslandManager.prototype.visit = function (node,bds,eqs){
    bds.push(node.body);
    var Neqs = node.equations.length;
    for(var i=0; i!==Neqs; i++){
        var eq = node.equations[i];
        if(eqs.indexOf(eq) === -1){ // Already added?
            eqs.push(eq);
        }
    }
};

/**
 * Runs the search algorithm, starting at a root node. The resulting bodies and equations will be stored in the provided arrays.
 * @method bfs
 * @param  {IslandNode} root The node to start from
 * @param  {Array} bds  An array to append resulting Bodies to.
 * @param  {Array} eqs  An array to append resulting Equations to.
 */
IslandManager.prototype.bfs = function(root,bds,eqs){

    // Reset the visit queue
    var queue = this.queue;
    queue.length = 0;

    // Add root node to queue
    queue.push(root);
    root.visited = true;
    this.visit(root,bds,eqs);

    // Process all queued nodes
    while(queue.length) {

        // Get next node in the queue
        var node = queue.pop();

        // Visit unvisited neighboring nodes
        var child;
        while((child = IslandManager.getUnvisitedNode(node.neighbors))) {
            child.visited = true;
            this.visit(child,bds,eqs);

            // Only visit the children of this node if it's dynamic
            if(child.body.type === Body.DYNAMIC){
                queue.push(child);
            }
        }
    }
};

/**
 * Split the world into independent islands. The result is stored in .islands.
 * @method split
 * @param  {World} world
 * @return {Array} The generated islands
 */
IslandManager.prototype.split = function(world){
    var bodies = world.bodies,
        nodes = this.nodes,
        equations = this.equations;

    // Move old nodes to the node pool
    while(nodes.length){
        this._nodePool.push(nodes.pop());
    }

    // Create needed nodes, reuse if possible
    for(var i=0; i!==bodies.length; i++){
        if(this._nodePool.length){
            var node = this._nodePool.pop();
            node.reset();
            node.body = bodies[i];
            nodes.push(node);
        } else {
            nodes.push(new IslandNode(bodies[i]));
        }
    }

    // Add connectivity data. Each equation connects 2 bodies.
    for(var k=0; k!==equations.length; k++){
        var eq=equations[k],
            i=bodies.indexOf(eq.bodyA),
            j=bodies.indexOf(eq.bodyB),
            ni=nodes[i],
            nj=nodes[j];
        ni.neighbors.push(nj);
        nj.neighbors.push(ni);
        ni.equations.push(eq);
        nj.equations.push(eq);
    }

    // Move old islands to the island pool
    var islands = this.islands;
    while(islands.length){
        var island = islands.pop();
        island.reset();
        this._islandPool.push(island);
    }

    // Get islands
    var child;
    while((child = IslandManager.getUnvisitedNode(nodes))){

        // Create new island
        var island = this._islandPool.length ? this._islandPool.pop() : new Island();

        // Get all equations and bodies in this island
        this.bfs(child, island.bodies, island.equations);

        islands.push(island);
    }

    return islands;
};

},{"../math/vec2":31,"../objects/Body":32,"./Island":51,"./IslandNode":53}],53:[function(_dereq_,module,exports){
module.exports = IslandNode;

/**
 * Holds a body and keeps track of some additional properties needed for graph traversal.
 * @class IslandNode
 * @constructor
 * @param {Body} body
 */
function IslandNode(body){

	/**
	 * The body that is contained in this node.
	 * @property {Body} body
	 */
    this.body = body;

    /**
     * Neighboring IslandNodes
     * @property {Array} neighbors
     */
    this.neighbors = [];

    /**
     * Equations connected to this node.
     * @property {Array} equations
     */
    this.equations = [];

    /**
     * If this node was visiting during the graph traversal.
     * @property visited
     * @type {Boolean}
     */
    this.visited = false;
}

/**
 * Clean this node from bodies and equations.
 * @method reset
 */
IslandNode.prototype.reset = function(){
    this.equations.length = 0;
    this.neighbors.length = 0;
    this.visited = false;
    this.body = null;
};

},{}],54:[function(_dereq_,module,exports){
/* global performance */
/*jshint -W020 */

var  GSSolver = _dereq_('../solver/GSSolver')
,    Solver = _dereq_('../solver/Solver')
,    NaiveBroadphase = _dereq_('../collision/NaiveBroadphase')
,    Ray = _dereq_('../collision/Ray')
,    vec2 = _dereq_('../math/vec2')
,    Circle = _dereq_('../shapes/Circle')
,    Rectangle = _dereq_('../shapes/Rectangle')
,    Convex = _dereq_('../shapes/Convex')
,    Line = _dereq_('../shapes/Line')
,    Plane = _dereq_('../shapes/Plane')
,    Capsule = _dereq_('../shapes/Capsule')
,    Particle = _dereq_('../shapes/Particle')
,    EventEmitter = _dereq_('../events/EventEmitter')
,    Body = _dereq_('../objects/Body')
,    Shape = _dereq_('../shapes/Shape')
,    LinearSpring = _dereq_('../objects/LinearSpring')
,    Material = _dereq_('../material/Material')
,    ContactMaterial = _dereq_('../material/ContactMaterial')
,    DistanceConstraint = _dereq_('../constraints/DistanceConstraint')
,    Constraint = _dereq_('../constraints/Constraint')
,    LockConstraint = _dereq_('../constraints/LockConstraint')
,    RevoluteConstraint = _dereq_('../constraints/RevoluteConstraint')
,    PrismaticConstraint = _dereq_('../constraints/PrismaticConstraint')
,    GearConstraint = _dereq_('../constraints/GearConstraint')
,    pkg = _dereq_('../../package.json')
,    Broadphase = _dereq_('../collision/Broadphase')
,    SAPBroadphase = _dereq_('../collision/SAPBroadphase')
,    Narrowphase = _dereq_('../collision/Narrowphase')
,    Utils = _dereq_('../utils/Utils')
,    OverlapKeeper = _dereq_('../utils/OverlapKeeper')
,    IslandManager = _dereq_('./IslandManager')
,    RotationalSpring = _dereq_('../objects/RotationalSpring');

module.exports = World;

if(typeof performance === 'undefined'){
    performance = {};
}
if(!performance.now){
    var nowOffset = Date.now();
    if (performance.timing && performance.timing.navigationStart){
        nowOffset = performance.timing.navigationStart;
    }
    performance.now = function(){
        return Date.now() - nowOffset;
    };
}

/**
 * The dynamics world, where all bodies and constraints lives.
 *
 * @class World
 * @constructor
 * @param {Object}          [options]
 * @param {Solver}          [options.solver]            Defaults to GSSolver.
 * @param {Array}           [options.gravity]           Defaults to [0,-9.78]
 * @param {Broadphase}      [options.broadphase]        Defaults to NaiveBroadphase
 * @param {Boolean}         [options.islandSplit=false]
 * @param {Boolean}         [options.doProfiling=false]
 * @extends EventEmitter
 *
 * @example
 *     var world = new World({
 *         gravity: [0, -9.81],
 *         broadphase: new SAPBroadphase()
 *     });
 */
function World(options){
    EventEmitter.apply(this);

    options = options || {};

    /**
     * All springs in the world. To add a spring to the world, use {{#crossLink "World/addSpring:method"}}{{/crossLink}}.
     *
     * @property springs
     * @type {Array}
     */
    this.springs = [];

    /**
     * All bodies in the world. To add a body to the world, use {{#crossLink "World/addBody:method"}}{{/crossLink}}.
     * @property {Array} bodies
     */
    this.bodies = [];

    /**
     * Disabled body collision pairs. See {{#crossLink "World/disableBodyCollision:method"}}.
     * @private
     * @property {Array} disabledBodyCollisionPairs
     */
    this.disabledBodyCollisionPairs = [];

    /**
     * The solver used to satisfy constraints and contacts. Default is {{#crossLink "GSSolver"}}{{/crossLink}}.
     * @property {Solver} solver
     */
    this.solver = options.solver || new GSSolver();

    /**
     * The narrowphase to use to generate contacts.
     *
     * @property narrowphase
     * @type {Narrowphase}
     */
    this.narrowphase = new Narrowphase(this);

    /**
     * The island manager of this world.
     * @property {IslandManager} islandManager
     */
    this.islandManager = new IslandManager();

    /**
     * Gravity in the world. This is applied on all bodies in the beginning of each step().
     *
     * @property gravity
     * @type {Array}
     */
    this.gravity = vec2.fromValues(0, -9.78);
    if(options.gravity){
        vec2.copy(this.gravity, options.gravity);
    }

    /**
     * Gravity to use when approximating the friction max force (mu*mass*gravity).
     * @property {Number} frictionGravity
     */
    this.frictionGravity = vec2.length(this.gravity) || 10;

    /**
     * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.
     * @property {Boolean} useWorldGravityAsFrictionGravity
     */
    this.useWorldGravityAsFrictionGravity = true;

    /**
     * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.
     * @property {Boolean} useFrictionGravityOnZeroGravity
     */
    this.useFrictionGravityOnZeroGravity = true;

    /**
     * Whether to do timing measurements during the step() or not.
     *
     * @property doPofiling
     * @type {Boolean}
     */
    this.doProfiling = options.doProfiling || false;

    /**
     * How many millisecconds the last step() took. This is updated each step if .doProfiling is set to true.
     *
     * @property lastStepTime
     * @type {Number}
     */
    this.lastStepTime = 0.0;

    /**
     * The broadphase algorithm to use.
     *
     * @property broadphase
     * @type {Broadphase}
     */
    this.broadphase = options.broadphase || new SAPBroadphase();
    this.broadphase.setWorld(this);

    /**
     * User-added constraints.
     *
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    /**
     * Dummy default material in the world, used in .defaultContactMaterial
     * @property {Material} defaultMaterial
     */
    this.defaultMaterial = new Material();

    /**
     * The default contact material to use, if no contact material was set for the colliding materials.
     * @property {ContactMaterial} defaultContactMaterial
     */
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial,this.defaultMaterial);

    /**
     * For keeping track of what time step size we used last step
     * @property lastTimeStep
     * @type {Number}
     */
    this.lastTimeStep = 1/60;

    /**
     * Enable to automatically apply spring forces each step.
     * @property applySpringForces
     * @type {Boolean}
     */
    this.applySpringForces = true;

    /**
     * Enable to automatically apply body damping each step.
     * @property applyDamping
     * @type {Boolean}
     */
    this.applyDamping = true;

    /**
     * Enable to automatically apply gravity each step.
     * @property applyGravity
     * @type {Boolean}
     */
    this.applyGravity = true;

    /**
     * Enable/disable constraint solving in each step.
     * @property solveConstraints
     * @type {Boolean}
     */
    this.solveConstraints = true;

    /**
     * The ContactMaterials added to the World.
     * @property contactMaterials
     * @type {Array}
     */
    this.contactMaterials = [];

    /**
     * World time.
     * @property time
     * @type {Number}
     */
    this.time = 0.0;

    /**
     * Is true during the step().
     * @property {Boolean} stepping
     */
    this.stepping = false;

    /**
     * Bodies that are scheduled to be removed at the end of the step.
     * @property {Array} bodiesToBeRemoved
     * @private
     */
    this.bodiesToBeRemoved = [];

    this.fixedStepTime = 0.0;

    /**
     * Whether to enable island splitting. Island splitting can be an advantage for many things, including solver performance. See {{#crossLink "IslandManager"}}{{/crossLink}}.
     * @property {Boolean} islandSplit
     */
    this.islandSplit = typeof(options.islandSplit)!=="undefined" ? !!options.islandSplit : false;

    /**
     * Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
     * @property emitImpactEvent
     * @type {Boolean}
     */
    this.emitImpactEvent = true;

    // Id counters
    this._constraintIdCounter = 0;
    this._bodyIdCounter = 0;

    /**
     * Fired after the step().
     * @event postStep
     */
    this.postStepEvent = {
        type : "postStep",
    };

    /**
     * Fired when a body is added to the world.
     * @event addBody
     * @param {Body} body
     */
    this.addBodyEvent = {
        type : "addBody",
        body : null
    };

    /**
     * Fired when a body is removed from the world.
     * @event removeBody
     * @param {Body} body
     */
    this.removeBodyEvent = {
        type : "removeBody",
        body : null
    };

    /**
     * Fired when a spring is added to the world.
     * @event addSpring
     * @param {Spring} spring
     */
    this.addSpringEvent = {
        type : "addSpring",
        spring : null,
    };

    /**
     * Fired when a first contact is created between two bodies. This event is fired after the step has been done.
     * @event impact
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    this.impactEvent = {
        type: "impact",
        bodyA : null,
        bodyB : null,
        shapeA : null,
        shapeB : null,
        contactEquation : null,
    };

    /**
     * Fired after the Broadphase has collected collision pairs in the world.
     * Inside the event handler, you can modify the pairs array as you like, to
     * prevent collisions between objects that you don't want.
     * @event postBroadphase
     * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.
     */
    this.postBroadphaseEvent = {
        type:"postBroadphase",
        pairs:null,
    };

    /**
     * How to deactivate bodies during simulation. Possible modes are: {{#crossLink "World/NO_SLEEPING:property"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink "World/BODY_SLEEPING:property"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink "World/ISLAND_SLEEPING:property"}}World.ISLAND_SLEEPING{{/crossLink}}.
     * If sleeping is enabled, you might need to {{#crossLink "Body/wakeUp:method"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink "Body/allowSleep:property"}}Body.allowSleep{{/crossLink}}.
     * @property sleepMode
     * @type {number}
     * @default World.NO_SLEEPING
     */
    this.sleepMode = World.NO_SLEEPING;

    /**
     * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.
     * @event beginContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     * @param {Array} contactEquations
     */
    this.beginContactEvent = {
        type:"beginContact",
        shapeA : null,
        shapeB : null,
        bodyA : null,
        bodyB : null,
        contactEquations : [],
    };

    /**
     * Fired when two shapes stop overlapping, after the narrowphase (during step).
     * @event endContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     * @param {Array} contactEquations
     */
    this.endContactEvent = {
        type:"endContact",
        shapeA : null,
        shapeB : null,
        bodyA : null,
        bodyB : null,
    };

    /**
     * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.
     * @event preSolve
     * @param {Array} contactEquations  An array of contacts to be solved.
     * @param {Array} frictionEquations An array of friction equations to be solved.
     */
    this.preSolveEvent = {
        type:"preSolve",
        contactEquations:null,
        frictionEquations:null,
    };

    // For keeping track of overlapping shapes
    this.overlappingShapesLastState = { keys:[] };
    this.overlappingShapesCurrentState = { keys:[] };

    this.overlapKeeper = new OverlapKeeper();
}
World.prototype = new Object(EventEmitter.prototype);
World.prototype.constructor = World;

/**
 * Never deactivate bodies.
 * @static
 * @property {number} NO_SLEEPING
 */
World.NO_SLEEPING = 1;

/**
 * Deactivate individual bodies if they are sleepy.
 * @static
 * @property {number} BODY_SLEEPING
 */
World.BODY_SLEEPING = 2;

/**
 * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink "World/islandSplit:property"}}.islandSplit{{/crossLink}} for this to work.
 * @static
 * @property {number} ISLAND_SLEEPING
 */
World.ISLAND_SLEEPING = 4;

/**
 * Add a constraint to the simulation.
 *
 * @method addConstraint
 * @param {Constraint} c
 */
World.prototype.addConstraint = function(c){
    this.constraints.push(c);
};

/**
 * Add a ContactMaterial to the simulation.
 * @method addContactMaterial
 * @param {ContactMaterial} contactMaterial
 */
World.prototype.addContactMaterial = function(contactMaterial){
    this.contactMaterials.push(contactMaterial);
};

/**
 * Removes a contact material
 *
 * @method removeContactMaterial
 * @param {ContactMaterial} cm
 */
World.prototype.removeContactMaterial = function(cm){
    var idx = this.contactMaterials.indexOf(cm);
    if(idx!==-1){
        Utils.splice(this.contactMaterials,idx,1);
    }
};

/**
 * Get a contact material given two materials
 * @method getContactMaterial
 * @param {Material} materialA
 * @param {Material} materialB
 * @return {ContactMaterial} The matching ContactMaterial, or false on fail.
 * @todo Use faster hash map to lookup from material id's
 */
World.prototype.getContactMaterial = function(materialA,materialB){
    var cmats = this.contactMaterials;
    for(var i=0, N=cmats.length; i!==N; i++){
        var cm = cmats[i];
        if( (cm.materialA.id === materialA.id) && (cm.materialB.id === materialB.id) ||
            (cm.materialA.id === materialB.id) && (cm.materialB.id === materialA.id) ){
            return cm;
        }
    }
    return false;
};

/**
 * Removes a constraint
 *
 * @method removeConstraint
 * @param {Constraint} c
 */
World.prototype.removeConstraint = function(c){
    var idx = this.constraints.indexOf(c);
    if(idx!==-1){
        Utils.splice(this.constraints,idx,1);
    }
};

var step_r = vec2.create(),
    step_runit = vec2.create(),
    step_u = vec2.create(),
    step_f = vec2.create(),
    step_fhMinv = vec2.create(),
    step_velodt = vec2.create(),
    step_mg = vec2.create(),
    xiw = vec2.fromValues(0,0),
    xjw = vec2.fromValues(0,0),
    zero = vec2.fromValues(0,0),
    interpvelo = vec2.fromValues(0,0);

/**
 * Step the physics world forward in time.
 *
 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
 *
 * @method step
 * @param {Number} dt                       The fixed time step size to use.
 * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.
 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
 *
 * @example
 *     // fixed timestepping without interpolation
 *     var world = new World();
 *     world.step(0.01);
 *
 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
 */
World.prototype.step = function(dt,timeSinceLastCalled,maxSubSteps){
    maxSubSteps = maxSubSteps || 10;
    timeSinceLastCalled = timeSinceLastCalled || 0;

    if(timeSinceLastCalled === 0){ // Fixed, simple stepping

        this.internalStep(dt);

        // Increment time
        this.time += dt;

    } else {

        // Compute the number of fixed steps we should have taken since the last step
        var internalSteps = Math.floor( (this.time+timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
        internalSteps = Math.min(internalSteps,maxSubSteps);

        // Do some fixed steps to catch up
        var t0 = performance.now();
        for(var i=0; i!==internalSteps; i++){
            this.internalStep(dt);
            if(performance.now() - t0 > dt*1000){
                // We are slower than real-time. Better bail out.
                break;
            }
        }

        // Increment internal clock
        this.time += timeSinceLastCalled;

        // Compute "Left over" time step
        var h = this.time % dt;
        var h_div_dt = h/dt;

        for(var j=0; j!==this.bodies.length; j++){
            var b = this.bodies[j];
            if(b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING){
                // Interpolate
                vec2.sub(interpvelo, b.position, b.previousPosition);
                vec2.scale(interpvelo, interpvelo, h_div_dt);
                vec2.add(b.interpolatedPosition, b.position, interpvelo);

                b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;
            } else {
                // For static bodies, just copy. Who else will do it?
                vec2.copy(b.interpolatedPosition, b.position);
                b.interpolatedAngle = b.angle;
            }
        }
    }
};

var endOverlaps = [];

/**
 * Make a fixed step.
 * @method internalStep
 * @param  {number} dt
 * @private
 */
World.prototype.internalStep = function(dt){
    this.stepping = true;

    var that = this,
        doProfiling = this.doProfiling,
        Nsprings = this.springs.length,
        springs = this.springs,
        bodies = this.bodies,
        g = this.gravity,
        solver = this.solver,
        Nbodies = this.bodies.length,
        broadphase = this.broadphase,
        np = this.narrowphase,
        constraints = this.constraints,
        t0, t1,
        fhMinv = step_fhMinv,
        velodt = step_velodt,
        mg = step_mg,
        scale = vec2.scale,
        add = vec2.add,
        rotate = vec2.rotate,
        islandManager = this.islandManager;

    this.overlapKeeper.tick();

    this.lastTimeStep = dt;

    if(doProfiling){
        t0 = performance.now();
    }

    // Update approximate friction gravity.
    if(this.useWorldGravityAsFrictionGravity){
        var gravityLen = vec2.length(this.gravity);
        if(!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)){
            // Nonzero gravity. Use it.
            this.frictionGravity = gravityLen;
        }
    }

    // Add gravity to bodies
    if(this.applyGravity){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i],
                fi = b.force;
            if(b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING){
                continue;
            }
            vec2.scale(mg,g,b.mass*b.gravityScale); // F=m*g
            add(fi,fi,mg);
        }
    }

    // Add spring forces
    if(this.applySpringForces){
        for(var i=0; i!==Nsprings; i++){
            var s = springs[i];
            s.applyForce();
        }
    }

    if(this.applyDamping){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i];
            if(b.type === Body.DYNAMIC){
                b.applyDamping(dt);
            }
        }
    }

    // Broadphase
    var result = broadphase.getCollisionPairs(this);

    // Remove ignored collision pairs
    var ignoredPairs = this.disabledBodyCollisionPairs;
    for(var i=ignoredPairs.length-2; i>=0; i-=2){
        for(var j=result.length-2; j>=0; j-=2){
            if( (ignoredPairs[i]   === result[j] && ignoredPairs[i+1] === result[j+1]) ||
                (ignoredPairs[i+1] === result[j] && ignoredPairs[i]   === result[j+1])){
                result.splice(j,2);
            }
        }
    }

    // Remove constrained pairs with collideConnected == false
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        if(!c.collideConnected){
            for(var j=result.length-2; j>=0; j-=2){
                if( (c.bodyA === result[j] && c.bodyB === result[j+1]) ||
                    (c.bodyB === result[j] && c.bodyA === result[j+1])){
                    result.splice(j,2);
                }
            }
        }
    }

    // postBroadphase event
    this.postBroadphaseEvent.pairs = result;
    this.emit(this.postBroadphaseEvent);

    // Narrowphase
    np.reset(this);
    for(var i=0, Nresults=result.length; i!==Nresults; i+=2){
        var bi = result[i],
            bj = result[i+1];

        // Loop over all shapes of body i
        for(var k=0, Nshapesi=bi.shapes.length; k!==Nshapesi; k++){
            var si = bi.shapes[k],
                xi = bi.shapeOffsets[k],
                ai = bi.shapeAngles[k];

            // All shapes of body j
            for(var l=0, Nshapesj=bj.shapes.length; l!==Nshapesj; l++){
                var sj = bj.shapes[l],
                    xj = bj.shapeOffsets[l],
                    aj = bj.shapeAngles[l];

                var cm = this.defaultContactMaterial;
                if(si.material && sj.material){
                    var tmp = this.getContactMaterial(si.material,sj.material);
                    if(tmp){
                        cm = tmp;
                    }
                }

                this.runNarrowphase(np,bi,si,xi,ai,bj,sj,xj,aj,cm,this.frictionGravity);
            }
        }
    }

    // Wake up bodies
    for(var i=0; i!==Nbodies; i++){
        var body = bodies[i];
        if(body._wakeUpAfterNarrowphase){
            body.wakeUp();
            body._wakeUpAfterNarrowphase = false;
        }
    }

    // Emit end overlap events
    if(this.has('endContact')){
        this.overlapKeeper.getEndOverlaps(endOverlaps);
        var e = this.endContactEvent;
        var l = endOverlaps.length;
        while(l--){
            var data = endOverlaps[l];
            e.shapeA = data.shapeA;
            e.shapeB = data.shapeB;
            e.bodyA = data.bodyA;
            e.bodyB = data.bodyB;
            this.emit(e);
        }
    }

    var preSolveEvent = this.preSolveEvent;
    preSolveEvent.contactEquations = np.contactEquations;
    preSolveEvent.frictionEquations = np.frictionEquations;
    this.emit(preSolveEvent);

    // update constraint equations
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        constraints[i].update();
    }

    if(np.contactEquations.length || np.frictionEquations.length || constraints.length){
        if(this.islandSplit){
            // Split into islands
            islandManager.equations.length = 0;
            Utils.appendArray(islandManager.equations, np.contactEquations);
            Utils.appendArray(islandManager.equations, np.frictionEquations);
            for(i=0; i!==Nconstraints; i++){
                Utils.appendArray(islandManager.equations, constraints[i].equations);
            }
            islandManager.split(this);

            for(var i=0; i!==islandManager.islands.length; i++){
                var island = islandManager.islands[i];
                if(island.equations.length){
                    solver.solveIsland(dt,island);
                }
            }

        } else {

            // Add contact equations to solver
            solver.addEquations(np.contactEquations);
            solver.addEquations(np.frictionEquations);

            // Add user-defined constraint equations
            for(i=0; i!==Nconstraints; i++){
                solver.addEquations(constraints[i].equations);
            }

            if(this.solveConstraints){
                solver.solve(dt,this);
            }

            solver.removeAllEquations();
        }
    }

    // Step forward
    for(var i=0; i!==Nbodies; i++){
        var body = bodies[i];

        if(body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC){
            body.integrate(dt);
        }
    }

    // Reset force
    for(var i=0; i!==Nbodies; i++){
        bodies[i].setZeroForce();
    }

    if(doProfiling){
        t1 = performance.now();
        that.lastStepTime = t1-t0;
    }

    // Emit impact event
    if(this.emitImpactEvent && this.has('impact')){
        var ev = this.impactEvent;
        for(var i=0; i!==np.contactEquations.length; i++){
            var eq = np.contactEquations[i];
            if(eq.firstImpact){
                ev.bodyA = eq.bodyA;
                ev.bodyB = eq.bodyB;
                ev.shapeA = eq.shapeA;
                ev.shapeB = eq.shapeB;
                ev.contactEquation = eq;
                this.emit(ev);
            }
        }
    }

    // Sleeping update
    if(this.sleepMode === World.BODY_SLEEPING){
        for(i=0; i!==Nbodies; i++){
            bodies[i].sleepTick(this.time, false, dt);
        }
    } else if(this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit){

        // Tell all bodies to sleep tick but dont sleep yet
        for(i=0; i!==Nbodies; i++){
            bodies[i].sleepTick(this.time, true, dt);
        }

        // Sleep islands
        for(var i=0; i<this.islandManager.islands.length; i++){
            var island = this.islandManager.islands[i];
            if(island.wantsToSleep()){
                island.sleep();
            }
        }
    }

    this.stepping = false;

    // Remove bodies that are scheduled for removal
    if(this.bodiesToBeRemoved.length){
        for(var i=0; i!==this.bodiesToBeRemoved.length; i++){
            this.removeBody(this.bodiesToBeRemoved[i]);
        }
        this.bodiesToBeRemoved.length = 0;
    }

    this.emit(this.postStepEvent);
};

/**
 * Runs narrowphase for the shape pair i and j.
 * @method runNarrowphase
 * @param  {Narrowphase} np
 * @param  {Body} bi
 * @param  {Shape} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Shape} sj
 * @param  {Array} xj
 * @param  {Number} aj
 * @param  {Number} mu
 */
World.prototype.runNarrowphase = function(np,bi,si,xi,ai,bj,sj,xj,aj,cm,glen){

    // Check collision groups and masks
    if(!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)){
        return;
    }

    // Get world position and angle of each shape
    vec2.rotate(xiw, xi, bi.angle);
    vec2.rotate(xjw, xj, bj.angle);
    vec2.add(xiw, xiw, bi.position);
    vec2.add(xjw, xjw, bj.position);
    var aiw = ai + bi.angle;
    var ajw = aj + bj.angle;

    np.enableFriction = cm.friction > 0;
    np.frictionCoefficient = cm.friction;
    var reducedMass;
    if(bi.type === Body.STATIC || bi.type === Body.KINEMATIC){
        reducedMass = bj.mass;
    } else if(bj.type === Body.STATIC || bj.type === Body.KINEMATIC){
        reducedMass = bi.mass;
    } else {
        reducedMass = (bi.mass*bj.mass)/(bi.mass+bj.mass);
    }
    np.slipForce = cm.friction*glen*reducedMass;
    np.restitution = cm.restitution;
    np.surfaceVelocity = cm.surfaceVelocity;
    np.frictionStiffness = cm.frictionStiffness;
    np.frictionRelaxation = cm.frictionRelaxation;
    np.stiffness = cm.stiffness;
    np.relaxation = cm.relaxation;
    np.contactSkinSize = cm.contactSkinSize;
    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

    var resolver = np[si.type | sj.type],
        numContacts = 0;
    if (resolver) {
        var sensor = si.sensor || sj.sensor;
        var numFrictionBefore = np.frictionEquations.length;
        if (si.type < sj.type) {
            numContacts = resolver.call(np, bi,si,xiw,aiw, bj,sj,xjw,ajw, sensor);
        } else {
            numContacts = resolver.call(np, bj,sj,xjw,ajw, bi,si,xiw,aiw, sensor);
        }
        var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;

        if(numContacts){

            if( bi.allowSleep &&
                bi.type === Body.DYNAMIC &&
                bi.sleepState  === Body.SLEEPING &&
                bj.sleepState  === Body.AWAKE &&
                bj.type !== Body.STATIC
            ){
                var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity,2);
                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
                if(speedSquaredB >= speedLimitSquaredB*2){
                    bi._wakeUpAfterNarrowphase = true;
                }
            }

            if( bj.allowSleep &&
                bj.type === Body.DYNAMIC &&
                bj.sleepState  === Body.SLEEPING &&
                bi.sleepState  === Body.AWAKE &&
                bi.type !== Body.STATIC
            ){
                var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity,2);
                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
                if(speedSquaredA >= speedLimitSquaredA*2){
                    bj._wakeUpAfterNarrowphase = true;
                }
            }

            this.overlapKeeper.setOverlapping(bi, si, bj, sj);
            if(this.has('beginContact') && this.overlapKeeper.isNewOverlap(si, sj)){

                // Report new shape overlap
                var e = this.beginContactEvent;
                e.shapeA = si;
                e.shapeB = sj;
                e.bodyA = bi;
                e.bodyB = bj;

                // Reset contact equations
                e.contactEquations.length = 0;

                if(typeof(numContacts)==="number"){
                    for(var i=np.contactEquations.length-numContacts; i<np.contactEquations.length; i++){
                        e.contactEquations.push(np.contactEquations[i]);
                    }
                }

                this.emit(e);
            }

            // divide the max friction force by the number of contacts
            if(typeof(numContacts)==="number" && numFrictionEquations > 1){ // Why divide by 1?
                for(var i=np.frictionEquations.length-numFrictionEquations; i<np.frictionEquations.length; i++){
                    var f = np.frictionEquations[i];
                    f.setSlipForce(f.getSlipForce() / numFrictionEquations);
                }
            }
        }
    }

};

/**
 * Add a spring to the simulation
 *
 * @method addSpring
 * @param {Spring} s
 */
World.prototype.addSpring = function(s){
    this.springs.push(s);
    this.addSpringEvent.spring = s;
    this.emit(this.addSpringEvent);
};

/**
 * Remove a spring
 *
 * @method removeSpring
 * @param {Spring} s
 */
World.prototype.removeSpring = function(s){
    var idx = this.springs.indexOf(s);
    if(idx!==-1){
        Utils.splice(this.springs,idx,1);
    }
};

/**
 * Add a body to the simulation
 *
 * @method addBody
 * @param {Body} body
 *
 * @example
 *     var world = new World(),
 *         body = new Body();
 *     world.addBody(body);
 * @todo What if this is done during step?
 */
World.prototype.addBody = function(body){
    if(this.bodies.indexOf(body) === -1){
        this.bodies.push(body);
        body.world = this;
        this.addBodyEvent.body = body;
        this.emit(this.addBodyEvent);
    }
};

/**
 * Remove a body from the simulation. If this method is called during step(), the body removal is scheduled to after the step.
 *
 * @method removeBody
 * @param {Body} body
 */
World.prototype.removeBody = function(body){
    if(this.stepping){
        this.bodiesToBeRemoved.push(body);
    } else {
        body.world = null;
        var idx = this.bodies.indexOf(body);
        if(idx!==-1){
            Utils.splice(this.bodies,idx,1);
            this.removeBodyEvent.body = body;
            body.resetConstraintVelocity();
            this.emit(this.removeBodyEvent);
        }
    }
};

/**
 * Get a body by its id.
 * @method getBodyById
 * @return {Body|Boolean} The body, or false if it was not found.
 */
World.prototype.getBodyById = function(id){
    var bodies = this.bodies;
    for(var i=0; i<bodies.length; i++){
        var b = bodies[i];
        if(b.id === id){
            return b;
        }
    }
    return false;
};

/**
 * Disable collision between two bodies
 * @method disableCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
World.prototype.disableBodyCollision = function(bodyA,bodyB){
    this.disabledBodyCollisionPairs.push(bodyA,bodyB);
};

/**
 * Enable collisions between the given two bodies
 * @method enableCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
World.prototype.enableBodyCollision = function(bodyA,bodyB){
    var pairs = this.disabledBodyCollisionPairs;
    for(var i=0; i<pairs.length; i+=2){
        if((pairs[i] === bodyA && pairs[i+1] === bodyB) || (pairs[i+1] === bodyA && pairs[i] === bodyB)){
            pairs.splice(i,2);
            return;
        }
    }
};


function v2a(v){
    if(!v){
        return v;
    }
    return [v[0],v[1]];
}

function extend(a,b){
    for(var key in b){
        a[key] = b[key];
    }
}

function contactMaterialToJSON(cm){
    return {
        id : cm.id,
        materialA :             cm.materialA.id,
        materialB :             cm.materialB.id,
        friction :              cm.friction,
        restitution :           cm.restitution,
        stiffness :             cm.stiffness,
        relaxation :            cm.relaxation,
        frictionStiffness :     cm.frictionStiffness,
        frictionRelaxation :    cm.frictionRelaxation,
    };
}

/**
 * Resets the World, removes all bodies, constraints and springs.
 *
 * @method clear
 */
World.prototype.clear = function(){

    this.time = 0;
    this.fixedStepTime = 0;

    // Remove all solver equations
    if(this.solver && this.solver.equations.length){
        this.solver.removeAllEquations();
    }

    // Remove all constraints
    var cs = this.constraints;
    for(var i=cs.length-1; i>=0; i--){
        this.removeConstraint(cs[i]);
    }

    // Remove all bodies
    var bodies = this.bodies;
    for(var i=bodies.length-1; i>=0; i--){
        this.removeBody(bodies[i]);
    }

    // Remove all springs
    var springs = this.springs;
    for(var i=springs.length-1; i>=0; i--){
        this.removeSpring(springs[i]);
    }

    // Remove all contact materials
    var cms = this.contactMaterials;
    for(var i=cms.length-1; i>=0; i--){
        this.removeContactMaterial(cms[i]);
    }

    World.apply(this);
};

/**
 * Get a copy of this World instance
 * @method clone
 * @return {World}
 */
World.prototype.clone = function(){
    var world = new World();
    world.fromJSON(this.toJSON());
    return world;
};

var hitTest_tmp1 = vec2.create(),
    hitTest_zero = vec2.fromValues(0,0),
    hitTest_tmp2 = vec2.fromValues(0,0);

/**
 * Test if a world point overlaps bodies
 * @method hitTest
 * @param  {Array}  worldPoint  Point to use for intersection tests
 * @param  {Array}  bodies      A list of objects to check for intersection
 * @param  {Number} precision   Used for matching against particles and lines. Adds some margin to these infinitesimal objects.
 * @return {Array}              Array of bodies that overlap the point
 */
World.prototype.hitTest = function(worldPoint,bodies,precision){
    precision = precision || 0;

    // Create a dummy particle body with a particle shape to test against the bodies
    var pb = new Body({ position:worldPoint }),
        ps = new Particle(),
        px = worldPoint,
        pa = 0,
        x = hitTest_tmp1,
        zero = hitTest_zero,
        tmp = hitTest_tmp2;
    pb.addShape(ps);

    var n = this.narrowphase,
        result = [];

    // Check bodies
    for(var i=0, N=bodies.length; i!==N; i++){
        var b = bodies[i];
        for(var j=0, NS=b.shapes.length; j!==NS; j++){
            var s = b.shapes[j],
                offset = b.shapeOffsets[j] || zero,
                angle = b.shapeAngles[j] || 0.0;

            // Get shape world position + angle
            vec2.rotate(x, offset, b.angle);
            vec2.add(x, x, b.position);
            var a = angle + b.angle;

            if( (s instanceof Circle    && n.circleParticle  (b,s,x,a,     pb,ps,px,pa, true)) ||
                (s instanceof Convex    && n.particleConvex  (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Plane     && n.particlePlane   (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Capsule   && n.particleCapsule (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Particle  && vec2.squaredLength(vec2.sub(tmp,x,worldPoint)) < precision*precision)
                ){
                result.push(b);
            }
        }
    }

    return result;
};

/**
 * Sets the Equation parameters for all constraints and contact materials.
 * @method setGlobalEquationParameters
 * @param {object} [parameters]
 * @param {Number} [parameters.relaxation]
 * @param {Number} [parameters.stiffness]
 */
World.prototype.setGlobalEquationParameters = function(parameters){
    parameters = parameters || {};

    // Set for all constraints
    for(var i=0; i !== this.constraints.length; i++){
        var c = this.constraints[i];
        for(var j=0; j !== c.equations.length; j++){
            var eq = c.equations[j];
            if(typeof(parameters.stiffness) !== "undefined"){
                eq.stiffness = parameters.stiffness;
            }
            if(typeof(parameters.relaxation) !== "undefined"){
                eq.relaxation = parameters.relaxation;
            }
            eq.needsUpdate = true;
        }
    }

    // Set for all contact materials
    for(var i=0; i !== this.contactMaterials.length; i++){
        var c = this.contactMaterials[i];
        if(typeof(parameters.stiffness) !== "undefined"){
            c.stiffness = parameters.stiffness;
            c.frictionStiffness = parameters.stiffness;
        }
        if(typeof(parameters.relaxation) !== "undefined"){
            c.relaxation = parameters.relaxation;
            c.frictionRelaxation = parameters.relaxation;
        }
    }

    // Set for default contact material
    var c = this.defaultContactMaterial;
    if(typeof(parameters.stiffness) !== "undefined"){
        c.stiffness = parameters.stiffness;
        c.frictionStiffness = parameters.stiffness;
    }
    if(typeof(parameters.relaxation) !== "undefined"){
        c.relaxation = parameters.relaxation;
        c.frictionRelaxation = parameters.relaxation;
    }
};

/**
 * Set the stiffness for all equations and contact materials.
 * @method setGlobalStiffness
 * @param {Number} stiffness
 */
World.prototype.setGlobalStiffness = function(stiffness){
    this.setGlobalEquationParameters({
        stiffness: stiffness
    });
};

/**
 * Set the relaxation for all equations and contact materials.
 * @method setGlobalRelaxation
 * @param {Number} relaxation
 */
World.prototype.setGlobalRelaxation = function(relaxation){
    this.setGlobalEquationParameters({
        relaxation: relaxation
    });
};

var tmpRay = new Ray();

/**
 * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
 * @method raycastAll
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {Function} callback
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAll = function(from, to, options, callback){
    options.mode = Ray.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
 * @method raycastAny
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAny = function(from, to, options, result){
    options.mode = Ray.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and return information of the closest hit.
 * @method raycastClosest
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastClosest = function(from, to, options, result){
    options.mode = Ray.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};
},{"../../package.json":6,"../collision/Broadphase":8,"../collision/NaiveBroadphase":10,"../collision/Narrowphase":11,"../collision/Ray":12,"../collision/SAPBroadphase":14,"../constraints/Constraint":15,"../constraints/DistanceConstraint":16,"../constraints/GearConstraint":17,"../constraints/LockConstraint":18,"../constraints/PrismaticConstraint":19,"../constraints/RevoluteConstraint":20,"../events/EventEmitter":27,"../material/ContactMaterial":28,"../material/Material":29,"../math/vec2":31,"../objects/Body":32,"../objects/LinearSpring":33,"../objects/RotationalSpring":34,"../shapes/Capsule":37,"../shapes/Circle":38,"../shapes/Convex":39,"../shapes/Line":41,"../shapes/Particle":42,"../shapes/Plane":43,"../shapes/Rectangle":44,"../shapes/Shape":45,"../solver/GSSolver":46,"../solver/Solver":47,"../utils/OverlapKeeper":48,"../utils/Utils":50,"./IslandManager":52}]},{},[36])
(36)
});;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/Lau/www/svjelly/libs/poly2tri/dist/poly2tri.js":[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.poly2tri=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports={"version": "1.3.5"}
},{}],2:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:11 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */


// -------------------------------------------------------------------------Node

/**
 * Advancing front node
 * @constructor
 * @private
 * @struct
 * @param {!XY} p - Point
 * @param {Triangle=} t triangle (optional)
 */
var Node = function(p, t) {
    /** @type {XY} */
    this.point = p;

    /** @type {Triangle|null} */
    this.triangle = t || null;

    /** @type {Node|null} */
    this.next = null;
    /** @type {Node|null} */
    this.prev = null;

    /** @type {number} */
    this.value = p.x;
};

// ---------------------------------------------------------------AdvancingFront
/**
 * @constructor
 * @private
 * @struct
 * @param {Node} head
 * @param {Node} tail
 */
var AdvancingFront = function(head, tail) {
    /** @type {Node} */
    this.head_ = head;
    /** @type {Node} */
    this.tail_ = tail;
    /** @type {Node} */
    this.search_node_ = head;
};

/** @return {Node} */
AdvancingFront.prototype.head = function() {
    return this.head_;
};

/** @param {Node} node */
AdvancingFront.prototype.setHead = function(node) {
    this.head_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.tail = function() {
    return this.tail_;
};

/** @param {Node} node */
AdvancingFront.prototype.setTail = function(node) {
    this.tail_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.search = function() {
    return this.search_node_;
};

/** @param {Node} node */
AdvancingFront.prototype.setSearch = function(node) {
    this.search_node_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.findSearchNode = function(/*x*/) {
    // TODO: implement BST index
    return this.search_node_;
};

/**
 * @param {number} x value
 * @return {Node}
 */
AdvancingFront.prototype.locateNode = function(x) {
    var node = this.search_node_;

    /* jshint boss:true */
    if (x < node.value) {
        while (node = node.prev) {
            if (x >= node.value) {
                this.search_node_ = node;
                return node;
            }
        }
    } else {
        while (node = node.next) {
            if (x < node.value) {
                this.search_node_ = node.prev;
                return node.prev;
            }
        }
    }
    return null;
};

/**
 * @param {!XY} point - Point
 * @return {Node}
 */
AdvancingFront.prototype.locatePoint = function(point) {
    var px = point.x;
    var node = this.findSearchNode(px);
    var nx = node.point.x;

    if (px === nx) {
        // Here we are comparing point references, not values
        if (point !== node.point) {
            // We might have two nodes with same x value for a short time
            if (point === node.prev.point) {
                node = node.prev;
            } else if (point === node.next.point) {
                node = node.next;
            } else {
                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
            }
        }
    } else if (px < nx) {
        /* jshint boss:true */
        while (node = node.prev) {
            if (point === node.point) {
                break;
            }
        }
    } else {
        while (node = node.next) {
            if (point === node.point) {
                break;
            }
        }
    }

    if (node) {
        this.search_node_ = node;
    }
    return node;
};


// ----------------------------------------------------------------------Exports

module.exports = AdvancingFront;
module.exports.Node = Node;


},{}],3:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 *
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Function added in the JavaScript version (was not present in the c++ version)
 */

/**
 * assert and throw an exception.
 *
 * @private
 * @param {boolean} condition   the condition which is asserted
 * @param {string} message      the message which is display is condition is falsy
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || "Assert Failed");
    }
}
module.exports = assert;



},{}],4:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = _dereq_('./xy');

// ------------------------------------------------------------------------Point
/**
 * Construct a point
 * @example
 *      var point = new poly2tri.Point(150, 150);
 * @public
 * @constructor
 * @struct
 * @param {number=} x    coordinate (0 if undefined)
 * @param {number=} y    coordinate (0 if undefined)
 */
var Point = function(x, y) {
    /**
     * @type {number}
     * @expose
     */
    this.x = +x || 0;
    /**
     * @type {number}
     * @expose
     */
    this.y = +y || 0;

    // All extra fields added to Point are prefixed with _p2t_
    // to avoid collisions if custom Point class is used.

    /**
     * The edges this point constitutes an upper ending point
     * @private
     * @type {Array.<Edge>}
     */
    this._p2t_edge_list = null;
};

/**
 * For pretty printing
 * @example
 *      "p=" + new poly2tri.Point(5,42)
 *      //  "p=(5;42)"
 * @returns {string} <code>"(x;y)"</code>
 */
Point.prototype.toString = function() {
    return xy.toStringBase(this);
};

/**
 * JSON output, only coordinates
 * @example
 *      JSON.stringify(new poly2tri.Point(1,2))
 *      //  '{"x":1,"y":2}'
 */
Point.prototype.toJSON = function() {
    return { x: this.x, y: this.y };
};

/**
 * Creates a copy of this Point object.
 * @return {Point} new cloned point
 */
Point.prototype.clone = function() {
    return new Point(this.x, this.y);
};

/**
 * Set this Point instance to the origo. <code>(0; 0)</code>
 * @return {Point} this (for chaining)
 */
Point.prototype.set_zero = function() {
    this.x = 0.0;
    this.y = 0.0;
    return this; // for chaining
};

/**
 * Set the coordinates of this instance.
 * @param {number} x   coordinate
 * @param {number} y   coordinate
 * @return {Point} this (for chaining)
 */
Point.prototype.set = function(x, y) {
    this.x = +x || 0;
    this.y = +y || 0;
    return this; // for chaining
};

/**
 * Negate this Point instance. (component-wise)
 * @return {Point} this (for chaining)
 */
Point.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this; // for chaining
};

/**
 * Add another Point object to this instance. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.add = function(n) {
    this.x += n.x;
    this.y += n.y;
    return this; // for chaining
};

/**
 * Subtract this Point instance with another point given. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.sub = function(n) {
    this.x -= n.x;
    this.y -= n.y;
    return this; // for chaining
};

/**
 * Multiply this Point instance by a scalar. (component-wise)
 * @param {number} s   scalar.
 * @return {Point} this (for chaining)
 */
Point.prototype.mul = function(s) {
    this.x *= s;
    this.y *= s;
    return this; // for chaining
};

/**
 * Return the distance of this Point instance from the origo.
 * @return {number} distance
 */
Point.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};

/**
 * Normalize this Point instance (as a vector).
 * @return {number} The original distance of this instance from the origo.
 */
Point.prototype.normalize = function() {
    var len = this.length();
    this.x /= len;
    this.y /= len;
    return len;
};

/**
 * Test this Point object with another for equality.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.
 */
Point.prototype.equals = function(p) {
    return this.x === p.x && this.y === p.y;
};


// -----------------------------------------------------Point ("static" methods)

/**
 * Negate a point component-wise and return the result as a new Point object.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.negate = function(p) {
    return new Point(-p.x, -p.y);
};

/**
 * Add two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.add = function(a, b) {
    return new Point(a.x + b.x, a.y + b.y);
};

/**
 * Subtract two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.sub = function(a, b) {
    return new Point(a.x - b.x, a.y - b.y);
};

/**
 * Multiply a point by a scalar and return the result as a new Point object.
 * @param {number} s - the scalar
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.mul = function(s, p) {
    return new Point(s * p.x, s * p.y);
};

/**
 * Perform the cross product on either two points (this produces a scalar)
 * or a point and a scalar (this produces a point).
 * This function requires two parameters, either may be a Point object or a
 * number.
 * @param  {XY|number} a - Point object or scalar.
 * @param  {XY|number} b - Point object or scalar.
 * @return {Point|number} a Point object or a number, depending on the parameters.
 */
Point.cross = function(a, b) {
    if (typeof(a) === 'number') {
        if (typeof(b) === 'number') {
            return a * b;
        } else {
            return new Point(-a * b.y, a * b.x);
        }
    } else {
        if (typeof(b) === 'number') {
            return new Point(b * a.y, -b * a.x);
        } else {
            return a.x * b.y - a.y * b.x;
        }
    }
};


// -----------------------------------------------------------------"Point-Like"
/*
 * The following functions operate on "Point" or any "Point like" object 
 * with {x,y} (duck typing).
 */

Point.toString = xy.toString;
Point.compare = xy.compare;
Point.cmp = xy.compare; // backward compatibility
Point.equals = xy.equals;

/**
 * Peform the dot product on two vectors.
 * @public
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {number} The dot product
 */
Point.dot = function(a, b) {
    return a.x * b.x + a.y * b.y;
};


// ---------------------------------------------------------Exports (public API)

module.exports = Point;

},{"./xy":11}],5:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Class added in the JavaScript version (was not present in the c++ version)
 */

var xy = _dereq_('./xy');

/**
 * Custom exception class to indicate invalid Point values
 * @constructor
 * @public
 * @extends Error
 * @struct
 * @param {string=} message - error message
 * @param {Array.<XY>=} points - invalid points
 */
var PointError = function(message, points) {
    this.name = "PointError";
    /**
     * Invalid points
     * @public
     * @type {Array.<XY>}
     */
    this.points = points = points || [];
    /**
     * Error message
     * @public
     * @type {string}
     */
    this.message = message || "Invalid Points!";
    for (var i = 0; i < points.length; i++) {
        this.message += " " + xy.toString(points[i]);
    }
};
PointError.prototype = new Error();
PointError.prototype.constructor = PointError;


module.exports = PointError;

},{"./xy":11}],6:[function(_dereq_,module,exports){
(function (global){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of Poly2Tri nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

"use strict";

/**
 * Public API for poly2tri.js
 * @module poly2tri
 */


/**
 * If you are not using a module system (e.g. CommonJS, RequireJS), you can access this library
 * as a global variable <code>poly2tri</code> i.e. <code>window.poly2tri</code> in a browser.
 * @name poly2tri
 * @global
 * @public
 * @type {module:poly2tri}
 */
var previousPoly2tri = global.poly2tri;
/**
 * For Browser + &lt;script&gt; :
 * reverts the {@linkcode poly2tri} global object to its previous value,
 * and returns a reference to the instance called.
 *
 * @example
 *              var p = poly2tri.noConflict();
 * @public
 * @return {module:poly2tri} instance called
 */
// (this feature is not automatically provided by browserify).
exports.noConflict = function() {
    global.poly2tri = previousPoly2tri;
    return exports;
};

/**
 * poly2tri library version
 * @public
 * @const {string}
 */
exports.VERSION = _dereq_('../dist/version.json').version;

/**
 * Exports the {@linkcode PointError} class.
 * @public
 * @typedef {PointError} module:poly2tri.PointError
 * @function
 */
exports.PointError = _dereq_('./pointerror');
/**
 * Exports the {@linkcode Point} class.
 * @public
 * @typedef {Point} module:poly2tri.Point
 * @function
 */
exports.Point = _dereq_('./point');
/**
 * Exports the {@linkcode Triangle} class.
 * @public
 * @typedef {Triangle} module:poly2tri.Triangle
 * @function
 */
exports.Triangle = _dereq_('./triangle');
/**
 * Exports the {@linkcode SweepContext} class.
 * @public
 * @typedef {SweepContext} module:poly2tri.SweepContext
 * @function
 */
exports.SweepContext = _dereq_('./sweepcontext');


// Backward compatibility
var sweep = _dereq_('./sweep');
/**
 * @function
 * @deprecated use {@linkcode SweepContext#triangulate} instead
 */
exports.triangulate = sweep.triangulate;
/**
 * @deprecated use {@linkcode SweepContext#triangulate} instead
 * @property {function} Triangulate - use {@linkcode SweepContext#triangulate} instead
 */
exports.sweep = {Triangulate: sweep.triangulate};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../dist/version.json":1,"./point":4,"./pointerror":5,"./sweep":7,"./sweepcontext":8,"./triangle":9}],7:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint latedef:nofunc, maxcomplexity:9 */

"use strict";

/**
 * This 'Sweep' module is present in order to keep this JavaScript version
 * as close as possible to the reference C++ version, even though almost all
 * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.
 * @module
 * @private
 */

/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var assert = _dereq_('./assert');
var PointError = _dereq_('./pointerror');
var Triangle = _dereq_('./triangle');
var Node = _dereq_('./advancingfront').Node;


// ------------------------------------------------------------------------utils

var utils = _dereq_('./utils');

/** @const */
var EPSILON = utils.EPSILON;

/** @const */
var Orientation = utils.Orientation;
/** @const */
var orient2d = utils.orient2d;
/** @const */
var inScanArea = utils.inScanArea;
/** @const */
var isAngleObtuse = utils.isAngleObtuse;


// ------------------------------------------------------------------------Sweep

/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @private
 * @param {!SweepContext} tcx - SweepContext object
 */
function triangulate(tcx) {
    tcx.initTriangulation();
    tcx.createAdvancingFront();
    // Sweep points; build mesh
    sweepPoints(tcx);
    // Clean up
    finalizationPolygon(tcx);
}

/**
 * Start sweeping the Y-sorted point set from bottom to top
 * @param {!SweepContext} tcx - SweepContext object
 */
function sweepPoints(tcx) {
    var i, len = tcx.pointCount();
    for (i = 1; i < len; ++i) {
        var point = tcx.getPoint(i);
        var node = pointEvent(tcx, point);
        var edges = point._p2t_edge_list;
        for (var j = 0; edges && j < edges.length; ++j) {
            edgeEventByEdge(tcx, edges[j], node);
        }
    }
}

/**
 * @param {!SweepContext} tcx - SweepContext object
 */
function finalizationPolygon(tcx) {
    // Get an Internal triangle to start with
    var t = tcx.front().head().next.triangle;
    var p = tcx.front().head().next.point;
    while (!t.getConstrainedEdgeCW(p)) {
        t = t.neighborCCW(p);
    }

    // Collect interior triangles constrained by edges
    tcx.meshClean(t);
}

/**
 * Find closes node to the left of the new point and
 * create a new triangle. If needed new holes and basins
 * will be filled to.
 * @param {!SweepContext} tcx - SweepContext object
 * @param {!XY} point   Point
 */
function pointEvent(tcx, point) {
    var node = tcx.locateNode(point);
    var new_node = newFrontTriangle(tcx, point, node);

    // Only need to check +epsilon since point never have smaller
    // x value than node due to how we fetch nodes from the front
    if (point.x <= node.point.x + (EPSILON)) {
        fill(tcx, node);
    }

    //tcx.AddNode(new_node);

    fillAdvancingFront(tcx, new_node);
    return new_node;
}

function edgeEventByEdge(tcx, edge, node) {
    tcx.edge_event.constrained_edge = edge;
    tcx.edge_event.right = (edge.p.x > edge.q.x);

    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
        return;
    }

    // For now we will do all needed filling
    // TODO: integrate with flip process might give some better performance
    //       but for now this avoid the issue with cases that needs both flips and fills
    fillEdgeEvent(tcx, edge, node);
    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
}

function edgeEventByPoints(tcx, ep, eq, triangle, point) {
    if (isEdgeSideOfTriangle(triangle, ep, eq)) {
        return;
    }

    var p1 = triangle.pointCCW(point);
    var o1 = orient2d(eq, p1, ep);
    if (o1 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
    }

    var p2 = triangle.pointCW(point);
    var o2 = orient2d(eq, p2, ep);
    if (o2 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
    }

    if (o1 === o2) {
        // Need to decide if we are rotating CW or CCW to get to a triangle
        // that will cross edge
        if (o1 === Orientation.CW) {
            triangle = triangle.neighborCCW(point);
        } else {
            triangle = triangle.neighborCW(point);
        }
        edgeEventByPoints(tcx, ep, eq, triangle, point);
    } else {
        // This triangle crosses constraint so lets flippin start!
        flipEdgeEvent(tcx, ep, eq, triangle, point);
    }
}

function isEdgeSideOfTriangle(triangle, ep, eq) {
    var index = triangle.edgeIndex(ep, eq);
    if (index !== -1) {
        triangle.markConstrainedEdgeByIndex(index);
        var t = triangle.getNeighbor(index);
        if (t) {
            t.markConstrainedEdgeByPoints(ep, eq);
        }
        return true;
    }
    return false;
}

/**
 * Creates a new front triangle and legalize it
 * @param {!SweepContext} tcx - SweepContext object
 */
function newFrontTriangle(tcx, point, node) {
    var triangle = new Triangle(point, node.point, node.next.point);

    triangle.markNeighbor(node.triangle);
    tcx.addToMap(triangle);

    var new_node = new Node(point);
    new_node.next = node.next;
    new_node.prev = node;
    node.next.prev = new_node;
    node.next = new_node;

    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    return new_node;
}

/**
 * Adds a triangle to the advancing front to fill a hole.
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - middle node, that is the bottom of the hole
 */
function fill(tcx, node) {
    var triangle = new Triangle(node.prev.point, node.point, node.next.point);

    // TODO: should copy the constrained_edge value from neighbor triangles
    //       for now constrained_edge values are copied during the legalize
    triangle.markNeighbor(node.prev.triangle);
    triangle.markNeighbor(node.triangle);

    tcx.addToMap(triangle);

    // Update the advancing front
    node.prev.next = node.next;
    node.next.prev = node.prev;


    // If it was legalized the triangle has already been mapped
    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    //tcx.removeNode(node);
}

/**
 * Fills holes in the Advancing Front
 * @param {!SweepContext} tcx - SweepContext object
 */
function fillAdvancingFront(tcx, n) {
    // Fill right holes
    var node = n.next;
    while (node.next) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.next;
    }

    // Fill left holes
    node = n.prev;
    while (node.prev) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.prev;
    }

    // Fill right basins
    if (n.next && n.next.next) {
        if (isBasinAngleRight(n)) {
            fillBasin(tcx, n);
        }
    }
}

/**
 * The basin angle is decided against the horizontal line [1,0].
 * @param {Node} node
 * @return {boolean} true if angle < 3*/4
 */
function isBasinAngleRight(node) {
    var ax = node.point.x - node.next.next.point.x;
    var ay = node.point.y - node.next.next.point.y;
    assert(ay >= 0, "unordered y");
    return (ax >= 0 || Math.abs(ax) < ay);
}

/**
 * Returns true if triangle was legalized
 * @param {!SweepContext} tcx - SweepContext object
 * @return {boolean}
 */
function legalize(tcx, t) {
    // To legalize a triangle we start by finding if any of the three edges
    // violate the Delaunay condition
    for (var i = 0; i < 3; ++i) {
        if (t.delaunay_edge[i]) {
            continue;
        }
        var ot = t.getNeighbor(i);
        if (ot) {
            var p = t.getPoint(i);
            var op = ot.oppositePoint(t, p);
            var oi = ot.index(op);

            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
            // then we should not try to legalize
            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                t.constrained_edge[i] = ot.constrained_edge[oi];
                continue;
            }

            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);
            if (inside) {
                // Lets mark this shared edge as Delaunay
                t.delaunay_edge[i] = true;
                ot.delaunay_edge[oi] = true;

                // Lets rotate shared edge one vertex CW to legalize it
                rotateTrianglePair(t, p, ot, op);

                // We now got one valid Delaunay Edge shared by two triangles
                // This gives us 4 new edges to check for Delaunay

                // Make sure that triangle to node mapping is done only one time for a specific triangle
                var not_legalized = !legalize(tcx, t);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(t);
                }

                not_legalized = !legalize(tcx, ot);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(ot);
                }
                // Reset the Delaunay edges, since they only are valid Delaunay edges
                // until we add a new triangle or point.
                // XXX: need to think about this. Can these edges be tried after we
                //      return to previous recursive level?
                t.delaunay_edge[i] = false;
                ot.delaunay_edge[oi] = false;

                // If triangle have been legalized no need to check the other edges since
                // the recursive legalization will handles those so we can end here.
                return true;
            }
        }
    }
    return false;
}

/**
 * <b>Requirement</b>:<br>
 * 1. a,b and c form a triangle.<br>
 * 2. a and d is know to be on opposite side of bc<br>
 * <pre>
 *                a
 *                +
 *               / \
 *              /   \
 *            b/     \c
 *            +-------+
 *           /    d    \
 *          /           \
 * </pre>
 * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
 *  a,b and c<br>
 *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
 *  This preknowledge gives us a way to optimize the incircle test
 * @param pa - triangle point, opposite d
 * @param pb - triangle point
 * @param pc - triangle point
 * @param pd - point opposite a
 * @return {boolean} true if d is inside circle, false if on circle edge
 */
function inCircle(pa, pb, pc, pd) {
    var adx = pa.x - pd.x;
    var ady = pa.y - pd.y;
    var bdx = pb.x - pd.x;
    var bdy = pb.y - pd.y;

    var adxbdy = adx * bdy;
    var bdxady = bdx * ady;
    var oabd = adxbdy - bdxady;
    if (oabd <= 0) {
        return false;
    }

    var cdx = pc.x - pd.x;
    var cdy = pc.y - pd.y;

    var cdxady = cdx * ady;
    var adxcdy = adx * cdy;
    var ocad = cdxady - adxcdy;
    if (ocad <= 0) {
        return false;
    }

    var bdxcdy = bdx * cdy;
    var cdxbdy = cdx * bdy;

    var alift = adx * adx + ady * ady;
    var blift = bdx * bdx + bdy * bdy;
    var clift = cdx * cdx + cdy * cdy;

    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
    return det > 0;
}

/**
 * Rotates a triangle pair one vertex CW
 *<pre>
 *       n2                    n2
 *  P +-----+             P +-----+
 *    | t  /|               |\  t |
 *    |   / |               | \   |
 *  n1|  /  |n3           n1|  \  |n3
 *    | /   |    after CW   |   \ |
 *    |/ oT |               | oT \|
 *    +-----+ oP            +-----+
 *       n4                    n4
 * </pre>
 */
function rotateTrianglePair(t, p, ot, op) {
    var n1, n2, n3, n4;
    n1 = t.neighborCCW(p);
    n2 = t.neighborCW(p);
    n3 = ot.neighborCCW(op);
    n4 = ot.neighborCW(op);

    var ce1, ce2, ce3, ce4;
    ce1 = t.getConstrainedEdgeCCW(p);
    ce2 = t.getConstrainedEdgeCW(p);
    ce3 = ot.getConstrainedEdgeCCW(op);
    ce4 = ot.getConstrainedEdgeCW(op);

    var de1, de2, de3, de4;
    de1 = t.getDelaunayEdgeCCW(p);
    de2 = t.getDelaunayEdgeCW(p);
    de3 = ot.getDelaunayEdgeCCW(op);
    de4 = ot.getDelaunayEdgeCW(op);

    t.legalize(p, op);
    ot.legalize(op, p);

    // Remap delaunay_edge
    ot.setDelaunayEdgeCCW(p, de1);
    t.setDelaunayEdgeCW(p, de2);
    t.setDelaunayEdgeCCW(op, de3);
    ot.setDelaunayEdgeCW(op, de4);

    // Remap constrained_edge
    ot.setConstrainedEdgeCCW(p, ce1);
    t.setConstrainedEdgeCW(p, ce2);
    t.setConstrainedEdgeCCW(op, ce3);
    ot.setConstrainedEdgeCW(op, ce4);

    // Remap neighbors
    // XXX: might optimize the markNeighbor by keeping track of
    //      what side should be assigned to what neighbor after the
    //      rotation. Now mark neighbor does lots of testing to find
    //      the right side.
    t.clearNeighbors();
    ot.clearNeighbors();
    if (n1) {
        ot.markNeighbor(n1);
    }
    if (n2) {
        t.markNeighbor(n2);
    }
    if (n3) {
        t.markNeighbor(n3);
    }
    if (n4) {
        ot.markNeighbor(n4);
    }
    t.markNeighbor(ot);
}

/**
 * Fills a basin that has formed on the Advancing Front to the right
 * of given node.<br>
 * First we decide a left,bottom and right node that forms the
 * boundaries of the basin. Then we do a reqursive fill.
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - starting node, this or next node will be left node
 */
function fillBasin(tcx, node) {
    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
        tcx.basin.left_node = node.next.next;
    } else {
        tcx.basin.left_node = node.next;
    }

    // Find the bottom and right node
    tcx.basin.bottom_node = tcx.basin.left_node;
    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
        tcx.basin.bottom_node = tcx.basin.bottom_node.next;
    }
    if (tcx.basin.bottom_node === tcx.basin.left_node) {
        // No valid basin
        return;
    }

    tcx.basin.right_node = tcx.basin.bottom_node;
    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
        tcx.basin.right_node = tcx.basin.right_node.next;
    }
    if (tcx.basin.right_node === tcx.basin.bottom_node) {
        // No valid basins
        return;
    }

    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

    fillBasinReq(tcx, tcx.basin.bottom_node);
}

/**
 * Recursive algorithm to fill a Basin with triangles
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - bottom_node
 */
function fillBasinReq(tcx, node) {
    // if shallow stop filling
    if (isShallow(tcx, node)) {
        return;
    }

    fill(tcx, node);

    var o;
    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
        return;
    } else if (node.prev === tcx.basin.left_node) {
        o = orient2d(node.point, node.next.point, node.next.next.point);
        if (o === Orientation.CW) {
            return;
        }
        node = node.next;
    } else if (node.next === tcx.basin.right_node) {
        o = orient2d(node.point, node.prev.point, node.prev.prev.point);
        if (o === Orientation.CCW) {
            return;
        }
        node = node.prev;
    } else {
        // Continue with the neighbor node with lowest Y value
        if (node.prev.point.y < node.next.point.y) {
            node = node.prev;
        } else {
            node = node.next;
        }
    }

    fillBasinReq(tcx, node);
}

function isShallow(tcx, node) {
    var height;
    if (tcx.basin.left_highest) {
        height = tcx.basin.left_node.point.y - node.point.y;
    } else {
        height = tcx.basin.right_node.point.y - node.point.y;
    }

    // if shallow stop filling
    if (tcx.basin.width > height) {
        return true;
    }
    return false;
}

function fillEdgeEvent(tcx, edge, node) {
    if (tcx.edge_event.right) {
        fillRightAboveEdgeEvent(tcx, edge, node);
    } else {
        fillLeftAboveEdgeEvent(tcx, edge, node);
    }
}

function fillRightAboveEdgeEvent(tcx, edge, node) {
    while (node.next.point.x < edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            fillRightBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.next;
        }
    }
}

function fillRightBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x < edge.p.x) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            // Concave
            fillRightConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillRightConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillRightBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillRightConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.next);
    if (node.next.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            // Below
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                // Next is concave
                fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function fillRightConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
        // Concave
        fillRightConcaveEdgeEvent(tcx, edge, node.next);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
            // Below
            fillRightConvexEdgeEvent(tcx, edge, node.next);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftAboveEdgeEvent(tcx, edge, node) {
    while (node.prev.point.x > edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            fillLeftBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.prev;
        }
    }
}

function fillLeftBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x > edge.p.x) {
        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
            // Concave
            fillLeftConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillLeftConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillLeftBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillLeftConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
        // Concave
        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
            // Below
            fillLeftConvexEdgeEvent(tcx, edge, node.prev);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.prev);
    if (node.prev.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            // Below
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                // Next is concave
                fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function flipEdgeEvent(tcx, ep, eq, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle!");

    var op = ot.oppositePoint(t, p);

    // Additional check from Java version (see issue #88)
    if (t.getConstrainedEdgeAcross(p)) {
        var index = t.index(p);
        throw new PointError("poly2tri Intersecting Constraints",
                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);
    }

    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
        // Lets rotate shared edge one vertex CW
        rotateTrianglePair(t, p, ot, op);
        tcx.mapTriangleToNodes(t);
        tcx.mapTriangleToNodes(ot);

        // XXX: in the original C++ code for the next 2 lines, we are
        // comparing point values (and not pointers). In this JavaScript
        // code, we are comparing point references (pointers). This works
        // because we can't have 2 different points with the same values.
        // But to be really equivalent, we should use "Point.equals" here.
        if (p === eq && op === ep) {
            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
                t.markConstrainedEdgeByPoints(ep, eq);
                ot.markConstrainedEdgeByPoints(ep, eq);
                legalize(tcx, t);
                legalize(tcx, ot);
            } else {
                // XXX: I think one of the triangles should be legalized here?
                /* jshint noempty:false */
            }
        } else {
            var o = orient2d(eq, op, ep);
            t = nextFlipTriangle(tcx, o, t, ot, p, op);
            flipEdgeEvent(tcx, ep, eq, t, p);
        }
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
        edgeEventByPoints(tcx, ep, eq, t, p);
    }
}

/**
 * After a flip we have two triangles and know that only one will still be
 * intersecting the edge. So decide which to contiune with and legalize the other
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param o - should be the result of an orient2d( eq, op, ep )
 * @param t - triangle 1
 * @param ot - triangle 2
 * @param p - a point shared by both triangles
 * @param op - another point shared by both triangles
 * @return returns the triangle still intersecting the edge
 */
function nextFlipTriangle(tcx, o, t, ot, p, op) {
    var edge_index;
    if (o === Orientation.CCW) {
        // ot is not crossing edge after flip
        edge_index = ot.edgeIndex(p, op);
        ot.delaunay_edge[edge_index] = true;
        legalize(tcx, ot);
        ot.clearDelaunayEdges();
        return t;
    }

    // t is not crossing edge after flip
    edge_index = t.edgeIndex(p, op);

    t.delaunay_edge[edge_index] = true;
    legalize(tcx, t);
    t.clearDelaunayEdges();
    return ot;
}

/**
 * When we need to traverse from one triangle to the next we need
 * the point in current triangle that is the opposite point to the next
 * triangle.
 */
function nextFlipPoint(ep, eq, ot, op) {
    var o2d = orient2d(eq, op, ep);
    if (o2d === Orientation.CW) {
        // Right
        return ot.pointCCW(op);
    } else if (o2d === Orientation.CCW) {
        // Left
        return ot.pointCW(op);
    } else {
        throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
    }
}

/**
 * Scan part of the FlipScan algorithm<br>
 * When a triangle pair isn't flippable we will scan for the next
 * point that is inside the flip triangle scan area. When found
 * we generate a new flipEdgeEvent
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param ep - last point on the edge we are traversing
 * @param eq - first point on the edge we are traversing
 * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge
 * @param t
 * @param p
 */
function flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle");

    var op = ot.oppositePoint(t, p);

    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
        // flip with new edge op.eq
        flipEdgeEvent(tcx, eq, op, ot, op);
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
    }
}


// ----------------------------------------------------------------------Exports

exports.triangulate = triangulate;

},{"./advancingfront":2,"./assert":3,"./pointerror":5,"./triangle":9,"./utils":10}],8:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:6 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var PointError = _dereq_('./pointerror');
var Point = _dereq_('./point');
var Triangle = _dereq_('./triangle');
var sweep = _dereq_('./sweep');
var AdvancingFront = _dereq_('./advancingfront');
var Node = AdvancingFront.Node;


// ------------------------------------------------------------------------utils

/**
 * Initial triangle factor, seed triangle will extend 30% of
 * PointSet width to both left and right.
 * @private
 * @const
 */
var kAlpha = 0.3;


// -------------------------------------------------------------------------Edge
/**
 * Represents a simple polygon's edge
 * @constructor
 * @struct
 * @private
 * @param {Point} p1
 * @param {Point} p2
 * @throw {PointError} if p1 is same as p2
 */
var Edge = function(p1, p2) {
    this.p = p1;
    this.q = p2;

    if (p1.y > p2.y) {
        this.q = p1;
        this.p = p2;
    } else if (p1.y === p2.y) {
        if (p1.x > p2.x) {
            this.q = p1;
            this.p = p2;
        } else if (p1.x === p2.x) {
            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
        }
    }

    if (!this.q._p2t_edge_list) {
        this.q._p2t_edge_list = [];
    }
    this.q._p2t_edge_list.push(this);
};


// ------------------------------------------------------------------------Basin
/**
 * @constructor
 * @struct
 * @private
 */
var Basin = function() {
    /** @type {Node} */
    this.left_node = null;
    /** @type {Node} */
    this.bottom_node = null;
    /** @type {Node} */
    this.right_node = null;
    /** @type {number} */
    this.width = 0.0;
    /** @type {boolean} */
    this.left_highest = false;
};

Basin.prototype.clear = function() {
    this.left_node = null;
    this.bottom_node = null;
    this.right_node = null;
    this.width = 0.0;
    this.left_highest = false;
};

// --------------------------------------------------------------------EdgeEvent
/**
 * @constructor
 * @struct
 * @private
 */
var EdgeEvent = function() {
    /** @type {Edge} */
    this.constrained_edge = null;
    /** @type {boolean} */
    this.right = false;
};

// ----------------------------------------------------SweepContext (public API)
/**
 * SweepContext constructor option
 * @typedef {Object} SweepContextOptions
 * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters
 *                  (contour, holes). Points inside arrays are never copied.
 *                  Default is <code>false</code> : keep a reference to the array arguments,
 *                  who will be modified in place.
 */
/**
 * Constructor for the triangulation context.
 * It accepts a simple polyline (with non repeating points), 
 * which defines the constrained edges.
 *
 * @example
 *          var contour = [
 *              new poly2tri.Point(100, 100),
 *              new poly2tri.Point(100, 300),
 *              new poly2tri.Point(300, 300),
 *              new poly2tri.Point(300, 100)
 *          ];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @example
 *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @constructor
 * @public
 * @struct
 * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,
 *          or any "Point like" custom class with <code>{x, y}</code> attributes.
 * @param {SweepContextOptions=} options - constructor options
 */
var SweepContext = function(contour, options) {
    options = options || {};
    this.triangles_ = [];
    this.map_ = [];
    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
    this.edge_list = [];

    // Bounding box of all points. Computed at the start of the triangulation, 
    // it is stored in case it is needed by the caller.
    this.pmin_ = this.pmax_ = null;

    /**
     * Advancing front
     * @private
     * @type {AdvancingFront}
     */
    this.front_ = null;

    /**
     * head point used with advancing front
     * @private
     * @type {Point}
     */
    this.head_ = null;

    /**
     * tail point used with advancing front
     * @private
     * @type {Point}
     */
    this.tail_ = null;

    /**
     * @private
     * @type {Node}
     */
    this.af_head_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_middle_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_tail_ = null;

    this.basin = new Basin();
    this.edge_event = new EdgeEvent();

    this.initEdges(this.points_);
};


/**
 * Add a hole to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var hole = [
 *          new poly2tri.Point(200, 200),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addHole(hole);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} polyline - array of "Point like" objects with {x,y}
 */
SweepContext.prototype.addHole = function(polyline) {
    this.initEdges(polyline);
    var i, len = polyline.length;
    for (i = 0; i < len; i++) {
        this.points_.push(polyline[i]);
    }
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addHole} instead
 */
SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


/**
 * Add several holes to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],
 *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]
 *      ];
 *      swctx.addHoles(holes);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],
 *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]
 *      ];
 *      swctx.addHoles(holes);
 * @public
 * @param {Array.<Array.<XY>>} holes - array of array of "Point like" objects with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addHoles = function(holes) {
    var i, len = holes.length;
    for (i = 0; i < len; i++) {
        this.initEdges(holes[i]);
    }
    this.points_ = this.points_.concat.apply(this.points_, holes);
    return this; // for chaining
};


/**
 * Add a Steiner point to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var point = new poly2tri.Point(150, 150);
 *      swctx.addPoint(point);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoint({x:150, y:150});
 * @public
 * @param {XY} point - any "Point like" object with {x,y}
 */
SweepContext.prototype.addPoint = function(point) {
    this.points_.push(point);
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addPoint} instead
 */
SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


/**
 * Add several Steiner points to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var points = [
 *          new poly2tri.Point(150, 150),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addPoints(points);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} points - array of "Point like" object with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addPoints = function(points) {
    this.points_ = this.points_.concat(points);
    return this; // for chaining
};


/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @public
 */
// Shortcut method for sweep.triangulate(SweepContext).
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.triangulate = function() {
    sweep.triangulate(this);
    return this; // for chaining
};


/**
 * Get the bounding box of the provided constraints (contour, holes and 
 * Steinter points). Warning : these values are not available if the triangulation 
 * has not been done yet.
 * @public
 * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.getBoundingBox = function() {
    return {min: this.pmin_, max: this.pmax_};
};

/**
 * Get result of triangulation.
 * The output triangles have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      //  "number"
 * @public
 * @returns {array<Triangle>}   array of triangles
 */
SweepContext.prototype.getTriangles = function() {
    return this.triangles_;
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#getTriangles} instead
 */
SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


// ---------------------------------------------------SweepContext (private API)

/** @private */
SweepContext.prototype.front = function() {
    return this.front_;
};

/** @private */
SweepContext.prototype.pointCount = function() {
    return this.points_.length;
};

/** @private */
SweepContext.prototype.head = function() {
    return this.head_;
};

/** @private */
SweepContext.prototype.setHead = function(p1) {
    this.head_ = p1;
};

/** @private */
SweepContext.prototype.tail = function() {
    return this.tail_;
};

/** @private */
SweepContext.prototype.setTail = function(p1) {
    this.tail_ = p1;
};

/** @private */
SweepContext.prototype.getMap = function() {
    return this.map_;
};

/** @private */
SweepContext.prototype.initTriangulation = function() {
    var xmax = this.points_[0].x;
    var xmin = this.points_[0].x;
    var ymax = this.points_[0].y;
    var ymin = this.points_[0].y;

    // Calculate bounds
    var i, len = this.points_.length;
    for (i = 1; i < len; i++) {
        var p = this.points_[i];
        /* jshint expr:true */
        (p.x > xmax) && (xmax = p.x);
        (p.x < xmin) && (xmin = p.x);
        (p.y > ymax) && (ymax = p.y);
        (p.y < ymin) && (ymin = p.y);
    }
    this.pmin_ = new Point(xmin, ymin);
    this.pmax_ = new Point(xmax, ymax);

    var dx = kAlpha * (xmax - xmin);
    var dy = kAlpha * (ymax - ymin);
    this.head_ = new Point(xmax + dx, ymin - dy);
    this.tail_ = new Point(xmin - dx, ymin - dy);

    // Sort points along y-axis
    this.points_.sort(Point.compare);
};

/** @private */
SweepContext.prototype.initEdges = function(polyline) {
    var i, len = polyline.length;
    for (i = 0; i < len; ++i) {
        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
    }
};

/** @private */
SweepContext.prototype.getPoint = function(index) {
    return this.points_[index];
};

/** @private */
SweepContext.prototype.addToMap = function(triangle) {
    this.map_.push(triangle);
};

/** @private */
SweepContext.prototype.locateNode = function(point) {
    return this.front_.locateNode(point.x);
};

/** @private */
SweepContext.prototype.createAdvancingFront = function() {
    var head;
    var middle;
    var tail;
    // Initial triangle
    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

    this.map_.push(triangle);

    head = new Node(triangle.getPoint(1), triangle);
    middle = new Node(triangle.getPoint(0), triangle);
    tail = new Node(triangle.getPoint(2));

    this.front_ = new AdvancingFront(head, tail);

    head.next = middle;
    middle.next = tail;
    middle.prev = head;
    tail.prev = middle;
};

/** @private */
SweepContext.prototype.removeNode = function(node) {
    // do nothing
    /* jshint unused:false */
};

/** @private */
SweepContext.prototype.mapTriangleToNodes = function(t) {
    for (var i = 0; i < 3; ++i) {
        if (!t.getNeighbor(i)) {
            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
            if (n) {
                n.triangle = t;
            }
        }
    }
};

/** @private */
SweepContext.prototype.removeFromMap = function(triangle) {
    var i, map = this.map_, len = map.length;
    for (i = 0; i < len; i++) {
        if (map[i] === triangle) {
            map.splice(i, 1);
            break;
        }
    }
};

/**
 * Do a depth first traversal to collect triangles
 * @private
 * @param {Triangle} triangle start
 */
SweepContext.prototype.meshClean = function(triangle) {
    // New implementation avoids recursive calls and use a loop instead.
    // Cf. issues # 57, 65 and 69.
    var triangles = [triangle], t, i;
    /* jshint boss:true */
    while (t = triangles.pop()) {
        if (!t.isInterior()) {
            t.setInterior(true);
            this.triangles_.push(t);
            for (i = 0; i < 3; i++) {
                if (!t.constrained_edge[i]) {
                    triangles.push(t.getNeighbor(i));
                }
            }
        }
    }
};

// ----------------------------------------------------------------------Exports

module.exports = SweepContext;

},{"./advancingfront":2,"./point":4,"./pointerror":5,"./sweep":7,"./triangle":9}],9:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:10 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = _dereq_("./xy");


// ---------------------------------------------------------------------Triangle
/**
 * Triangle class.<br>
 * Triangle-based data structures are known to have better performance than
 * quad-edge structures.
 * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
 * Delaunay Triangulator", "Triangulations in CGAL"
 *
 * @constructor
 * @struct
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 */
var Triangle = function(a, b, c) {
    /**
     * Triangle points
     * @private
     * @type {Array.<XY>}
     */
    this.points_ = [a, b, c];

    /**
     * Neighbor list
     * @private
     * @type {Array.<Triangle>}
     */
    this.neighbors_ = [null, null, null];

    /**
     * Has this triangle been marked as an interior triangle?
     * @private
     * @type {boolean}
     */
    this.interior_ = false;

    /**
     * Flags to determine if an edge is a Constrained edge
     * @private
     * @type {Array.<boolean>}
     */
    this.constrained_edge = [false, false, false];

    /**
     * Flags to determine if an edge is a Delauney edge
     * @private
     * @type {Array.<boolean>}
     */
    this.delaunay_edge = [false, false, false];
};

var p2s = xy.toString;
/**
 * For pretty printing ex. <code>"[(5;42)(10;20)(21;30)]"</code>.
 * @public
 * @return {string}
 */
Triangle.prototype.toString = function() {
    return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
};

/**
 * Get one vertice of the triangle.
 * The output triangles of a triangulation have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      //  "number"
 * @param {number} index - vertice index: 0, 1 or 2
 * @public
 * @returns {XY}
 */
Triangle.prototype.getPoint = function(index) {
    return this.points_[index];
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode Triangle#getPoint} instead
 */
Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

/**
 * Get all 3 vertices of the triangle as an array
 * @public
 * @return {Array.<XY>}
 */
// Method added in the JavaScript version (was not present in the c++ version)
Triangle.prototype.getPoints = function() {
    return this.points_;
};

/**
 * @private
 * @param {number} index
 * @returns {?Triangle}
 */
Triangle.prototype.getNeighbor = function(index) {
    return this.neighbors_[index];
};

/**
 * Test if this Triangle contains the Point object given as parameter as one of its vertices.
 * Only point references are compared, not values.
 * @public
 * @param {XY} point - point object with {x,y}
 * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,
 *         <code>false</code> otherwise.
 */
Triangle.prototype.containsPoint = function(point) {
    var points = this.points_;
    // Here we are comparing point references, not values
    return (point === points[0] || point === points[1] || point === points[2]);
};

/**
 * Test if this Triangle contains the Edge object given as parameter as its
 * bounding edges. Only point references are compared, not values.
 * @private
 * @param {Edge} edge
 * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding
 *         edges, <code>false</code> otherwise.
 */
Triangle.prototype.containsEdge = function(edge) {
    return this.containsPoint(edge.p) && this.containsPoint(edge.q);
};

/**
 * Test if this Triangle contains the two Point objects given as parameters among its vertices.
 * Only point references are compared, not values.
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {boolean}
 */
Triangle.prototype.containsPoints = function(p1, p2) {
    return this.containsPoint(p1) && this.containsPoint(p2);
};

/**
 * Has this triangle been marked as an interior triangle?
 * @returns {boolean}
 */
Triangle.prototype.isInterior = function() {
    return this.interior_;
};

/**
 * Mark this triangle as an interior triangle
 * @private
 * @param {boolean} interior
 * @returns {Triangle} this
 */
Triangle.prototype.setInterior = function(interior) {
    this.interior_ = interior;
    return this;
};

/**
 * Update neighbor pointers.
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @param {Triangle} t Triangle object.
 * @throws {Error} if can't find objects
 */
Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
        this.neighbors_[0] = t;
    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
        this.neighbors_[1] = t;
    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
        this.neighbors_[2] = t;
    } else {
        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
    }
};

/**
 * Exhaustive search to update neighbor pointers
 * @private
 * @param {!Triangle} t
 */
Triangle.prototype.markNeighbor = function(t) {
    var points = this.points_;
    if (t.containsPoints(points[1], points[2])) {
        this.neighbors_[0] = t;
        t.markNeighborPointers(points[1], points[2], this);
    } else if (t.containsPoints(points[0], points[2])) {
        this.neighbors_[1] = t;
        t.markNeighborPointers(points[0], points[2], this);
    } else if (t.containsPoints(points[0], points[1])) {
        this.neighbors_[2] = t;
        t.markNeighborPointers(points[0], points[1], this);
    }
};


Triangle.prototype.clearNeighbors = function() {
    this.neighbors_[0] = null;
    this.neighbors_[1] = null;
    this.neighbors_[2] = null;
};

Triangle.prototype.clearDelaunayEdges = function() {
    this.delaunay_edge[0] = false;
    this.delaunay_edge[1] = false;
    this.delaunay_edge[2] = false;
};

/**
 * Returns the point clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[2];
    } else if (p === points[1]) {
        return points[0];
    } else if (p === points[2]) {
        return points[1];
    } else {
        return null;
    }
};

/**
 * Returns the point counter-clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[1];
    } else if (p === points[1]) {
        return points[2];
    } else if (p === points[2]) {
        return points[0];
    } else {
        return null;
    }
};

/**
 * Returns the neighbor clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[1];
    } else if (p === this.points_[1]) {
        return this.neighbors_[2];
    } else {
        return this.neighbors_[0];
    }
};

/**
 * Returns the neighbor counter-clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[2];
    } else if (p === this.points_[1]) {
        return this.neighbors_[0];
    } else {
        return this.neighbors_[1];
    }
};

Triangle.prototype.getConstrainedEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[1];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[2];
    } else {
        return this.constrained_edge[0];
    }
};

Triangle.prototype.getConstrainedEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[2];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[0];
    } else {
        return this.constrained_edge[1];
    }
};

// Additional check from Java version (see issue #88)
Triangle.prototype.getConstrainedEdgeAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[0];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[1];
    } else {
        return this.constrained_edge[2];
    }
};

Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[1] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[2] = ce;
    } else {
        this.constrained_edge[0] = ce;
    }
};

Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[2] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[0] = ce;
    } else {
        this.constrained_edge[1] = ce;
    }
};

Triangle.prototype.getDelaunayEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[1];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[2];
    } else {
        return this.delaunay_edge[0];
    }
};

Triangle.prototype.getDelaunayEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[2];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[0];
    } else {
        return this.delaunay_edge[1];
    }
};

Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[1] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[2] = e;
    } else {
        this.delaunay_edge[0] = e;
    }
};

Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[2] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[0] = e;
    } else {
        this.delaunay_edge[1] = e;
    }
};

/**
 * The neighbor across to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {Triangle}
 */
Triangle.prototype.neighborAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[0];
    } else if (p === this.points_[1]) {
        return this.neighbors_[1];
    } else {
        return this.neighbors_[2];
    }
};

/**
 * @private
 * @param {!Triangle} t Triangle object.
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.oppositePoint = function(t, p) {
    var cw = t.pointCW(p);
    return this.pointCW(cw);
};

/**
 * Legalize triangle by rotating clockwise around oPoint
 * @private
 * @param {XY} opoint - point object with {x,y}
 * @param {XY} npoint - point object with {x,y}
 * @throws {Error} if oPoint can not be found
 */
Triangle.prototype.legalize = function(opoint, npoint) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (opoint === points[0]) {
        points[1] = points[0];
        points[0] = points[2];
        points[2] = npoint;
    } else if (opoint === points[1]) {
        points[2] = points[1];
        points[1] = points[0];
        points[0] = npoint;
    } else if (opoint === points[2]) {
        points[0] = points[2];
        points[2] = points[1];
        points[1] = npoint;
    } else {
        throw new Error('poly2tri Invalid Triangle.legalize() call');
    }
};

/**
 * Returns the index of a point in the triangle. 
 * The point *must* be a reference to one of the triangle's vertices.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {number} index 0, 1 or 2
 * @throws {Error} if p can not be found
 */
Triangle.prototype.index = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return 0;
    } else if (p === points[1]) {
        return 1;
    } else if (p === points[2]) {
        return 2;
    } else {
        throw new Error('poly2tri Invalid Triangle.index() call');
    }
};

/**
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {number} index 0, 1 or 2, or -1 if errror
 */
Triangle.prototype.edgeIndex = function(p1, p2) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p1 === points[0]) {
        if (p2 === points[1]) {
            return 2;
        } else if (p2 === points[2]) {
            return 1;
        }
    } else if (p1 === points[1]) {
        if (p2 === points[2]) {
            return 0;
        } else if (p2 === points[0]) {
            return 2;
        }
    } else if (p1 === points[2]) {
        if (p2 === points[0]) {
            return 1;
        } else if (p2 === points[1]) {
            return 0;
        }
    }
    return -1;
};

/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {number} index - edge index
 */
Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
    this.constrained_edge[index] = true;
};
/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {Edge} edge instance
 */
Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
    this.markConstrainedEdgeByPoints(edge.p, edge.q);
};
/**
 * Mark an edge of this triangle as constrained.
 * This method takes two Point instances defining the edge of the triangle.
 * @private
 * @param {XY} p - point object with {x,y}
 * @param {XY} q - point object with {x,y}
 */
Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
    var points = this.points_;
    // Here we are comparing point references, not values        
    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
        this.constrained_edge[2] = true;
    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
        this.constrained_edge[1] = true;
    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
        this.constrained_edge[0] = true;
    }
};


// ---------------------------------------------------------Exports (public API)

module.exports = Triangle;

},{"./xy":11}],10:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/**
 * Precision to detect repeated or collinear points
 * @private
 * @const {number}
 * @default
 */
var EPSILON = 1e-12;
exports.EPSILON = EPSILON;

/**
 * @private
 * @enum {number}
 * @readonly
 */
var Orientation = {
    "CW": 1,
    "CCW": -1,
    "COLLINEAR": 0
};
exports.Orientation = Orientation;


/**
 * Formula to calculate signed area<br>
 * Positive if CCW<br>
 * Negative if CW<br>
 * 0 if collinear<br>
 * <pre>
 * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
 *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
 * </pre>
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {Orientation}
 */
function orient2d(pa, pb, pc) {
    var detleft = (pa.x - pc.x) * (pb.y - pc.y);
    var detright = (pa.y - pc.y) * (pb.x - pc.x);
    var val = detleft - detright;
    if (val > -(EPSILON) && val < (EPSILON)) {
        return Orientation.COLLINEAR;
    } else if (val > 0) {
        return Orientation.CCW;
    } else {
        return Orientation.CW;
    }
}
exports.orient2d = orient2d;


/**
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @param {!XY} pd  point object with {x,y}
 * @return {boolean}
 */
function inScanArea(pa, pb, pc, pd) {
    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);
    if (oadb >= -EPSILON) {
        return false;
    }

    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);
    if (oadc <= EPSILON) {
        return false;
    }
    return true;
}
exports.inScanArea = inScanArea;


/**
 * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > /2 || angle < -/2)
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {boolean} true if angle is obtuse
 */
function isAngleObtuse(pa, pb, pc) {
    var ax = pb.x - pa.x;
    var ay = pb.y - pa.y;
    var bx = pc.x - pa.x;
    var by = pc.y - pa.y;
    return (ax * bx + ay * by) < 0;
}
exports.isAngleObtuse = isAngleObtuse;


},{}],11:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/**
 * The following functions operate on "Point" or any "Point like" object with {x,y},
 * as defined by the {@link XY} type
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 * @module
 * @private
 */

/**
 * poly2tri.js supports using custom point class instead of {@linkcode Point}.
 * Any "Point like" object with <code>{x, y}</code> attributes is supported
 * to initialize the SweepContext polylines and points
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 *
 * poly2tri.js might add extra fields to the point objects when computing the
 * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions
 * with fields in the custom class.
 *
 * @example
 *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *
 * @typedef {Object} XY
 * @property {number} x - x coordinate
 * @property {number} y - y coordinate
 */


/**
 * Point pretty printing : prints x and y coordinates.
 * @example
 *      xy.toStringBase({x:5, y:42})
 *      //  "(5;42)"
 * @protected
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toStringBase(p) {
    return ("(" + p.x + ";" + p.y + ")");
}

/**
 * Point pretty printing. Delegates to the point's custom "toString()" method if exists,
 * else simply prints x and y coordinates.
 * @example
 *      xy.toString({x:5, y:42})
 *      //  "(5;42)"
 * @example
 *      xy.toString({x:5,y:42,toString:function() {return this.x+":"+this.y;}})
 *      //  "5:42"
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toString(p) {
    // Try a custom toString first, and fallback to own implementation if none
    var s = p.toString();
    return (s === '[object Object]' ? toStringBase(p) : s);
}


/**
 * Compare two points component-wise. Ordered by y axis first, then x axis.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,
 *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
 *         <code>0</code> otherwise.
 */
function compare(a, b) {
    if (a.y === b.y) {
        return a.x - b.x;
    } else {
        return a.y - b.y;
    }
}

/**
 * Test two Point objects for equality.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
 */
function equals(a, b) {
    return a.x === b.x && a.y === b.y;
}


module.exports = {
    toString: toString,
    toStringBase: toStringBase,
    compare: compare,
    equals: equals
};

},{}]},{},[6])
(6)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/Lau/www/svjelly/src/core/ConfObject.js":[function(require,module,exports){
module.exports = {

	definition: 1,
	worldWidth: 20,
	simRenderFreq: 50,
	gravity: [0, -9.8],
	groups:
	{
		default:
		{
			structure: 'preciseHexaFill',
			innerStructureDef: 0.04,
			physics:
			{
				distanceConstraint:
				{
					stiffness: 500,
					relaxation: 0.1
				},
				nodeRadius: 0.1,
				mass: 1
			}
		},
		line:
		{
			structure: 'line',
			physics:
			{
				distanceConstraint:
				{
					stiffness: 500,
					relaxation: 0.1
				},
				nodeRadius: 0.1,
				mass: 1
			}
		},
		hard:
		{
			physics:
			{
				mass: 1,
				bodyType: 'hard'
			}
		},
		noCollide:
		{
			physics:
			{
				mass: 1,
				bodyType: 'hard',
				noCollide: true
			}
		},
		cloud:
		{
			physics:
			{
				mass: 1,
				gravityScale: 0,
				bodyType: 'hard',
				noCollide: true
			}
		},
		metal:
		{

			physics:
			{
				mass: 10,
				bodyType: 'hard'
			}
		},
		balloon:
		{
			physics:
			{
				mass: 1,
				gravityScale: -1,
				bodyType: 'hard'
			}
		},
		static:
		{
			fixed: true,
			physics:
			{
				mass: 0,
				bodyType: 'hard'
			}
		},
		ghost:
		{
			physics:
			{
				bodyType: 'ghost'
			}
		}
	}
};


},{}],"/Users/Lau/www/svjelly/src/core/Grid.js":[function(require,module,exports){
var Grid =
{
	init: function ($graph)
	{
		this._graph = $graph;
		var nodesArray = this._nodesArray = [];
		this._graph.forEach(function ($line)
		{
			if ($line)
			{
				$line.forEach(function ($node)
				{
					if ($node) { nodesArray.push($node); }
				});
			}
		});
		return this;
	},

	createFromPolygon: function ($polygon, $def, $hexa)
	{
		var boundingBox = $polygon.getBoundingBox();

		var def = $def;
		//var def = width / $def;
		var toReturn = [];
		var yInc = $hexa ? def * (Math.sqrt(3) / 2) : def;
		var halfDef = def * 0.5;
		for (var yPos = boundingBox[0][1]; yPos <= boundingBox[1][1]; yPos += yInc)
		{
			var line = [];
			//var intersections = $polygon.getIntersectionsAtY(yPos);
			var xPos = boundingBox[0][0];
			xPos = ($hexa && toReturn.length % 2 !== 0) ? xPos + halfDef : xPos;
			for (xPos; xPos <= boundingBox[1][0] + halfDef; xPos += def)
			{
				if ($polygon.isInside([xPos, yPos])) { line.push([xPos, yPos]); }
				else { line.push(null); }
			}
			toReturn.push(line);
		}
		return Object.create(Grid).init(toReturn);
	},

	getGraph: function () { return this._graph; },

	getNodesArray: function () { return this._nodesArray; },

	getClosest: function ($x, $y, $size)
	{
		var size = $size || 1;
		var closest = this._nodesArray.concat();
		closest.sort(function ($a, $b)
		{
			if ($a === null || $b === null) { return true; }
			var sideX1 = Math.abs($a[0] - $x);
			var sideY1 = Math.abs($a[1] - $y);
			var dist1 = Math.sqrt(sideX1 * sideX1 + sideY1 * sideY1);

			var sideX2 = Math.abs($b[0] - $x);
			var sideY2 = Math.abs($b[1] - $y);
			var dist2 = Math.sqrt(sideX2 * sideX2 + sideY2 * sideY2);

			return dist1 - dist2;
		});
		return closest.slice(0, size);
	},

	getNeighbours: function ($x, $y, $returnEmpty)
	{
		var toReturn = [];
		var graph = this._graph;
		var even = $y % 2 > 0;
		var left = even ? $x : $x - 1;
		var right = even ? $x + 1 : $x;

		var NE = graph[$y - 1] && graph[$y - 1][right] ? graph[$y - 1][right] : null;
		var E = graph[$y + 0] && graph[$y + 0][$x + 1] ? graph[$y][$x + 1] : null;
		var SE = graph[$y + 1] && graph[$y + 1][right] ? graph[$y + 1][right] : null;
		var SW = graph[$y + 1] && graph[$y + 1][left] ? graph[$y + 1][left] : null;
		var W = graph[$y + 0] && graph[$y + 0][$x - 1] ? graph[$y][$x - 1] : null;
		var NW = graph[$y - 1] && graph[$y - 1][left] ? graph[$y - 1][left] : null;

		if (NE || $returnEmpty) { toReturn.push(NE); }
		if (E || $returnEmpty) { toReturn.push(E); }
		if (SE || $returnEmpty) { toReturn.push(SE); }
		if (SW || $returnEmpty) { toReturn.push(SW); }
		if (W || $returnEmpty) { toReturn.push(W); }
		if (NW || $returnEmpty) { toReturn.push(NW); }

		return toReturn;
	},

	getNetwork: function ()
	{
		var graph = this._graph;
		var network = [];
		var visited = [];
		var i = 0;
		var rowsLength = graph.length;
		for (i; i < rowsLength; i += 1)
		{
			var k = 0;
			var pointsLength = graph[i].length;
			for (k; k < pointsLength; k += 1)
			{
				var currPoint = graph[i][k];
				if (currPoint)
				{
					var currPointNeighbours = this.getNeighbours(k, i);
					for (var m = 0, neighboursLength = currPointNeighbours.length; m < neighboursLength; m += 1)
					{
						var currNeigh = currPointNeighbours[m];
						if (currNeigh && visited.indexOf(currNeigh) === -1)
						{
							network.push([currPoint, currNeigh]);
						}
					}
					visited.push(currPoint);
				}
			}
		}
		return network;
	},

	getOutline: function ()
	{
		if (!this.outline)
		{
			var graph = this._graph;
			var outlineGraph = [];
			for (var i = 0, rowsLength = graph.length; i < rowsLength; i += 1)
			{
				outlineGraph[i] = [];
				for (var k = 0, pointsLength = graph[i].length; k < pointsLength; k += 1)
				{
					var point = graph[i][k];
					outlineGraph[i][k] = null;
					if (point)
					{
						var isEdge = this.getNeighbours(k, i).length < 6;
						if (isEdge)
						{
							outlineGraph[i][k] = [k, i];
						}
					}
				}
			}
			this.outline = Object.create(Grid).init(outlineGraph);
		}

		return this.outline;
	},

	getShapePath: function ()
	{
		var path = [];
		var currentOutline = this.getOutlines()[0];
		var outlineGraph = currentOutline.getGraph();
		var getStartingIndex = function ()
		{
			for (var i = 0, length = outlineGraph.length; i < length; i += 1)
			{
				if (!outlineGraph[i]) { continue; }
				for (var k = 0, pointsLength = outlineGraph[i].length; k < pointsLength; k += 1)
				{
					var currPoint = outlineGraph[i][k];
					if (currPoint)
					{
						console.log(currPoint, currentOutline.getNeighbours(currPoint[0], currPoint[1]));
					}
					if (currPoint && currentOutline.getNeighbours(currPoint[0], currPoint[1]).length === 2)
					{
						return currPoint;
					}
				}
			}
		};

		var visited = [];
		var startingIndex = getStartingIndex.call(this);
		console.log(startingIndex);
		debugger;
		if (!startingIndex) { return; }

		var getAngle = function ($index)
		{
			var angle = ($index + 1) * 60;
			angle = angle === 0 ? 360 : angle;
			return angle;
		};
		var getNeighbourIndex = function ($point, $neighbour)
		{
			return currentOutline.getNeighbours($point[0], $point[1], true).indexOf($neighbour);
		};

		var next = currentOutline.getNeighbours(startingIndex[0], startingIndex[1])[0];
		var lastAngle = getAngle(getNeighbourIndex(startingIndex, next));
		var currIndex = next;
		path.push(this._graph[startingIndex[1]][startingIndex[0]]);
		path.push(this._graph[next[1]][next[0]]);
		visited.push(startingIndex);

		var best;
		var neighbours;
		var bestAngle;
		var outlineNodesArray = currentOutline.getNodesArray();
		var outlinePointsLength = outlineNodesArray.length;

		while (visited.length < outlinePointsLength - 1)//currIndex !== startingIndex)
		{
			neighbours = currentOutline.getNeighbours(currIndex[0], currIndex[1]);
			var bestScore = 0;
			best = undefined;

			for (var i = 0, length = neighbours.length; i < length; i += 1)
			{
				var currNeigh = neighbours[i];
				var currScore = 0;
				var currAngle = getAngle(getNeighbourIndex(currIndex, currNeigh));
				currScore = currAngle - lastAngle;
				if (currScore > 180) { currScore = currScore - 360; }
				if (currScore < -180) { currScore = currScore + 360; }
				var neighIndex = visited.indexOf(currNeigh);
				if (neighIndex !== -1) { currScore = neighIndex / visited.length * 10000 + 10000 + currScore; }
				if (!best || currScore < bestScore)
				{
					bestScore = currScore;
					best = currNeigh;
					bestAngle = currAngle;
				}
			}
			lastAngle = bestAngle;
			if (visited.indexOf(currIndex) !== -1) { visited.splice(visited.indexOf(currIndex), 1); }
			visited.push(currIndex);
			currIndex = best;

			path.push(this._graph[currIndex[1]][currIndex[0]]);
		}
		return path;
	},

	getOutlines: function ()
	{
		var toReturn = [];
		var currentGraph;
		var outline = this.getOutline();
		var remaining = outline.getNodesArray().concat();

		var recur = function ($point)
		{
			currentGraph[$point[1]] = currentGraph[$point[1]] || [];
			currentGraph[$point[1]][$point[0]] = $point;
			var neighbours = outline.getNeighbours($point[0], $point[1]);
			remaining.splice(remaining.indexOf($point), 1);
			for (var i = 0, length = neighbours.length; i < length; i += 1)
			{
				var neigh = neighbours[i];
				if (remaining.indexOf(neigh) !== -1) { recur(neigh); }
			}
		};

		while (remaining.length)
		{
			currentGraph = [];
			var startingPoint = remaining[0];
			recur(startingPoint);
			toReturn.push(Object.create(Grid).init(currentGraph));
		}
		return toReturn;
	}
};

module.exports = Grid;


},{}],"/Users/Lau/www/svjelly/src/core/Polygon.js":[function(require,module,exports){
var Polygon =
{
	init: function ($points)
	{
		var polygon = Object.create(Polygon);
		polygon.points = $points;
		polygon._boundingBox = undefined;
		return polygon;
	},

	getArea: function ()
	{
		var sumA = 0;
		var sumB = 0;
		for (var i = 0, length = this.points.length; i < length; i += 1)
		{
			var currPoint = this.points[i];
			var next = i === length - 1 ? this.points[0] : this.points[i + 1];
			sumA += currPoint[0] * next[1];
			sumB += currPoint[1] * next[0];
		}

		return Math.abs((sumA - sumB) * 0.5);
	},

	getBoundingBox: function ()
	{
		if (!this._boundingBox)
		{
			var minX = this.points[0][0];
			var maxX = minX;
			var minY = this.points[0][1];
			var maxY = minY;

			for (var i = 0, length = this.points.length; i < length; i += 1)
			{
				var point = this.points[i];
				minX = Math.min(minX, point[0]);
				maxX = Math.max(maxX, point[0]);
				minY = Math.min(minY, point[1]);
				maxY = Math.max(maxY, point[1]);
			}
			this._boundingBox = [[minX, minY], [maxX, maxY]];
		}
		return this._boundingBox;
	},

	getSegments: function ()
	{
		var segments = [];
		for (var i = 0, length = this.points.length - 1; i < length; i += 1)
		{
			segments.push([this.points[i], this.points[i + 1]]);
		}
		segments.push([this.points[this.points.length - 1], this.points[0]]);
		return segments;
	},

	getIntersectionsAtY: function ($testY)
	{
		var segments = this.getSegments();
		var intersections = [];
		for (var i = 0, length = segments.length; i < length; i += 1)
		{
			var currSegment = segments[i];
			var x1 = currSegment[0][0];
			var y1 = currSegment[0][1];
			var x2 = currSegment[1][0];
			var y2 = currSegment[1][1];
			var smallY = Math.min(y1, y2);
			var bigY = Math.max(y1, y2);

			if ($testY > smallY && $testY < bigY)
			{
				var pY = y2 - $testY;
				var segY = y2 - y1;
				var segX = x2 - x1;
				var pX = pY * segX / segY;
				intersections.push(x2 - pX);
			}
		}
		return intersections;
	},

	isInside: function ($point)
	{
		var infNumber = 0;
		var intersections = this.getIntersectionsAtY($point[1]);
		for (var i = 0, length = intersections.length; i < length; i += 1)
		{
			if ($point[0] < intersections[i]) { infNumber += 1; }
		}
		return infNumber % 2 > 0;
	}
};

module.exports = Polygon;


},{}],"/Users/Lau/www/svjelly/src/core/SVGParser.js":[function(require,module,exports){

var SVGParser = function () {};
//var isPolygon = /polygon|rect/ig;
var isLine = /polyline|line|path/ig;
var lineTags = 'polyline, line, path';

SVGParser.prototype.parse = function ($world, $SVG)
{
	this.SVG = $SVG;
	this.viewBoxWidth = Number(this.SVG.getAttribute('viewBox').split(' ')[2]);
	this.viewBoxHeight = Number(this.SVG.getAttribute('viewBox').split(' ')[3]);
	this.ratio = $world.getWidth() / this.viewBoxWidth;
	this.world = $world;
	this.world.setHeight(this.viewBoxHeight * this.ratio);

	//temp
	var elementsQuery = '*:not(g):not(linearGradient):not(radialGradient):not(stop):not([id*="joint"]):not([id*="constraint"])';
	var elemRaws = this.SVG.querySelectorAll(elementsQuery);

	var i = 0;
	var rawGroupPairings = [];
	var elemsLength = elemRaws.length;

	for (i = 0; i < elemsLength; i += 1)
	{
		var rawElement = elemRaws[i];
		//if (rawElement.nodeType === 3) { continue; }
		var groupInfos = this.getGroupInfos(rawElement);
		var currGroup = $world.createGroup(groupInfos.type, groupInfos.ID);

		//var elements = rawElement;
		//this.parseElements(elements, currGroup);

		var element = this.parseElement(rawElement);
		var nodesToDraw = currGroup.structure.create(element);
		this.setGraphicInstructions(currGroup, rawElement, nodesToDraw, element);

		// var hasGroup;
		// for (var k = 0, length = rawGroupPairings.length; k < length; k += 1)
		// {
		// 	var curr = rawGroupPairings[k];
		// 	if (curr.group === currGroup)
		// 	{
		// 		hasGroup = true;
		// 		break;
		// 	}
		// }
		// if (!hasGroup) { rawGroupPairings.push({ group: currGroup, raw: rawElement.parentNode }); }
		rawGroupPairings.push({ group: currGroup, raw: rawElement.parentNode });
	}

	var pairingsLength = rawGroupPairings.length;
	for (i = 0; i < pairingsLength; i += 1)
	{
		var pairing = rawGroupPairings[i];
		// this.parseAnchors(pairing.raw, pairing.group);
		this.parseConstraints(pairing.raw, pairing.group);
		this.parseCustomJoints(pairing.raw, pairing.group);
	}

	this.world.addGroupsToWorld();
};

SVGParser.prototype.getGroupInfos = function ($rawGroup)
{
	var groupElement = !$rawGroup.id && $rawGroup.parentNode.tagName !== 'svg' ? $rawGroup.parentNode : $rawGroup;
	var type;
	var ID;
	var regex = /([a-z\d]+)\w*/igm;
	var first = regex.exec(groupElement.id);
	var second = regex.exec(groupElement.id);
	//if (first) { type = second ? second[1] : first[1]; }
	//var groupType = groupElement.id.match();
	//if (groupType) { return groupType[1] || groupType[0]; }
	//automatic for lines
	if (!first && (groupElement.querySelectorAll(lineTags).length > 0 || groupElement.tagName.search(isLine) > -1))
	{
		type = 'line';
	}
	type = first ? first[1] : undefined;
	ID = second ? second[1] : null;

	return { ID: ID, type: type };
};

SVGParser.prototype.parseConstraints = function ($rawGroup, $group)
{
	var children = $rawGroup.childNodes;//$rawGroup.querySelectorAll('[id*="constraint"]');

	for (var i = 0, childrenLength = children.length; i < childrenLength; i += 1)
	{
		if (children[i].nodeType === Node.TEXT_NODE || children[i].id.search(/constraint/i) < 0) { continue; }
		var currConstraint = children[i];
		var result = /constraint-([a-z\d]*)/ig.exec(currConstraint.id);

		var parentGroupID = result ? result[1] : undefined;
		var parentGroup = parentGroupID ? this.world.getGroupByID(parentGroupID) : undefined;
		var points = this.parseElement(currConstraint).points;
		// console.log($group.ID, parentGroup ? parentGroup.ID : undefined);
		this.world.constrainGroups($group, parentGroup, points);
	}
};

SVGParser.prototype.parseElements = function ($elements, $group)
{
	for (var i = 0, elementsLength = $elements.length; i < elementsLength; i += 1)
	{
		var rawElement = $elements[i];

		var element = this.parseElement(rawElement);

		var nodesToDraw = $group.structure.create(element);
		this.setGraphicInstructions($group, rawElement, nodesToDraw, element);
	}
};

SVGParser.prototype.parseElement = function ($rawElement)
{
	var tagName = $rawElement.tagName;

	switch (tagName)
	{
		case 'line':
			return this.parseLine($rawElement);
		case 'rect':
			return this.parseRect($rawElement);

		case 'polygon':
		case 'polyline':
			return this.parsePoly($rawElement);

		case 'path':
			return this.parsePath($rawElement);

		case 'circle':
			return this.parseCircle($rawElement);
	}
};

SVGParser.prototype.setGraphicInstructions = function ($group, $rawElement, $nodes)
{
	for (var i = 0, length = $nodes.length; i < length; i += 1)
	{
		var currNode = $nodes[i];
		currNode.drawing = {};
		$group.nodes.splice($group.nodes.indexOf(currNode), 1);
		$group.nodes.splice(i, 0, currNode);
		// console.log($group.nodes.indexOf(currNode));
		// debugger;
	}
	var startNode = $nodes[0];
	var endNode = $nodes[$nodes.length - 1];

	var fill = $rawElement.getAttribute('fill') || '#000000';
	var stroke = $rawElement.getAttribute('stroke') || 'none';
	var lineWidth = $rawElement.getAttribute('stroke-width');
	var opacity = $rawElement.getAttribute('opacity');
	startNode.drawing.fill = fill;//fill === undefined ? 'none' : fill;
	startNode.drawing.stroke = stroke;
	startNode.drawing.radius = $group.structureProperties.radius / this.ratio;
	startNode.drawing.lineWidth = lineWidth * this.ratio || 1 * this.ratio;//lineWidth === undefined ? 'none' : lineWidth * this.ratio;
	startNode.drawing.lineCap = $rawElement.getAttribute('stroke-linecap') || 'round';
	startNode.drawing.lineJoin = $rawElement.getAttribute('stroke-linejoin') || 'round';
	startNode.drawing.opacity = opacity ? opacity : undefined;
	startNode.drawing.closePath = $group.type !== 'line' && $group.structureProperties.radius === undefined;

	startNode.drawing.strokeGradient = this.getGradient(stroke);
	startNode.drawing.fillGradient = this.getGradient(fill);

	startNode.endNode = endNode;
	startNode.isStart = true;
};

SVGParser.prototype.getGradient = function ($value)
{
	var gradientID = /url\(#(.*)\)/im.exec($value);
	if (gradientID)
	{
		var gradientElement = this.SVG.querySelector('#' + gradientID[1]);
		if (gradientElement.tagName !== 'linearGradient' && gradientElement.tagName !== 'radialGradient') { return; }

		var gradient = { stops: [], type: gradientElement.tagName };

		if (gradientElement.tagName === 'linearGradient')
		{
			gradient.x1 = this.getCoordX(gradientElement.getAttribute('x1'));
			gradient.y1 = this.getCoordX(gradientElement.getAttribute('y1'));
			gradient.x2 = this.getCoordX(gradientElement.getAttribute('x2'));
			gradient.y2 = this.getCoordX(gradientElement.getAttribute('y2'));
		}
		if (gradientElement.tagName === 'radialGradient')
		{
			gradient.cx = this.getCoordX(gradientElement.getAttribute('cx'));
			gradient.cy = this.getCoordX(gradientElement.getAttribute('cy'));
			gradient.fx = this.getCoordX(gradientElement.getAttribute('fx'));
			gradient.fy = this.getCoordX(gradientElement.getAttribute('fy'));
			gradient.r = this.getCoordX(gradientElement.getAttribute('r'));
		}

		var stops = gradientElement.querySelectorAll('stop');
		for (var k = 0, stopLength = stops.length; k < stopLength; k += 1)
		{
			var currStop = stops[k];
			var offset = Number(currStop.getAttribute('offset'));
			var color = /stop-color:(#[0-9A-F]+)/im.exec(currStop.getAttribute('style'))[1];
			gradient.stops.push({ offset: offset, color: color });
		}

		return gradient;
	}
};

SVGParser.prototype.parseCircle = function ($rawCircle)
{
	var xPos = this.getCoordX($rawCircle.getAttribute('cx'));
	var yPos = this.getCoordY($rawCircle.getAttribute('cy'));
	var radius = this.getCoordX($rawCircle.getAttribute('r'));
	return { type: 'circle', points: [[xPos, yPos]], radius: radius };
};

SVGParser.prototype.parseLine = function ($rawLine)
{
	var x1 = this.getCoordX($rawLine.getAttribute('x1'));
	var x2 = this.getCoordX($rawLine.getAttribute('x2'));
	var y1 = this.getCoordX($rawLine.getAttribute('y1'));
	var y2 = this.getCoordX($rawLine.getAttribute('y2'));
	var points = [];
	points.push([x1, y1]);
	points.push([x2, y2]);
	var thickness = this.getCoordX($rawLine.getAttribute('stroke-width'));
	return { type: 'line', points: points, thickness: thickness };
};

SVGParser.prototype.parseRect = function ($rawRect)
{
	var x1 = $rawRect.getAttribute('x') ? this.getCoordX($rawRect.getAttribute('x')) : 0;
	var y1 = $rawRect.getAttribute('y') ? this.getCoordY($rawRect.getAttribute('y')) : 0;
	var x2 = x1 + this.getCoordX($rawRect.getAttribute('width'));
	var y2 = y1 + this.getCoordY($rawRect.getAttribute('height'));
	var points = [];
	points.push([x1, y1]);
	points.push([x1, y2]);
	points.push([x2, y2]);
	points.push([x2, y1]);

	return { type: 'polygon', points: points };
};

SVGParser.prototype.parsePoly = function ($rawPoly)
{
	var splits = $rawPoly.getAttribute('points').split(' ');
	var points = [];

	for (var i = 0, splitsLength = splits.length; i < splitsLength; i += 1)
	{
		var currSplit = splits[i];

		if (currSplit !== '')
		{
			var point = currSplit.split(',');
			var pointX = this.getCoordX(point[0]);
			var pointY = this.getCoordY(point[1]);
			var exists = false;
			for (var k = 0, otherCoordsArrayLength = points.length; k < otherCoordsArrayLength; k += 1)
			{
				var otherPoint = points[k];
				var otherX = otherPoint[0];
				var otherY = otherPoint[1];
				if (otherX === pointX && otherY === pointY)
				{
					exists = true;
				}
			}
			if (exists === false)
			{
				points.push([pointX, pointY]);
			}
		}
	}

	var thickness = this.getCoordX($rawPoly.getAttribute('stroke-width'));
	var type = $rawPoly.tagName === 'polyline' ? 'line' : 'polygon';
	return { type: type, points: points, thickness: thickness };
};

SVGParser.prototype.parsePath = function ($rawPath)
{
	var d = $rawPath.getAttribute('d');
	var pathReg = /([mlscvh])(-?[\d\.]*[,-]+[\d\.]*),?(-?[\d\.]*,?-?[\d\.]*),?(-?[\d\.]*,?-?[\d\.]*)/igm;
	var points = [];
	var lastCoordX = this.getCoordX(0);
	var lastCoordY = this.getCoordY(0);
	for (var array = pathReg.exec(d); array !== null; array = pathReg.exec(d))
	{
		var coordString;
		var numberCoordX;
		var numberCoordY;
		if (array[1] === 'v')
		{
			numberCoordX = lastCoordX;
			numberCoordY = lastCoordY + this.getCoordY(array[2]);
		}
		else if (array[1] === 'h')
		{
			numberCoordX = lastCoordX + this.getCoordY(array[2]);
			numberCoordY = lastCoordY;
		}
		else
		{
			if (array[4] !== '')
			{
				coordString = array[4];
			}
			else if (array[3] !== '')
			{
				coordString = array[3];
			}
			else
			{
				coordString = array[2];
			}
			var coordReg = /(-?\d+\.?\d*)/igm;
			var coords = coordString.match(coordReg);

			numberCoordX = lastCoordX + this.getCoordX(coords[0]);
			numberCoordY = lastCoordY + this.getCoordY(coords[1]);
		}
		//console.log(numberCoordX, numberCoordY);
		points.push([numberCoordX, numberCoordY]);

		lastCoordX = numberCoordX;
		lastCoordY = numberCoordY;
	}

	var thickness = this.getCoordX($rawPath.getAttribute('stroke-width'));
	return { type: 'line', points: points, thickness: thickness };
};

SVGParser.prototype.round = function ($number)
{
	// var number = Number($number);
	// return Math.floor(number * 100) / 100;
	return $number;
	//return Math.floor(Number($number));
};

SVGParser.prototype.getCoordX = function ($coordSTR)
{
	var number = this.round($coordSTR);
	return number * this.ratio;
};

SVGParser.prototype.getCoordY = function ($coordSTR)
{
	var number = this.round($coordSTR);
	//number = this.viewBoxHeight - number;
	return number * this.ratio;
};

SVGParser.prototype.parseCustomJoints = function ($rawGroup, $group)
{
	var children = $rawGroup.childNodes;//$rawGroup.querySelectorAll('[id*="constraint"]');

	for (var i = 0, childrenLength = children.length; i < childrenLength; i += 1)
	{
		if (children[i].nodeType === Node.TEXT_NODE || children[i].id.search(/joint/i) < 0) { continue; }

		var currRawJoint = children[i];
		var p1x = this.getCoordX(currRawJoint.getAttribute('x1'));
		var p1y = this.getCoordY(currRawJoint.getAttribute('y1'));
		var p2x = this.getCoordX(currRawJoint.getAttribute('x2'));
		var p2y = this.getCoordY(currRawJoint.getAttribute('y2'));

		var n1 = $group.getNodeAtPoint(p1x, p1y) || $group.createNode(p1x, p1y);
		var n2 = $group.getNodeAtPoint(p2x, p2y) || $group.createNode(p2x, p2y);
		$group.createJoint(n1, n2);
	}
};

module.exports = SVGParser;


},{}],"/Users/Lau/www/svjelly/src/core/SVJellyGroup.js":[function(require,module,exports){
var SVJellyNode = require('./SVJellyNode');
var SVJellyJoint = require('./SVJellyJoint');

var SVJellyGroup = function ($type, $conf, $ID)
{
	this.physicsManager = undefined;
	this.structure = undefined;
	this.conf = $conf;
	this.type = $type;
	this.nodes = [];
	this.joints = [];
	this.ID = $ID;
};

SVJellyGroup.prototype.getNodeAtPoint = function ($x, $y)
{
	for (var i = 0, nodesLength = this.nodes.length; i < nodesLength; i += 1)
	{
		var node = this.nodes[i];

		if (node.oX === $x && node.oY === $y)
		{
			return node;
		}
	}
};

SVJellyGroup.prototype.createNode = function ($px, $py, $options, $overwrite)
{
	var node = this.getNodeAtPoint($px, $py);
	if (node !== undefined && $overwrite)
	{
		node.setOptions($options);
	}
	else
	{
		node = new SVJellyNode($px, $py, $options);
		this.nodes.push(node);
	}

	//this.physicsManager.addNodeToWorld(node);

	return node;
};

SVJellyGroup.prototype.getClosestPoint = function ($points, $nodes)
{
	var nodes = $nodes || this.nodes;
	var closestDist = Infinity;
	var closestPoint;
	var closestNode;
	var closestOffsetX;
	var closestOffsetY;

	for (var i = 0, length = $points.length; i < length; i += 1)
	{
		var currPoint = $points[i];
		for (var k = 0, nodesLength = nodes.length; k < nodesLength; k += 1)
		{
			var currNode = nodes[k];
			var offsetX = currPoint[0] - currNode.oX;
			var offsetY = currPoint[1] - currNode.oY;
			var cX = Math.abs(offsetX);
			var cY = Math.abs(offsetY);
			var dist = Math.sqrt(cX * cX + cY * cY);
			if (dist < closestDist)
			{
				closestNode = currNode;
				closestPoint = currPoint;
				closestDist = dist;
				closestOffsetX = offsetX;
				closestOffsetY = offsetY;
			}
		}
	}

	return closestPoint;
};

SVJellyGroup.prototype.getClosestNode = function ($coord, $nodes)
{
	var nodes = $nodes || this.nodes;
	var closestDist = Infinity;
	var closest;
	for (var i = 0, length = nodes.length; i < length; i += 1)
	{
		var node = nodes[i];
		var offsetX = $coord[0] - node.oX;
		var offsetY = $coord[1] - node.oY;
		var cX = Math.abs(offsetX);
		var cY = Math.abs(offsetY);
		var dist = Math.sqrt(cX * cX + cY * cY);
		if (dist < closestDist)
		{
			closest = node;
			closestDist = dist;
		}
	}
	return closest;
};

SVJellyGroup.prototype.getNodesInside = function ($points)
{
	var Polygon = require('./Polygon');
	var toReturn = [];
	var polygon = Polygon.init($points);
	for (var i = 0, length = this.nodes.length; i < length; i += 1)
	{
		var node = this.nodes[i];
		if (polygon.isInside([node.oX, node.oY]))
		{
			toReturn.push(node);
		}
	}
	return toReturn;
};

SVJellyGroup.prototype.getBoundingBox = function ()
{
	var minX;
	var maxX;
	var minY;
	var maxY;
	for (var i = 0, length = this.nodes.length; i < length; i += 1)
	{
		var node = this.nodes[i];
		minX = minX > node.oX || minX === undefined ? node.oX : minX;
		maxX = maxX < node.oX || maxX === undefined ? node.oX : maxX;
		minY = minY > node.oY || minY === undefined ? node.oY : minY;
		maxY = maxY < node.oY || maxY === undefined ? node.oY : maxY;
	}
	return [[minX, minY], [maxX, maxY]];
};

//TODO : to remove
SVJellyGroup.prototype.hitTest = function ($point)
{
	var currX = $point[0];
	var currY = $point[1];
	var bounding = this.getBoundingBox();
	if (currX >= bounding[0][0] && currX <= bounding[1][0] &&
		currY >= bounding[0][1] && currY <= bounding[1][1])
	{
		return true;
	}
	return false;
};

SVJellyGroup.prototype.createJoint = function ($node1, $node2)
{
	for (var i = 0, jointsLength = this.joints.length; i < jointsLength; i += 1)
	{
		var currJoint = this.joints[i];
		if ((currJoint.node1 === $node1 && currJoint.node2 === $node2) || (currJoint.node2 === $node1 && currJoint.node1 === $node2))
		{
			return;
		}
	}

	var joint = new SVJellyJoint($node1, $node2);

	this.joints.push(joint);

	//this.physicsManager.addJointToWorld(joint);
};

SVJellyGroup.prototype.createNodesFromPoints = function ($coordsArray)
{
	var coordsArrayLength = $coordsArray.length;
	var toReturn = [];
	for (var i = 0; i < coordsArrayLength; i += 1)
	{
		var currPoint = $coordsArray[i];
		toReturn.push(this.createNode(currPoint[0], currPoint[1], undefined, false));
	}
	return toReturn;
};

SVJellyGroup.prototype.getBestMatchForGroupConstraint = function ($points, $anchor)
{
	return this.physicsManager.getBestMatchForGroupConstraint($points, $anchor);
};

SVJellyGroup.prototype.createJointsFromPoints = function ($coordsArray, $noClose)
{
	var coordsArrayLength = $coordsArray.length;
	for (var i = 1; i < coordsArrayLength; i += 1)
	{
		var currPoint = $coordsArray[i];
		var lastPoint = $coordsArray[i - 1];
		var lastNode = this.getNodeAtPoint(lastPoint[0], lastPoint[1]);
		var currNode = this.getNodeAtPoint(currPoint[0], currPoint[1]);
		this.createJoint(lastNode, currNode);
		if (i === coordsArrayLength - 1 && $noClose !== true)
		{
			var firstNode = this.getNodeAtPoint($coordsArray[0][0], $coordsArray[0][1]);
			this.createJoint(currNode, firstNode);
		}
	}
};

SVJellyGroup.prototype.addNodesToWorld = function ()
{
	this.physicsManager.addNodesToWorld();
};

SVJellyGroup.prototype.addJointsToWorld = function ()
{
	this.physicsManager.addJointsToWorld();
};

module.exports = SVJellyGroup;


},{"./Polygon":"/Users/Lau/www/svjelly/src/core/Polygon.js","./SVJellyJoint":"/Users/Lau/www/svjelly/src/core/SVJellyJoint.js","./SVJellyNode":"/Users/Lau/www/svjelly/src/core/SVJellyNode.js"}],"/Users/Lau/www/svjelly/src/core/SVJellyJoint.js":[function(require,module,exports){
var SVJellyJoint = function ($node1, $node2)
{
	this.node1 = $node1;
	this.node2 = $node2;
};

module.exports = SVJellyJoint;


},{}],"/Users/Lau/www/svjelly/src/core/SVJellyNode.js":[function(require,module,exports){
var SVJellyNode = function ($oX, $oY, $options)
{
	this.jointsArray = [];
	this.oX = $oX;
	this.oY = $oY;
	this.drawing = undefined;
	this.fixed = false;
	this.isStart = false;
	this.endNode = undefined;
	this.setOptions($options);
};

//raccourci
SVJellyNode.prototype.setOptions = function ($options)
{
	if ($options)
	{
		// var = $ === undefined ? {} : $options;
		if ($options.fixed !== undefined) { this.fixed = $options.fixed; }
	}
};

SVJellyNode.prototype.setFixed = function ($fixed)
{
	this.fixed = $fixed;
	this.physicsManager.setFixed($fixed);
};

SVJellyNode.prototype.getX = function ()
{
	return this.physicsManager.getX();
};

//raccourci
SVJellyNode.prototype.getY = function ()
{
	return this.physicsManager.getY();
};

module.exports = SVJellyNode;


},{}],"/Users/Lau/www/svjelly/src/core/SVJellyUtils.js":[function(require,module,exports){
module.exports = {
	extend: function ($toExtend, $extension)
	{
		var recur = function ($object, $extend)
		{
			for (var name in $extend)
			{
				if (typeof $extend[name] === 'object' && !Array.isArray($extend[name]) && $extend[name] !== null)
				{
					if ($object[name] === undefined) { $object[name] = {}; }
					recur($object[name], $extend[name]);
				}
				else
				{
					$object[name] = $extend[name];
				}
			}
		};
		recur($toExtend, $extension);

		return $toExtend;
	}
};


},{}],"/Users/Lau/www/svjelly/src/core/SVJellyWorld.js":[function(require,module,exports){
var SVJellyGroup = require('./SVJellyGroup');
var Structure = require('./Structure');

var SVJellyWorld = function ($physicsManager, $conf)
{
	this.physicsManager = $physicsManager;
	this.groupsArray = [];
	this.conf = $conf;
	this.worldNodes = [];
	this.groupConstraints = [];
	this.worldWidth = this.physicsManager.worldWidth = $conf.worldWidth;
};

SVJellyWorld.prototype.setHeight = function ($height)
{
	this.worldHeight = this.physicsManager.worldHeight = $height;
};

SVJellyWorld.prototype.getWidth = function ()
{
	return this.worldWidth;
};

SVJellyWorld.prototype.getGroupByID = function ($ID)
{
	for (var i = 0, length = this.groupsArray.length; i < length; i += 1)
	{
		var currGroup = this.groupsArray[i];
		if (currGroup.ID === $ID) { return currGroup; }
	}
};

SVJellyWorld.prototype.createGroup = function ($type, $ID)
{
	var type = $type || 'default';
	var group = new SVJellyGroup(type, this.conf.groups[type], $ID);
	group.physicsManager = this.physicsManager.getGroupPhysicsManager(group);
	group.structure = new Structure(group, this);
	this.groupsArray.push(group);
	return group;
};

SVJellyWorld.prototype.constrainGroups = function ($groupA, $groupB, $points)
{
	var points = $points;
	var groupA = $groupA;
	var groupB = $groupB;

	if (points.length < 3)
	{
		var anchorA = groupA.physicsManager.createAnchorFromLine(points);
		points.splice(points.indexOf(anchorA.point), 1);
		var anchorB = groupB ? groupB.physicsManager.createAnchorFromPoint(points[0]) : this.physicsManager.getAnchorPhysicsManager(points[0]);
		this.groupConstraints.push({ anchorA: anchorA, anchorB: anchorB });
	}
	else
	{
		var anchorsA = groupA.physicsManager.createAnchors(points);
		//console.log('A', groupA.ID, anchorsA.length, 'B', groupB ? groupB.ID : groupB);
		for (var i = 0, nodesLength = anchorsA.length; i < nodesLength; i += 1)
		{
			var currAnchorA = anchorsA[i];
			if (!groupB)
			{
				currAnchorA.setFixed(true);
			}
			else
			{
				var anchorsB = groupB.physicsManager.createAnchors(points);
				for (var k = 0, anchorsBLength = anchorsB.length; k < anchorsBLength; k += 1)
				{
					var currAnchorB = anchorsB[k];
					this.groupConstraints.push({ anchorA: currAnchorA, anchorB: currAnchorB });
				}
			}
		}
	}
};

SVJellyWorld.prototype.addGroupsToWorld = function ()
{
	for (var i = 0, groupsArrayLength = this.groupsArray.length; i < groupsArrayLength; i += 1)
	{
		var currGroup = this.groupsArray[i];
		currGroup.addNodesToWorld();
		currGroup.addJointsToWorld();
		this.worldNodes = this.worldNodes.concat(currGroup.nodes);
	}

	var toConstrainLength = this.groupConstraints.length;
	for (i = 0; i < toConstrainLength; i += 1)
	{
		var currToConstrain = this.groupConstraints[i];
		this.physicsManager.constrainGroups(currToConstrain.anchorA, currToConstrain.anchorB);
	}
};

module.exports = SVJellyWorld;


},{"./SVJellyGroup":"/Users/Lau/www/svjelly/src/core/SVJellyGroup.js","./Structure":"/Users/Lau/www/svjelly/src/core/Structure.js"}],"/Users/Lau/www/svjelly/src/core/Structure.js":[function(require,module,exports){
var Triangulator = require('./Triangulator');
var Polygon = require('./Polygon');
var Grid = require('./Grid');

var Structure = function ($group, $world)
{
	this.world = $world;
	this.group = $group;
	this.innerStructure = undefined;
};

Structure.prototype.create = function ($properties)
{
	var nodesToDraw;
	var points = $properties.points;
	this.group.structureProperties = $properties;

	if ($properties.type === 'polygon')
	{
		var polygon = Polygon.init(points);
		this.group.structureProperties.area = polygon.getArea();
	}
	else if ($properties.type === 'line')
	{
		var area = 0;
		for (var i = 1, length = this.points.length; i < length; i += 1)
		{
			var currPoint = this.points[i];
			var lastPoint = this.points[i - 1];
			var dX = Math.abs(currPoint[0] - lastPoint[0]);
			var dY = Math.abs(currPoint[1] - lastPoint[1]);
			area += Math.sqrt(dX * dX + dY * dY);
		}
		this.group.structureProperties.area = area;
	}
	else if ($properties.type === 'circle')
	{
		this.group.structureProperties.area = Math.pow(Math.PI * $properties.radius, 2);
	}

	switch (this.group.conf.structure)
	{
		case 'triangulate':
			nodesToDraw = this.group.createNodesFromPoints(points);
			this.createJointsFromTriangles(points);
			break;
		case 'line':
			nodesToDraw = this.group.createNodesFromPoints(points);
			this.group.createJointsFromPoints(points, true);
			//nodesToDraw[0].fixed = true;//to remove later maybe ?
			break;
		case 'preciseHexaFill':
			nodesToDraw = this.createPreciseHexaFillStructure(points);
			// structureNodes.forEach(function ($element) { $element.drawing = { notToDraw: true }; });
			break;
		case 'hexaFill':
			nodesToDraw = this.createHexaFillStructure(points);
			break;
		default:
			nodesToDraw = this.group.createNodesFromPoints(points);
			break;
	}

	return nodesToDraw;
};

Structure.prototype.createHexaFillStructure = function ($coordsArray)
{
	this.createInnerStructure($coordsArray);
	var path = this.innerStructure.getShapePath();
	var nodesToDraw = [];
	for (var i = 0, length = path.length; i < length; i += 1)
	{
		nodesToDraw.push(this.group.getNodeAtPoint(path[i][0], path[i][1]));
	}
	return nodesToDraw;
};

Structure.prototype.createPreciseHexaFillStructure = function ($coordsArray)
{
	var nodesToDraw = this.group.createNodesFromPoints($coordsArray);
	this.createInnerStructure($coordsArray);

	this.group.createJointsFromPoints($coordsArray, false);
	var i = 0;
	var length = $coordsArray.length;
	for (i; i < length; i += 1)
	{
		var currPoint = $coordsArray[i];
		var closest = this.innerStructure.getClosest(currPoint[0], currPoint[1], 2);
		for (var k = 0, closestLength = closest.length; k < closestLength; k += 1)
		{
			var currClosest = closest[k];
			var n1 = this.group.getNodeAtPoint(currPoint[0], currPoint[1]);
			var n2 = this.group.getNodeAtPoint(currClosest[0], currClosest[1]);
			this.group.createJoint(n1, n2);
		}
	}
	return nodesToDraw;
};

Structure.prototype.createJointsFromTriangles = function ($coordsArray)
{
	var triangulator = new Triangulator();
	var triangles = triangulator.triangulate($coordsArray);

	var trianglesLength = triangles.length;
	for (var i = 0; i < trianglesLength; i += 1)
	{
		var currTriangle = triangles[i];
		var n0 = this.group.getNodeAtPoint(currTriangle[0].x, currTriangle[0].y);
		var n1 = this.group.getNodeAtPoint(currTriangle[1].x, currTriangle[1].y);
		var n2 = this.group.getNodeAtPoint(currTriangle[2].x, currTriangle[2].y);
		this.group.createJoint(n0, n1);
		this.group.createJoint(n1, n2);
		this.group.createJoint(n2, n0);
	}
};

Structure.prototype.createInnerStructure = function ($coordsArray)
{
	var polygon = Polygon.init($coordsArray);
	var diam = this.world.getWidth() * this.group.conf.innerStructureDef;//width / 10;//this.world.getWidth() / 30;
	this.innerStructure = Grid.createFromPolygon(polygon, diam, true);
	var structureNodes = this.group.createNodesFromPoints(this.innerStructure.getNodesArray());

	var network = this.innerStructure.getNetwork();
	var i = 0;
	var length = network.length;
	for (i; i < length; i += 1)
	{
		var currLink = network[i];
		var n1 = this.group.getNodeAtPoint(currLink[0][0], currLink[0][1]);
		var n2 = this.group.getNodeAtPoint(currLink[1][0], currLink[1][1]);
		this.group.createJoint(n1, n2);
	}
	return structureNodes;
};

module.exports = Structure;


},{"./Grid":"/Users/Lau/www/svjelly/src/core/Grid.js","./Polygon":"/Users/Lau/www/svjelly/src/core/Polygon.js","./Triangulator":"/Users/Lau/www/svjelly/src/core/Triangulator.js"}],"/Users/Lau/www/svjelly/src/core/Triangulator.js":[function(require,module,exports){
var poly2tri = require('../../libs/poly2tri/dist/poly2tri');

var Triangulator = function ()
{
};

Triangulator.prototype.triangulate = function ($coords)
{
	var poly2triContour = [];
	//debugger;

	for (var i = 0, pointsLength = $coords.length; i < pointsLength; i += 1)
	{
		var point = $coords[i];
		poly2triContour.push(new poly2tri.Point(point[0], point[1]));
	}

	var swctx;
	try
	{
		// prepare SweepContext
		swctx = new poly2tri.SweepContext(poly2triContour, { cloneArrays: true });

		// triangulate
		swctx.triangulate();
	}
	catch (e)
	{
		throw e;
		// console.log(e);
		// console.log(e.points);
	}
	var triangles = swctx.getTriangles();

	var pointsArray = [];

	var trianglesLength = triangles.length;
	for (i = 0; i < trianglesLength; i += 1)
	{
		var currTriangle = triangles[i];
		/*jshint camelcase:false*/
		//jscs:disable disallowDanglingUnderscores
		pointsArray.push(currTriangle.points_);
		//jscs:enable disallowDanglingUnderscores
		/*jshint camelcase:true*/
	}

	return pointsArray;
};

module.exports = Triangulator;


},{"../../libs/poly2tri/dist/poly2tri":"/Users/Lau/www/svjelly/libs/poly2tri/dist/poly2tri.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2GhostPhysicsManager.js":[function(require,module,exports){
var AnchorP2GhostPhysicsManager = function ($p2, $p2World, $worldHeight)
{
	this.p2 = $p2;
	this.p2World = $p2World;
	this.offset = [0, 0];
	this.worldHeight = $worldHeight;
};

AnchorP2GhostPhysicsManager.prototype.setFromPoint = function ($point)
{
	this.point = $point;
};

AnchorP2GhostPhysicsManager.prototype.addToWorld = function ()
{
	this.body = new this.p2.Body({
		position: [this.point[0], this.worldHeight - this.point[1]]
	});
	this.p2World.addBody(this.body);
};

AnchorP2GhostPhysicsManager.prototype.getX = function ()
{
	return this.body.position[0];
};

AnchorP2GhostPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - this.body.position[1];
};

module.exports = AnchorP2GhostPhysicsManager;

},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2HardPhysicsManager.js":[function(require,module,exports){
var AnchorP2HardPhysicsManager = function ($group) { this.group = $group; };

AnchorP2HardPhysicsManager.prototype.setFromPoint = function ($point)
{
	this.point = $point;
};

AnchorP2HardPhysicsManager.prototype.addToWorld = function ()
{
	this.body = this.group.physicsManager.body;
	this.worldHeight = this.group.physicsManager.worldHeight;
	this.offset = [this.point[0] - this.body.position[0], (this.worldHeight - this.point[1]) - this.body.position[1]];
	var dX = this.offset[0];
	var dY = this.offset[1];
	this.angle = Math.atan2(dY, dX);
	this.hyp = Math.sqrt(dX * dX + dY * dY);
};

AnchorP2HardPhysicsManager.prototype.setFixed = function ($fixed)
{
	this.group.fixed = $fixed;
};

AnchorP2HardPhysicsManager.prototype.getX = function ()
{
	return this.body.position[0] + this.hyp * Math.cos(this.body.angle + this.angle);
};

AnchorP2HardPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - (this.body.position[1] + this.hyp * Math.sin(this.body.angle + this.angle));
};

module.exports = AnchorP2HardPhysicsManager;

},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2SoftPhysicsManager.js":[function(require,module,exports){
var AnchorP2SoftPhysicsManager = function ($group) { this.group = $group; };

AnchorP2SoftPhysicsManager.prototype.setFromPoint = function ($point)
{
	this.point = $point;
	this.node = this.group.getClosestNode($point);
	this.worldHeight = this.group.physicsManager.worldHeight;
	this.offset = [0, 0];
};

AnchorP2SoftPhysicsManager.prototype.addToWorld = function ()
{
	this.body = this.node.physicsManager.body;
};

AnchorP2SoftPhysicsManager.prototype.setFixed = function ($fixed)
{
	this.node.fixed = $fixed;
};

AnchorP2SoftPhysicsManager.prototype.getX = function ()
{
	return this.body.position[0];
};

AnchorP2SoftPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - this.body.position[1];
};

module.exports = AnchorP2SoftPhysicsManager;

},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/GroupGhostPhysicsManager.js":[function(require,module,exports){
var GroupGhostPhysicsManager = function ($group)
{
	this.group = $group;
};

GroupGhostPhysicsManager.prototype.addJointsToWorld = function ()
{
	return null;
};

GroupGhostPhysicsManager.prototype.addNodesToWorld = function ()
{
	var getX = function ($nodeOX) { return function () { return $nodeOX; }; };
	var getY = function ($nodeOY) { return function () { return $nodeOY; }; };
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		var node = this.group.nodes[i];
		var manager = {};
		manager.getX = getX(node.oX);
		manager.getY = getY(node.oY);
		node.physicsManager = manager;
	}
};

module.exports = GroupGhostPhysicsManager;


},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2HardPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var p2 = require('../../../libs/p2');
var NodeP2HardPhysicsManager = require('./NodeP2HardPhysicsManager');
var AnchorP2HardPhysicsManager = require('./AnchorP2HardPhysicsManager');

var GroupP2HardPhysicsManager = function ($P2World, $worldHeight, $group, $conf)
{
	this.group = $group;
	this.group.fixed = this.group.conf.fixed;
	this.worldHeight = $worldHeight;
	this.P2World = $P2World;
	this.conf = $conf;
};

GroupP2HardPhysicsManager.prototype.createAnchorFromPoint = function ($point)
{
	var anchor = new AnchorP2HardPhysicsManager(this.group);
	anchor.setFromPoint($point);
	return anchor;
};

GroupP2HardPhysicsManager.prototype.createAnchorFromLine = function ($linePoints)
{
	var closestPoint = this.group.getClosestPoint($linePoints);
	var anchor = new AnchorP2HardPhysicsManager(this.group);
	anchor.setFromPoint(closestPoint);
	return anchor;
};

GroupP2HardPhysicsManager.prototype.createAnchors = function ($points)
{
	var toReturn = [];
	var nodes = this.group.getNodesInside($points);
	if (!nodes.length)
	{
		var defaultAnchor = new AnchorP2HardPhysicsManager(this.group);
		var closest = this.group.getClosestPoint($points);
		defaultAnchor.setFromPoint(closest);
		return [defaultAnchor];
	}
	for (var i = 0, length = nodes.length; i < length; i += 1)
	{
		var node = nodes[i];
		var currAnchorA = new AnchorP2HardPhysicsManager(this.group);
		currAnchorA.setFromPoint([node.oX, node.oY]);
		toReturn.push(currAnchorA);
	}
	return toReturn;
};

GroupP2HardPhysicsManager.prototype.addJointsToWorld = function () { return; };

GroupP2HardPhysicsManager.prototype.addNodesToWorld = function ()
{
	var path = [];
	var boundingBox = this.group.getBoundingBox();
	var width = boundingBox[1][0] - boundingBox[0][0];
	var height = boundingBox[1][1] - boundingBox[0][1];
	var startX = boundingBox[0][0] + width * 0.5;
	var startY = boundingBox[0][1] + height * 0.5;

	//startX = this.group.nodes[0].oX;
	//startY = this.group.nodes[0].oY;
	var initX = startX;
	var initY = this.worldHeight - startY;

	this.body = new p2.Body({
		mass: this.group.fixed ? 0 : 1,
		position: [startX, this.worldHeight - startY]
	});
	var node;
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		node = this.group.nodes[i];
		var pos = [node.oX - startX, -(node.oY - startY)];
		node.physicsManager = new NodeP2HardPhysicsManager(this.body, pos, this.worldHeight);
		path.push(pos);
	}

	if (length > 1)
	{
		this.body.fromPolygon(path);
		var offset = [initX - this.body.position[0], this.body.position[1] - initY];
		i = 0;
		for (i; i < length; i += 1)
		{
			node = this.group.nodes[i];
			node.physicsManager.setOffset(offset);
		}
	}
	else
	{
		var radius = this.group.structureProperties.radius;
		var circleShape = new p2.Circle(radius);
		this.body.addShape(circleShape);
	}

	this.body.gravityScale = this.conf.gravityScale || 1;
	// console.log(startX, this.worldHeight - startY, this.body.position[0], this.body.position[1]);
	//this.body.mass = this.conf.mass;
	//if (this.group.conf.fixed) { node.physicsManager.setFixed(this.group.conf.fixed); }
	//this.body.updateMassProperties();
	this.P2World.addBody(this.body);
	this.body.mass = this.body.getArea() * this.conf.mass;
	this.body.updateMassProperties();
	this.body.collisionResponse = false;
	//node.physicsManager.setFixed(this.group.conf.fixed);
	// console.log(this.body.shapes);
	// debugger;
};

module.exports = GroupP2HardPhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js","./AnchorP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2HardPhysicsManager.js","./NodeP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2HardPhysicsManager.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2SoftPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var p2 = require('../../../libs/p2');
var NodeP2SoftPhysicsManager = require('./NodeP2SoftPhysicsManager');
var AnchorP2SoftPhysicsManager = require('./AnchorP2SoftPhysicsManager');

var GroupP2SoftPhysicsManager = function ($world, $worldHeight, $group, $conf)
{
	this.group = $group;
	this.world = $world;
	this.worldHeight = $worldHeight;
	this.conf = $conf;
	//this.nodesDiameter = this.conf.nodesDiameter;
};

GroupP2SoftPhysicsManager.prototype.createAnchorFromPoint = function ($point)
{
	var anchor = new AnchorP2SoftPhysicsManager(this.group);
	anchor.setFromPoint($point);
	return anchor;
};

GroupP2SoftPhysicsManager.prototype.createAnchorFromLine = function ($linePoints)
{
	var closestPoint = this.group.getClosestPoint($linePoints);
	var anchor = new AnchorP2SoftPhysicsManager(this.group);
	anchor.setFromPoint(closestPoint);
	return anchor;
};

GroupP2SoftPhysicsManager.prototype.createAnchors = function ($points)
{
	var toReturn = [];
	var nodes = this.group.getNodesInside($points);
	for (var i = 0, length = nodes.length; i < length; i += 1)
	{
		var node = nodes[i];
		var currAnchorA = new AnchorP2SoftPhysicsManager(this.group);
		currAnchorA.setFromPoint([node.oX, node.oY]);
		toReturn.push(currAnchorA);
	}
	return toReturn;
};

GroupP2SoftPhysicsManager.prototype.addJointsToWorld = function ()
{
	for (var i = 0, length = this.group.joints.length; i < length; i += 1)
	{
		var joint = this.group.joints[i];
		var lock = this.conf.lockConstraint;
		var distance = this.conf.distanceConstraint;
		var linearSpring = this.conf.linearSpring;
		var rotationalSpring = this.conf.rotationalSpring;

		if (lock)
		{
			var constraint1 = new p2.LockConstraint(joint.node1.physicsManager.body, joint.node2.physicsManager.body);
			if (lock.stiffness) { constraint1.setStiffness(lock.stiffness); } //default 20
			if (lock.relaxation) { constraint1.setRelaxation(lock.relaxation); }
			this.world.addConstraint(constraint1);
		}
		if (distance)
		{
			var constraint2 = new p2.DistanceConstraint(joint.node1.physicsManager.body, joint.node2.physicsManager.body);
			if (distance.stiffness) { constraint2.setStiffness(distance.stiffness); } // default 500
			if (distance.relaxation) { constraint2.setRelaxation(distance.relaxation); }// default 0.1
			this.world.addConstraint(constraint2);
		}
		if (linearSpring)
		{
			var constraint3 = new p2.LinearSpring(joint.node1.physicsManager.body, joint.node2.physicsManager.body);
			if (linearSpring.stiffness) { constraint3.stiffness = linearSpring.stiffness; }
			if (linearSpring.damping) { constraint3.damping = linearSpring.damping; }
			this.world.addSpring(constraint3);
		}
		if (rotationalSpring)
		{
			console.log(rotationalSpring.stiffness, rotationalSpring.damping);
			var constraint4 = new p2.RotationalSpring(joint.node1.physicsManager.body, joint.node2.physicsManager.body);
			if (rotationalSpring.stiffness) { constraint4.stiffness = rotationalSpring.stiffness; }
			if (rotationalSpring.damping) { constraint4.damping = rotationalSpring.damping; }
			//this.world.addSpring(constraint4);
		}
	}
};

GroupP2SoftPhysicsManager.prototype.addNodesToWorld = function ()
{
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		var node = this.group.nodes[i];
		//var fractionMass = this.conf.mass / this.group.nodes.length;
		var area = this.group.structureProperties.area;
		var nodeMass = area * this.conf.mass / this.group.nodes.length;
		//var mass = 500;
		//var mass = this.conf.mass;//Math.random() * 10 + 1;
		var body = new p2.Body({
			mass: node.fixed ? 0 : nodeMass,
			position: [node.oX, this.worldHeight - node.oY]
		});
		//if (node.fixed) { body.type = p2.Body.STATIC; }
		//console.log(node.oX, node.oY);
		//this.body.fixedRotation = true;
		body.gravityScale = this.conf.gravityScale || 1;//0;// -1;

		var radius = this.conf.nodeRadius;
		var circleShape = new p2.Circle(radius);
		body.addShape(circleShape);
		// var particleShape = new p2.Particle();
		// body.addShape(particleShape);

		//console.log(this.body.getArea());

		//this.body.setDensity(node.type === 'line' ? 1 : 5000);

		// this.body.damping = 0.8;
		//body.mass = mass;
		node.physicsManager = new NodeP2SoftPhysicsManager(p2, body, this.worldHeight);
		//node.physicsManager.setFixed(node.fixed);
		this.world.addBody(body);
		//body.mass = body.getArea() * this.conf.mass;
		//body.gravityScale = 0.1;
		//body.updateMassProperties();
		// body.mass = 0;
		// body.setDensity(0);
		//node.physicsManager.applyForce([0, 0]);
	}
};

module.exports = GroupP2SoftPhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js","./AnchorP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2SoftPhysicsManager.js","./NodeP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2SoftPhysicsManager.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2HardPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/
var p2 = require('../../../libs/p2');

var NodeP2HardPhysicsManager = function ($body, $position, $worldHeight)
{
	this.body = $body;
	this.position = $position;
	this.worldHeight = $worldHeight;
	this.offset = [0, 0];
	this.getX = this.getXSimple;
	this.getY = this.getYSimple;
};

NodeP2HardPhysicsManager.prototype.setFixed = function ($fixed)
{
	if ($fixed)
	{
		this.body.type = p2.Body.STATIC;
		this.body.updateMassProperties();
	}
};

NodeP2HardPhysicsManager.prototype.setOffset = function ($offset)
{
	var dX = this.position[0] + $offset[0];
	var dY = this.position[1] - $offset[1];
	this.angle = Math.atan2(dY, dX);
	this.hyp = Math.sqrt(dX * dX + dY * dY);
	this.getX = this.getXOffset;
	this.getY = this.getYOffset;
};

NodeP2HardPhysicsManager.prototype.getXSimple = function ()
{
	return this.body.position[0];
};

NodeP2HardPhysicsManager.prototype.getYSimple = function ()
{
	return this.worldHeight - this.body.position[1];
};

NodeP2HardPhysicsManager.prototype.getXOffset = function ()
{
	return this.body.position[0] + this.hyp * Math.cos(this.body.angle + this.angle);
};

NodeP2HardPhysicsManager.prototype.getYOffset = function ()
{
	return this.worldHeight - (this.body.position[1] + this.hyp * Math.sin(this.body.angle + this.angle));
};

module.exports = NodeP2HardPhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2SoftPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var NodeP2SoftPhysicsManager = function ($p2, $body, $worldHeight)
{
	this.p2 = $p2;
	this.body = $body;
	this.worldHeight = $worldHeight;
};

NodeP2SoftPhysicsManager.prototype.applyForce = function ($vec)
{
	//console.log('nop', this.body.applyForceLocal, $vec);
	var loc = [];
	this.body.toWorldFrame(loc, [0, 0]);
	this.body.applyForce($vec, loc);
};

NodeP2SoftPhysicsManager.prototype.setFixed = function ($fixed)
{
	if ($fixed)
	{
		this.body.type = this.p2.Body.STATIC;
	}
};

NodeP2SoftPhysicsManager.prototype.getX = function ()
{
	//console.log(this.body.GetWorldCenter().get_x());
	return this.body.position[0];
};

NodeP2SoftPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - this.body.position[1];
};

module.exports = NodeP2SoftPhysicsManager;


},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/P2PhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var p2 = require('../../../libs/p2');
var GroupP2SoftPhysicsManager = require('./GroupP2SoftPhysicsManager');
var GroupP2HardPhysicsManager = require('./GroupP2HardPhysicsManager');
var GroupGhostPhysicsManager = require('./GroupGhostPhysicsManager');
var AnchorP2HardPhysicsManager = require('./AnchorP2HardPhysicsManager');
var AnchorP2SoftPhysicsManager = require('./AnchorP2SoftPhysicsManager');
var AnchorP2GhostPhysicsManager = require('./AnchorP2GhostPhysicsManager');

var P2PhysicsManager = function ($conf)
{
	this.p2World = new p2.World($conf);
	this.p2 = p2;
	this.conf = $conf;
	this.worldWidth = undefined;
	this.worldHeight = undefined;
	//this.p2World.gravity = this.conf.gravity;
};

P2PhysicsManager.prototype.step = function ($time)
{
	this.p2World.step($time);
};

P2PhysicsManager.prototype.constrainGroups = function ($anchorA, $anchorB)
{
	$anchorA.addToWorld();
	$anchorB.addToWorld();
	var constraint = new p2.DistanceConstraint($anchorA.body, $anchorB.body,
	{
		localAnchorA: $anchorA.offset, // Point on bodyA
		localAnchorB: $anchorB.offset // Point on bodyB
	});
	this.p2World.addConstraint(constraint);
};

P2PhysicsManager.prototype.getAnchorPhysicsManager = function ($group)
{
	if (!$group) { return new AnchorP2GhostPhysicsManager(this.p2, this.p2World, this.worldHeight); }

	switch ($group.conf.physics.bodyType)
	{
		case 'hard': return new AnchorP2HardPhysicsManager($group);
		default: return new AnchorP2SoftPhysicsManager($group);
	}
};

P2PhysicsManager.prototype.getGroupPhysicsManager = function ($group)
{
	switch ($group.conf.physics.bodyType)
	{
		case 'ghost': return new GroupGhostPhysicsManager($group);
		case 'hard': return new GroupP2HardPhysicsManager(this.p2World, this.worldHeight, $group, $group.conf.physics);
		default: return new GroupP2SoftPhysicsManager(this.p2World, this.worldHeight, $group, $group.conf.physics);
	}
};

module.exports = P2PhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js","./AnchorP2GhostPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2GhostPhysicsManager.js","./AnchorP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2HardPhysicsManager.js","./AnchorP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2SoftPhysicsManager.js","./GroupGhostPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/GroupGhostPhysicsManager.js","./GroupP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2HardPhysicsManager.js","./GroupP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2SoftPhysicsManager.js"}],"/Users/Lau/www/svjelly/src/renderer/svjelly/SVJellyRenderer.js":[function(require,module,exports){
var SVJellyRenderer = function ($world, $canvas)
{
	this.canvas = $canvas;
	this.world = $world;
	this.context = this.canvas.getContext('2d');
	this.debug = $world.conf.debug;
	this.cached = [];

	this.width = this.canvas.width;
	this.height = this.canvas.height;
	this.drawScaleX = this.drawScaleY = this.canvas.width / this.world.getWidth();

	this.drawingGroups = [];
	var k = 0;
	var i;
	var drawingGroup;
	for (var groupsLength = this.world.groupsArray.length; k < groupsLength; k += 1)
	{
		var currGroup = this.world.groupsArray[k];

		i = 0;
		for (var nodesLength = currGroup.nodes.length; i < nodesLength; i += 1)
		{
			var currNode = currGroup.nodes[i];
			if (currNode.drawing)
			{
				if (currNode.drawing.fill || currNode.drawing.stroke)// && !currNode.drawing.notToDraw)
				{
					drawingGroup =
					{
						properties: currNode.drawing,
						nodes: [],
						type: currGroup.type,
						structure: currGroup.conf.structure,
						fixed: currGroup.conf.fixed
					};
					this.drawingGroups.push(drawingGroup);
				}
				drawingGroup.nodes.push(currNode);
			}
		}
	}
	this.drawingGroupLength = this.drawingGroups.length;

	//caching gradients
	for (i = 0; i < this.drawingGroupLength; i += 1)
	{
		drawingGroup = this.drawingGroups[i];
		if (drawingGroup.properties.strokeGradient)
		{
			drawingGroup.properties.stroke = this.createGradient(drawingGroup.properties.strokeGradient);
		}
		if (drawingGroup.properties.fillGradient)
		{
			drawingGroup.properties.fill = this.createGradient(drawingGroup.properties.fillGradient);
		}
	}

	//caching ghosts
	i = 0;
	var previousDrawingGroup;
	for (i; i < this.drawingGroupLength; i += 1)
	{
		drawingGroup = this.drawingGroups[i];
		if (drawingGroup.type === 'ghost' || drawingGroup.fixed === true)
		{
			var canvas;
			if (this.cached[i - 1] === undefined)
			{
				canvas = window.document.createElement('canvas');
				canvas.width = this.width;
				canvas.height = this.height;
			}
			else
			{
				//if some ghost layers are on top of each other, no need to create
				//a new canvas, you can just draw the layers on the same one
				canvas = this.cached[i - 1];
			}

			var context = canvas.getContext('2d');
			this.drawGroup(drawingGroup, context);
			this.cached[i] = canvas;
		}
		previousDrawingGroup = drawingGroup;
	}
};

SVJellyRenderer.prototype.createGradient = function ($properties)
{
	var x1 = $properties.x1 * this.drawScaleX;
	var y1 = $properties.y1 * this.drawScaleY;
	var x2 = $properties.x2 * this.drawScaleX;
	var y2 = $properties.y2 * this.drawScaleY;

	var cx = $properties.cx * this.drawScaleX;
	var cy = $properties.cy * this.drawScaleY;
	var fx = $properties.fx * this.drawScaleX || cx;
	var fy = $properties.fy * this.drawScaleY || cy;
	var r = $properties.r * this.drawScaleX;

	var gradient = $properties.type === 'linearGradient' ? this.context.createLinearGradient(x1, y1, x2, y2) : this.context.createRadialGradient(cx, cy, 0, fx, fy, r);

	//gradient = this.context.createLinearGradient(0, 0, 500, 500);

	for (var stopN = 0, stopLength = $properties.stops.length; stopN < stopLength; stopN += 1)
	{
		gradient.addColorStop($properties.stops[stopN].offset, $properties.stops[stopN].color);
	}

	// var gueugueu = this.context.createLinearGradient(0, 0, 500, 500);
	// gueugueu.addColorStop(0, 'red');
	// gueugueu.addColorStop(1, 'blue');
	return gradient;
};

SVJellyRenderer.prototype.getDrawingGroup = function ($comparison)
{
	for (var i = 0, length = this.drawingGroups.length; i < length; i += 1)
	{
		var currGroup = this.drawingGroups[i];
		if (this.compareProperties(currGroup.properties, $comparison)) { return currGroup; }
	}
};

SVJellyRenderer.prototype.compareProperties = function ($one, $two)
{
	var comparison = true;
	for (var name in $two)
	{
		if ($one[name] !== $two[name]) { comparison = false; }
	}
	return comparison;
};

SVJellyRenderer.prototype.draw = function ()
{
	this.context.clearRect(0, 0, this.width, this.height);
	this.context.miterLimit = 1;
	var previousCached;
	for (var i = 0; i < this.drawingGroupLength; i += 1)
	{
		var drawingGroup = this.drawingGroups[i];
		if (this.cached[i] && this.cached[i] !== previousCached)
		{
			this.context.drawImage(this.cached[i], 0, 0);
		}
		else
		{
			this.drawGroup(drawingGroup, this.context);
		}
		previousCached = this.cached[i];
	}

	if (this.debug) { this.debugDraw(); }
};

SVJellyRenderer.prototype.drawGroup = function ($drawingGroup, $context)
{
	var nodesLength = $drawingGroup.nodes.length;
	$context.beginPath();

	// console.log($context.fillStyle, $context.strokeStyle);
	// console.log($drawingGroup.properties.fill, $drawingGroup.properties.stroke);
	// debugger;

	// if ($drawingGroup.properties.fill !== 'none') { $context.fillStyle = $drawingGroup.properties.fill; }
	// if ($drawingGroup.properties.stroke !== 'none') { $context.strokeStyle = $drawingGroup.properties.stroke; }
	if ($context.fillStyle !== $drawingGroup.properties.fill) { $context.fillStyle = $drawingGroup.properties.fill; }
	if ($context.strokeStyle !== $drawingGroup.properties.stroke) { $context.strokeStyle = $drawingGroup.properties.stroke; }

	if ($drawingGroup.properties.lineWidth !== 'none') { $context.lineWidth = $drawingGroup.properties.lineWidth * this.drawScaleX; }
	if ($drawingGroup.properties.lineCap) { $context.lineCap = $drawingGroup.properties.lineCap; }
	if ($drawingGroup.properties.lineJoin) { $context.lineJoin = $drawingGroup.properties.lineJoin; }
	$context.globalAlpha = $drawingGroup.properties.opacity ? $drawingGroup.properties.opacity : 1;

	for (var k = 0; k < nodesLength; k += 1)
	{
		var currNode = $drawingGroup.nodes[k];
		if (currNode.drawing && currNode.drawing.notToDraw) { continue; }
		if (currNode.isStart)
		{
			//line gradient
			if ($drawingGroup.type === 'line' && $drawingGroup.properties.strokeGradient)
			{
				var x1 = currNode.getX() * this.drawScaleX;
				var y1 = currNode.getY() * this.drawScaleY;
				var x2 = currNode.endNode.getX() * this.drawScaleX;
				var y2 = currNode.endNode.getY() * this.drawScaleY;
				var gradient = $context.createLinearGradient(x1, y1, x2, y2);
				for (var stopN = 0, stopLength = currNode.drawing.strokeGradient.length; stopN < stopLength; stopN += 1)
				{
					gradient.addColorStop(1 - currNode.drawing.strokeGradient[stopN].offset, currNode.drawing.strokeGradient[stopN].color);
				}
				$context.strokeStyle = gradient;
			}
			//

			$context.moveTo(currNode.getX() * this.drawScaleX, currNode.getY() * this.drawScaleY);
			if ($drawingGroup.properties.radius)
			{
				$context.arc(currNode.getX() * this.drawScaleX, currNode.getY() * this.drawScaleY, $drawingGroup.properties.radius, 0, Math.PI * 2);
			}
		}
		else
		{
			$context.lineTo(currNode.getX() * this.drawScaleX, currNode.getY() * this.drawScaleY);
		}
		// $context.moveTo(currNode.getX() * this.drawScaleX, this.height - currNode.getY() * this.drawScaleY);
		// $context.arc(currNode.getX() * this.drawScaleX, this.height - currNode.getY() * this.drawScaleY, 2, 0, Math.PI * 2);
	}
	if ($drawingGroup.properties.closePath) { $context.closePath(); }
	if ($drawingGroup.properties.fill !== 'none') { $context.fill(); }
	if ($drawingGroup.properties.stroke !== 'none') { $context.stroke(); }
};

SVJellyRenderer.prototype.debugDraw = function ($clear)
{
	if ($clear !== undefined) { this.context.clearRect(0, 0, this.width, this.height); }

	this.context.strokeStyle = 'rgba(255,255,1,1)';
	this.context.lineCap = 'butt';
	this.context.lineJoin = 'miter';
	this.context.lineWidth = 1;
	this.context.beginPath();
	var currGroup;
	var i;
	var k;
	var groupsLength = this.world.groupsArray.length;
	for (k = 0; k < groupsLength; k += 1)
	{
		currGroup = this.world.groupsArray[k];

		var nodesLength = currGroup.nodes.length;
		for (i = 0; i < nodesLength; i += 1)
		{
			var currNode = currGroup.nodes[i];
			this.context.moveTo(currNode.getX() * this.drawScaleX, currNode.getY() * this.drawScaleY);
			this.context.arc(currNode.getX() * this.drawScaleX, currNode.getY() * this.drawScaleY, currGroup.conf.physics.nodeRadius * this.drawScaleX, 0, Math.PI * 2);
		}
	}
	this.context.stroke();

	this.context.strokeStyle = 'rgba(255,1,1,1)';
	this.context.beginPath();
	for (k = 0; k < groupsLength; k += 1)
	{
		currGroup = this.world.groupsArray[k];
		var jointsLength = currGroup.joints.length;

		for (i = 0; i < jointsLength; i += 1)
		{
			var currJoint = currGroup.joints[i];
			this.context.moveTo(currJoint.node1.getX() * this.drawScaleX, currJoint.node1.getY() * this.drawScaleY);
			this.context.lineTo(currJoint.node2.getX() * this.drawScaleX, currJoint.node2.getY() * this.drawScaleY);
		}
	}
	this.context.stroke();

	this.context.strokeStyle = 'blue';
	this.context.beginPath();
	var length = this.world.groupConstraints.length;
	for (k = 0; k < length; k += 1)
	{
		var currLock = this.world.groupConstraints[k];
		this.context.moveTo(currLock.anchorA.getX() * this.drawScaleX, currLock.anchorA.getY() * this.drawScaleY);
		this.context.lineTo(currLock.anchorB.getX() * this.drawScaleX, currLock.anchorB.getY() * this.drawScaleY);
	}
	this.context.stroke();
};

module.exports = SVJellyRenderer;


},{}],"/Users/Lau/www/svjelly/src/svjellymaker.js":[function(require,module,exports){
var SVJellyWorld = require('./core/SVJellyWorld');
var SVJellyRenderer = require('./renderer/svjelly/SVJellyRenderer');
var SVGParser = require('./core/SVGParser');
var P2PhysicsManager = require('./physics/p2physics/P2PhysicsManager');
var SVJellyUtils = require('./core/SVJellyUtils');
var confObject = require('./core/ConfObject');

//TODO promise polyfill
var SVJellyMaker =
{
	createFromURL: function ($canvas, $URL, $physicsManager, $renderer)
	{
		var svjellyMaker = Object.create(SVJellyMaker);
		svjellyMaker.canvas = $canvas;
		svjellyMaker.renderer = $renderer;
		svjellyMaker.physicsManager = $physicsManager;
		svjellyMaker.loadFile($URL, function ($SVG) { svjellyMaker.create($SVG); }, true);
		return svjellyMaker;
	},
	createFromConfig: function ($canvas, $configURL, $physicsManager, $renderer)
	{
		var svjellyMaker = Object.create(SVJellyMaker);
		svjellyMaker.canvas = $canvas;
		svjellyMaker.renderer = $renderer;
		svjellyMaker.physicsManager = $physicsManager;

		svjellyMaker.promise = new window.Promise(function (resolve)
		{
			var loadConfigComplete = function ($configData)
			{
				var JSONConfig = JSON.parse($configData);
				svjellyMaker.conf = SVJellyUtils.extend(confObject, JSONConfig);

				SVJellyMaker.loadFile(svjellyMaker.conf.source, function ($SVG)
				{
					svjellyMaker.create($SVG);
					resolve();
				}, true);
			};
			SVJellyMaker.loadFile($configURL, loadConfigComplete);
		});

		return svjellyMaker;
	},
	createFromPageSVG: function ($physicsManager, $renderer)
	{
		var svjellies = document.querySelectorAll('[data-svjelly]');

		var createViewer = function ($element)
		{
			var svjellyMaker = Object.create(SVJellyMaker);
			var currSVG = $element;
			var appendCanvas = function ($config)
			{
				svjellyMaker.conf = $config;
				var canvas = document.createElement('canvas');
				canvas.width = currSVG.clientWidth;
				canvas.height = currSVG.clientHeight;
				currSVG.parentElement.insertBefore(canvas, currSVG);
				currSVG.remove();
				svjellyMaker.canvas = canvas;
				svjellyMaker.renderer = $renderer;
				svjellyMaker.physicsManager = $physicsManager;
				var wrapper = document.createElement('div');
				wrapper.appendChild(currSVG);
				svjellyMaker.create(wrapper);
			};
			var configURL = currSVG.getAttribute('data-svjelly');
			if (configURL)
			{
				SVJellyMaker.loadFile(configURL, function ($configData)
				{
					var JSONConfig = JSON.parse($configData);
					appendCanvas(SVJellyUtils.extend(confObject, JSONConfig));
				});
			}
			else
			{
				appendCanvas();
			}
		};

		for (var i = 0, length = svjellies.length; i < length; i += 1)
		{
			var currSVG = svjellies[i];
			createViewer(currSVG);
		}
	},
	create: function ($SVG)
	{
		var requestAnimFrame = window.requestAnimationFrame ||
								window.webkitRequestAnimationFrame ||
								window.mozRequestAnimationFrame;

		var cancelAnimFrame = window.cancelAnimationFrame ||
								window.webkitCancelAnimationFrame ||
								window.mozCancelAnimationFrame;

		var conf = this.conf || confObject;
		var canvas = this.canvas;

		this.physicsManager = this.physicsManager || new P2PhysicsManager(conf);
		var svjellyWorld = this.svjellyWorld = new SVJellyWorld(this.physicsManager, conf);

		var requestID = '';

		var canvasDefinition = conf.definition;
		var svgDef = $SVG.querySelector('svg');
		var parser = new SVGParser();
		parser.parse(svjellyWorld, svgDef);
		var canvasWidth = canvas.clientWidth * canvasDefinition;
		var canvasHeight = canvas.clientWidth * (parser.viewBoxHeight / parser.viewBoxWidth) * canvasDefinition;

		canvas.width = canvasWidth;
		canvas.height = canvasHeight;
		canvas.style.transformOrigin = '0 0';
		canvas.style.transform = 'scale(' + 1 / canvasDefinition + ')';

		var Renderer = this.renderer || SVJellyRenderer;
		var svjellyDraw = new Renderer(svjellyWorld, canvas);

		var lastSim = window.performance.now();
		var lastRender = window.performance.now();
		var simDiff;
		var diffRender;
		var simTargetFPSMilliSeconds = 16;//$configData.simRenderFreq; //60fps
		var renderTargetFPSMilliSeconds = 0;

		var update = function ($now)
		{
			simDiff = $now - lastSim;
			diffRender = $now - lastRender;
			if (simDiff >= simTargetFPSMilliSeconds)
			{
				svjellyWorld.physicsManager.step(Math.min(1, simDiff / 1000));
				lastSim = $now;
			}
			if (diffRender >= renderTargetFPSMilliSeconds)
			{
				svjellyDraw.draw();
				lastRender = $now;
			}
			requestID = requestAnimFrame(update);
		};

		window.addEventListener('focus', function () { requestID = requestAnimFrame(update); });
		window.addEventListener('blur', function () { cancelAnimFrame(requestID); });

		requestID = requestAnimFrame(update);
	},

	loadFile: function ($URL, $successCallback, $XML)
	{
		var error = function ()
		{
			console.log('error', $URL);
		};

		var handler = function ()
		{
			$successCallback($XML ? this.responseXML : this.responseText);
		};

		var request = new XMLHttpRequest();
		request.addEventListener('load', handler);
		request.addEventListener('error', error);
		request.open('get', $URL, true);
		request.send();
	}
};

if (document.querySelector('[data-svjelly-auto]'))
{
	var windowLoadHandler = function ()
	{
		SVJellyMaker.createFromPageSVG();
	};
	window.addEventListener('load', windowLoadHandler);
}

module.exports = SVJellyMaker;

},{"./core/ConfObject":"/Users/Lau/www/svjelly/src/core/ConfObject.js","./core/SVGParser":"/Users/Lau/www/svjelly/src/core/SVGParser.js","./core/SVJellyUtils":"/Users/Lau/www/svjelly/src/core/SVJellyUtils.js","./core/SVJellyWorld":"/Users/Lau/www/svjelly/src/core/SVJellyWorld.js","./physics/p2physics/P2PhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/P2PhysicsManager.js","./renderer/svjelly/SVJellyRenderer":"/Users/Lau/www/svjelly/src/renderer/svjelly/SVJellyRenderer.js"}]},{},["/Users/Lau/www/svjelly/src/svjellymaker.js"])("/Users/Lau/www/svjelly/src/svjellymaker.js")
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWJzL3AyLmpzIiwibGlicy9wb2x5MnRyaS9kaXN0L3BvbHkydHJpLmpzIiwic3JjL2NvcmUvQ29uZk9iamVjdC5qcyIsInNyYy9jb3JlL0dyaWQuanMiLCJzcmMvY29yZS9Qb2x5Z29uLmpzIiwic3JjL2NvcmUvU1ZHUGFyc2VyLmpzIiwic3JjL2NvcmUvU1ZKZWxseUdyb3VwLmpzIiwic3JjL2NvcmUvU1ZKZWxseUpvaW50LmpzIiwic3JjL2NvcmUvU1ZKZWxseU5vZGUuanMiLCJzcmMvY29yZS9TVkplbGx5VXRpbHMuanMiLCJzcmMvY29yZS9TVkplbGx5V29ybGQuanMiLCJzcmMvY29yZS9TdHJ1Y3R1cmUuanMiLCJzcmMvY29yZS9Ucmlhbmd1bGF0b3IuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL0FuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL0FuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL0dyb3VwR2hvc3RQaHlzaWNzTWFuYWdlci5qcyIsInNyYy9waHlzaWNzL3AycGh5c2ljcy9Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL0dyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL05vZGVQMlNvZnRQaHlzaWNzTWFuYWdlci5qcyIsInNyYy9waHlzaWNzL3AycGh5c2ljcy9QMlBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3JlbmRlcmVyL3N2amVsbHkvU1ZKZWxseVJlbmRlcmVyLmpzIiwic3JjL3N2amVsbHltYWtlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3OVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgcDIuanMgYXV0aG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmZhbHNlKWRlZmluZShlKTtlbHNle3ZhciBmO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/Zj13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9mPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGY9c2VsZiksZi5wMj1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTY2FsYXIgPSBfZGVyZXFfKCcuL1NjYWxhcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cbi8qKlxuICogQ29udGFpbmVyIGZvciBsaW5lLXJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAY2xhc3MgTGluZVxuICovXG5mdW5jdGlvbiBMaW5lKCl7fTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0d28gbGluZXMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGxpbmVJbnRcbiAqIEBwYXJhbSAge0FycmF5fSAgbDEgICAgICAgICAgTGluZSB2ZWN0b3IgMVxuICogQHBhcmFtICB7QXJyYXl9ICBsMiAgICAgICAgICBMaW5lIHZlY3RvciAyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHByZWNpc2lvbiAgIFByZWNpc2lvbiB0byB1c2Ugd2hlbiBjaGVja2luZyBpZiB0aGUgbGluZXMgYXJlIHBhcmFsbGVsXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgIFRoZSBpbnRlcnNlY3Rpb24gcG9pbnQuXG4gKi9cbkxpbmUubGluZUludCA9IGZ1bmN0aW9uKGwxLGwyLHByZWNpc2lvbil7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG4gICAgdmFyIGkgPSBbMCwwXTsgLy8gcG9pbnRcbiAgICB2YXIgYTEsIGIxLCBjMSwgYTIsIGIyLCBjMiwgZGV0OyAvLyBzY2FsYXJzXG4gICAgYTEgPSBsMVsxXVsxXSAtIGwxWzBdWzFdO1xuICAgIGIxID0gbDFbMF1bMF0gLSBsMVsxXVswXTtcbiAgICBjMSA9IGExICogbDFbMF1bMF0gKyBiMSAqIGwxWzBdWzFdO1xuICAgIGEyID0gbDJbMV1bMV0gLSBsMlswXVsxXTtcbiAgICBiMiA9IGwyWzBdWzBdIC0gbDJbMV1bMF07XG4gICAgYzIgPSBhMiAqIGwyWzBdWzBdICsgYjIgKiBsMlswXVsxXTtcbiAgICBkZXQgPSBhMSAqIGIyIC0gYTIqYjE7XG4gICAgaWYgKCFTY2FsYXIuZXEoZGV0LCAwLCBwcmVjaXNpb24pKSB7IC8vIGxpbmVzIGFyZSBub3QgcGFyYWxsZWxcbiAgICAgICAgaVswXSA9IChiMiAqIGMxIC0gYjEgKiBjMikgLyBkZXQ7XG4gICAgICAgIGlbMV0gPSAoYTEgKiBjMiAtIGEyICogYzEpIC8gZGV0O1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdHMuXG4gKiBAbWV0aG9kIHNlZ21lbnRzSW50ZXJzZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBwMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBwMiBUaGUgZW5kIHZlcnRleCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcTEgVGhlIHN0YXJ0IHZlcnRleCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHEyIFRoZSBlbmQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0XG4gKi9cbkxpbmUuc2VnbWVudHNJbnRlcnNlY3QgPSBmdW5jdGlvbihwMSwgcDIsIHExLCBxMil7XG4gICB2YXIgZHggPSBwMlswXSAtIHAxWzBdO1xuICAgdmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcbiAgIHZhciBkYSA9IHEyWzBdIC0gcTFbMF07XG4gICB2YXIgZGIgPSBxMlsxXSAtIHExWzFdO1xuXG4gICAvLyBzZWdtZW50cyBhcmUgcGFyYWxsZWxcbiAgIGlmKGRhKmR5IC0gZGIqZHggPT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgdmFyIHMgPSAoZHggKiAocTFbMV0gLSBwMVsxXSkgKyBkeSAqIChwMVswXSAtIHExWzBdKSkgLyAoZGEgKiBkeSAtIGRiICogZHgpXG4gICB2YXIgdCA9IChkYSAqIChwMVsxXSAtIHExWzFdKSArIGRiICogKHExWzBdIC0gcDFbMF0pKSAvIChkYiAqIGR4IC0gZGEgKiBkeSlcblxuICAgcmV0dXJuIChzPj0wICYmIHM8PTEgJiYgdD49MCAmJiB0PD0xKTtcbn07XG5cblxufSx7XCIuL1NjYWxhclwiOjR9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbi8qKlxuICogUG9pbnQgcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBjbGFzcyBQb2ludFxuICovXG5mdW5jdGlvbiBQb2ludCgpe307XG5cbi8qKlxuICogR2V0IHRoZSBhcmVhIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB0aGUgdGhyZWUgZ2l2ZW4gcG9pbnRzLiBOb3RlIHRoYXQgdGhlIGFyZWEgd2lsbCBiZSBuZWdhdGl2ZSBpZiB0aGUgcG9pbnRzIGFyZSBub3QgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGFyZWFcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuUG9pbnQuYXJlYSA9IGZ1bmN0aW9uKGEsYixjKXtcbiAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pKihjWzFdIC0gYVsxXSkpLSgoY1swXSAtIGFbMF0pKihiWzFdIC0gYVsxXSkpKTtcbn07XG5cblBvaW50LmxlZnQgPSBmdW5jdGlvbihhLGIsYyl7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSxiLGMpID4gMDtcbn07XG5cblBvaW50LmxlZnRPbiA9IGZ1bmN0aW9uKGEsYixjKSB7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPj0gMDtcbn07XG5cblBvaW50LnJpZ2h0ID0gZnVuY3Rpb24oYSxiLGMpIHtcbiAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA8IDA7XG59O1xuXG5Qb2ludC5yaWdodE9uID0gZnVuY3Rpb24oYSxiLGMpIHtcbiAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA8PSAwO1xufTtcblxudmFyIHRtcFBvaW50MSA9IFtdLFxuICAgIHRtcFBvaW50MiA9IFtdO1xuXG4vKipcbiAqIENoZWNrIGlmIHRocmVlIHBvaW50cyBhcmUgY29sbGluZWFyXG4gKiBAbWV0aG9kIGNvbGxpbmVhclxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge0FycmF5fSBiXG4gKiBAcGFyYW0gIHtBcnJheX0gY1xuICogQHBhcmFtICB7TnVtYmVyfSBbdGhyZXNob2xkQW5nbGU9MF0gVGhyZXNob2xkIGFuZ2xlIHRvIHVzZSB3aGVuIGNvbXBhcmluZyB0aGUgdmVjdG9ycy4gVGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIHJlc3VsdGluZyB2ZWN0b3JzIGlzIGxlc3MgdGhhbiB0aGlzIHZhbHVlLiBVc2UgemVybyBmb3IgbWF4IHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBvaW50LmNvbGxpbmVhciA9IGZ1bmN0aW9uKGEsYixjLHRocmVzaG9sZEFuZ2xlKSB7XG4gICAgaWYoIXRocmVzaG9sZEFuZ2xlKVxuICAgICAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA9PSAwO1xuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYWIgPSB0bXBQb2ludDEsXG4gICAgICAgICAgICBiYyA9IHRtcFBvaW50MjtcblxuICAgICAgICBhYlswXSA9IGJbMF0tYVswXTtcbiAgICAgICAgYWJbMV0gPSBiWzFdLWFbMV07XG4gICAgICAgIGJjWzBdID0gY1swXS1iWzBdO1xuICAgICAgICBiY1sxXSA9IGNbMV0tYlsxXTtcblxuICAgICAgICB2YXIgZG90ID0gYWJbMF0qYmNbMF0gKyBhYlsxXSpiY1sxXSxcbiAgICAgICAgICAgIG1hZ0EgPSBNYXRoLnNxcnQoYWJbMF0qYWJbMF0gKyBhYlsxXSphYlsxXSksXG4gICAgICAgICAgICBtYWdCID0gTWF0aC5zcXJ0KGJjWzBdKmJjWzBdICsgYmNbMV0qYmNbMV0pLFxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmFjb3MoZG90LyhtYWdBKm1hZ0IpKTtcbiAgICAgICAgcmV0dXJuIGFuZ2xlIDwgdGhyZXNob2xkQW5nbGU7XG4gICAgfVxufTtcblxuUG9pbnQuc3FkaXN0ID0gZnVuY3Rpb24oYSxiKXtcbiAgICB2YXIgZHggPSBiWzBdIC0gYVswXTtcbiAgICB2YXIgZHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59O1xuXG59LHt9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBMaW5lID0gX2RlcmVxXyhcIi4vTGluZVwiKVxuLCAgIFBvaW50ID0gX2RlcmVxXyhcIi4vUG9pbnRcIilcbiwgICBTY2FsYXIgPSBfZGVyZXFfKFwiLi9TY2FsYXJcIilcblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuXG4vKipcbiAqIFBvbHlnb24gY2xhc3MuXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBvbHlnb24oKXtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2VzIHRoYXQgdGhpcyBwb2x5Z29uIGNvbnNpc3RzIG9mLiBBbiBhcnJheSBvZiBhcnJheSBvZiBudW1iZXJzLCBleGFtcGxlOiBbWzAsMF0sWzEsMF0sLi5dXG4gICAgICogQHByb3BlcnR5IHZlcnRpY2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSBbXTtcbn1cblxuLyoqXG4gKiBHZXQgYSB2ZXJ0ZXggYXQgcG9zaXRpb24gaS4gSXQgZG9lcyBub3QgbWF0dGVyIGlmIGkgaXMgb3V0IG9mIGJvdW5kcywgdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgY3ljbGUuXG4gKiBAbWV0aG9kIGF0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKGkpe1xuICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgcyA9IHYubGVuZ3RoO1xuICAgIHJldHVybiB2W2kgPCAwID8gaSAlIHMgKyBzIDogaSAlIHNdO1xufTtcblxuLyoqXG4gKiBHZXQgZmlyc3QgdmVydGV4XG4gKiBAbWV0aG9kIGZpcnN0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzWzBdO1xufTtcblxuLyoqXG4gKiBHZXQgbGFzdCB2ZXJ0ZXhcbiAqIEBtZXRob2QgbGFzdFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzW3RoaXMudmVydGljZXMubGVuZ3RoLTFdO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgcG9seWdvbiBkYXRhXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMudmVydGljZXMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogQXBwZW5kIHBvaW50cyBcImZyb21cIiB0byBcInRvXCItMSBmcm9tIGFuIG90aGVyIHBvbHlnb24gXCJwb2x5XCIgb250byB0aGlzIG9uZS5cbiAqIEBtZXRob2QgYXBwZW5kXG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHkgVGhlIHBvbHlnb24gdG8gZ2V0IHBvaW50cyBmcm9tLlxuICogQHBhcmFtIHtOdW1iZXJ9ICBmcm9tIFRoZSB2ZXJ0ZXggaW5kZXggaW4gXCJwb2x5XCIuXG4gKiBAcGFyYW0ge051bWJlcn0gIHRvIFRoZSBlbmQgdmVydGV4IGluZGV4IGluIFwicG9seVwiLiBOb3RlIHRoYXQgdGhpcyB2ZXJ0ZXggaXMgTk9UIGluY2x1ZGVkIHdoZW4gYXBwZW5kaW5nLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHBvbHksZnJvbSx0byl7XG4gICAgaWYodHlwZW9mKGZyb20pID09IFwidW5kZWZpbmVkXCIpIHRocm93IG5ldyBFcnJvcihcIkZyb20gaXMgbm90IGdpdmVuIVwiKTtcbiAgICBpZih0eXBlb2YodG8pID09IFwidW5kZWZpbmVkXCIpICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gaXMgbm90IGdpdmVuIVwiKTtcblxuICAgIGlmKHRvLTEgPCBmcm9tKSAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9sMVwiKTtcbiAgICBpZih0byA+IHBvbHkudmVydGljZXMubGVuZ3RoKSAgIHRocm93IG5ldyBFcnJvcihcImxvbDJcIik7XG4gICAgaWYoZnJvbSA8IDApICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2wzXCIpO1xuXG4gICAgZm9yKHZhciBpPWZyb207IGk8dG87IGkrKyl7XG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaChwb2x5LnZlcnRpY2VzW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2x5Z29uIHZlcnRpY2VzIGFyZSBvcmRlcmVkIGNvdW50ZXItY2xvY2t3aXNlLlxuICogQG1ldGhvZCBtYWtlQ0NXXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLm1ha2VDQ1cgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiciA9IDAsXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgLy8gZmluZCBib3R0b20gcmlnaHQgcG9pbnRcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHZbaV1bMV0gPCB2W2JyXVsxXSB8fCAodltpXVsxXSA9PSB2W2JyXVsxXSAmJiB2W2ldWzBdID4gdlticl1bMF0pKSB7XG4gICAgICAgICAgICBiciA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXZlcnNlIHBvbHkgaWYgY2xvY2t3aXNlXG4gICAgaWYgKCFQb2ludC5sZWZ0KHRoaXMuYXQoYnIgLSAxKSwgdGhpcy5hdChiciksIHRoaXMuYXQoYnIgKyAxKSkpIHtcbiAgICAgICAgdGhpcy5yZXZlcnNlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXZlcnNlIHRoZSB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvblxuICogQG1ldGhvZCByZXZlcnNlXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICBmb3IodmFyIGk9MCwgTj10aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHRtcC5wdXNoKHRoaXMudmVydGljZXMucG9wKCkpO1xuICAgIH1cbiAgICB0aGlzLnZlcnRpY2VzID0gdG1wO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGluIHRoZSBwb2x5Z29uIGlzIGEgcmVmbGV4IHBvaW50XG4gKiBAbWV0aG9kIGlzUmVmbGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBpXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5pc1JlZmxleCA9IGZ1bmN0aW9uKGkpe1xuICAgIHJldHVybiBQb2ludC5yaWdodCh0aGlzLmF0KGkgLSAxKSwgdGhpcy5hdChpKSwgdGhpcy5hdChpICsgMSkpO1xufTtcblxudmFyIHRtcExpbmUxPVtdLFxuICAgIHRtcExpbmUyPVtdO1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcbiAqIEBtZXRob2QgY2FuU2VlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGEgVmVydGV4IGluZGV4IDFcbiAqIEBwYXJhbSAge051bWJlcn0gYiBWZXJ0ZXggaW5kZXggMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY2FuU2VlID0gZnVuY3Rpb24oYSxiKSB7XG4gICAgdmFyIHAsIGRpc3QsIGwxPXRtcExpbmUxLCBsMj10bXBMaW5lMjtcblxuICAgIGlmIChQb2ludC5sZWZ0T24odGhpcy5hdChhICsgMSksIHRoaXMuYXQoYSksIHRoaXMuYXQoYikpICYmIFBvaW50LnJpZ2h0T24odGhpcy5hdChhIC0gMSksIHRoaXMuYXQoYSksIHRoaXMuYXQoYikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGlzdCA9IFBvaW50LnNxZGlzdCh0aGlzLmF0KGEpLCB0aGlzLmF0KGIpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkgeyAvLyBmb3IgZWFjaCBlZGdlXG4gICAgICAgIGlmICgoaSArIDEpICUgdGhpcy52ZXJ0aWNlcy5sZW5ndGggPT09IGEgfHwgaSA9PT0gYSkgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKFBvaW50LmxlZnRPbih0aGlzLmF0KGEpLCB0aGlzLmF0KGIpLCB0aGlzLmF0KGkgKyAxKSkgJiYgUG9pbnQucmlnaHRPbih0aGlzLmF0KGEpLCB0aGlzLmF0KGIpLCB0aGlzLmF0KGkpKSkgeyAvLyBpZiBkaWFnIGludGVyc2VjdHMgYW4gZWRnZVxuICAgICAgICAgICAgbDFbMF0gPSB0aGlzLmF0KGEpO1xuICAgICAgICAgICAgbDFbMV0gPSB0aGlzLmF0KGIpO1xuICAgICAgICAgICAgbDJbMF0gPSB0aGlzLmF0KGkpO1xuICAgICAgICAgICAgbDJbMV0gPSB0aGlzLmF0KGkgKyAxKTtcbiAgICAgICAgICAgIHAgPSBMaW5lLmxpbmVJbnQobDEsbDIpO1xuICAgICAgICAgICAgaWYgKFBvaW50LnNxZGlzdCh0aGlzLmF0KGEpLCBwKSA8IGRpc3QpIHsgLy8gaWYgZWRnZSBpcyBibG9ja2luZyB2aXNpYmlsaXR5IHRvIGJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgcG9seWdvbiBmcm9tIHZlcnRleCBpIHRvIHZlcnRleCBqLlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtICB7UG9seWdvbn0gW3RhcmdldFBvbHldICAgT3B0aW9uYWwgdGFyZ2V0IHBvbHlnb24gdG8gc2F2ZSBpbi5cbiAqIEByZXR1cm4ge1BvbHlnb259ICAgICAgICAgICAgICAgIFRoZSByZXN1bHRpbmcgY29weS5cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGksaix0YXJnZXRQb2x5KXtcbiAgICB2YXIgcCA9IHRhcmdldFBvbHkgfHwgbmV3IFBvbHlnb24oKTtcbiAgICBwLmNsZWFyKCk7XG4gICAgaWYgKGkgPCBqKSB7XG4gICAgICAgIC8vIEluc2VydCBhbGwgdmVydGljZXMgZnJvbSBpIHRvIGpcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8PWo7IGsrKylcbiAgICAgICAgICAgIHAudmVydGljZXMucHVzaCh0aGlzLnZlcnRpY2VzW2tdKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gSW5zZXJ0IHZlcnRpY2VzIDAgdG8galxuICAgICAgICBmb3IodmFyIGs9MDsgazw9ajsgaysrKVxuICAgICAgICAgICAgcC52ZXJ0aWNlcy5wdXNoKHRoaXMudmVydGljZXNba10pO1xuXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyBpIHRvIGVuZFxuICAgICAgICBmb3IodmFyIGs9aTsgazx0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgcC52ZXJ0aWNlcy5wdXNoKHRoaXMudmVydGljZXNba10pO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLyoqXG4gKiBEZWNvbXBvc2VzIHRoZSBwb2x5Z29uIGludG8gY29udmV4IHBpZWNlcy4gUmV0dXJucyBhIGxpc3Qgb2YgZWRnZXMgW1twMSxwMl0sW3AyLHAzXSwuLi5dIHRoYXQgY3V0cyB0aGUgcG9seWdvbi5cbiAqIE5vdGUgdGhhdCB0aGlzIGFsZ29yaXRobSBoYXMgY29tcGxleGl0eSBPKE5eNCkgYW5kIHdpbGwgYmUgdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1hbnkgdmVydGljZXMuXG4gKiBAbWV0aG9kIGdldEN1dEVkZ2VzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuZ2V0Q3V0RWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWluPVtdLCB0bXAxPVtdLCB0bXAyPVtdLCB0bXBQb2x5ID0gbmV3IFBvbHlnb24oKTtcbiAgICB2YXIgbkRpYWdzID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5pc1JlZmxleChpKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuU2VlKGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcDEgPSB0aGlzLmNvcHkoaSwgaiwgdG1wUG9seSkuZ2V0Q3V0RWRnZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wMiA9IHRoaXMuY29weShqLCBpLCB0bXBQb2x5KS5nZXRDdXRFZGdlcygpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrPHRtcDIubGVuZ3RoOyBrKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAxLnB1c2godG1wMltrXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcDEubGVuZ3RoIDwgbkRpYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB0bXAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbkRpYWdzID0gdG1wMS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4ucHVzaChbdGhpcy5hdChpKSwgdGhpcy5hdChqKV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbjtcbn07XG5cbi8qKlxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIG9uZSBvciBtb3JlIGNvbnZleCBzdWItUG9seWdvbnMuXG4gKiBAbWV0aG9kIGRlY29tcFxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9yIFBvbHlnb24gb2JqZWN0cy5cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuZGVjb21wID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmdldEN1dEVkZ2VzKCk7XG4gICAgaWYoZWRnZXMubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoZWRnZXMpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcbn07XG5cbi8qKlxuICogU2xpY2VzIHRoZSBwb2x5Z29uIGdpdmVuIG9uZSBvciBtb3JlIGN1dCBlZGdlcy4gSWYgZ2l2ZW4gb25lLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHR3byBwb2x5Z29ucyAoZmFsc2Ugb24gZmFpbHVyZSkuIElmIG1hbnksIGFuIGFycmF5IG9mIHBvbHlnb25zLlxuICogQG1ldGhvZCBzbGljZVxuICogQHBhcmFtIHtBcnJheX0gY3V0RWRnZXMgQSBsaXN0IG9mIGVkZ2VzLCBhcyByZXR1cm5lZCBieSAuZ2V0Q3V0RWRnZXMoKVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oY3V0RWRnZXMpe1xuICAgIGlmKGN1dEVkZ2VzLmxlbmd0aCA9PSAwKSByZXR1cm4gW3RoaXNdO1xuICAgIGlmKGN1dEVkZ2VzIGluc3RhbmNlb2YgQXJyYXkgJiYgY3V0RWRnZXMubGVuZ3RoICYmIGN1dEVkZ2VzWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgY3V0RWRnZXNbMF0ubGVuZ3RoPT0yICYmIGN1dEVkZ2VzWzBdWzBdIGluc3RhbmNlb2YgQXJyYXkpe1xuXG4gICAgICAgIHZhciBwb2x5cyA9IFt0aGlzXTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxjdXRFZGdlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzW2ldO1xuICAgICAgICAgICAgLy8gQ3V0IGFsbCBwb2x5c1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8cG9seXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgIHZhciBwb2x5ID0gcG9seXNbal07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBvbHkuc2xpY2UoY3V0RWRnZSk7XG4gICAgICAgICAgICAgICAgaWYocmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgcG9seSEgQ3V0IGFuZCBxdWl0XG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnNwbGljZShqLDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5cy5wdXNoKHJlc3VsdFswXSxyZXN1bHRbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seXM7XG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBXYXMgZ2l2ZW4gb25lIGVkZ2VcbiAgICAgICAgdmFyIGN1dEVkZ2UgPSBjdXRFZGdlcztcbiAgICAgICAgdmFyIGkgPSB0aGlzLnZlcnRpY2VzLmluZGV4T2YoY3V0RWRnZVswXSk7XG4gICAgICAgIHZhciBqID0gdGhpcy52ZXJ0aWNlcy5pbmRleE9mKGN1dEVkZ2VbMV0pO1xuXG4gICAgICAgIGlmKGkgIT0gLTEgJiYgaiAhPSAtMSl7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuY29weShpLGopLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHkoaixpKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyB0aGF0IHRoZSBsaW5lIHNlZ21lbnRzIG9mIHRoaXMgcG9seWdvbiBkbyBub3QgaW50ZXJzZWN0IGVhY2ggb3RoZXIuXG4gKiBAbWV0aG9kIGlzU2ltcGxlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiB2ZXJ0aWNlcyBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHRvZG8gU2hvdWxkIGl0IGNoZWNrIGFsbCBzZWdtZW50cyB3aXRoIGFsbCBvdGhlcnM/XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmlzU2ltcGxlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGF0aCA9IHRoaXMudmVydGljZXM7XG4gICAgLy8gQ2hlY2tcbiAgICBmb3IodmFyIGk9MDsgaTxwYXRoLmxlbmd0aC0xOyBpKyspe1xuICAgICAgICBmb3IodmFyIGo9MDsgajxpLTE7IGorKyl7XG4gICAgICAgICAgICBpZihMaW5lLnNlZ21lbnRzSW50ZXJzZWN0KHBhdGhbaV0sIHBhdGhbaSsxXSwgcGF0aFtqXSwgcGF0aFtqKzFdICkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBzZWdtZW50IGJldHdlZW4gdGhlIGxhc3QgYW5kIHRoZSBmaXJzdCBwb2ludCB0byBhbGwgb3RoZXJzXG4gICAgZm9yKHZhciBpPTE7IGk8cGF0aC5sZW5ndGgtMjsgaSsrKXtcbiAgICAgICAgaWYoTGluZS5zZWdtZW50c0ludGVyc2VjdChwYXRoWzBdLCBwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoW2ldLCBwYXRoW2krMV0gKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50KHAxLCBwMiwgcTEsIHEyLCBkZWx0YSl7XG4gICAgZGVsdGEgPSBkZWx0YSB8fCAwO1xuICAgdmFyIGExID0gcDJbMV0gLSBwMVsxXTtcbiAgIHZhciBiMSA9IHAxWzBdIC0gcDJbMF07XG4gICB2YXIgYzEgPSAoYTEgKiBwMVswXSkgKyAoYjEgKiBwMVsxXSk7XG4gICB2YXIgYTIgPSBxMlsxXSAtIHExWzFdO1xuICAgdmFyIGIyID0gcTFbMF0gLSBxMlswXTtcbiAgIHZhciBjMiA9IChhMiAqIHExWzBdKSArIChiMiAqIHExWzFdKTtcbiAgIHZhciBkZXQgPSAoYTEgKiBiMikgLSAoYTIgKiBiMSk7XG5cbiAgIGlmKCFTY2FsYXIuZXEoZGV0LDAsZGVsdGEpKVxuICAgICAgcmV0dXJuIFsoKGIyICogYzEpIC0gKGIxICogYzIpKSAvIGRldCwgKChhMSAqIGMyKSAtIChhMiAqIGMxKSkgLyBkZXRdXG4gICBlbHNlXG4gICAgICByZXR1cm4gWzAsMF1cbn1cblxuLyoqXG4gKiBRdWlja2x5IGRlY29tcG9zZSB0aGUgUG9seWdvbiBpbnRvIGNvbnZleCBzdWItcG9seWdvbnMuXG4gKiBAbWV0aG9kIHF1aWNrRGVjb21wXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XG4gKiBAcGFyYW0gIHtBcnJheX0gW3JlZmxleFZlcnRpY2VzXVxuICogQHBhcmFtICB7QXJyYXl9IFtzdGVpbmVyUG9pbnRzXVxuICogQHBhcmFtICB7TnVtYmVyfSBbZGVsdGFdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXhsZXZlbF1cbiAqIEBwYXJhbSAge051bWJlcn0gW2xldmVsXVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnF1aWNrRGVjb21wID0gZnVuY3Rpb24ocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpe1xuICAgIG1heGxldmVsID0gbWF4bGV2ZWwgfHwgMTAwO1xuICAgIGxldmVsID0gbGV2ZWwgfHwgMDtcbiAgICBkZWx0YSA9IGRlbHRhIHx8IDI1O1xuICAgIHJlc3VsdCA9IHR5cGVvZihyZXN1bHQpIT1cInVuZGVmaW5lZFwiID8gcmVzdWx0IDogW107XG4gICAgcmVmbGV4VmVydGljZXMgPSByZWZsZXhWZXJ0aWNlcyB8fCBbXTtcbiAgICBzdGVpbmVyUG9pbnRzID0gc3RlaW5lclBvaW50cyB8fCBbXTtcblxuICAgIHZhciB1cHBlckludD1bMCwwXSwgbG93ZXJJbnQ9WzAsMF0sIHA9WzAsMF07IC8vIFBvaW50c1xuICAgIHZhciB1cHBlckRpc3Q9MCwgbG93ZXJEaXN0PTAsIGQ9MCwgY2xvc2VzdERpc3Q9MDsgLy8gc2NhbGFyc1xuICAgIHZhciB1cHBlckluZGV4PTAsIGxvd2VySW5kZXg9MCwgY2xvc2VzdEluZGV4PTA7IC8vIEludGVnZXJzXG4gICAgdmFyIGxvd2VyUG9seT1uZXcgUG9seWdvbigpLCB1cHBlclBvbHk9bmV3IFBvbHlnb24oKTsgLy8gcG9seWdvbnNcbiAgICB2YXIgcG9seSA9IHRoaXMsXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgaWYodi5sZW5ndGggPCAzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgbGV2ZWwrKztcbiAgICBpZihsZXZlbCA+IG1heGxldmVsKXtcbiAgICAgICAgY29uc29sZS53YXJuKFwicXVpY2tEZWNvbXA6IG1heCBsZXZlbCAoXCIrbWF4bGV2ZWwrXCIpIHJlYWNoZWQuXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAocG9seS5pc1JlZmxleChpKSkge1xuICAgICAgICAgICAgcmVmbGV4VmVydGljZXMucHVzaChwb2x5LnZlcnRpY2VzW2ldKTtcbiAgICAgICAgICAgIHVwcGVyRGlzdCA9IGxvd2VyRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKFBvaW50LmxlZnQocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBQb2ludC5yaWdodE9uKHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGogLSAxKSkpIHsgLy8gaWYgbGluZSBpbnRlcnNlY3RzIHdpdGggYW4gZWRnZVxuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaiksIHBvbHkuYXQoaiAtIDEpKTsgLy8gZmluZCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChQb2ludC5yaWdodChwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcCkpIHsgLy8gbWFrZSBzdXJlIGl0J3MgaW5zaWRlIHRoZSBwb2x5XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gUG9pbnQuc3FkaXN0KHBvbHkudmVydGljZXNbaV0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBsb3dlckRpc3QpIHsgLy8ga2VlcCBvbmx5IHRoZSBjbG9zZXN0IGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyRGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChQb2ludC5sZWZ0KHBvbHkuYXQoaSArIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGogKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIFBvaW50LnJpZ2h0T24ocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqKSwgcG9seS5hdChqICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoUG9pbnQubGVmdChwb2x5LmF0KGkgLSAxKSwgcG9seS5hdChpKSwgcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBQb2ludC5zcWRpc3QocG9seS52ZXJ0aWNlc1tpXSwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IHVwcGVyRGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyRGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdmVydGljZXMgdG8gY29ubmVjdCB0bywgY2hvb3NlIGEgcG9pbnQgaW4gdGhlIG1pZGRsZVxuICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggPT0gKHVwcGVySW5kZXggKyAxKSAlIHRoaXMudmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMTogVmVydGV4KFwiK2krXCIpLCBsb3dlckluZGV4KFwiK2xvd2VySW5kZXgrXCIpLCB1cHBlckluZGV4KFwiK3VwcGVySW5kZXgrXCIpLCBwb2x5LnNpemUoXCIrdGhpcy52ZXJ0aWNlcy5sZW5ndGgrXCIpXCIpO1xuICAgICAgICAgICAgICAgIHBbMF0gPSAobG93ZXJJbnRbMF0gKyB1cHBlckludFswXSkgLyAyO1xuICAgICAgICAgICAgICAgIHBbMV0gPSAobG93ZXJJbnRbMV0gKyB1cHBlckludFsxXSkgLyAyO1xuICAgICAgICAgICAgICAgIHN0ZWluZXJQb2ludHMucHVzaChwKTtcblxuICAgICAgICAgICAgICAgIGlmIChpIDwgdXBwZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSwgaSwgdXBwZXJJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnZlcnRpY2VzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGxvd2VySW5kZXgsIHBvbHkuZW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LGxvd2VySW5kZXgscG9seS52ZXJ0aWNlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksMCxpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5lbmQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksaSxwb2x5LnZlcnRpY2VzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSwwLHVwcGVySW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkudmVydGljZXMucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5iZWdpbigpICsgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksbG93ZXJJbmRleCxpKzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdCB0byB0aGUgY2xvc2VzdCBwb2ludCB3aXRoaW4gdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMjogVmVydGV4KFwiK2krXCIpLCBjbG9zZXN0SW5kZXgoXCIrY2xvc2VzdEluZGV4K1wiKSwgcG9seS5zaXplKFwiK3RoaXMudmVydGljZXMubGVuZ3RoK1wiKVxcblwiKTtcblxuICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID4gdXBwZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ICs9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgICAgICAgICBpZih1cHBlckluZGV4IDwgbG93ZXJJbmRleCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGxvd2VySW5kZXg7IGogPD0gdXBwZXJJbmRleDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChQb2ludC5sZWZ0T24ocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgUG9pbnQucmlnaHRPbihwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBQb2ludC5zcWRpc3QocG9seS5hdChpKSwgcG9seS5hdChqKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGNsb3Nlc3REaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGogJSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpIDwgY2xvc2VzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSxpLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RJbmRleCAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSxjbG9zZXN0SW5kZXgsdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSwwLGkrMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksaSx2Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LDAsY2xvc2VzdEluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksY2xvc2VzdEluZGV4LGkrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzb2x2ZSBzbWFsbGVzdCBwb2x5IGZpcnN0XG4gICAgICAgICAgICBpZiAobG93ZXJQb2x5LnZlcnRpY2VzLmxlbmd0aCA8IHVwcGVyUG9seS52ZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb3dlclBvbHkucXVpY2tEZWNvbXAocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgICAgIHVwcGVyUG9seS5xdWlja0RlY29tcChyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwcGVyUG9seS5xdWlja0RlY29tcChyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICAgICAgbG93ZXJQb2x5LnF1aWNrRGVjb21wKHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQucHVzaCh0aGlzKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBjb2xsaW5lYXIgcG9pbnRzIGluIHRoZSBwb2x5Z29uLlxuICogQG1ldGhvZCByZW1vdmVDb2xsaW5lYXJQb2ludHNcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBlZGdlcyBhcmUgY29sbGluZWFyLiBVc2UgemVybyBmb3IgZmluZXN0IHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlbW92ZWRcbiAqL1xuUG9seWdvbi5wcm90b3R5cGUucmVtb3ZlQ29sbGluZWFyUG9pbnRzID0gZnVuY3Rpb24ocHJlY2lzaW9uKXtcbiAgICB2YXIgbnVtID0gMDtcbiAgICBmb3IodmFyIGk9dGhpcy52ZXJ0aWNlcy5sZW5ndGgtMTsgdGhpcy52ZXJ0aWNlcy5sZW5ndGg+MyAmJiBpPj0wOyAtLWkpe1xuICAgICAgICBpZihQb2ludC5jb2xsaW5lYXIodGhpcy5hdChpLTEpLHRoaXMuYXQoaSksdGhpcy5hdChpKzEpLHByZWNpc2lvbikpe1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBtaWRkbGUgcG9pbnRcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMuc3BsaWNlKGkldGhpcy52ZXJ0aWNlcy5sZW5ndGgsMSk7XG4gICAgICAgICAgICBpLS07IC8vIEp1bXAgb25lIHBvaW50IGZvcndhcmQuIE90aGVyd2lzZSB3ZSBtYXkgZ2V0IGEgY2hhaW4gcmVtb3ZhbFxuICAgICAgICAgICAgbnVtKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbn07XG5cbn0se1wiLi9MaW5lXCI6MSxcIi4vUG9pbnRcIjoyLFwiLi9TY2FsYXJcIjo0fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxhcjtcblxuLyoqXG4gKiBTY2FsYXIgZnVuY3Rpb25zXG4gKiBAY2xhc3MgU2NhbGFyXG4gKi9cbmZ1bmN0aW9uIFNjYWxhcigpe31cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gc2NhbGFycyBhcmUgZXF1YWxcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZXFcbiAqIEBwYXJhbSAge051bWJlcn0gYVxuICogQHBhcmFtICB7TnVtYmVyfSBiXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5TY2FsYXIuZXEgPSBmdW5jdGlvbihhLGIscHJlY2lzaW9uKXtcbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMDtcbiAgICByZXR1cm4gTWF0aC5hYnMoYS1iKSA8IHByZWNpc2lvbjtcbn07XG5cbn0se31dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUG9seWdvbiA6IF9kZXJlcV8oXCIuL1BvbHlnb25cIiksXG4gICAgUG9pbnQgOiBfZGVyZXFfKFwiLi9Qb2ludFwiKSxcbn07XG5cbn0se1wiLi9Qb2ludFwiOjIsXCIuL1BvbHlnb25cIjozfV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcInAyXCIsXG4gIFwidmVyc2lvblwiOiBcIjAuNi4xXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIEphdmFTY3JpcHQgMkQgcGh5c2ljcyBlbmdpbmUuXCIsXG4gIFwiYXV0aG9yXCI6IFwiU3RlZmFuIEhlZG1hbiA8c2NodGVwcGVAZ21haWwuY29tPiAoaHR0cDovL3N0ZWZmZS5zZSlcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJwMi5qc1wiLFxuICAgIFwicDJcIixcbiAgICBcInBoeXNpY3NcIixcbiAgICBcImVuZ2luZVwiLFxuICAgIFwiMmRcIlxuICBdLFxuICBcIm1haW5cIjogXCIuL3NyYy9wMi5qc1wiLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIipcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3AyLmpzLmdpdFwiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvcDIuanMvaXNzdWVzXCJcbiAgfSxcbiAgXCJsaWNlbnNlc1wiOiBbXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwiTUlUXCJcbiAgICB9XG4gIF0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImdydW50XCI6IFwifjAuNC4wXCIsXG4gICAgXCJncnVudC1jb250cmliLWpzaGludFwiOiBcIn4wLjkuMlwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1ub2RldW5pdFwiOiBcIn4wLjEuMlwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJ+MC40LjBcIixcbiAgICBcImdydW50LWNvbnRyaWItd2F0Y2hcIjogXCJ+MC41LjBcIixcbiAgICBcImdydW50LWJyb3dzZXJpZnlcIjogXCJ+Mi4wLjFcIixcbiAgICBcImdydW50LWNvbnRyaWItY29uY2F0XCI6IFwiXjAuNC4wXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwicG9seS1kZWNvbXBcIjogXCIwLjEuMFwiXG4gIH1cbn1cblxufSx7fV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFBQkI7XG5cbi8qKlxuICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBjbGFzcy5cbiAqIEBjbGFzcyBBQUJCXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLnVwcGVyQm91bmRdXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvd2VyQm91bmRdXG4gKi9cbmZ1bmN0aW9uIEFBQkIob3B0aW9ucyl7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAcHJvcGVydHkgbG93ZXJCb3VuZFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyQm91bmQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5sb3dlckJvdW5kKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMubG93ZXJCb3VuZCwgb3B0aW9ucy5sb3dlckJvdW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAcHJvcGVydHkgdXBwZXJCb3VuZFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyQm91bmQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIGlmKG9wdGlvbnMgJiYgb3B0aW9ucy51cHBlckJvdW5kKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMudXBwZXJCb3VuZCwgb3B0aW9ucy51cHBlckJvdW5kKTtcbiAgICB9XG59XG5cbnZhciB0bXAgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFNldCB0aGUgQUFCQiBib3VuZHMgZnJvbSBhIHNldCBvZiBwb2ludHMuXG4gKiBAbWV0aG9kIHNldEZyb21Qb2ludHNcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBbiBhcnJheSBvZiB2ZWMyJ3MuXG4gKi9cbkFBQkIucHJvdG90eXBlLnNldEZyb21Qb2ludHMgPSBmdW5jdGlvbihwb2ludHMsIHBvc2l0aW9uLCBhbmdsZSwgc2tpblNpemUpe1xuICAgIHZhciBsID0gdGhpcy5sb3dlckJvdW5kLFxuICAgICAgICB1ID0gdGhpcy51cHBlckJvdW5kO1xuXG4gICAgaWYodHlwZW9mKGFuZ2xlKSAhPT0gXCJudW1iZXJcIil7XG4gICAgICAgIGFuZ2xlID0gMDtcbiAgICB9XG5cbiAgICAvLyBTZXQgdG8gdGhlIGZpcnN0IHBvaW50XG4gICAgaWYoYW5nbGUgIT09IDApe1xuICAgICAgICB2ZWMyLnJvdGF0ZShsLCBwb2ludHNbMF0sIGFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2ZWMyLmNvcHkobCwgcG9pbnRzWzBdKTtcbiAgICB9XG4gICAgdmVjMi5jb3B5KHUsIGwpO1xuXG4gICAgLy8gQ29tcHV0ZSBjb3NpbmVzIGFuZCBzaW5lcyBqdXN0IG9uY2VcbiAgICB2YXIgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGZvcih2YXIgaSA9IDE7IGk8cG9pbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG5cbiAgICAgICAgaWYoYW5nbGUgIT09IDApe1xuICAgICAgICAgICAgdmFyIHggPSBwWzBdLFxuICAgICAgICAgICAgICAgIHkgPSBwWzFdO1xuICAgICAgICAgICAgdG1wWzBdID0gY29zQW5nbGUgKiB4IC1zaW5BbmdsZSAqIHk7XG4gICAgICAgICAgICB0bXBbMV0gPSBzaW5BbmdsZSAqIHggK2Nvc0FuZ2xlICogeTtcbiAgICAgICAgICAgIHAgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IodmFyIGo9MDsgajwyOyBqKyspe1xuICAgICAgICAgICAgaWYocFtqXSA+IHVbal0pe1xuICAgICAgICAgICAgICAgIHVbal0gPSBwW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYocFtqXSA8IGxbal0pe1xuICAgICAgICAgICAgICAgIGxbal0gPSBwW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIG9mZnNldFxuICAgIGlmKHBvc2l0aW9uKXtcbiAgICAgICAgdmVjMi5hZGQodGhpcy5sb3dlckJvdW5kLCB0aGlzLmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5hZGQodGhpcy51cHBlckJvdW5kLCB0aGlzLnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZihza2luU2l6ZSl7XG4gICAgICAgIHRoaXMubG93ZXJCb3VuZFswXSAtPSBza2luU2l6ZTtcbiAgICAgICAgdGhpcy5sb3dlckJvdW5kWzFdIC09IHNraW5TaXplO1xuICAgICAgICB0aGlzLnVwcGVyQm91bmRbMF0gKz0gc2tpblNpemU7XG4gICAgICAgIHRoaXMudXBwZXJCb3VuZFsxXSArPSBza2luU2l6ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvcHkgYm91bmRzIGZyb20gYW4gQUFCQiB0byB0aGlzIEFBQkJcbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICovXG5BQUJCLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oYWFiYil7XG4gICAgdmVjMi5jb3B5KHRoaXMubG93ZXJCb3VuZCwgYWFiYi5sb3dlckJvdW5kKTtcbiAgICB2ZWMyLmNvcHkodGhpcy51cHBlckJvdW5kLCBhYWJiLnVwcGVyQm91bmQpO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgdGhpcyBBQUJCIHNvIHRoYXQgaXQgY292ZXJzIHRoZSBnaXZlbiBBQUJCIHRvby5cbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKi9cbkFBQkIucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIC8vIExvb3Agb3ZlciB4IGFuZCB5XG4gICAgdmFyIGkgPSAyO1xuICAgIHdoaWxlKGktLSl7XG4gICAgICAgIC8vIEV4dGVuZCBsb3dlciBib3VuZFxuICAgICAgICB2YXIgbCA9IGFhYmIubG93ZXJCb3VuZFtpXTtcbiAgICAgICAgaWYodGhpcy5sb3dlckJvdW5kW2ldID4gbCl7XG4gICAgICAgICAgICB0aGlzLmxvd2VyQm91bmRbaV0gPSBsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBwZXJcbiAgICAgICAgdmFyIHUgPSBhYWJiLnVwcGVyQm91bmRbaV07XG4gICAgICAgIGlmKHRoaXMudXBwZXJCb3VuZFtpXSA8IHUpe1xuICAgICAgICAgICAgdGhpcy51cHBlckJvdW5kW2ldID0gdTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBBQUJCIG92ZXJsYXBzIHRoaXMgQUFCQi5cbiAqIEBtZXRob2Qgb3ZlcmxhcHNcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkFBQkIucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24oYWFiYil7XG4gICAgdmFyIGwxID0gdGhpcy5sb3dlckJvdW5kLFxuICAgICAgICB1MSA9IHRoaXMudXBwZXJCb3VuZCxcbiAgICAgICAgbDIgPSBhYWJiLmxvd2VyQm91bmQsXG4gICAgICAgIHUyID0gYWFiYi51cHBlckJvdW5kO1xuXG4gICAgLy8gICAgICBsMiAgICAgICAgdTJcbiAgICAvLyAgICAgIHwtLS0tLS0tLS18XG4gICAgLy8gfC0tLS0tLS0tfFxuICAgIC8vIGwxICAgICAgIHUxXG5cbiAgICByZXR1cm4gKChsMlswXSA8PSB1MVswXSAmJiB1MVswXSA8PSB1MlswXSkgfHwgKGwxWzBdIDw9IHUyWzBdICYmIHUyWzBdIDw9IHUxWzBdKSkgJiZcbiAgICAgICAgICAgKChsMlsxXSA8PSB1MVsxXSAmJiB1MVsxXSA8PSB1MlsxXSkgfHwgKGwxWzFdIDw9IHUyWzFdICYmIHUyWzFdIDw9IHUxWzFdKSk7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBicm9hZHBoYXNlIGltcGxlbWVudGF0aW9ucy5cbiAqIEBjbGFzcyBCcm9hZHBoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQnJvYWRwaGFzZSh0eXBlKXtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0aW5nIG92ZXJsYXBwaW5nIHBhaXJzLiBXaWxsIGJlIGZpbGxlZCB3aXRoIHJlc3VsdHMgZHVyaW5nIC5nZXRDb2xsaXNpb25QYWlycygpLlxuICAgICAqIEBwcm9wZXJ0eSByZXN1bHRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5yZXN1bHQgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZCB0byBzZWFyY2ggZm9yIGNvbGxpc2lvbiBwYWlycyBpbi4gVG8gY2hhbmdlIGl0LCB1c2UgLnNldFdvcmxkKClcbiAgICAgKiBAcHJvcGVydHkgd29ybGRcbiAgICAgKiBAdHlwZSB7V29ybGR9XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm91bmRpbmcgdm9sdW1lIHR5cGUgdG8gdXNlIGluIHRoZSBicm9hZHBoYXNlIGFsZ29yaXRobXMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGJvdW5kaW5nVm9sdW1lVHlwZVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRpbmdWb2x1bWVUeXBlID0gQnJvYWRwaGFzZS5BQUJCO1xufVxuXG4vKipcbiAqIEF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggdHlwZS5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBBQUJCXG4gKi9cbkJyb2FkcGhhc2UuQUFCQiA9IDE7XG5cbi8qKlxuICogQm91bmRpbmcgY2lyY2xlIHR5cGUuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQk9VTkRJTkdfQ0lSQ0xFXG4gKi9cbkJyb2FkcGhhc2UuQk9VTkRJTkdfQ0lSQ0xFID0gMjtcblxuLyoqXG4gKiBTZXQgdGhlIHdvcmxkIHRoYXQgd2UgYXJlIHNlYXJjaGluZyBmb3IgY29sbGlzaW9uIHBhaXJzIGluXG4gKiBAbWV0aG9kIHNldFdvcmxkXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuc2V0V29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xufTtcblxuLyoqXG4gKiBHZXQgYWxsIHBvdGVudGlhbCBpbnRlcnNlY3RpbmcgYm9keSBwYWlycy5cbiAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZCBUaGUgd29ybGQgdG8gc2VhcmNoIGluLlxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSBib2RpZXMsIG9yZGVyZWQgaW4gcGFpcnMuIEV4YW1wbGU6IEEgcmVzdWx0IG9mIFthLGIsYyxkXSBtZWFucyB0aGF0IHRoZSBwb3RlbnRpYWwgcGFpcnMgYXJlOiAoYSxiKSwgKGMsZCkuXG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQpe1xuICAgIHRocm93IG5ldyBFcnJvcihcImdldENvbGxpc2lvblBhaXJzIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBzdWJjbGFzcyFcIik7XG59O1xuXG52YXIgZGlzdCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgYm91bmRpbmcgcmFkaXVzIG9mIHR3byBib2RpZXMgb3ZlcmxhcC5cbiAqIEBtZXRob2QgIGJvdW5kaW5nUmFkaXVzQ2hlY2tcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuQnJvYWRwaGFzZS5ib3VuZGluZ1JhZGl1c0NoZWNrID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2ZWMyLnN1YihkaXN0LCBib2R5QS5wb3NpdGlvbiwgYm9keUIucG9zaXRpb24pO1xuICAgIHZhciBkMiA9IHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSxcbiAgICAgICAgciA9IGJvZHlBLmJvdW5kaW5nUmFkaXVzICsgYm9keUIuYm91bmRpbmdSYWRpdXM7XG4gICAgcmV0dXJuIGQyIDw9IHIqcjtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgYm91bmRpbmcgcmFkaXVzIG9mIHR3byBib2RpZXMgb3ZlcmxhcC5cbiAqIEBtZXRob2QgIGJvdW5kaW5nUmFkaXVzQ2hlY2tcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuQnJvYWRwaGFzZS5hYWJiQ2hlY2sgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHJldHVybiBib2R5QS5nZXRBQUJCKCkub3ZlcmxhcHMoYm9keUIuZ2V0QUFCQigpKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgYm91bmRpbmcgcmFkaXVzIG9mIHR3byBib2RpZXMgb3ZlcmxhcC5cbiAqIEBtZXRob2QgIGJvdW5kaW5nUmFkaXVzQ2hlY2tcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuYm91bmRpbmdWb2x1bWVDaGVjayA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHN3aXRjaCh0aGlzLmJvdW5kaW5nVm9sdW1lVHlwZSl7XG4gICAgY2FzZSBCcm9hZHBoYXNlLkJPVU5ESU5HX0NJUkNMRTpcbiAgICAgICAgcmVzdWx0ID0gIEJyb2FkcGhhc2UuYm91bmRpbmdSYWRpdXNDaGVjayhib2R5QSxib2R5Qik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgQnJvYWRwaGFzZS5BQUJCOlxuICAgICAgICByZXN1bHQgPSBCcm9hZHBoYXNlLmFhYmJDaGVjayhib2R5QSxib2R5Qik7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQm91bmRpbmcgdm9sdW1lIHR5cGUgbm90IHJlY29nbml6ZWQ6ICcrdGhpcy5ib3VuZGluZ1ZvbHVtZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBib2RpZXMgYXJlIGFsbG93ZWQgdG8gY29sbGlkZSBhdCBhbGwuXG4gKiBAbWV0aG9kICBjYW5Db2xsaWRlXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkJyb2FkcGhhc2UuY2FuQ29sbGlkZSA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBzdGF0aWMgYm9kaWVzXG4gICAgaWYoYm9keUEudHlwZSA9PT0gQm9keS5TVEFUSUMgJiYgYm9keUIudHlwZSA9PT0gQm9keS5TVEFUSUMpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgc3RhdGljIHZzIGtpbmVtYXRpYyBib2RpZXNcbiAgICBpZiggKGJvZHlBLnR5cGUgPT09IEJvZHkuS0lORU1BVElDICYmIGJvZHlCLnR5cGUgPT09IEJvZHkuU1RBVElDKSB8fFxuICAgICAgICAoYm9keUEudHlwZSA9PT0gQm9keS5TVEFUSUMgICAgJiYgYm9keUIudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENhbm5vdCBjb2xsaWRlIGtpbmVtYXRpYyB2cyBraW5lbWF0aWNcbiAgICBpZihib2R5QS50eXBlID09PSBCb2R5LktJTkVNQVRJQyAmJiBib2R5Qi50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBib3RoIHNsZWVwaW5nIGJvZGllc1xuICAgIGlmKGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBpZiBvbmUgaXMgc3RhdGljIGFuZCB0aGUgb3RoZXIgaXMgc2xlZXBpbmdcbiAgICBpZiggKGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keUIudHlwZSA9PT0gQm9keS5TVEFUSUMpIHx8XG4gICAgICAgIChib2R5Qi5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HICYmIGJvZHlBLnR5cGUgPT09IEJvZHkuU1RBVElDKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkJyb2FkcGhhc2UuTkFJVkUgPSAxO1xuQnJvYWRwaGFzZS5TQVAgPSAyO1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzJ9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDaXJjbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ2lyY2xlJylcbiwgICBQbGFuZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QbGFuZScpXG4sICAgUGFydGljbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGFydGljbGUnKVxuLCAgIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWRCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEJyb2FkcGhhc2UgdGhhdCB1c2VzIGF4aXMtYWxpZ25lZCBiaW5zLlxuICogQGNsYXNzIEdyaWRCcm9hZHBoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEJyb2FkcGhhc2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy54bWluXSAgIExvd2VyIHggYm91bmQgb2YgdGhlIGdyaWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy54bWF4XSAgIFVwcGVyIHggYm91bmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy55bWluXSAgIExvd2VyIHkgYm91bmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy55bWF4XSAgIFVwcGVyIHkgYm91bmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ueF0gICAgIE51bWJlciBvZiBiaW5zIGFsb25nIHggYXhpc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm55XSAgICAgTnVtYmVyIG9mIGJpbnMgYWxvbmcgeSBheGlzXG4gKiBAdG9kbyBTaG91bGQgaGF2ZSBhbiBvcHRpb24gZm9yIGR5bmFtaWMgc2NlbmUgc2l6ZVxuICovXG5mdW5jdGlvbiBHcmlkQnJvYWRwaGFzZShvcHRpb25zKXtcbiAgICBCcm9hZHBoYXNlLmFwcGx5KHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICB4bWluOiAgIC0xMDAsXG4gICAgICAgIHhtYXg6ICAgMTAwLFxuICAgICAgICB5bWluOiAgIC0xMDAsXG4gICAgICAgIHltYXg6ICAgMTAwLFxuICAgICAgICBueDogICAgIDEwLFxuICAgICAgICBueTogICAgIDEwXG4gICAgfSk7XG5cbiAgICB0aGlzLnhtaW4gPSBvcHRpb25zLnhtaW47XG4gICAgdGhpcy55bWluID0gb3B0aW9ucy55bWluO1xuICAgIHRoaXMueG1heCA9IG9wdGlvbnMueG1heDtcbiAgICB0aGlzLnltYXggPSBvcHRpb25zLnltYXg7XG4gICAgdGhpcy5ueCA9IG9wdGlvbnMubng7XG4gICAgdGhpcy5ueSA9IG9wdGlvbnMubnk7XG5cbiAgICB0aGlzLmJpbnNpemVYID0gKHRoaXMueG1heC10aGlzLnhtaW4pIC8gdGhpcy5ueDtcbiAgICB0aGlzLmJpbnNpemVZID0gKHRoaXMueW1heC10aGlzLnltaW4pIC8gdGhpcy5ueTtcbn1cbkdyaWRCcm9hZHBoYXNlLnByb3RvdHlwZSA9IG5ldyBCcm9hZHBoYXNlKCk7XG5HcmlkQnJvYWRwaGFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmlkQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBHZXQgY29sbGlzaW9uIHBhaXJzLlxuICogQG1ldGhvZCBnZXRDb2xsaXNpb25QYWlyc1xuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQpe1xuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICBOY29sbGlkaW5nID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgYmluc2l6ZVggPSB0aGlzLmJpbnNpemVYLFxuICAgICAgICBiaW5zaXplWSA9IHRoaXMuYmluc2l6ZVksXG4gICAgICAgIG54ID0gdGhpcy5ueCxcbiAgICAgICAgbnkgPSB0aGlzLm55LFxuICAgICAgICB4bWluID0gdGhpcy54bWluLFxuICAgICAgICB5bWluID0gdGhpcy55bWluLFxuICAgICAgICB4bWF4ID0gdGhpcy54bWF4LFxuICAgICAgICB5bWF4ID0gdGhpcy55bWF4O1xuXG4gICAgLy8gVG9kbzogbWFrZSBnYXJiYWdlIGZyZWVcbiAgICB2YXIgYmlucz1bXSwgTmJpbnM9bngqbnk7XG4gICAgZm9yKHZhciBpPTA7IGk8TmJpbnM7IGkrKyl7XG4gICAgICAgIGJpbnMucHVzaChbXSk7XG4gICAgfVxuXG4gICAgdmFyIHhtdWx0ID0gbnggLyAoeG1heC14bWluKTtcbiAgICB2YXIgeW11bHQgPSBueSAvICh5bWF4LXltaW4pO1xuXG4gICAgLy8gUHV0IGFsbCBib2RpZXMgaW50byBiaW5zXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OY29sbGlkaW5nOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG4gICAgICAgIHZhciBhYWJiID0gYmkuYWFiYjtcbiAgICAgICAgdmFyIGxvd2VyWCA9IE1hdGgubWF4KGFhYmIubG93ZXJCb3VuZFswXSwgeG1pbik7XG4gICAgICAgIHZhciBsb3dlclkgPSBNYXRoLm1heChhYWJiLmxvd2VyQm91bmRbMV0sIHltaW4pO1xuICAgICAgICB2YXIgdXBwZXJYID0gTWF0aC5taW4oYWFiYi51cHBlckJvdW5kWzBdLCB4bWF4KTtcbiAgICAgICAgdmFyIHVwcGVyWSA9IE1hdGgubWluKGFhYmIudXBwZXJCb3VuZFsxXSwgeW1heCk7XG4gICAgICAgIHZhciB4aTEgPSBNYXRoLmZsb29yKHhtdWx0ICogKGxvd2VyWCAtIHhtaW4pKTtcbiAgICAgICAgdmFyIHlpMSA9IE1hdGguZmxvb3IoeW11bHQgKiAobG93ZXJZIC0geW1pbikpO1xuICAgICAgICB2YXIgeGkyID0gTWF0aC5mbG9vcih4bXVsdCAqICh1cHBlclggLSB4bWluKSk7XG4gICAgICAgIHZhciB5aTIgPSBNYXRoLmZsb29yKHltdWx0ICogKHVwcGVyWSAtIHltaW4pKTtcblxuICAgICAgICAvLyBQdXQgaW4gYmluXG4gICAgICAgIGZvcih2YXIgaj14aTE7IGo8PXhpMjsgaisrKXtcbiAgICAgICAgICAgIGZvcih2YXIgaz15aTE7IGs8PXlpMjsgaysrKXtcbiAgICAgICAgICAgICAgICB2YXIgeGkgPSBqO1xuICAgICAgICAgICAgICAgIHZhciB5aSA9IGs7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IHhpKihueS0xKSArIHlpO1xuICAgICAgICAgICAgICAgIGlmKGlkeCA+PSAwICYmIGlkeCA8IE5iaW5zKXtcbiAgICAgICAgICAgICAgICAgICAgYmluc1sgaWR4IF0ucHVzaChiaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZWFjaCBiaW5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU5iaW5zOyBpKyspe1xuICAgICAgICB2YXIgYmluID0gYmluc1tpXTtcblxuICAgICAgICBmb3IodmFyIGo9MCwgTmJvZGllc0luQmluPWJpbi5sZW5ndGg7IGohPT1OYm9kaWVzSW5CaW47IGorKyl7XG4gICAgICAgICAgICB2YXIgYmkgPSBiaW5bal07XG4gICAgICAgICAgICBmb3IodmFyIGs9MDsgayE9PWo7IGsrKyl7XG4gICAgICAgICAgICAgICAgdmFyIGJqID0gYmluW2tdO1xuICAgICAgICAgICAgICAgIGlmKEJyb2FkcGhhc2UuY2FuQ29sbGlkZShiaSxiaikgJiYgdGhpcy5ib3VuZGluZ1ZvbHVtZUNoZWNrKGJpLGJqKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpLGJqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbn0se1wiLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo4LFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9zaGFwZXMvQ2lyY2xlXCI6MzgsXCIuLi9zaGFwZXMvUGFydGljbGVcIjo0MixcIi4uL3NoYXBlcy9QbGFuZVwiOjQzLFwiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDaXJjbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ2lyY2xlJyksXG4gICAgUGxhbmUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGxhbmUnKSxcbiAgICBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpLFxuICAgIFBhcnRpY2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL1BhcnRpY2xlJyksXG4gICAgQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJyksXG4gICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5haXZlQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBOYWl2ZSBicm9hZHBoYXNlIGltcGxlbWVudGF0aW9uLiBEb2VzIE5eMiB0ZXN0cy5cbiAqXG4gKiBAY2xhc3MgTmFpdmVCcm9hZHBoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEJyb2FkcGhhc2VcbiAqL1xuZnVuY3Rpb24gTmFpdmVCcm9hZHBoYXNlKCl7XG4gICAgQnJvYWRwaGFzZS5jYWxsKHRoaXMsIEJyb2FkcGhhc2UuTkFJVkUpO1xufVxuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZSA9IG5ldyBCcm9hZHBoYXNlKCk7XG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTmFpdmVCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEdldCB0aGUgY29sbGlkaW5nIHBhaXJzXG4gKiBAbWV0aG9kIGdldENvbGxpc2lvblBhaXJzXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQpe1xuICAgIHZhciBib2RpZXMgPSB3b3JsZC5ib2RpZXMsXG4gICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0O1xuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IDA7XG5cbiAgICBmb3IodmFyIGk9MCwgTmNvbGxpZGluZz1ib2RpZXMubGVuZ3RoOyBpIT09TmNvbGxpZGluZzsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPGk7IGorKyl7XG4gICAgICAgICAgICB2YXIgYmogPSBib2RpZXNbal07XG5cbiAgICAgICAgICAgIGlmKEJyb2FkcGhhc2UuY2FuQ29sbGlkZShiaSxiaikgJiYgdGhpcy5ib3VuZGluZ1ZvbHVtZUNoZWNrKGJpLGJqKSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmksYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gYW4gQUFCQi5cbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24od29ybGQsIGFhYmIsIHJlc3VsdCl7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gICAgdmFyIGJvZGllcyA9IHdvcmxkLmJvZGllcztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBib2RpZXNbaV07XG5cbiAgICAgICAgaWYoYi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgYi51cGRhdGVBQUJCKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihiLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbn0se1wiLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo4LFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9zaGFwZXMvQ2lyY2xlXCI6MzgsXCIuLi9zaGFwZXMvUGFydGljbGVcIjo0MixcIi4uL3NoYXBlcy9QbGFuZVwiOjQzLFwiLi4vc2hhcGVzL1NoYXBlXCI6NDV9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgc3ViID0gdmVjMi5zdWJcbiwgICBhZGQgPSB2ZWMyLmFkZFxuLCAgIGRvdCA9IHZlYzIuZG90XG4sICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpXG4sICAgVHVwbGVEaWN0aW9uYXJ5ID0gX2RlcmVxXygnLi4vdXRpbHMvVHVwbGVEaWN0aW9uYXJ5JylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpXG4sICAgRnJpY3Rpb25FcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uJylcbiwgICBDaXJjbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ2lyY2xlJylcbiwgICBDb252ZXggPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ29udmV4JylcbiwgICBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpXG4sICAgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpXG4sICAgUmVjdGFuZ2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL1JlY3RhbmdsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hcnJvd3BoYXNlO1xuXG4vLyBUZW1wIHRoaW5nc1xudmFyIHlBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDAsMSk7XG5cbnZhciB0bXAxID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAzID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA1ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA2ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA3ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA4ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA5ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxMCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDEyID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTQgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE1ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxNiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTcgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE4ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXBBcnJheSA9IFtdO1xuXG4vKipcbiAqIE5hcnJvd3BoYXNlLiBDcmVhdGVzIGNvbnRhY3RzIGFuZCBmcmljdGlvbiBnaXZlbiBzaGFwZXMgYW5kIHRyYW5zZm9ybXMuXG4gKiBAY2xhc3MgTmFycm93cGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBOYXJyb3dwaGFzZSgpe1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RFcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25FcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBtYWtlIGZyaWN0aW9uIGVxdWF0aW9ucyBpbiB0aGUgdXBjb21pbmcgY29udGFjdHMuXG4gICAgICogQHByb3BlcnR5IGVuYWJsZUZyaWN0aW9uXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIG1ha2UgZXF1YXRpb25zIGVuYWJsZWQgaW4gdXBjb21pbmcgY29udGFjdHMuXG4gICAgICogQHByb3BlcnR5IGVuYWJsZWRFcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZWRFcXVhdGlvbnMgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyaWN0aW9uIHNsaXAgZm9yY2UgdG8gdXNlIHdoZW4gY3JlYXRpbmcgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBzbGlwRm9yY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2xpcEZvcmNlID0gMTAuMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmljdGlvbiB2YWx1ZSB0byB1c2UgaW4gdGhlIHVwY29taW5nIGZyaWN0aW9uIGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25Db2VmZmljaWVudFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkNvZWZmaWNpZW50ID0gMC4zO1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBiZSB0aGUgLnJlbGF0aXZlVmVsb2NpdHkgaW4gZWFjaCBwcm9kdWNlZCBGcmljdGlvbkVxdWF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdXJmYWNlVmVsb2NpdHlcbiAgICAgKi9cbiAgICB0aGlzLnN1cmZhY2VWZWxvY2l0eSA9IDA7XG5cbiAgICB0aGlzLnJldXNlT2JqZWN0cyA9IHRydWU7XG4gICAgdGhpcy5yZXVzYWJsZUNvbnRhY3RFcXVhdGlvbnMgPSBbXTtcbiAgICB0aGlzLnJldXNhYmxlRnJpY3Rpb25FcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN0aXR1dGlvbiB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgY29udGFjdCBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGlmZm5lc3MgdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGNvbnRhY3QgZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdGlmZm5lc3NcbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0aWZmbmVzcyB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgY29udGFjdCBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN0aWZmbmVzc1xuICAgICAqL1xuICAgIHRoaXMucmVsYXhhdGlvbiA9IEVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGlmZm5lc3MgdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGZyaWN0aW9uIGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25TdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25TdGlmZm5lc3MgPSBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWxheGF0aW9uIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBmcmljdGlvbiBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uUmVsYXhhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblJlbGF4YXRpb24gPSBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgcmVkdWN0aW9uIG9mIGZyaWN0aW9uIGVxdWF0aW9ucy4gSWYgZGlzYWJsZWQsIGEgYm94IG9uIGEgcGxhbmUgd2lsbCBnZW5lcmF0ZSAyIGNvbnRhY3QgZXF1YXRpb25zIGFuZCAyIGZyaWN0aW9uIGVxdWF0aW9ucy4gSWYgZW5hYmxlZCwgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSBmcmljdGlvbiBlcXVhdGlvbi4gU2FtZSBraW5kIG9mIHNpbXBsaWZpY2F0aW9ucyBhcmUgbWFkZSAgZm9yIGFsbCBjb2xsaXNpb24gdHlwZXMuXG4gICAgICogQHByb3BlcnR5IGVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBmbGFnIHdpbGwgYmUgcmVtb3ZlZCB3aGVuIHRoZSBmZWF0dXJlIGlzIHN0YWJsZSBlbm91Z2guXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGNvbGxpZGluZyBib2RpZXMgbGFzdCBzdGVwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IGNvbGxpZGluZ0JvZGllc0xhc3RTdGVwXG4gICAgICogQHR5cGUge1R1cGxlRGljdGlvbmFyeX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpZGluZ0JvZGllc0xhc3RTdGVwID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuXG4gICAgLyoqXG4gICAgICogQ29udGFjdCBza2luIHNpemUgdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGNvbnRhY3QgZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0U2tpblNpemVcbiAgICAgKiBAZGVmYXVsdCAwLjAxXG4gICAgICovXG4gICAgdGhpcy5jb250YWN0U2tpblNpemUgPSAwLjAxO1xufVxuXG52YXIgYm9kaWVzT3ZlcmxhcF9zaGFwZVBvc2l0aW9uQSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgYm9kaWVzT3ZlcmxhcF9zaGFwZVBvc2l0aW9uQiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBib2RpZXNPdmVybGFwXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib2RpZXNPdmVybGFwID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgc2hhcGVQb3NpdGlvbkEgPSBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25BO1xuICAgIHZhciBzaGFwZVBvc2l0aW9uQiA9IGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkI7XG5cbiAgICAvLyBMb29wIG92ZXIgYWxsIHNoYXBlcyBvZiBib2R5QVxuICAgIGZvcih2YXIgaz0wLCBOc2hhcGVzaT1ib2R5QS5zaGFwZXMubGVuZ3RoOyBrIT09TnNoYXBlc2k7IGsrKyl7XG4gICAgICAgIHZhciBzaGFwZUEgPSBib2R5QS5zaGFwZXNba10sXG4gICAgICAgICAgICBwb3NpdGlvbkEgPSBib2R5QS5zaGFwZU9mZnNldHNba10sXG4gICAgICAgICAgICBhbmdsZUEgPSBib2R5QS5zaGFwZUFuZ2xlc1trXTtcblxuICAgICAgICBib2R5QS50b1dvcmxkRnJhbWUoc2hhcGVQb3NpdGlvbkEsIHBvc2l0aW9uQSk7XG5cbiAgICAgICAgLy8gQWxsIHNoYXBlcyBvZiBib2R5IGpcbiAgICAgICAgZm9yKHZhciBsPTAsIE5zaGFwZXNqPWJvZHlCLnNoYXBlcy5sZW5ndGg7IGwhPT1Oc2hhcGVzajsgbCsrKXtcbiAgICAgICAgICAgIHZhciBzaGFwZUIgPSBib2R5Qi5zaGFwZXNbbF0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25CID0gYm9keUIuc2hhcGVPZmZzZXRzW2xdLFxuICAgICAgICAgICAgICAgIGFuZ2xlQiA9IGJvZHlCLnNoYXBlQW5nbGVzW2xdO1xuXG4gICAgICAgICAgICBib2R5Qi50b1dvcmxkRnJhbWUoc2hhcGVQb3NpdGlvbkIsIHBvc2l0aW9uQik7XG5cbiAgICAgICAgICAgIGlmKHRoaXNbc2hhcGVBLnR5cGUgfCBzaGFwZUIudHlwZV0oXG4gICAgICAgICAgICAgICAgYm9keUEsXG4gICAgICAgICAgICAgICAgc2hhcGVBLFxuICAgICAgICAgICAgICAgIHNoYXBlUG9zaXRpb25BLFxuICAgICAgICAgICAgICAgIHNoYXBlQS5hbmdsZSArIGJvZHlBLmFuZ2xlLFxuICAgICAgICAgICAgICAgIGJvZHlCLFxuICAgICAgICAgICAgICAgIHNoYXBlQixcbiAgICAgICAgICAgICAgICBzaGFwZVBvc2l0aW9uQixcbiAgICAgICAgICAgICAgICBzaGFwZUIuYW5nbGUgKyBib2R5Qi5hbmdsZSxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvZGllcyB3ZXJlIGluIGNvbnRhY3Qgc2luY2UgdGhlIGxhc3QgcmVzZXQoKS5cbiAqIEBtZXRob2QgY29sbGlkZWRMYXN0U3RlcFxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29sbGlkZWRMYXN0U3RlcCA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmFyIGlkMSA9IGJvZHlBLmlkfDAsXG4gICAgICAgIGlkMiA9IGJvZHlCLmlkfDA7XG4gICAgcmV0dXJuICEhdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5nZXQoaWQxLCBpZDIpO1xufTtcblxuLyoqXG4gKiBUaHJvd3MgYXdheSB0aGUgb2xkIGVxdWF0aW9ucyBhbmQgZ2V0cyByZWFkeSB0byBjcmVhdGUgbmV3XG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5yZXNldCgpO1xuXG4gICAgdmFyIGVxcyA9IHRoaXMuY29udGFjdEVxdWF0aW9ucztcbiAgICB2YXIgbCA9IGVxcy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2xdLFxuICAgICAgICAgICAgaWQxID0gZXEuYm9keUEuaWQsXG4gICAgICAgICAgICBpZDIgPSBlcS5ib2R5Qi5pZDtcbiAgICAgICAgdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5zZXQoaWQxLCBpZDIsIHRydWUpO1xuICAgIH1cblxuICAgIGlmKHRoaXMucmV1c2VPYmplY3RzKXtcbiAgICAgICAgdmFyIGNlID0gdGhpcy5jb250YWN0RXF1YXRpb25zLFxuICAgICAgICAgICAgZmUgPSB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLFxuICAgICAgICAgICAgcmZlID0gdGhpcy5yZXVzYWJsZUZyaWN0aW9uRXF1YXRpb25zLFxuICAgICAgICAgICAgcmNlID0gdGhpcy5yZXVzYWJsZUNvbnRhY3RFcXVhdGlvbnM7XG4gICAgICAgIFV0aWxzLmFwcGVuZEFycmF5KHJjZSxjZSk7XG4gICAgICAgIFV0aWxzLmFwcGVuZEFycmF5KHJmZSxmZSk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXRcbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgQ29udGFjdEVxdWF0aW9uLCBlaXRoZXIgYnkgcmV1c2luZyBhbiBleGlzdGluZyBvYmplY3Qgb3IgY3JlYXRpbmcgYSBuZXcgb25lLlxuICogQG1ldGhvZCBjcmVhdGVDb250YWN0RXF1YXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Q29udGFjdEVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlQ29udGFjdEVxdWF0aW9uID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCLCBzaGFwZUEsIHNoYXBlQil7XG4gICAgdmFyIGMgPSB0aGlzLnJldXNhYmxlQ29udGFjdEVxdWF0aW9ucy5sZW5ndGggPyB0aGlzLnJldXNhYmxlQ29udGFjdEVxdWF0aW9ucy5wb3AoKSA6IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIpO1xuICAgIGMuYm9keUEgPSBib2R5QTtcbiAgICBjLmJvZHlCID0gYm9keUI7XG4gICAgYy5zaGFwZUEgPSBzaGFwZUE7XG4gICAgYy5zaGFwZUIgPSBzaGFwZUI7XG4gICAgYy5yZXN0aXR1dGlvbiA9IHRoaXMucmVzdGl0dXRpb247XG4gICAgYy5maXJzdEltcGFjdCA9ICF0aGlzLmNvbGxpZGVkTGFzdFN0ZXAoYm9keUEsYm9keUIpO1xuICAgIGMuc3RpZmZuZXNzID0gdGhpcy5zdGlmZm5lc3M7XG4gICAgYy5yZWxheGF0aW9uID0gdGhpcy5yZWxheGF0aW9uO1xuICAgIGMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGMuZW5hYmxlZCA9IHRoaXMuZW5hYmxlZEVxdWF0aW9ucztcbiAgICBjLm9mZnNldCA9IHRoaXMuY29udGFjdFNraW5TaXplO1xuXG4gICAgcmV0dXJuIGM7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBGcmljdGlvbkVxdWF0aW9uLCBlaXRoZXIgYnkgcmV1c2luZyBhbiBleGlzdGluZyBvYmplY3Qgb3IgY3JlYXRpbmcgYSBuZXcgb25lLlxuICogQG1ldGhvZCBjcmVhdGVGcmljdGlvbkVxdWF0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0ZyaWN0aW9uRXF1YXRpb259XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkVxdWF0aW9uID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCLCBzaGFwZUEsIHNoYXBlQil7XG4gICAgdmFyIGMgPSB0aGlzLnJldXNhYmxlRnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoID8gdGhpcy5yZXVzYWJsZUZyaWN0aW9uRXF1YXRpb25zLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYm9keUEsYm9keUIpO1xuICAgIGMuYm9keUEgPSBib2R5QTtcbiAgICBjLmJvZHlCID0gYm9keUI7XG4gICAgYy5zaGFwZUEgPSBzaGFwZUE7XG4gICAgYy5zaGFwZUIgPSBzaGFwZUI7XG4gICAgYy5zZXRTbGlwRm9yY2UodGhpcy5zbGlwRm9yY2UpO1xuICAgIGMuZnJpY3Rpb25Db2VmZmljaWVudCA9IHRoaXMuZnJpY3Rpb25Db2VmZmljaWVudDtcbiAgICBjLnJlbGF0aXZlVmVsb2NpdHkgPSB0aGlzLnN1cmZhY2VWZWxvY2l0eTtcbiAgICBjLmVuYWJsZWQgPSB0aGlzLmVuYWJsZWRFcXVhdGlvbnM7XG4gICAgYy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgYy5zdGlmZm5lc3MgPSB0aGlzLmZyaWN0aW9uU3RpZmZuZXNzO1xuICAgIGMucmVsYXhhdGlvbiA9IHRoaXMuZnJpY3Rpb25SZWxheGF0aW9uO1xuICAgIGMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggPSAwO1xuICAgIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgRnJpY3Rpb25FcXVhdGlvbiBnaXZlbiB0aGUgZGF0YSBpbiB0aGUgQ29udGFjdEVxdWF0aW9uLiBVc2VzIHNhbWUgb2Zmc2V0IHZlY3RvcnMgcmkgYW5kIHJqLCBidXQgdGhlIHRhbmdlbnQgdmVjdG9yIHdpbGwgYmUgY29uc3RydWN0ZWQgZnJvbSB0aGUgY29sbGlzaW9uIG5vcm1hbC5cbiAqIEBtZXRob2QgY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdFxuICogQHBhcmFtICB7Q29udGFjdEVxdWF0aW9ufSBjb250YWN0RXF1YXRpb25cbiAqIEByZXR1cm4ge0ZyaWN0aW9uRXF1YXRpb259XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0ID0gZnVuY3Rpb24oYyl7XG4gICAgdmFyIGVxID0gdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uKGMuYm9keUEsIGMuYm9keUIsIGMuc2hhcGVBLCBjLnNoYXBlQik7XG4gICAgdmVjMi5jb3B5KGVxLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSk7XG4gICAgdmVjMi5jb3B5KGVxLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50Qik7XG4gICAgdmVjMi5yb3RhdGU5MGN3KGVxLnQsIGMubm9ybWFsQSk7XG4gICAgZXEuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuICAgIHJldHVybiBlcTtcbn07XG5cbi8vIFRha2UgdGhlIGF2ZXJhZ2UgTiBsYXRlc3QgY29udGFjdCBwb2ludCBvbiB0aGUgcGxhbmUuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZSA9IGZ1bmN0aW9uKG51bUNvbnRhY3RzKXtcbiAgICB2YXIgYyA9IHRoaXMuY29udGFjdEVxdWF0aW9uc1t0aGlzLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGVxID0gdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uKGMuYm9keUEsIGMuYm9keUIsIGMuc2hhcGVBLCBjLnNoYXBlQik7XG4gICAgdmFyIGJvZHlBID0gYy5ib2R5QTtcbiAgICB2YXIgYm9keUIgPSBjLmJvZHlCO1xuICAgIHZlYzIuc2V0KGVxLmNvbnRhY3RQb2ludEEsIDAsIDApO1xuICAgIHZlYzIuc2V0KGVxLmNvbnRhY3RQb2ludEIsIDAsIDApO1xuICAgIHZlYzIuc2V0KGVxLnQsIDAsIDApO1xuICAgIGZvcih2YXIgaT0wOyBpIT09bnVtQ29udGFjdHM7IGkrKyl7XG4gICAgICAgIGMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvbnNbdGhpcy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgaWYoYy5ib2R5QSA9PT0gYm9keUEpe1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEudCwgZXEudCwgYy5ub3JtYWxBKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSk7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVjMi5zdWIoZXEudCwgZXEudCwgYy5ub3JtYWxBKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50Qik7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgICAgICB9XG4gICAgICAgIGVxLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcbiAgICB9XG5cbiAgICB2YXIgaW52TnVtQ29udGFjdHMgPSAxL251bUNvbnRhY3RzO1xuICAgIHZlYzIuc2NhbGUoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgaW52TnVtQ29udGFjdHMpO1xuICAgIHZlYzIuc2NhbGUoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgaW52TnVtQ29udGFjdHMpO1xuICAgIHZlYzIubm9ybWFsaXplKGVxLnQsIGVxLnQpO1xuICAgIHZlYzIucm90YXRlOTBjdyhlcS50LCBlcS50KTtcbiAgICByZXR1cm4gZXE7XG59O1xuXG4vKipcbiAqIENvbnZleC9saW5lIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNvbnZleExpbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGNvbnZleEJvZHlcbiAqIEBwYXJhbSAge0NvbnZleH0gICAgIGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBjb252ZXhPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gICAgICAgbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBsaW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBsaW5lQW5nbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIGp1c3RUZXN0XG4gKiBAdG9kbyBJbXBsZW1lbnQgbWUhXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FIHwgU2hhcGUuQ09OVkVYXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4TGluZSA9IGZ1bmN0aW9uKFxuICAgIGNvbnZleEJvZHksXG4gICAgY29udmV4U2hhcGUsXG4gICAgY29udmV4T2Zmc2V0LFxuICAgIGNvbnZleEFuZ2xlLFxuICAgIGxpbmVCb2R5LFxuICAgIGxpbmVTaGFwZSxcbiAgICBsaW5lT2Zmc2V0LFxuICAgIGxpbmVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICAvLyBUT0RPXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaW5lL3JlY3RhbmdsZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBsaW5lUmVjdGFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gICAgICAgbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBsaW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBsaW5lQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHJlY3RhbmdsZUJvZHlcbiAqIEBwYXJhbSAge1JlY3RhbmdsZX0gIHJlY3RhbmdsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICByZWN0YW5nbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIHJlY3RhbmdsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICBqdXN0VGVzdFxuICogQHRvZG8gSW1wbGVtZW50IG1lIVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuTElORSB8IFNoYXBlLlJFQ1RBTkdMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmxpbmVSZWN0YW5nbGUgPSBmdW5jdGlvbihcbiAgICBsaW5lQm9keSxcbiAgICBsaW5lU2hhcGUsXG4gICAgbGluZU9mZnNldCxcbiAgICBsaW5lQW5nbGUsXG4gICAgcmVjdGFuZ2xlQm9keSxcbiAgICByZWN0YW5nbGVTaGFwZSxcbiAgICByZWN0YW5nbGVPZmZzZXQsXG4gICAgcmVjdGFuZ2xlQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgLy8gVE9ET1xuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHNldENvbnZleFRvQ2Fwc3VsZVNoYXBlTWlkZGxlKGNvbnZleFNoYXBlLCBjYXBzdWxlU2hhcGUpe1xuICAgIHZlYzIuc2V0KGNvbnZleFNoYXBlLnZlcnRpY2VzWzBdLCAtY2Fwc3VsZVNoYXBlLmxlbmd0aCAqIDAuNSwgLWNhcHN1bGVTaGFwZS5yYWRpdXMpO1xuICAgIHZlYzIuc2V0KGNvbnZleFNoYXBlLnZlcnRpY2VzWzFdLCAgY2Fwc3VsZVNoYXBlLmxlbmd0aCAqIDAuNSwgLWNhcHN1bGVTaGFwZS5yYWRpdXMpO1xuICAgIHZlYzIuc2V0KGNvbnZleFNoYXBlLnZlcnRpY2VzWzJdLCAgY2Fwc3VsZVNoYXBlLmxlbmd0aCAqIDAuNSwgIGNhcHN1bGVTaGFwZS5yYWRpdXMpO1xuICAgIHZlYzIuc2V0KGNvbnZleFNoYXBlLnZlcnRpY2VzWzNdLCAtY2Fwc3VsZVNoYXBlLmxlbmd0aCAqIDAuNSwgIGNhcHN1bGVTaGFwZS5yYWRpdXMpO1xufVxuXG52YXIgY29udmV4Q2Fwc3VsZV90ZW1wUmVjdCA9IG5ldyBSZWN0YW5nbGUoMSwxKSxcbiAgICBjb252ZXhDYXBzdWxlX3RlbXBWZWMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIENvbnZleC9jYXBzdWxlIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNvbnZleENhcHN1bGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGNvbnZleEJvZHlcbiAqIEBwYXJhbSAge0NvbnZleH0gICAgIGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBjb252ZXhQb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgY29udmV4QW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGNhcHN1bGVCb2R5XG4gKiBAcGFyYW0gIHtDYXBzdWxlfSAgICBjYXBzdWxlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGNhcHN1bGVQb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgY2Fwc3VsZUFuZ2xlXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DQVBTVUxFIHwgU2hhcGUuQ09OVkVYXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0FQU1VMRSB8IFNoYXBlLlJFQ1RBTkdMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleENhcHN1bGUgPSBmdW5jdGlvbihcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleFBvc2l0aW9uLFxuICAgIGNvbnZleEFuZ2xlLFxuICAgIGNhcHN1bGVCb2R5LFxuICAgIGNhcHN1bGVTaGFwZSxcbiAgICBjYXBzdWxlUG9zaXRpb24sXG4gICAgY2Fwc3VsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuXG4gICAgLy8gQ2hlY2sgdGhlIGNpcmNsZXNcbiAgICAvLyBBZGQgb2Zmc2V0cyFcbiAgICB2YXIgY2lyY2xlUG9zID0gY29udmV4Q2Fwc3VsZV90ZW1wVmVjO1xuICAgIHZlYzIuc2V0KGNpcmNsZVBvcywgY2Fwc3VsZVNoYXBlLmxlbmd0aC8yLDApO1xuICAgIHZlYzIucm90YXRlKGNpcmNsZVBvcyxjaXJjbGVQb3MsY2Fwc3VsZUFuZ2xlKTtcbiAgICB2ZWMyLmFkZChjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVQb3NpdGlvbik7XG4gICAgdmFyIHJlc3VsdDEgPSB0aGlzLmNpcmNsZUNvbnZleChjYXBzdWxlQm9keSxjYXBzdWxlU2hhcGUsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSwgY29udmV4Qm9keSxjb252ZXhTaGFwZSxjb252ZXhQb3NpdGlvbixjb252ZXhBbmdsZSwganVzdFRlc3QsIGNhcHN1bGVTaGFwZS5yYWRpdXMpO1xuXG4gICAgdmVjMi5zZXQoY2lyY2xlUG9zLC1jYXBzdWxlU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIucm90YXRlKGNpcmNsZVBvcyxjaXJjbGVQb3MsY2Fwc3VsZUFuZ2xlKTtcbiAgICB2ZWMyLmFkZChjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVQb3NpdGlvbik7XG4gICAgdmFyIHJlc3VsdDIgPSB0aGlzLmNpcmNsZUNvbnZleChjYXBzdWxlQm9keSxjYXBzdWxlU2hhcGUsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSwgY29udmV4Qm9keSxjb252ZXhTaGFwZSxjb252ZXhQb3NpdGlvbixjb252ZXhBbmdsZSwganVzdFRlc3QsIGNhcHN1bGVTaGFwZS5yYWRpdXMpO1xuXG4gICAgaWYoanVzdFRlc3QgJiYgKHJlc3VsdDEgfHwgcmVzdWx0Mikpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjZW50ZXIgcmVjdFxuICAgIHZhciByID0gY29udmV4Q2Fwc3VsZV90ZW1wUmVjdDtcbiAgICBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShyLGNhcHN1bGVTaGFwZSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuY29udmV4Q29udmV4KGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zaXRpb24sY29udmV4QW5nbGUsIGNhcHN1bGVCb2R5LHIsY2Fwc3VsZVBvc2l0aW9uLGNhcHN1bGVBbmdsZSwganVzdFRlc3QpO1xuXG4gICAgcmV0dXJuIHJlc3VsdCArIHJlc3VsdDEgKyByZXN1bHQyO1xufTtcblxuLyoqXG4gKiBDYXBzdWxlL2xpbmUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgbGluZUNhcHN1bGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGxpbmVCb2R5XG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxpbmVQb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjYXBzdWxlQm9keVxuICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgY2Fwc3VsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBjYXBzdWxlUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNhcHN1bGVBbmdsZVxuICogQHRvZG8gSW1wbGVtZW50IG1lIVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0FQU1VMRSB8IFNoYXBlLkxJTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5saW5lQ2Fwc3VsZSA9IGZ1bmN0aW9uKFxuICAgIGxpbmVCb2R5LFxuICAgIGxpbmVTaGFwZSxcbiAgICBsaW5lUG9zaXRpb24sXG4gICAgbGluZUFuZ2xlLFxuICAgIGNhcHN1bGVCb2R5LFxuICAgIGNhcHN1bGVTaGFwZSxcbiAgICBjYXBzdWxlUG9zaXRpb24sXG4gICAgY2Fwc3VsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIC8vIFRPRE9cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG52YXIgY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMyID0gdmVjMi5jcmVhdGUoKTtcbnZhciBjYXBzdWxlQ2Fwc3VsZV90ZW1wUmVjdDEgPSBuZXcgUmVjdGFuZ2xlKDEsMSk7XG5cbi8qKlxuICogQ2Fwc3VsZS9jYXBzdWxlIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNhcHN1bGVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgc2lcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHhpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIHNqXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICB4alxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYWpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5DQVBTVUxFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2Fwc3VsZUNhcHN1bGUgPSBmdW5jdGlvbihiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0KXtcblxuICAgIHZhciBlbmFibGVGcmljdGlvbkJlZm9yZTtcblxuICAgIC8vIENoZWNrIHRoZSBjaXJjbGVzXG4gICAgLy8gQWRkIG9mZnNldHMhXG4gICAgdmFyIGNpcmNsZVBvc2kgPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMSxcbiAgICAgICAgY2lyY2xlUG9zaiA9IGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMyO1xuXG4gICAgdmFyIG51bUNvbnRhY3RzID0gMDtcblxuXG4gICAgLy8gTmVlZCA0IGNpcmNsZSBjaGVja3MsIGJldHdlZW4gYWxsXG4gICAgZm9yKHZhciBpPTA7IGk8MjsgaSsrKXtcblxuICAgICAgICB2ZWMyLnNldChjaXJjbGVQb3NpLChpPT09MD8tMToxKSpzaS5sZW5ndGgvMiwwKTtcbiAgICAgICAgdmVjMi5yb3RhdGUoY2lyY2xlUG9zaSxjaXJjbGVQb3NpLGFpKTtcbiAgICAgICAgdmVjMi5hZGQoY2lyY2xlUG9zaSxjaXJjbGVQb3NpLHhpKTtcblxuICAgICAgICBmb3IodmFyIGo9MDsgajwyOyBqKyspe1xuXG4gICAgICAgICAgICB2ZWMyLnNldChjaXJjbGVQb3NqLChqPT09MD8tMToxKSpzai5sZW5ndGgvMiwgMCk7XG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3NqLGNpcmNsZVBvc2osYWopO1xuICAgICAgICAgICAgdmVjMi5hZGQoY2lyY2xlUG9zaixjaXJjbGVQb3NqLHhqKTtcblxuICAgICAgICAgICAgLy8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNpcmNsZUNpcmNsZShiaSxzaSxjaXJjbGVQb3NpLGFpLCBiaixzaixjaXJjbGVQb3NqLGFqLCBqdXN0VGVzdCwgc2kucmFkaXVzLCBzai5yYWRpdXMpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0ICYmIHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG51bUNvbnRhY3RzICs9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxuICAgICAgICBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjaXJjbGVzIGFnYWluc3QgdGhlIGNlbnRlciByZWN0YW5nbGVzXG4gICAgdmFyIHJlY3QgPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wUmVjdDE7XG4gICAgc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUocmVjdCxzaSk7XG4gICAgdmFyIHJlc3VsdDEgPSB0aGlzLmNvbnZleENhcHN1bGUoYmkscmVjdCx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0KTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3QgJiYgcmVzdWx0MSl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBudW1Db250YWN0cyArPSByZXN1bHQxO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXG4gICAgICAgIHZhciBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShyZWN0LHNqKTtcbiAgICB2YXIgcmVzdWx0MiA9IHRoaXMuY29udmV4Q2Fwc3VsZShiaixyZWN0LHhqLGFqLCBiaSxzaSx4aSxhaSwganVzdFRlc3QpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBlbmFibGVGcmljdGlvbkJlZm9yZTtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCAmJiByZXN1bHQyKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG51bUNvbnRhY3RzICs9IHJlc3VsdDI7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgaWYobnVtQ29udGFjdHMgJiYgdGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtQ29udGFjdHM7XG59O1xuXG4vKipcbiAqIExpbmUvbGluZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBsaW5lTGluZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYm9keUFcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIHNoYXBlQVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcG9zaXRpb25BXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZUFcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJvZHlCXG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBzaGFwZUJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBvc2l0aW9uQlxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGVCXG4gKiBAdG9kbyBJbXBsZW1lbnQgbWUhXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FIHwgU2hhcGUuTElORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmxpbmVMaW5lID0gZnVuY3Rpb24oXG4gICAgYm9keUEsXG4gICAgc2hhcGVBLFxuICAgIHBvc2l0aW9uQSxcbiAgICBhbmdsZUEsXG4gICAgYm9keUIsXG4gICAgc2hhcGVCLFxuICAgIHBvc2l0aW9uQixcbiAgICBhbmdsZUIsXG4gICAganVzdFRlc3Rcbil7XG4gICAgLy8gVE9ET1xuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogUGxhbmUvbGluZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBwbGFuZUxpbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgcGxhbmVCb2R5XG4gKiBAcGFyYW0gIHtQbGFuZX0gIHBsYW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgcGxhbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGxhbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gICBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBsaW5lQW5nbGVcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuTElORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lTGluZSA9IGZ1bmN0aW9uKHBsYW5lQm9keSwgcGxhbmVTaGFwZSwgcGxhbmVPZmZzZXQsIHBsYW5lQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUJvZHksICBsaW5lU2hhcGUsICBsaW5lT2Zmc2V0LCAgbGluZUFuZ2xlLCBqdXN0VGVzdCl7XG4gICAgdmFyIHdvcmxkVmVydGV4MCA9IHRtcDEsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHRtcDIsXG4gICAgICAgIHdvcmxkVmVydGV4MDEgPSB0bXAzLFxuICAgICAgICB3b3JsZFZlcnRleDExID0gdG1wNCxcbiAgICAgICAgd29ybGRFZGdlID0gdG1wNSxcbiAgICAgICAgd29ybGRFZGdlVW5pdCA9IHRtcDYsXG4gICAgICAgIGRpc3QgPSB0bXA3LFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDgsXG4gICAgICAgIHdvcmxkVGFuZ2VudCA9IHRtcDksXG4gICAgICAgIHZlcnRzID0gdG1wQXJyYXksXG4gICAgICAgIG51bUNvbnRhY3RzID0gMDtcblxuICAgIC8vIEdldCBzdGFydCBhbmQgZW5kIHBvaW50c1xuICAgIHZlYzIuc2V0KHdvcmxkVmVydGV4MCwgLWxpbmVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5zZXQod29ybGRWZXJ0ZXgxLCAgbGluZVNoYXBlLmxlbmd0aC8yLCAwKTtcblxuICAgIC8vIE5vdCBzdXJlIHdoeSB3ZSBoYXZlIHRvIHVzZSB3b3JsZFZlcnRleCoxIGhlcmUsIGJ1dCBpdCB3b24ndCB3b3JrIG90aGVyd2lzZS4gVGlyZWQuXG4gICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwLCBsaW5lQW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MSwgbGluZUFuZ2xlKTtcblxuICAgIGFkZCh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAxLCBsaW5lT2Zmc2V0KTtcbiAgICBhZGQod29ybGRWZXJ0ZXgxMSwgd29ybGRWZXJ0ZXgxMSwgbGluZU9mZnNldCk7XG5cbiAgICB2ZWMyLmNvcHkod29ybGRWZXJ0ZXgwLHdvcmxkVmVydGV4MDEpO1xuICAgIHZlYzIuY29weSh3b3JsZFZlcnRleDEsd29ybGRWZXJ0ZXgxMSk7XG5cbiAgICAvLyBHZXQgdmVjdG9yIGFsb25nIHRoZSBsaW5lXG4gICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xuICAgIHZlYzIubm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XG5cbiAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS5cbiAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGRUYW5nZW50LCB3b3JsZEVkZ2VVbml0KTtcblxuICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XG5cbiAgICAvLyBDaGVjayBsaW5lIGVuZHNcbiAgICB2ZXJ0c1swXSA9IHdvcmxkVmVydGV4MDtcbiAgICB2ZXJ0c1sxXSA9IHdvcmxkVmVydGV4MTtcbiAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVydHNbaV07XG5cbiAgICAgICAgc3ViKGRpc3QsIHYsIHBsYW5lT2Zmc2V0KTtcblxuICAgICAgICB2YXIgZCA9IGRvdChkaXN0LHdvcmxkTm9ybWFsKTtcblxuICAgICAgICBpZihkIDwgMCl7XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksbGluZUJvZHkscGxhbmVTaGFwZSxsaW5lU2hhcGUpO1xuICAgICAgICAgICAgbnVtQ29udGFjdHMrKztcblxuICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgd29ybGROb3JtYWwpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgIC8vIGRpc3RhbmNlIHZlY3RvciBhbG9uZyBwbGFuZSBub3JtYWxcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoZGlzdCwgd29ybGROb3JtYWwsIGQpO1xuXG4gICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBwbGFuZSBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgdiwgZGlzdCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIC8vIEZyb20gbGluZSBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgdiwgICAgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgaWYobnVtQ29udGFjdHMgJiYgdGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtQ29udGFjdHM7XG59O1xuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUEFSVElDTEUgfCBTaGFwZS5DQVBTVUxFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGFydGljbGVDYXBzdWxlID0gZnVuY3Rpb24oXG4gICAgcGFydGljbGVCb2R5LFxuICAgIHBhcnRpY2xlU2hhcGUsXG4gICAgcGFydGljbGVQb3NpdGlvbixcbiAgICBwYXJ0aWNsZUFuZ2xlLFxuICAgIGNhcHN1bGVCb2R5LFxuICAgIGNhcHN1bGVTaGFwZSxcbiAgICBjYXBzdWxlUG9zaXRpb24sXG4gICAgY2Fwc3VsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHJldHVybiB0aGlzLmNpcmNsZUxpbmUocGFydGljbGVCb2R5LHBhcnRpY2xlU2hhcGUscGFydGljbGVQb3NpdGlvbixwYXJ0aWNsZUFuZ2xlLCBjYXBzdWxlQm9keSxjYXBzdWxlU2hhcGUsY2Fwc3VsZVBvc2l0aW9uLGNhcHN1bGVBbmdsZSwganVzdFRlc3QsIGNhcHN1bGVTaGFwZS5yYWRpdXMsIDApO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvbGluZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjaXJjbGVMaW5lXG4gKiBAcGFyYW0gIHtCb2R5fSBjaXJjbGVCb2R5XG4gKiBAcGFyYW0gIHtDaXJjbGV9IGNpcmNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY2lyY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNpcmNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBsaW5lQW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3QgSWYgc2V0IHRvIHRydWUsIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCAoaW50ZXJzZWN0aW9uIG9yIG5vdCkgd2l0aG91dCBhZGRpbmcgZXF1YXRpb25zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVSYWRpdXMgUmFkaXVzIHRvIGFkZCB0byB0aGUgbGluZS4gQ2FuIGJlIHVzZWQgdG8gdGVzdCBDYXBzdWxlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjaXJjbGVSYWRpdXMgSWYgc2V0LCB0aGlzIHZhbHVlIG92ZXJyaWRlcyB0aGUgY2lyY2xlIHNoYXBlIHJhZGl1cy5cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkxJTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVMaW5lID0gZnVuY3Rpb24oXG4gICAgY2lyY2xlQm9keSxcbiAgICBjaXJjbGVTaGFwZSxcbiAgICBjaXJjbGVPZmZzZXQsXG4gICAgY2lyY2xlQW5nbGUsXG4gICAgbGluZUJvZHksXG4gICAgbGluZVNoYXBlLFxuICAgIGxpbmVPZmZzZXQsXG4gICAgbGluZUFuZ2xlLFxuICAgIGp1c3RUZXN0LFxuICAgIGxpbmVSYWRpdXMsXG4gICAgY2lyY2xlUmFkaXVzXG4pe1xuICAgIHZhciBsaW5lUmFkaXVzID0gbGluZVJhZGl1cyB8fCAwLFxuICAgICAgICBjaXJjbGVSYWRpdXMgPSB0eXBlb2YoY2lyY2xlUmFkaXVzKSE9PVwidW5kZWZpbmVkXCIgPyBjaXJjbGVSYWRpdXMgOiBjaXJjbGVTaGFwZS5yYWRpdXMsXG5cbiAgICAgICAgb3J0aG9EaXN0ID0gdG1wMSxcbiAgICAgICAgbGluZVRvQ2lyY2xlT3J0aG9Vbml0ID0gdG1wMixcbiAgICAgICAgcHJvamVjdGVkUG9pbnQgPSB0bXAzLFxuICAgICAgICBjZW50ZXJEaXN0ID0gdG1wNCxcbiAgICAgICAgd29ybGRUYW5nZW50ID0gdG1wNSxcbiAgICAgICAgd29ybGRFZGdlID0gdG1wNixcbiAgICAgICAgd29ybGRFZGdlVW5pdCA9IHRtcDcsXG4gICAgICAgIHdvcmxkVmVydGV4MCA9IHRtcDgsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHRtcDksXG4gICAgICAgIHdvcmxkVmVydGV4MDEgPSB0bXAxMCxcbiAgICAgICAgd29ybGRWZXJ0ZXgxMSA9IHRtcDExLFxuICAgICAgICBkaXN0ID0gdG1wMTIsXG4gICAgICAgIGxpbmVUb0NpcmNsZSA9IHRtcDEzLFxuICAgICAgICBsaW5lRW5kVG9MaW5lUmFkaXVzID0gdG1wMTQsXG5cbiAgICAgICAgdmVydHMgPSB0bXBBcnJheTtcblxuICAgIC8vIEdldCBzdGFydCBhbmQgZW5kIHBvaW50c1xuICAgIHZlYzIuc2V0KHdvcmxkVmVydGV4MCwgLWxpbmVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5zZXQod29ybGRWZXJ0ZXgxLCAgbGluZVNoYXBlLmxlbmd0aC8yLCAwKTtcblxuICAgIC8vIE5vdCBzdXJlIHdoeSB3ZSBoYXZlIHRvIHVzZSB3b3JsZFZlcnRleCoxIGhlcmUsIGJ1dCBpdCB3b24ndCB3b3JrIG90aGVyd2lzZS4gVGlyZWQuXG4gICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwLCBsaW5lQW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MSwgbGluZUFuZ2xlKTtcblxuICAgIGFkZCh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAxLCBsaW5lT2Zmc2V0KTtcbiAgICBhZGQod29ybGRWZXJ0ZXgxMSwgd29ybGRWZXJ0ZXgxMSwgbGluZU9mZnNldCk7XG5cbiAgICB2ZWMyLmNvcHkod29ybGRWZXJ0ZXgwLHdvcmxkVmVydGV4MDEpO1xuICAgIHZlYzIuY29weSh3b3JsZFZlcnRleDEsd29ybGRWZXJ0ZXgxMSk7XG5cbiAgICAvLyBHZXQgdmVjdG9yIGFsb25nIHRoZSBsaW5lXG4gICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xuICAgIHZlYzIubm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XG5cbiAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS5cbiAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGRUYW5nZW50LCB3b3JsZEVkZ2VVbml0KTtcblxuICAgIC8vIENoZWNrIGRpc3RhbmNlIGZyb20gdGhlIHBsYW5lIHNwYW5uZWQgYnkgdGhlIGVkZ2UgdnMgdGhlIGNpcmNsZVxuICAgIHN1YihkaXN0LCBjaXJjbGVPZmZzZXQsIHdvcmxkVmVydGV4MCk7XG4gICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGRUYW5nZW50KTsgLy8gRGlzdGFuY2UgZnJvbSBjZW50ZXIgb2YgbGluZSB0byBjaXJjbGUgY2VudGVyXG4gICAgc3ViKGNlbnRlckRpc3QsIHdvcmxkVmVydGV4MCwgbGluZU9mZnNldCk7XG5cbiAgICBzdWIobGluZVRvQ2lyY2xlLCBjaXJjbGVPZmZzZXQsIGxpbmVPZmZzZXQpO1xuXG4gICAgdmFyIHJhZGl1c1N1bSA9IGNpcmNsZVJhZGl1cyArIGxpbmVSYWRpdXM7XG5cbiAgICBpZihNYXRoLmFicyhkKSA8IHJhZGl1c1N1bSl7XG5cbiAgICAgICAgLy8gTm93IHByb2plY3QgdGhlIGNpcmNsZSBvbnRvIHRoZSBlZGdlXG4gICAgICAgIHZlYzIuc2NhbGUob3J0aG9EaXN0LCB3b3JsZFRhbmdlbnQsIGQpO1xuICAgICAgICBzdWIocHJvamVjdGVkUG9pbnQsIGNpcmNsZU9mZnNldCwgb3J0aG9EaXN0KTtcblxuICAgICAgICAvLyBBZGQgdGhlIG1pc3NpbmcgbGluZSByYWRpdXNcbiAgICAgICAgdmVjMi5zY2FsZShsaW5lVG9DaXJjbGVPcnRob1VuaXQsIHdvcmxkVGFuZ2VudCwgZG90KHdvcmxkVGFuZ2VudCwgbGluZVRvQ2lyY2xlKSk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKGxpbmVUb0NpcmNsZU9ydGhvVW5pdCxsaW5lVG9DaXJjbGVPcnRob1VuaXQpO1xuICAgICAgICB2ZWMyLnNjYWxlKGxpbmVUb0NpcmNsZU9ydGhvVW5pdCwgbGluZVRvQ2lyY2xlT3J0aG9Vbml0LCBsaW5lUmFkaXVzKTtcbiAgICAgICAgYWRkKHByb2plY3RlZFBvaW50LHByb2plY3RlZFBvaW50LGxpbmVUb0NpcmNsZU9ydGhvVW5pdCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgZWRnZSBzcGFuXG4gICAgICAgIHZhciBwb3MgPSAgZG90KHdvcmxkRWRnZVVuaXQsIHByb2plY3RlZFBvaW50KTtcbiAgICAgICAgdmFyIHBvczAgPSBkb3Qod29ybGRFZGdlVW5pdCwgd29ybGRWZXJ0ZXgwKTtcbiAgICAgICAgdmFyIHBvczEgPSBkb3Qod29ybGRFZGdlVW5pdCwgd29ybGRWZXJ0ZXgxKTtcblxuICAgICAgICBpZihwb3MgPiBwb3MwICYmIHBvcyA8IHBvczEpe1xuICAgICAgICAgICAgLy8gV2UgZ290IGNvbnRhY3QhXG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LGxpbmVCb2R5LGNpcmNsZVNoYXBlLGxpbmVTaGFwZSk7XG5cbiAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5ub3JtYWxBLCBvcnRob0Rpc3QsIC0xKTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgdmVjMi5zY2FsZSggYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsICBjaXJjbGVSYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgcHJvamVjdGVkUG9pbnQsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGNvcm5lclxuICAgIHZlcnRzWzBdID0gd29ybGRWZXJ0ZXgwO1xuICAgIHZlcnRzWzFdID0gd29ybGRWZXJ0ZXgxO1xuXG4gICAgZm9yKHZhciBpPTA7IGk8dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuXG4gICAgICAgIHN1YihkaXN0LCB2LCBjaXJjbGVPZmZzZXQpO1xuXG4gICAgICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA8IE1hdGgucG93KHJhZGl1c1N1bSwgMikpe1xuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxsaW5lQm9keSxjaXJjbGVTaGFwZSxsaW5lU2hhcGUpO1xuXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gY29udGFjdCBwb2ludCBpcyB0aGUgbm9ybWFsIHRpbWVzIHRoZSBjaXJjbGUgcmFkaXVzXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgdiwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGxpbmVFbmRUb0xpbmVSYWRpdXMsIGMubm9ybWFsQSwgLWxpbmVSYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lRW5kVG9MaW5lUmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvY2Fwc3VsZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjaXJjbGVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgIGJpXG4gKiBAcGFyYW0gIHtDaXJjbGV9IHNpXG4gKiBAcGFyYW0gIHtBcnJheX0gIHhpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFpXG4gKiBAcGFyYW0gIHtCb2R5fSAgIGJqXG4gKiBAcGFyYW0gIHtMaW5lfSAgIHNqXG4gKiBAcGFyYW0gIHtBcnJheX0gIHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5DQVBTVUxFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlQ2Fwc3VsZSA9IGZ1bmN0aW9uKGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3Qpe1xuICAgIHJldHVybiB0aGlzLmNpcmNsZUxpbmUoYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCwgc2oucmFkaXVzKTtcbn07XG5cbi8qKlxuICogQ2lyY2xlL2NvbnZleCBOYXJyb3dwaGFzZS5cbiAqIEBtZXRob2QgY2lyY2xlQ29udmV4XG4gKiBAcGFyYW0gIHtCb2R5fSBjaXJjbGVCb2R5XG4gKiBAcGFyYW0gIHtDaXJjbGV9IGNpcmNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY2lyY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNpcmNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0gIHtCb29sZWFufSBqdXN0VGVzdFxuICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVSYWRpdXNcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLlJFQ1RBTkdMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUNvbnZleCA9IGZ1bmN0aW9uKFxuICAgIGNpcmNsZUJvZHksXG4gICAgY2lyY2xlU2hhcGUsXG4gICAgY2lyY2xlT2Zmc2V0LFxuICAgIGNpcmNsZUFuZ2xlLFxuICAgIGNvbnZleEJvZHksXG4gICAgY29udmV4U2hhcGUsXG4gICAgY29udmV4T2Zmc2V0LFxuICAgIGNvbnZleEFuZ2xlLFxuICAgIGp1c3RUZXN0LFxuICAgIGNpcmNsZVJhZGl1c1xuKXtcbiAgICB2YXIgY2lyY2xlUmFkaXVzID0gdHlwZW9mKGNpcmNsZVJhZGl1cyk9PT1cIm51bWJlclwiID8gY2lyY2xlUmFkaXVzIDogY2lyY2xlU2hhcGUucmFkaXVzO1xuXG4gICAgdmFyIHdvcmxkVmVydGV4MCA9IHRtcDEsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHRtcDIsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDMsXG4gICAgICAgIHdvcmxkRWRnZVVuaXQgPSB0bXA0LFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDUsXG4gICAgICAgIGNlbnRlckRpc3QgPSB0bXA2LFxuICAgICAgICBjb252ZXhUb0NpcmNsZSA9IHRtcDcsXG4gICAgICAgIG9ydGhvRGlzdCA9IHRtcDgsXG4gICAgICAgIHByb2plY3RlZFBvaW50ID0gdG1wOSxcbiAgICAgICAgZGlzdCA9IHRtcDEwLFxuICAgICAgICB3b3JsZFZlcnRleCA9IHRtcDExLFxuXG4gICAgICAgIGNsb3Nlc3RFZGdlID0gLTEsXG4gICAgICAgIGNsb3Nlc3RFZGdlRGlzdGFuY2UgPSBudWxsLFxuICAgICAgICBjbG9zZXN0RWRnZU9ydGhvRGlzdCA9IHRtcDEyLFxuICAgICAgICBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50ID0gdG1wMTMsXG4gICAgICAgIGNhbmRpZGF0ZSA9IHRtcDE0LFxuICAgICAgICBjYW5kaWRhdGVEaXN0ID0gdG1wMTUsXG4gICAgICAgIG1pbkNhbmRpZGF0ZSA9IHRtcDE2LFxuXG4gICAgICAgIGZvdW5kID0gZmFsc2UsXG4gICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIHZhciBudW1SZXBvcnRlZCA9IDA7XG5cbiAgICAvLyBOZXcgYWxnb3JpdGhtOlxuICAgIC8vIDEuIENoZWNrIHNvIGNlbnRlciBvZiBjaXJjbGUgaXMgbm90IGluc2lkZSB0aGUgcG9seWdvbi4gSWYgaXQgaXMsIHRoaXMgd29udCB3b3JrLi4uXG4gICAgLy8gMi4gRm9yIGVhY2ggZWRnZVxuICAgIC8vIDIuIDEuIEdldCBwb2ludCBvbiBjaXJjbGUgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBlZGdlIChzY2FsZSBub3JtYWwgd2l0aCAtcmFkaXVzKVxuICAgIC8vIDIuIDIuIENoZWNrIGlmIHBvaW50IGlzIGluc2lkZS5cblxuICAgIHZhciB2ZXJ0cyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzO1xuXG4gICAgLy8gQ2hlY2sgYWxsIGVkZ2VzIGZpcnN0XG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGgrMTsgaSsrKXtcbiAgICAgICAgdmFyIHYwID0gdmVydHNbaSV2ZXJ0cy5sZW5ndGhdLFxuICAgICAgICAgICAgdjEgPSB2ZXJ0c1soaSsxKSV2ZXJ0cy5sZW5ndGhdO1xuXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MCwgdjAsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgxLCB2MSwgY29udmV4QW5nbGUpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgwLCB3b3JsZFZlcnRleDAsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MSwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xuXG4gICAgICAgIHZlYzIubm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XG5cbiAgICAgICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuIFBvaW50cyBvdXQgb2YgdGhlIENvbnZleFxuICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGROb3JtYWwsIHdvcmxkRWRnZVVuaXQpO1xuXG4gICAgICAgIC8vIEdldCBwb2ludCBvbiBjaXJjbGUsIGNsb3Nlc3QgdG8gdGhlIHBvbHlnb25cbiAgICAgICAgdmVjMi5zY2FsZShjYW5kaWRhdGUsd29ybGROb3JtYWwsLWNpcmNsZVNoYXBlLnJhZGl1cyk7XG4gICAgICAgIGFkZChjYW5kaWRhdGUsY2FuZGlkYXRlLGNpcmNsZU9mZnNldCk7XG5cbiAgICAgICAgaWYocG9pbnRJbkNvbnZleChjYW5kaWRhdGUsY29udmV4U2hhcGUsY29udmV4T2Zmc2V0LGNvbnZleEFuZ2xlKSl7XG5cbiAgICAgICAgICAgIHZlYzIuc3ViKGNhbmRpZGF0ZURpc3Qsd29ybGRWZXJ0ZXgwLGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlRGlzdGFuY2UgPSBNYXRoLmFicyh2ZWMyLmRvdChjYW5kaWRhdGVEaXN0LHdvcmxkTm9ybWFsKSk7XG5cbiAgICAgICAgICAgIGlmKGNhbmRpZGF0ZURpc3RhbmNlIDwgbWluQ2FuZGlkYXRlRGlzdGFuY2Upe1xuICAgICAgICAgICAgICAgIHZlYzIuY29weShtaW5DYW5kaWRhdGUsY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IGNhbmRpZGF0ZURpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCx3b3JsZE5vcm1hbCxjYW5kaWRhdGVEaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgdmVjMi5hZGQoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCxjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZm91bmQpe1xuXG4gICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LGNvbnZleEJvZHksY2lyY2xlU2hhcGUsY29udmV4U2hhcGUpO1xuICAgICAgICB2ZWMyLnN1YihjLm5vcm1hbEEsIG1pbkNhbmRpZGF0ZSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xuXG4gICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRBLCAgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xuICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleEJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKCB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGFsbCB2ZXJ0aWNlc1xuICAgIGlmKGNpcmNsZVJhZGl1cyA+IDApe1xuICAgICAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgbG9jYWxWZXJ0ZXggPSB2ZXJ0c1tpXTtcbiAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4LCBsb2NhbFZlcnRleCwgY29udmV4QW5nbGUpO1xuICAgICAgICAgICAgYWRkKHdvcmxkVmVydGV4LCB3b3JsZFZlcnRleCwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICAgICAgc3ViKGRpc3QsIHdvcmxkVmVydGV4LCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICAgICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpIDwgTWF0aC5wb3coY2lyY2xlUmFkaXVzLCAyKSl7XG5cbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxjb252ZXhCb2R5LGNpcmNsZVNoYXBlLGNvbnZleFNoYXBlKTtcblxuICAgICAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIGRpc3QpO1xuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gY2lyY2xlIHRvIGNvbnRhY3QgcG9pbnQgaXMgdGhlIG5vcm1hbCB0aW1lcyB0aGUgY2lyY2xlIHJhZGl1c1xuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsIGNpcmNsZVJhZGl1cyk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB3b3JsZFZlcnRleCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG52YXIgcGljX3dvcmxkVmVydGV4MCA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGljX3dvcmxkVmVydGV4MSA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGljX3IwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBwaWNfcjEgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpcyBpbiBhIHBvbHlnb25cbiAqL1xuZnVuY3Rpb24gcG9pbnRJbkNvbnZleCh3b3JsZFBvaW50LGNvbnZleFNoYXBlLGNvbnZleE9mZnNldCxjb252ZXhBbmdsZSl7XG4gICAgdmFyIHdvcmxkVmVydGV4MCA9IHBpY193b3JsZFZlcnRleDAsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHBpY193b3JsZFZlcnRleDEsXG4gICAgICAgIHIwID0gcGljX3IwLFxuICAgICAgICByMSA9IHBpY19yMSxcbiAgICAgICAgcG9pbnQgPSB3b3JsZFBvaW50LFxuICAgICAgICB2ZXJ0cyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzLFxuICAgICAgICBsYXN0Q3Jvc3MgPSBudWxsO1xuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoKzE7IGkrKyl7XG4gICAgICAgIHZhciB2MCA9IHZlcnRzW2kldmVydHMubGVuZ3RoXSxcbiAgICAgICAgICAgIHYxID0gdmVydHNbKGkrMSkldmVydHMubGVuZ3RoXTtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gdmVydGljZXMgdG8gd29ybGRcbiAgICAgICAgLy8gQHRvZG8gVGhlIHBvaW50IHNob3VsZCBiZSB0cmFuc2Zvcm1lZCB0byBsb2NhbCBjb29yZGluYXRlcyBpbiB0aGUgY29udmV4LCBubyBuZWVkIHRvIHRyYW5zZm9ybSBlYWNoIHZlcnRleFxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAsIHYwLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MSwgdjEsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDEsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgc3ViKHIwLCB3b3JsZFZlcnRleDAsIHBvaW50KTtcbiAgICAgICAgc3ViKHIxLCB3b3JsZFZlcnRleDEsIHBvaW50KTtcbiAgICAgICAgdmFyIGNyb3NzID0gdmVjMi5jcm9zc0xlbmd0aChyMCxyMSk7XG5cbiAgICAgICAgaWYobGFzdENyb3NzPT09bnVsbCl7XG4gICAgICAgICAgICBsYXN0Q3Jvc3MgPSBjcm9zcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGdvdCBhIGRpZmZlcmVudCBzaWduIG9mIHRoZSBkaXN0YW5jZSB2ZWN0b3IsIHRoZSBwb2ludCBpcyBvdXQgb2YgdGhlIHBvbHlnb25cbiAgICAgICAgaWYoY3Jvc3MqbGFzdENyb3NzIDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RDcm9zcyA9IGNyb3NzO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBQYXJ0aWNsZS9jb252ZXggTmFycm93cGhhc2VcbiAqIEBtZXRob2QgcGFydGljbGVDb252ZXhcbiAqIEBwYXJhbSAge0JvZHl9IHBhcnRpY2xlQm9keVxuICogQHBhcmFtICB7UGFydGljbGV9IHBhcnRpY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBwYXJ0aWNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwYXJ0aWNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XG4gKiBAdG9kbyB1c2UgcG9pbnRJbkNvbnZleCBhbmQgY29kZSBtb3JlIHNpbWlsYXIgdG8gY2lyY2xlQ29udmV4XG4gKiBAdG9kbyBkb24ndCB0cmFuc2Zvcm0gZWFjaCB2ZXJ0ZXgsIGJ1dCB0cmFuc2Zvcm0gdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHRvIGNvbnZleC1sb2NhbCBpbnN0ZWFkXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuUkVDVEFOR0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGFydGljbGVDb252ZXggPSBmdW5jdGlvbihcbiAgICBwYXJ0aWNsZUJvZHksXG4gICAgcGFydGljbGVTaGFwZSxcbiAgICBwYXJ0aWNsZU9mZnNldCxcbiAgICBwYXJ0aWNsZUFuZ2xlLFxuICAgIGNvbnZleEJvZHksXG4gICAgY29udmV4U2hhcGUsXG4gICAgY29udmV4T2Zmc2V0LFxuICAgIGNvbnZleEFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLFxuICAgICAgICB3b3JsZFZlcnRleDEgPSB0bXAyLFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXAzLFxuICAgICAgICB3b3JsZEVkZ2VVbml0ID0gdG1wNCxcbiAgICAgICAgd29ybGRUYW5nZW50ID0gdG1wNSxcbiAgICAgICAgY2VudGVyRGlzdCA9IHRtcDYsXG4gICAgICAgIGNvbnZleFRvcGFydGljbGUgPSB0bXA3LFxuICAgICAgICBvcnRob0Rpc3QgPSB0bXA4LFxuICAgICAgICBwcm9qZWN0ZWRQb2ludCA9IHRtcDksXG4gICAgICAgIGRpc3QgPSB0bXAxMCxcbiAgICAgICAgd29ybGRWZXJ0ZXggPSB0bXAxMSxcbiAgICAgICAgY2xvc2VzdEVkZ2UgPSAtMSxcbiAgICAgICAgY2xvc2VzdEVkZ2VEaXN0YW5jZSA9IG51bGwsXG4gICAgICAgIGNsb3Nlc3RFZGdlT3J0aG9EaXN0ID0gdG1wMTIsXG4gICAgICAgIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQgPSB0bXAxMyxcbiAgICAgICAgcjAgPSB0bXAxNCwgLy8gdmVjdG9yIGZyb20gcGFydGljbGUgdG8gdmVydGV4MFxuICAgICAgICByMSA9IHRtcDE1LFxuICAgICAgICBsb2NhbFBvaW50ID0gdG1wMTYsXG4gICAgICAgIGNhbmRpZGF0ZURpc3QgPSB0bXAxNyxcbiAgICAgICAgbWluRWRnZU5vcm1hbCA9IHRtcDE4LFxuICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICB2YXIgbnVtUmVwb3J0ZWQgPSAwLFxuICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICB2ZXJ0cyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHBhcnRpY2xlIGlzIGluIHRoZSBwb2x5Z29uIGF0IGFsbFxuICAgIGlmKCFwb2ludEluQ29udmV4KHBhcnRpY2xlT2Zmc2V0LGNvbnZleFNoYXBlLGNvbnZleE9mZnNldCxjb252ZXhBbmdsZSkpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGVkZ2VzIGZpcnN0XG4gICAgdmFyIGxhc3RDcm9zcyA9IG51bGw7XG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGgrMTsgaSsrKXtcbiAgICAgICAgdmFyIHYwID0gdmVydHNbaSV2ZXJ0cy5sZW5ndGhdLFxuICAgICAgICAgICAgdjEgPSB2ZXJ0c1soaSsxKSV2ZXJ0cy5sZW5ndGhdO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSB2ZXJ0aWNlcyB0byB3b3JsZFxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAsIHYwLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MSwgdjEsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDEsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgLy8gR2V0IHdvcmxkIGVkZ2VcbiAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xuXG4gICAgICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLiBQb2ludHMgb3V0IG9mIHRoZSBDb252ZXhcbiAgICAgICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkVGFuZ2VudCwgd29ybGRFZGdlVW5pdCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZGlzdGFuY2UgZnJvbSB0aGUgaW5maW5pdGUgbGluZSAoc3Bhbm5lZCBieSB0aGUgZWRnZSkgdG8gdGhlIHBhcnRpY2xlXG4gICAgICAgIHN1YihkaXN0LCBwYXJ0aWNsZU9mZnNldCwgd29ybGRWZXJ0ZXgwKTtcbiAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGRUYW5nZW50KTtcbiAgICAgICAgc3ViKGNlbnRlckRpc3QsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICBzdWIoY29udmV4VG9wYXJ0aWNsZSwgcGFydGljbGVPZmZzZXQsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgdmVjMi5zdWIoY2FuZGlkYXRlRGlzdCx3b3JsZFZlcnRleDAscGFydGljbGVPZmZzZXQpO1xuICAgICAgICB2YXIgY2FuZGlkYXRlRGlzdGFuY2UgPSBNYXRoLmFicyh2ZWMyLmRvdChjYW5kaWRhdGVEaXN0LHdvcmxkVGFuZ2VudCkpO1xuXG4gICAgICAgIGlmKGNhbmRpZGF0ZURpc3RhbmNlIDwgbWluQ2FuZGlkYXRlRGlzdGFuY2Upe1xuICAgICAgICAgICAgbWluQ2FuZGlkYXRlRGlzdGFuY2UgPSBjYW5kaWRhdGVEaXN0YW5jZTtcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCx3b3JsZFRhbmdlbnQsY2FuZGlkYXRlRGlzdGFuY2UpO1xuICAgICAgICAgICAgdmVjMi5hZGQoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCxjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LHBhcnRpY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgIHZlYzIuY29weShtaW5FZGdlTm9ybWFsLHdvcmxkVGFuZ2VudCk7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihmb3VuZCl7XG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGFydGljbGVCb2R5LGNvbnZleEJvZHkscGFydGljbGVTaGFwZSxjb252ZXhTaGFwZSk7XG5cbiAgICAgICAgdmVjMi5zY2FsZShjLm5vcm1hbEEsIG1pbkVkZ2VOb3JtYWwsIC0xKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xuXG4gICAgICAgIC8vIFBhcnRpY2xlIGhhcyBubyBleHRlbnQgdG8gdGhlIGNvbnRhY3QgcG9pbnRcbiAgICAgICAgdmVjMi5zZXQoYy5jb250YWN0UG9pbnRBLCAgMCwgMCk7XG4gICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGFydGljbGVPZmZzZXQpO1xuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBhcnRpY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgLy8gRnJvbSBjb252ZXggY2VudGVyIHRvIHBvaW50XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCggdGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cblxuICAgIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvY2lyY2xlIE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNpcmNsZUNpcmNsZVxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0NpcmNsZX0gc2hhcGVBXG4gKiBAcGFyYW0gIHtBcnJheX0gb2Zmc2V0QVxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0gIHtDaXJjbGV9IHNoYXBlQlxuICogQHBhcmFtICB7QXJyYXl9IG9mZnNldEJcbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVCXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1c0FdIE9wdGlvbmFsIHJhZGl1cyB0byB1c2UgZm9yIHNoYXBlQVxuICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXNCXSBPcHRpb25hbCByYWRpdXMgdG8gdXNlIGZvciBzaGFwZUJcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUNpcmNsZSA9IGZ1bmN0aW9uKFxuICAgIGJvZHlBLFxuICAgIHNoYXBlQSxcbiAgICBvZmZzZXRBLFxuICAgIGFuZ2xlQSxcbiAgICBib2R5QixcbiAgICBzaGFwZUIsXG4gICAgb2Zmc2V0QixcbiAgICBhbmdsZUIsXG4gICAganVzdFRlc3QsXG4gICAgcmFkaXVzQSxcbiAgICByYWRpdXNCXG4pe1xuXG4gICAgdmFyIGRpc3QgPSB0bXAxLFxuICAgICAgICByYWRpdXNBID0gcmFkaXVzQSB8fCBzaGFwZUEucmFkaXVzLFxuICAgICAgICByYWRpdXNCID0gcmFkaXVzQiB8fCBzaGFwZUIucmFkaXVzO1xuXG4gICAgc3ViKGRpc3Qsb2Zmc2V0QSxvZmZzZXRCKTtcbiAgICB2YXIgciA9IHJhZGl1c0EgKyByYWRpdXNCO1xuICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA+IE1hdGgucG93KHIsMikpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIsc2hhcGVBLHNoYXBlQik7XG4gICAgc3ViKGMubm9ybWFsQSwgb2Zmc2V0Qiwgb2Zmc2V0QSk7XG4gICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICB2ZWMyLnNjYWxlKCBjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgIHJhZGl1c0EpO1xuICAgIHZlYzIuc2NhbGUoIGMuY29udGFjdFBvaW50QiwgYy5ub3JtYWxBLCAtcmFkaXVzQik7XG5cbiAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIG9mZnNldEEpO1xuICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgYm9keUEucG9zaXRpb24pO1xuXG4gICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBvZmZzZXRCKTtcbiAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGJvZHlCLnBvc2l0aW9uKTtcblxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogUGxhbmUvQ29udmV4IE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIHBsYW5lQ29udmV4XG4gKiBAcGFyYW0gIHtCb2R5fSBwbGFuZUJvZHlcbiAqIEBwYXJhbSAge1BsYW5lfSBwbGFuZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGxhbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGxhbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLlJFQ1RBTkdMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQ29udmV4ID0gZnVuY3Rpb24oXG4gICAgcGxhbmVCb2R5LFxuICAgIHBsYW5lU2hhcGUsXG4gICAgcGxhbmVPZmZzZXQsXG4gICAgcGxhbmVBbmdsZSxcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgd29ybGRWZXJ0ZXggPSB0bXAxLFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDIsXG4gICAgICAgIGRpc3QgPSB0bXAzO1xuXG4gICAgdmFyIG51bVJlcG9ydGVkID0gMDtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1jb252ZXhTaGFwZS52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gY29udmV4U2hhcGUudmVydGljZXNbaV07XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4LCB2LCBjb252ZXhBbmdsZSk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgc3ViKGRpc3QsIHdvcmxkVmVydGV4LCBwbGFuZU9mZnNldCk7XG5cbiAgICAgICAgaWYoZG90KGRpc3Qsd29ybGROb3JtYWwpIDw9IDApe1xuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvdW5kIHZlcnRleFxuICAgICAgICAgICAgbnVtUmVwb3J0ZWQrKztcblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksY29udmV4Qm9keSxwbGFuZVNoYXBlLGNvbnZleFNoYXBlKTtcblxuICAgICAgICAgICAgc3ViKGRpc3QsIHdvcmxkVmVydGV4LCBwbGFuZU9mZnNldCk7XG5cbiAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCwgYy5ub3JtYWxBKTtcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoZGlzdCwgYy5ub3JtYWxBLCBkKTtcblxuICAgICAgICAgICAgLy8gcmogaXMgZnJvbSBjb252ZXggY2VudGVyIHRvIGNvbnRhY3RcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHdvcmxkVmVydGV4LCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcblxuXG4gICAgICAgICAgICAvLyByaSBpcyBmcm9tIHBsYW5lIGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICBzdWIoIGMuY29udGFjdFBvaW50QSwgd29ybGRWZXJ0ZXgsIGRpc3QpO1xuICAgICAgICAgICAgc3ViKCBjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24gJiYgbnVtUmVwb3J0ZWQpe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1SZXBvcnRlZCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bVJlcG9ydGVkO1xufTtcblxuLyoqXG4gKiBOYXJyb3dwaGFzZSBmb3IgcGFydGljbGUgdnMgcGxhbmVcbiAqIEBtZXRob2QgcGFydGljbGVQbGFuZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgcGFydGljbGVCb2R5XG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gICBwYXJ0aWNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBwYXJ0aWNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgcGFydGljbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgcGxhbmVCb2R5XG4gKiBAcGFyYW0gIHtQbGFuZX0gICAgICBwbGFuZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBwbGFuZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgcGxhbmVBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSAgICAganVzdFRlc3RcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuUExBTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wYXJ0aWNsZVBsYW5lID0gZnVuY3Rpb24oXG4gICAgcGFydGljbGVCb2R5LFxuICAgIHBhcnRpY2xlU2hhcGUsXG4gICAgcGFydGljbGVPZmZzZXQsXG4gICAgcGFydGljbGVBbmdsZSxcbiAgICBwbGFuZUJvZHksXG4gICAgcGxhbmVTaGFwZSxcbiAgICBwbGFuZU9mZnNldCxcbiAgICBwbGFuZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciBkaXN0ID0gdG1wMSxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXAyO1xuXG4gICAgcGxhbmVBbmdsZSA9IHBsYW5lQW5nbGUgfHwgMDtcblxuICAgIHN1YihkaXN0LCBwYXJ0aWNsZU9mZnNldCwgcGxhbmVPZmZzZXQpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XG5cbiAgICB2YXIgZCA9IGRvdChkaXN0LCB3b3JsZE5vcm1hbCk7XG5cbiAgICBpZihkID4gMCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LHBhcnRpY2xlQm9keSxwbGFuZVNoYXBlLHBhcnRpY2xlU2hhcGUpO1xuXG4gICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgd29ybGROb3JtYWwpO1xuICAgIHZlYzIuc2NhbGUoIGRpc3QsIGMubm9ybWFsQSwgZCApO1xuICAgIC8vIGRpc3QgaXMgbm93IHRoZSBkaXN0YW5jZSB2ZWN0b3IgaW4gdGhlIG5vcm1hbCBkaXJlY3Rpb25cblxuICAgIC8vIHJpIGlzIHRoZSBwYXJ0aWNsZSBwb3NpdGlvbiBwcm9qZWN0ZWQgZG93biBvbnRvIHRoZSBwbGFuZSwgZnJvbSB0aGUgcGxhbmUgY2VudGVyXG4gICAgc3ViKCBjLmNvbnRhY3RQb2ludEEsIHBhcnRpY2xlT2Zmc2V0LCBkaXN0KTtcbiAgICBzdWIoIGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xuXG4gICAgLy8gcmogaXMgZnJvbSB0aGUgYm9keSBjZW50ZXIgdG8gdGhlIHBhcnRpY2xlIGNlbnRlclxuICAgIHN1YiggYy5jb250YWN0UG9pbnRCLCBwYXJ0aWNsZU9mZnNldCwgcGFydGljbGVCb2R5LnBvc2l0aW9uICk7XG5cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIENpcmNsZS9QYXJ0aWNsZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjaXJjbGVQYXJ0aWNsZVxuICogQHBhcmFtICB7Qm9keX0gY2lyY2xlQm9keVxuICogQHBhcmFtICB7Q2lyY2xlfSBjaXJjbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNpcmNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gcGFydGljbGVCb2R5XG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gcGFydGljbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IHBhcnRpY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBhcnRpY2xlQW5nbGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGp1c3RUZXN0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5QQVJUSUNMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZVBhcnRpY2xlID0gZnVuY3Rpb24oXG4gICAgY2lyY2xlQm9keSxcbiAgICBjaXJjbGVTaGFwZSxcbiAgICBjaXJjbGVPZmZzZXQsXG4gICAgY2lyY2xlQW5nbGUsXG4gICAgcGFydGljbGVCb2R5LFxuICAgIHBhcnRpY2xlU2hhcGUsXG4gICAgcGFydGljbGVPZmZzZXQsXG4gICAgcGFydGljbGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgZGlzdCA9IHRtcDE7XG5cbiAgICBzdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIGNpcmNsZU9mZnNldCk7XG4gICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpID4gTWF0aC5wb3coY2lyY2xlU2hhcGUucmFkaXVzLCAyKSl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxwYXJ0aWNsZUJvZHksY2lyY2xlU2hhcGUscGFydGljbGVTaGFwZSk7XG4gICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgZGlzdCk7XG4gICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gY29udGFjdCBwb2ludCBpcyB0aGUgbm9ybWFsIHRpbWVzIHRoZSBjaXJjbGUgcmFkaXVzXG4gICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlU2hhcGUucmFkaXVzKTtcbiAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XG4gICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgIC8vIFZlY3RvciBmcm9tIHBhcnRpY2xlIGNlbnRlciB0byBjb250YWN0IHBvaW50IGlzIHplcm9cbiAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBwYXJ0aWNsZU9mZnNldCwgcGFydGljbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xufTtcblxudmFyIHBsYW5lQ2Fwc3VsZV90bXBDaXJjbGUgPSBuZXcgQ2lyY2xlKDEpLFxuICAgIHBsYW5lQ2Fwc3VsZV90bXAxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBwbGFuZUNhcHN1bGVfdG1wMiA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGxhbmVDYXBzdWxlX3RtcDMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgcGxhbmVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSBwbGFuZUJvZHlcbiAqIEBwYXJhbSAge0NpcmNsZX0gcGxhbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IHBsYW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNhcHN1bGVCb2R5XG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gY2Fwc3VsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY2Fwc3VsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjYXBzdWxlQW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuQ0FQU1VMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQ2Fwc3VsZSA9IGZ1bmN0aW9uKFxuICAgIHBsYW5lQm9keSxcbiAgICBwbGFuZVNoYXBlLFxuICAgIHBsYW5lT2Zmc2V0LFxuICAgIHBsYW5lQW5nbGUsXG4gICAgY2Fwc3VsZUJvZHksXG4gICAgY2Fwc3VsZVNoYXBlLFxuICAgIGNhcHN1bGVPZmZzZXQsXG4gICAgY2Fwc3VsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciBlbmQxID0gcGxhbmVDYXBzdWxlX3RtcDEsXG4gICAgICAgIGVuZDIgPSBwbGFuZUNhcHN1bGVfdG1wMixcbiAgICAgICAgY2lyY2xlID0gcGxhbmVDYXBzdWxlX3RtcENpcmNsZSxcbiAgICAgICAgZHN0ID0gcGxhbmVDYXBzdWxlX3RtcDM7XG5cbiAgICAvLyBDb21wdXRlIHdvcmxkIGVuZCBwb3NpdGlvbnNcbiAgICB2ZWMyLnNldChlbmQxLCAtY2Fwc3VsZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnJvdGF0ZShlbmQxLGVuZDEsY2Fwc3VsZUFuZ2xlKTtcbiAgICBhZGQoZW5kMSxlbmQxLGNhcHN1bGVPZmZzZXQpO1xuXG4gICAgdmVjMi5zZXQoZW5kMiwgIGNhcHN1bGVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5yb3RhdGUoZW5kMixlbmQyLGNhcHN1bGVBbmdsZSk7XG4gICAgYWRkKGVuZDIsZW5kMixjYXBzdWxlT2Zmc2V0KTtcblxuICAgIGNpcmNsZS5yYWRpdXMgPSBjYXBzdWxlU2hhcGUucmFkaXVzO1xuXG4gICAgdmFyIGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuXG4gICAgLy8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRG8gTmFycm93cGhhc2UgYXMgdHdvIGNpcmNsZXNcbiAgICB2YXIgbnVtQ29udGFjdHMxID0gdGhpcy5jaXJjbGVQbGFuZShjYXBzdWxlQm9keSxjaXJjbGUsZW5kMSwwLCBwbGFuZUJvZHkscGxhbmVTaGFwZSxwbGFuZU9mZnNldCxwbGFuZUFuZ2xlLCBqdXN0VGVzdCksXG4gICAgICAgIG51bUNvbnRhY3RzMiA9IHRoaXMuY2lyY2xlUGxhbmUoY2Fwc3VsZUJvZHksY2lyY2xlLGVuZDIsMCwgcGxhbmVCb2R5LHBsYW5lU2hhcGUscGxhbmVPZmZzZXQscGxhbmVBbmdsZSwganVzdFRlc3QpO1xuXG4gICAgLy8gUmVzdG9yZSBmcmljdGlvblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gbnVtQ29udGFjdHMxIHx8IG51bUNvbnRhY3RzMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbnVtVG90YWwgPSBudW1Db250YWN0czEgKyBudW1Db250YWN0czI7XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgaWYobnVtVG90YWwpe1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtVG90YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtVG90YWw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIENvbnRhY3RFcXVhdGlvbnMgYW5kIEZyaWN0aW9uRXF1YXRpb25zIGZvciBhIGNvbGxpc2lvbi5cbiAqIEBtZXRob2QgY2lyY2xlUGxhbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgIGJpICAgICBUaGUgZmlyc3QgYm9keSB0aGF0IHNob3VsZCBiZSBjb25uZWN0ZWQgdG8gdGhlIGVxdWF0aW9ucy5cbiAqIEBwYXJhbSAge0NpcmNsZX0gIHNpICAgICBUaGUgY2lyY2xlIHNoYXBlIHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbGxpc2lvbi5cbiAqIEBwYXJhbSAge0FycmF5fSAgIHhpICAgICBFeHRyYSBvZmZzZXQgdG8gdGFrZSBpbnRvIGFjY291bnQgZm9yIHRoZSBTaGFwZSwgaW4gYWRkaXRpb24gdG8gdGhlIG9uZSBpbiBjaXJjbGVCb2R5LnBvc2l0aW9uLiBXaWxsICpub3QqIGJlIHJvdGF0ZWQgYnkgY2lyY2xlQm9keS5hbmdsZSAobWF5YmUgaXQgc2hvdWxkLCBmb3Igc2FrZSBvZiBob21vZ2VuaXR5PykuIFNldCB0byBudWxsIGlmIG5vbmUuXG4gKiBAcGFyYW0gIHtCb2R5fSAgICBiaiAgICAgVGhlIHNlY29uZCBib2R5IHRoYXQgc2hvdWxkIGJlIGNvbm5lY3RlZCB0byB0aGUgZXF1YXRpb25zLlxuICogQHBhcmFtICB7UGxhbmV9ICAgc2ogICAgIFRoZSBQbGFuZSBzaGFwZSB0aGF0IGlzIHBhcnRpY2lwYXRpbmdcbiAqIEBwYXJhbSAge0FycmF5fSAgIHhqICAgICBFeHRyYSBvZmZzZXQgZm9yIHRoZSBwbGFuZSBzaGFwZS5cbiAqIEBwYXJhbSAge051bWJlcn0gIGFqICAgICBFeHRyYSBhbmdsZSB0byBhcHBseSB0byB0aGUgcGxhbmVcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLlBMQU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlUGxhbmUgPSBmdW5jdGlvbiggICBiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0ICl7XG4gICAgdmFyIGNpcmNsZUJvZHkgPSBiaSxcbiAgICAgICAgY2lyY2xlU2hhcGUgPSBzaSxcbiAgICAgICAgY2lyY2xlT2Zmc2V0ID0geGksIC8vIE9mZnNldCBmcm9tIGJvZHkgY2VudGVyLCByb3RhdGVkIVxuICAgICAgICBwbGFuZUJvZHkgPSBiaixcbiAgICAgICAgc2hhcGVCID0gc2osXG4gICAgICAgIHBsYW5lT2Zmc2V0ID0geGosXG4gICAgICAgIHBsYW5lQW5nbGUgPSBhajtcblxuICAgIHBsYW5lQW5nbGUgPSBwbGFuZUFuZ2xlIHx8IDA7XG5cbiAgICAvLyBWZWN0b3IgZnJvbSBwbGFuZSB0byBjaXJjbGVcbiAgICB2YXIgcGxhbmVUb0NpcmNsZSA9IHRtcDEsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wMixcbiAgICAgICAgdGVtcCA9IHRtcDM7XG5cbiAgICBzdWIocGxhbmVUb0NpcmNsZSwgY2lyY2xlT2Zmc2V0LCBwbGFuZU9mZnNldCk7XG5cbiAgICAvLyBXb3JsZCBwbGFuZSBub3JtYWxcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xuXG4gICAgLy8gTm9ybWFsIGRpcmVjdGlvbiBkaXN0YW5jZVxuICAgIHZhciBkID0gZG90KHdvcmxkTm9ybWFsLCBwbGFuZVRvQ2lyY2xlKTtcblxuICAgIGlmKGQgPiBjaXJjbGVTaGFwZS5yYWRpdXMpe1xuICAgICAgICByZXR1cm4gMDsgLy8gTm8gb3ZlcmxhcC4gQWJvcnQuXG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgY29udGFjdFxuICAgIHZhciBjb250YWN0ID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LGNpcmNsZUJvZHksc2osc2kpO1xuXG4gICAgLy8gbmkgaXMgdGhlIHBsYW5lIHdvcmxkIG5vcm1hbFxuICAgIHZlYzIuY29weShjb250YWN0Lm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcblxuICAgIC8vIHJqIGlzIHRoZSB2ZWN0b3IgZnJvbSBjaXJjbGUgY2VudGVyIHRvIHRoZSBjb250YWN0IHBvaW50XG4gICAgdmVjMi5zY2FsZShjb250YWN0LmNvbnRhY3RQb2ludEIsIGNvbnRhY3Qubm9ybWFsQSwgLWNpcmNsZVNoYXBlLnJhZGl1cyk7XG4gICAgYWRkKGNvbnRhY3QuY29udGFjdFBvaW50QiwgY29udGFjdC5jb250YWN0UG9pbnRCLCBjaXJjbGVPZmZzZXQpO1xuICAgIHN1Yihjb250YWN0LmNvbnRhY3RQb2ludEIsIGNvbnRhY3QuY29udGFjdFBvaW50QiwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAvLyByaSBpcyB0aGUgZGlzdGFuY2UgZnJvbSBwbGFuZSBjZW50ZXIgdG8gY29udGFjdC5cbiAgICB2ZWMyLnNjYWxlKHRlbXAsIGNvbnRhY3Qubm9ybWFsQSwgZCk7XG4gICAgc3ViKGNvbnRhY3QuY29udGFjdFBvaW50QSwgcGxhbmVUb0NpcmNsZSwgdGVtcCApOyAvLyBTdWJ0cmFjdCBub3JtYWwgZGlzdGFuY2UgdmVjdG9yIGZyb20gdGhlIGRpc3RhbmNlIHZlY3RvclxuICAgIGFkZChjb250YWN0LmNvbnRhY3RQb2ludEEsIGNvbnRhY3QuY29udGFjdFBvaW50QSwgcGxhbmVPZmZzZXQpO1xuICAgIHN1Yihjb250YWN0LmNvbnRhY3RQb2ludEEsIGNvbnRhY3QuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGNvbnRhY3QpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCggdGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGNvbnRhY3QpICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIENvbnZleC9jb252ZXggTmFycm93cGhhc2UuU2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFsdGRldmJsb2dhZGF5LmNvbS8yMDExLzA1LzEzL2NvbnRhY3QtZ2VuZXJhdGlvbi1iZXR3ZWVuLTNkLWNvbnZleC1tZXNoZXMvXCI+dGhpcyBhcnRpY2xlPC9hPiBmb3IgbW9yZSBpbmZvLlxuICogQG1ldGhvZCBjb252ZXhDb252ZXhcbiAqIEBwYXJhbSAge0JvZHl9IGJpXG4gKiBAcGFyYW0gIHtDb252ZXh9IHNpXG4gKiBAcGFyYW0gIHtBcnJheX0geGlcbiAqIEBwYXJhbSAge051bWJlcn0gYWlcbiAqIEBwYXJhbSAge0JvZHl9IGJqXG4gKiBAcGFyYW0gIHtDb252ZXh9IHNqXG4gKiBAcGFyYW0gIHtBcnJheX0geGpcbiAqIEBwYXJhbSAge051bWJlcn0gYWpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLlJFQ1RBTkdMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlJFQ1RBTkdMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleENvbnZleCA9IGZ1bmN0aW9uKCAgYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCwgcHJlY2lzaW9uICl7XG4gICAgdmFyIHNlcEF4aXMgPSB0bXAxLFxuICAgICAgICB3b3JsZFBvaW50ID0gdG1wMixcbiAgICAgICAgd29ybGRQb2ludDAgPSB0bXAzLFxuICAgICAgICB3b3JsZFBvaW50MSA9IHRtcDQsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDUsXG4gICAgICAgIHByb2plY3RlZCA9IHRtcDYsXG4gICAgICAgIHBlbmV0cmF0aW9uVmVjID0gdG1wNyxcbiAgICAgICAgZGlzdCA9IHRtcDgsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wOSxcbiAgICAgICAgbnVtQ29udGFjdHMgPSAwLFxuICAgICAgICBwcmVjaXNpb24gPSB0eXBlb2YocHJlY2lzaW9uKSA9PT0gJ251bWJlcicgPyBwcmVjaXNpb24gOiAwO1xuXG4gICAgdmFyIGZvdW5kID0gTmFycm93cGhhc2UuZmluZFNlcGFyYXRpbmdBeGlzKHNpLHhpLGFpLHNqLHhqLGFqLHNlcEF4aXMpO1xuICAgIGlmKCFmb3VuZCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgc2VwYXJhdGluZyBheGlzIGlzIGRpcmVjdGVkIGZyb20gc2hhcGUgaSB0byBzaGFwZSBqXG4gICAgc3ViKGRpc3QseGoseGkpO1xuICAgIGlmKGRvdChzZXBBeGlzLGRpc3QpID4gMCl7XG4gICAgICAgIHZlYzIuc2NhbGUoc2VwQXhpcyxzZXBBeGlzLC0xKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGVkZ2VzIHdpdGggbm9ybWFscyBjbG9zZXN0IHRvIHRoZSBzZXBhcmF0aW5nIGF4aXNcbiAgICB2YXIgY2xvc2VzdEVkZ2UxID0gTmFycm93cGhhc2UuZ2V0Q2xvc2VzdEVkZ2Uoc2ksYWksc2VwQXhpcyx0cnVlKSwgLy8gRmxpcHBlZCBheGlzXG4gICAgICAgIGNsb3Nlc3RFZGdlMiA9IE5hcnJvd3BoYXNlLmdldENsb3Nlc3RFZGdlKHNqLGFqLHNlcEF4aXMpO1xuXG4gICAgaWYoY2xvc2VzdEVkZ2UxID09PSAtMSB8fCBjbG9zZXN0RWRnZTIgPT09IC0xKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gTG9vcCBvdmVyIHRoZSBzaGFwZXNcbiAgICBmb3IodmFyIGs9MDsgazwyOyBrKyspe1xuXG4gICAgICAgIHZhciBjbG9zZXN0RWRnZUEgPSBjbG9zZXN0RWRnZTEsXG4gICAgICAgICAgICBjbG9zZXN0RWRnZUIgPSBjbG9zZXN0RWRnZTIsXG4gICAgICAgICAgICBzaGFwZUEgPSAgc2ksIHNoYXBlQiA9ICBzaixcbiAgICAgICAgICAgIG9mZnNldEEgPSB4aSwgb2Zmc2V0QiA9IHhqLFxuICAgICAgICAgICAgYW5nbGVBID0gYWksIGFuZ2xlQiA9IGFqLFxuICAgICAgICAgICAgYm9keUEgPSBiaSwgYm9keUIgPSBiajtcblxuICAgICAgICBpZihrID09PSAwKXtcbiAgICAgICAgICAgIC8vIFN3YXAhXG4gICAgICAgICAgICB2YXIgdG1wO1xuICAgICAgICAgICAgdG1wID0gY2xvc2VzdEVkZ2VBO1xuICAgICAgICAgICAgY2xvc2VzdEVkZ2VBID0gY2xvc2VzdEVkZ2VCO1xuICAgICAgICAgICAgY2xvc2VzdEVkZ2VCID0gdG1wO1xuXG4gICAgICAgICAgICB0bXAgPSBzaGFwZUE7XG4gICAgICAgICAgICBzaGFwZUEgPSBzaGFwZUI7XG4gICAgICAgICAgICBzaGFwZUIgPSB0bXA7XG5cbiAgICAgICAgICAgIHRtcCA9IG9mZnNldEE7XG4gICAgICAgICAgICBvZmZzZXRBID0gb2Zmc2V0QjtcbiAgICAgICAgICAgIG9mZnNldEIgPSB0bXA7XG5cbiAgICAgICAgICAgIHRtcCA9IGFuZ2xlQTtcbiAgICAgICAgICAgIGFuZ2xlQSA9IGFuZ2xlQjtcbiAgICAgICAgICAgIGFuZ2xlQiA9IHRtcDtcblxuICAgICAgICAgICAgdG1wID0gYm9keUE7XG4gICAgICAgICAgICBib2R5QSA9IGJvZHlCO1xuICAgICAgICAgICAgYm9keUIgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIG92ZXIgMiBwb2ludHMgaW4gY29udmV4IEJcbiAgICAgICAgZm9yKHZhciBqPWNsb3Nlc3RFZGdlQjsgajxjbG9zZXN0RWRnZUIrMjsgaisrKXtcblxuICAgICAgICAgICAgLy8gR2V0IHdvcmxkIHBvaW50XG4gICAgICAgICAgICB2YXIgdiA9IHNoYXBlQi52ZXJ0aWNlc1soaitzaGFwZUIudmVydGljZXMubGVuZ3RoKSVzaGFwZUIudmVydGljZXMubGVuZ3RoXTtcbiAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQsIHYsIGFuZ2xlQik7XG4gICAgICAgICAgICBhZGQod29ybGRQb2ludCwgd29ybGRQb2ludCwgb2Zmc2V0Qik7XG5cbiAgICAgICAgICAgIHZhciBpbnNpZGVOdW1FZGdlcyA9IDA7XG5cbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciB0aGUgMyBjbG9zZXN0IGVkZ2VzIGluIGNvbnZleCBBXG4gICAgICAgICAgICBmb3IodmFyIGk9Y2xvc2VzdEVkZ2VBLTE7IGk8Y2xvc2VzdEVkZ2VBKzI7IGkrKyl7XG5cbiAgICAgICAgICAgICAgICB2YXIgdjAgPSBzaGFwZUEudmVydGljZXNbKGkgICtzaGFwZUEudmVydGljZXMubGVuZ3RoKSVzaGFwZUEudmVydGljZXMubGVuZ3RoXSxcbiAgICAgICAgICAgICAgICAgICAgdjEgPSBzaGFwZUEudmVydGljZXNbKGkrMStzaGFwZUEudmVydGljZXMubGVuZ3RoKSVzaGFwZUEudmVydGljZXMubGVuZ3RoXTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgZWRnZVxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQwLCB2MCwgYW5nbGVBKTtcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MSwgdjEsIGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQwLCB3b3JsZFBvaW50MCwgb2Zmc2V0QSk7XG4gICAgICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MSwgb2Zmc2V0QSk7XG5cbiAgICAgICAgICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkTm9ybWFsLCB3b3JsZEVkZ2UpOyAvLyBOb3JtYWwgcG9pbnRzIG91dCBvZiBjb252ZXggMVxuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKHdvcmxkTm9ybWFsLHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFBvaW50LCB3b3JsZFBvaW50MCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRvdCh3b3JsZE5vcm1hbCxkaXN0KTtcblxuICAgICAgICAgICAgICAgIGlmKChpID09PSBjbG9zZXN0RWRnZUEgJiYgZCA8PSBwcmVjaXNpb24pIHx8IChpICE9PSBjbG9zZXN0RWRnZUEgJiYgZCA8PSAwKSl7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZU51bUVkZ2VzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpbnNpZGVOdW1FZGdlcyA+PSAzKXtcblxuICAgICAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gd29ybGRQb2ludCB3YXMgb24gdGhlIFwiaW5zaWRlXCIgc2lkZSBvZiBlYWNoIG9mIHRoZSAzIGNoZWNrZWQgZWRnZXMuXG4gICAgICAgICAgICAgICAgLy8gUHJvamVjdCBpdCB0byB0aGUgY2VudGVyIGVkZ2UgYW5kIHVzZSB0aGUgcHJvamVjdGlvbiBkaXJlY3Rpb24gYXMgbm9ybWFsXG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgY29udGFjdFxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIsc2hhcGVBLHNoYXBlQik7XG4gICAgICAgICAgICAgICAgbnVtQ29udGFjdHMrKztcblxuICAgICAgICAgICAgICAgIC8vIEdldCBjZW50ZXIgZWRnZSBmcm9tIGJvZHkgQVxuICAgICAgICAgICAgICAgIHZhciB2MCA9IHNoYXBlQS52ZXJ0aWNlc1soY2xvc2VzdEVkZ2VBKSAgICUgc2hhcGVBLnZlcnRpY2VzLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgICAgIHYxID0gc2hhcGVBLnZlcnRpY2VzWyhjbG9zZXN0RWRnZUErMSkgJSBzaGFwZUEudmVydGljZXMubGVuZ3RoXTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgZWRnZVxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQwLCB2MCwgYW5nbGVBKTtcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MSwgdjEsIGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQwLCB3b3JsZFBvaW50MCwgb2Zmc2V0QSk7XG4gICAgICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MSwgb2Zmc2V0QSk7XG5cbiAgICAgICAgICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGU5MGN3KGMubm9ybWFsQSwgd29ybGRFZGdlKTsgLy8gTm9ybWFsIHBvaW50cyBvdXQgb2YgY29udmV4IEFcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFBvaW50LCB3b3JsZFBvaW50MCk7IC8vIEZyb20gZWRnZSBwb2ludCB0byB0aGUgcGVuZXRyYXRpbmcgcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRvdChjLm5vcm1hbEEsZGlzdCk7ICAgICAgICAgICAgIC8vIFBlbmV0cmF0aW9uXG4gICAgICAgICAgICAgICAgdmVjMi5zY2FsZShwZW5ldHJhdGlvblZlYywgYy5ub3JtYWxBLCBkKTsgICAgIC8vIFZlY3RvciBwZW5ldHJhdGlvblxuXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgd29ybGRQb2ludCwgb2Zmc2V0QSk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwZW5ldHJhdGlvblZlYyk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBvZmZzZXRBKTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGJvZHlBLnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHdvcmxkUG9pbnQsIG9mZnNldEIpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50Qiwgb2Zmc2V0Qik7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBib2R5Qi5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgICAgIC8vIFRvZG8gcmVkdWNlIHRvIDEgZnJpY3Rpb24gZXF1YXRpb24gaWYgd2UgaGF2ZSAyIGNvbnRhY3QgcG9pbnRzXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24gJiYgbnVtQ29udGFjdHMpe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTtcblxuLy8gLnByb2plY3RDb252ZXggaXMgY2FsbGVkIGJ5IG90aGVyIGZ1bmN0aW9ucywgbmVlZCBsb2NhbCB0bXAgdmVjdG9yc1xudmFyIHBjb2FfdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIFByb2plY3QgYSBDb252ZXggb250byBhIHdvcmxkLW9yaWVudGVkIGF4aXNcbiAqIEBtZXRob2QgcHJvamVjdENvbnZleE9udG9BeGlzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRBeGlzXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XG4gKi9cbk5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyA9IGZ1bmN0aW9uKGNvbnZleFNoYXBlLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlLCB3b3JsZEF4aXMsIHJlc3VsdCl7XG4gICAgdmFyIG1heD1udWxsLFxuICAgICAgICBtaW49bnVsbCxcbiAgICAgICAgdixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGxvY2FsQXhpcyA9IHBjb2FfdG1wMTtcblxuICAgIC8vIENvbnZlcnQgdGhlIGF4aXMgdG8gbG9jYWwgY29vcmRzIG9mIHRoZSBib2R5XG4gICAgdmVjMi5yb3RhdGUobG9jYWxBeGlzLCB3b3JsZEF4aXMsIC1jb252ZXhBbmdsZSk7XG5cbiAgICAvLyBHZXQgcHJvamVjdGVkIHBvc2l0aW9uIG9mIGFsbCB2ZXJ0aWNlc1xuICAgIGZvcih2YXIgaT0wOyBpPGNvbnZleFNoYXBlLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdiA9IGNvbnZleFNoYXBlLnZlcnRpY2VzW2ldO1xuICAgICAgICB2YWx1ZSA9IGRvdCh2LGxvY2FsQXhpcyk7XG4gICAgICAgIGlmKG1heCA9PT0gbnVsbCB8fCB2YWx1ZSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZihtaW4gPT09IG51bGwgfHwgdmFsdWUgPCBtaW4pe1xuICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihtaW4gPiBtYXgpe1xuICAgICAgICB2YXIgdCA9IG1pbjtcbiAgICAgICAgbWluID0gbWF4O1xuICAgICAgICBtYXggPSB0O1xuICAgIH1cblxuICAgIC8vIFByb2plY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5IG9udG8gdGhlIGF4aXMgLSBuZWVkIHRvIGFkZCB0aGlzIHRvIHRoZSByZXN1bHRcbiAgICB2YXIgb2Zmc2V0ID0gZG90KGNvbnZleE9mZnNldCwgd29ybGRBeGlzKTtcblxuICAgIHZlYzIuc2V0KCByZXN1bHQsIG1pbiArIG9mZnNldCwgbWF4ICsgb2Zmc2V0KTtcbn07XG5cbi8vIC5maW5kU2VwYXJhdGluZ0F4aXMgaXMgY2FsbGVkIGJ5IG90aGVyIGZ1bmN0aW9ucywgbmVlZCBsb2NhbCB0bXAgdmVjdG9yc1xudmFyIGZzYV90bXAxID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXA0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wNSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDYgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBGaW5kIGEgc2VwYXJhdGluZyBheGlzIGJldHdlZW4gdGhlIHNoYXBlcywgdGhhdCBtYXhpbWl6ZXMgdGhlIHNlcGFyYXRpbmcgZGlzdGFuY2UgYmV0d2VlbiB0aGVtLlxuICogQG1ldGhvZCBmaW5kU2VwYXJhdGluZ0F4aXNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0NvbnZleH0gICAgIGMxXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBvZmZzZXQxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZTFcbiAqIEBwYXJhbSAge0NvbnZleH0gICAgIGMyXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBvZmZzZXQyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZTJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHNlcEF4aXMgICAgIFRoZSByZXN1bHRpbmcgYXhpc1xuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgV2hldGhlciB0aGUgYXhpcyBjb3VsZCBiZSBmb3VuZC5cbiAqL1xuTmFycm93cGhhc2UuZmluZFNlcGFyYXRpbmdBeGlzID0gZnVuY3Rpb24oYzEsb2Zmc2V0MSxhbmdsZTEsYzIsb2Zmc2V0MixhbmdsZTIsc2VwQXhpcyl7XG4gICAgdmFyIG1heERpc3QgPSBudWxsLFxuICAgICAgICBvdmVybGFwID0gZmFsc2UsXG4gICAgICAgIGZvdW5kID0gZmFsc2UsXG4gICAgICAgIGVkZ2UgPSBmc2FfdG1wMSxcbiAgICAgICAgd29ybGRQb2ludDAgPSBmc2FfdG1wMixcbiAgICAgICAgd29ybGRQb2ludDEgPSBmc2FfdG1wMyxcbiAgICAgICAgbm9ybWFsID0gZnNhX3RtcDQsXG4gICAgICAgIHNwYW4xID0gZnNhX3RtcDUsXG4gICAgICAgIHNwYW4yID0gZnNhX3RtcDY7XG5cbiAgICBpZihjMSBpbnN0YW5jZW9mIFJlY3RhbmdsZSAmJiBjMiBpbnN0YW5jZW9mIFJlY3RhbmdsZSl7XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT0yOyBqKyspe1xuICAgICAgICAgICAgdmFyIGMgPSBjMSxcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMTtcbiAgICAgICAgICAgIGlmKGo9PT0xKXtcbiAgICAgICAgICAgICAgICBjID0gYzI7XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpIT09MjsgaSsrKXtcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgd29ybGQgZWRnZVxuICAgICAgICAgICAgICAgIGlmKGkgPT09IDApe1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLnNldChub3JtYWwsIDAsIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIuc2V0KG5vcm1hbCwgMSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUobm9ybWFsLCBub3JtYWwsIGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9qZWN0IGh1bGxzIG9udG8gdGhhdCBub3JtYWxcbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzEsb2Zmc2V0MSxhbmdsZTEsbm9ybWFsLHNwYW4xKTtcbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzIsb2Zmc2V0MixhbmdsZTIsbm9ybWFsLHNwYW4yKTtcblxuICAgICAgICAgICAgICAgIC8vIE9yZGVyIGJ5IHNwYW4gcG9zaXRpb25cbiAgICAgICAgICAgICAgICB2YXIgYT1zcGFuMSxcbiAgICAgICAgICAgICAgICAgICAgYj1zcGFuMixcbiAgICAgICAgICAgICAgICAgICAgc3dhcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmKHNwYW4xWzBdID4gc3BhbjJbMF0pe1xuICAgICAgICAgICAgICAgICAgICBiPXNwYW4xO1xuICAgICAgICAgICAgICAgICAgICBhPXNwYW4yO1xuICAgICAgICAgICAgICAgICAgICBzd2FwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgc2VwYXJhdGluZyBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gYlswXSAtIGFbMV07XG4gICAgICAgICAgICAgICAgb3ZlcmxhcCA9IChkaXN0IDw9IDApO1xuXG4gICAgICAgICAgICAgICAgaWYobWF4RGlzdD09PW51bGwgfHwgZGlzdCA+IG1heERpc3Qpe1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoc2VwQXhpcywgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4RGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT0yOyBqKyspe1xuICAgICAgICAgICAgdmFyIGMgPSBjMSxcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMTtcbiAgICAgICAgICAgIGlmKGo9PT0xKXtcbiAgICAgICAgICAgICAgICBjID0gYzI7XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpIT09Yy52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB3b3JsZCBlZGdlXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDAsIGMudmVydGljZXNbaV0sIGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MSwgYy52ZXJ0aWNlc1soaSsxKSVjLnZlcnRpY2VzLmxlbmd0aF0sIGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIHN1YihlZGdlLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IG5vcm1hbCAtIGp1c3Qgcm90YXRlIDkwIGRlZ3JlZXMgc2luY2UgdmVydGljZXMgYXJlIGdpdmVuIGluIENDV1xuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlOTBjdyhub3JtYWwsIGVkZ2UpO1xuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJvamVjdCBodWxscyBvbnRvIHRoYXQgbm9ybWFsXG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMxLG9mZnNldDEsYW5nbGUxLG5vcm1hbCxzcGFuMSk7XG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMyLG9mZnNldDIsYW5nbGUyLG5vcm1hbCxzcGFuMik7XG5cbiAgICAgICAgICAgICAgICAvLyBPcmRlciBieSBzcGFuIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGE9c3BhbjEsXG4gICAgICAgICAgICAgICAgICAgIGI9c3BhbjIsXG4gICAgICAgICAgICAgICAgICAgIHN3YXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZihzcGFuMVswXSA+IHNwYW4yWzBdKXtcbiAgICAgICAgICAgICAgICAgICAgYj1zcGFuMTtcbiAgICAgICAgICAgICAgICAgICAgYT1zcGFuMjtcbiAgICAgICAgICAgICAgICAgICAgc3dhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHNlcGFyYXRpbmcgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGJbMF0gLSBhWzFdO1xuICAgICAgICAgICAgICAgIG92ZXJsYXAgPSAoZGlzdCA8PSAwKTtcblxuICAgICAgICAgICAgICAgIGlmKG1heERpc3Q9PT1udWxsIHx8IGRpc3QgPiBtYXhEaXN0KXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5jb3B5KHNlcEF4aXMsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIG1heERpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKlxuICAgIC8vIE5lZWRzIHRvIGJlIHRlc3RlZCBzb21lIG1vcmVcbiAgICBmb3IodmFyIGo9MDsgaiE9PTI7IGorKyl7XG4gICAgICAgIHZhciBjID0gYzEsXG4gICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMTtcbiAgICAgICAgaWYoaj09PTEpe1xuICAgICAgICAgICAgYyA9IGMyO1xuICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTI7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWMuYXhlcy5sZW5ndGg7IGkrKyl7XG5cbiAgICAgICAgICAgIHZhciBub3JtYWwgPSBjLmF4ZXNbaV07XG5cbiAgICAgICAgICAgIC8vIFByb2plY3QgaHVsbHMgb250byB0aGF0IG5vcm1hbFxuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMxLCBvZmZzZXQxLCBhbmdsZTEsIG5vcm1hbCwgc3BhbjEpO1xuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMyLCBvZmZzZXQyLCBhbmdsZTIsIG5vcm1hbCwgc3BhbjIpO1xuXG4gICAgICAgICAgICAvLyBPcmRlciBieSBzcGFuIHBvc2l0aW9uXG4gICAgICAgICAgICB2YXIgYT1zcGFuMSxcbiAgICAgICAgICAgICAgICBiPXNwYW4yLFxuICAgICAgICAgICAgICAgIHN3YXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKHNwYW4xWzBdID4gc3BhbjJbMF0pe1xuICAgICAgICAgICAgICAgIGI9c3BhbjE7XG4gICAgICAgICAgICAgICAgYT1zcGFuMjtcbiAgICAgICAgICAgICAgICBzd2FwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IHNlcGFyYXRpbmcgZGlzdGFuY2VcbiAgICAgICAgICAgIHZhciBkaXN0ID0gYlswXSAtIGFbMV07XG4gICAgICAgICAgICBvdmVybGFwID0gKGRpc3QgPD0gTmFycm93cGhhc2UuY29udmV4UHJlY2lzaW9uKTtcblxuICAgICAgICAgICAgaWYobWF4RGlzdD09PW51bGwgfHwgZGlzdCA+IG1heERpc3Qpe1xuICAgICAgICAgICAgICAgIHZlYzIuY29weShzZXBBeGlzLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgIG1heERpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgIGZvdW5kID0gb3ZlcmxhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAqL1xuXG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLy8gLmdldENsb3Nlc3RFZGdlIGlzIGNhbGxlZCBieSBvdGhlciBmdW5jdGlvbnMsIG5lZWQgbG9jYWwgdG1wIHZlY3RvcnNcbnZhciBnY2VfdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZ2NlX3RtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGdjZV90bXAzID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogR2V0IHRoZSBlZGdlIHRoYXQgaGFzIGEgbm9ybWFsIGNsb3Nlc3QgdG8gYW4gYXhpcy5cbiAqIEBtZXRob2QgZ2V0Q2xvc2VzdEVkZ2VcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0NvbnZleH0gICAgIGNcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBheGlzXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICBmbGlwXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgIEluZGV4IG9mIHRoZSBlZGdlIHRoYXQgaXMgY2xvc2VzdC4gVGhpcyBpbmRleCBhbmQgdGhlIG5leHQgc3BhbnMgdGhlIHJlc3VsdGluZyBlZGdlLiBSZXR1cm5zIC0xIGlmIGZhaWxlZC5cbiAqL1xuTmFycm93cGhhc2UuZ2V0Q2xvc2VzdEVkZ2UgPSBmdW5jdGlvbihjLGFuZ2xlLGF4aXMsZmxpcCl7XG4gICAgdmFyIGxvY2FsQXhpcyA9IGdjZV90bXAxLFxuICAgICAgICBlZGdlID0gZ2NlX3RtcDIsXG4gICAgICAgIG5vcm1hbCA9IGdjZV90bXAzO1xuXG4gICAgLy8gQ29udmVydCB0aGUgYXhpcyB0byBsb2NhbCBjb29yZHMgb2YgdGhlIGJvZHlcbiAgICB2ZWMyLnJvdGF0ZShsb2NhbEF4aXMsIGF4aXMsIC1hbmdsZSk7XG4gICAgaWYoZmxpcCl7XG4gICAgICAgIHZlYzIuc2NhbGUobG9jYWxBeGlzLGxvY2FsQXhpcywtMSk7XG4gICAgfVxuXG4gICAgdmFyIGNsb3Nlc3RFZGdlID0gLTEsXG4gICAgICAgIE4gPSBjLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgbWF4RG90ID0gLTE7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICAvLyBHZXQgdGhlIGVkZ2VcbiAgICAgICAgc3ViKGVkZ2UsIGMudmVydGljZXNbKGkrMSklTl0sIGMudmVydGljZXNbaSVOXSk7XG5cbiAgICAgICAgLy8gR2V0IG5vcm1hbCAtIGp1c3Qgcm90YXRlIDkwIGRlZ3JlZXMgc2luY2UgdmVydGljZXMgYXJlIGdpdmVuIGluIENDV1xuICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cobm9ybWFsLCBlZGdlKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7XG5cbiAgICAgICAgdmFyIGQgPSBkb3Qobm9ybWFsLGxvY2FsQXhpcyk7XG4gICAgICAgIGlmKGNsb3Nlc3RFZGdlID09PSAtMSB8fCBkID4gbWF4RG90KXtcbiAgICAgICAgICAgIGNsb3Nlc3RFZGdlID0gaSAlIE47XG4gICAgICAgICAgICBtYXhEb3QgPSBkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb3Nlc3RFZGdlO1xufTtcblxudmFyIGNpcmNsZUhlaWdodGZpZWxkX2NhbmRpZGF0ZSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfZGlzdCA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfdjAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX3YxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGUgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX3dvcmxkTm9ybWFsID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGVOb3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgY2lyY2xlSGVpZ2h0ZmllbGRcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgICAgICBiaVxuICogQHBhcmFtICB7Q2lyY2xlfSAgICAgICAgIHNpXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgeGlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgICAgICBialxuICogQHBhcmFtICB7SGVpZ2h0ZmllbGR9ICAgIHNqXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgeGpcbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuSEVJR0hURklFTERdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uKCBjaXJjbGVCb2R5LGNpcmNsZVNoYXBlLGNpcmNsZVBvcyxjaXJjbGVBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZkJvZHksaGZTaGFwZSxoZlBvcyxoZkFuZ2xlLCBqdXN0VGVzdCwgcmFkaXVzICl7XG4gICAgdmFyIGRhdGEgPSBoZlNoYXBlLmRhdGEsXG4gICAgICAgIHJhZGl1cyA9IHJhZGl1cyB8fCBjaXJjbGVTaGFwZS5yYWRpdXMsXG4gICAgICAgIHcgPSBoZlNoYXBlLmVsZW1lbnRXaWR0aCxcbiAgICAgICAgZGlzdCA9IGNpcmNsZUhlaWdodGZpZWxkX2Rpc3QsXG4gICAgICAgIGNhbmRpZGF0ZSA9IGNpcmNsZUhlaWdodGZpZWxkX2NhbmRpZGF0ZSxcbiAgICAgICAgbWluQ2FuZGlkYXRlID0gY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlLFxuICAgICAgICBtaW5DYW5kaWRhdGVOb3JtYWwgPSBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGVOb3JtYWwsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gY2lyY2xlSGVpZ2h0ZmllbGRfd29ybGROb3JtYWwsXG4gICAgICAgIHYwID0gY2lyY2xlSGVpZ2h0ZmllbGRfdjAsXG4gICAgICAgIHYxID0gY2lyY2xlSGVpZ2h0ZmllbGRfdjE7XG5cbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIGlkeEEgPSBNYXRoLmZsb29yKCAoY2lyY2xlUG9zWzBdIC0gcmFkaXVzIC0gaGZQb3NbMF0pIC8gdyApLFxuICAgICAgICBpZHhCID0gTWF0aC5jZWlsKCAgKGNpcmNsZVBvc1swXSArIHJhZGl1cyAtIGhmUG9zWzBdKSAvIHcgKTtcblxuICAgIC8qaWYoaWR4QiA8IDAgfHwgaWR4QSA+PSBkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGp1c3RUZXN0ID8gZmFsc2UgOiAwOyovXG5cbiAgICBpZihpZHhBIDwgMCl7XG4gICAgICAgIGlkeEEgPSAwO1xuICAgIH1cbiAgICBpZihpZHhCID49IGRhdGEubGVuZ3RoKXtcbiAgICAgICAgaWR4QiA9IGRhdGEubGVuZ3RoLTE7XG4gICAgfVxuXG4gICAgLy8gR2V0IG1heCBhbmQgbWluXG4gICAgdmFyIG1heCA9IGRhdGFbaWR4QV0sXG4gICAgICAgIG1pbiA9IGRhdGFbaWR4Ql07XG4gICAgZm9yKHZhciBpPWlkeEE7IGk8aWR4QjsgaSsrKXtcbiAgICAgICAgaWYoZGF0YVtpXSA8IG1pbil7XG4gICAgICAgICAgICBtaW4gPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmKGRhdGFbaV0gPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGNpcmNsZVBvc1sxXS1yYWRpdXMgPiBtYXgpe1xuICAgICAgICByZXR1cm4ganVzdFRlc3QgPyBmYWxzZSA6IDA7XG4gICAgfVxuXG4gICAgLypcbiAgICBpZihjaXJjbGVQb3NbMV0rcmFkaXVzIDwgbWluKXtcbiAgICAgICAgLy8gQmVsb3cgdGhlIG1pbmltdW0gcG9pbnQuLi4gV2UgY2FuIGp1c3QgZ3Vlc3MuXG4gICAgICAgIC8vIFRPRE9cbiAgICB9XG4gICAgKi9cblxuICAgIC8vIDEuIENoZWNrIHNvIGNlbnRlciBvZiBjaXJjbGUgaXMgbm90IGluc2lkZSB0aGUgZmllbGQuIElmIGl0IGlzLCB0aGlzIHdvbnQgd29yay4uLlxuICAgIC8vIDIuIEZvciBlYWNoIGVkZ2VcbiAgICAvLyAyLiAxLiBHZXQgcG9pbnQgb24gY2lyY2xlIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgZWRnZSAoc2NhbGUgbm9ybWFsIHdpdGggLXJhZGl1cylcbiAgICAvLyAyLiAyLiBDaGVjayBpZiBwb2ludCBpcyBpbnNpZGUuXG5cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGFsbCBlZGdlcyBmaXJzdFxuICAgIGZvcih2YXIgaT1pZHhBOyBpPGlkeEI7IGkrKyl7XG5cbiAgICAgICAgLy8gR2V0IHBvaW50c1xuICAgICAgICB2ZWMyLnNldCh2MCwgICAgIGkqdywgZGF0YVtpXSAgKTtcbiAgICAgICAgdmVjMi5zZXQodjEsIChpKzEpKncsIGRhdGFbaSsxXSk7XG4gICAgICAgIHZlYzIuYWRkKHYwLHYwLGhmUG9zKTtcbiAgICAgICAgdmVjMi5hZGQodjEsdjEsaGZQb3MpO1xuXG4gICAgICAgIC8vIEdldCBub3JtYWxcbiAgICAgICAgdmVjMi5zdWIod29ybGROb3JtYWwsIHYxLCB2MCk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCwgTWF0aC5QSS8yKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUod29ybGROb3JtYWwsd29ybGROb3JtYWwpO1xuXG4gICAgICAgIC8vIEdldCBwb2ludCBvbiBjaXJjbGUsIGNsb3Nlc3QgdG8gdGhlIGVkZ2VcbiAgICAgICAgdmVjMi5zY2FsZShjYW5kaWRhdGUsd29ybGROb3JtYWwsLXJhZGl1cyk7XG4gICAgICAgIHZlYzIuYWRkKGNhbmRpZGF0ZSxjYW5kaWRhdGUsY2lyY2xlUG9zKTtcblxuICAgICAgICAvLyBEaXN0YW5jZSBmcm9tIHYwIHRvIHRoZSBjYW5kaWRhdGUgcG9pbnRcbiAgICAgICAgdmVjMi5zdWIoZGlzdCxjYW5kaWRhdGUsdjApO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGlzIGluIHRoZSBlbGVtZW50IFwic3RpY2tcIlxuICAgICAgICB2YXIgZCA9IHZlYzIuZG90KGRpc3Qsd29ybGROb3JtYWwpO1xuICAgICAgICBpZihjYW5kaWRhdGVbMF0gPj0gdjBbMF0gJiYgY2FuZGlkYXRlWzBdIDwgdjFbMF0gJiYgZCA8PSAwKXtcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjYW5kaWRhdGUgcG9pbnQsIHByb2plY3RlZCB0byB0aGUgZWRnZVxuICAgICAgICAgICAgdmVjMi5zY2FsZShkaXN0LHdvcmxkTm9ybWFsLC1kKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKG1pbkNhbmRpZGF0ZSxjYW5kaWRhdGUsZGlzdCk7XG4gICAgICAgICAgICB2ZWMyLmNvcHkobWluQ2FuZGlkYXRlTm9ybWFsLHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihoZkJvZHksY2lyY2xlQm9keSxoZlNoYXBlLGNpcmNsZVNoYXBlKTtcblxuICAgICAgICAgICAgLy8gTm9ybWFsIGlzIG91dCBvZiB0aGUgaGVpZ2h0ZmllbGRcbiAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIG1pbkNhbmRpZGF0ZU5vcm1hbCk7XG5cbiAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBoZWlnaHRmaWVsZFxuICAgICAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEIsICBjLm5vcm1hbEEsIC1yYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVQb3MpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdmVjMi5jb3B5KGMuY29udGFjdFBvaW50QSwgbWluQ2FuZGlkYXRlKTtcbiAgICAgICAgICAgIHZlYzIuc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBoZkJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKCB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGFsbCB2ZXJ0aWNlc1xuICAgIGZvdW5kID0gZmFsc2U7XG4gICAgaWYocmFkaXVzID4gMCl7XG4gICAgICAgIGZvcih2YXIgaT1pZHhBOyBpPD1pZHhCOyBpKyspe1xuXG4gICAgICAgICAgICAvLyBHZXQgcG9pbnRcbiAgICAgICAgICAgIHZlYzIuc2V0KHYwLCBpKncsIGRhdGFbaV0pO1xuICAgICAgICAgICAgdmVjMi5hZGQodjAsdjAsaGZQb3MpO1xuXG4gICAgICAgICAgICB2ZWMyLnN1YihkaXN0LCBjaXJjbGVQb3MsIHYwKTtcblxuICAgICAgICAgICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpIDwgTWF0aC5wb3cocmFkaXVzLCAyKSl7XG5cbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oaGZCb2R5LGNpcmNsZUJvZHksaGZTaGFwZSxjaXJjbGVTaGFwZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3Qgbm9ybWFsIC0gb3V0IG9mIGhlaWdodGZpZWxkXG4gICAgICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgZGlzdCk7XG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QiwgYy5ub3JtYWxBLCAtcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZVBvcyk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHYwLCBoZlBvcyk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBoZlBvcyk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBoZkJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZm91bmQpe1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcblxufTtcblxudmFyIGNvbnZleEhlaWdodGZpZWxkX3YwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb252ZXhIZWlnaHRmaWVsZF92MSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29udmV4SGVpZ2h0ZmllbGRfdGlsZVBvcyA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29udmV4SGVpZ2h0ZmllbGRfdGVtcENvbnZleFNoYXBlID0gbmV3IENvbnZleChbdmVjMi5jcmVhdGUoKSx2ZWMyLmNyZWF0ZSgpLHZlYzIuY3JlYXRlKCksdmVjMi5jcmVhdGUoKV0pO1xuLyoqXG4gKiBAbWV0aG9kIGNpcmNsZUhlaWdodGZpZWxkXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICAgICAgYmlcbiAqIEBwYXJhbSAge0NpcmNsZX0gICAgICAgICBzaVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIHhpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICAgICAgYmpcbiAqIEBwYXJhbSAge0hlaWdodGZpZWxkfSAgICBzalxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgYWpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlJFQ1RBTkdMRSB8IFNoYXBlLkhFSUdIVEZJRUxEXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ09OVkVYIHwgU2hhcGUuSEVJR0hURklFTERdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uKCBjb252ZXhCb2R5LGNvbnZleFNoYXBlLGNvbnZleFBvcyxjb252ZXhBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZkJvZHksaGZTaGFwZSxoZlBvcyxoZkFuZ2xlLCBqdXN0VGVzdCApe1xuICAgIHZhciBkYXRhID0gaGZTaGFwZS5kYXRhLFxuICAgICAgICB3ID0gaGZTaGFwZS5lbGVtZW50V2lkdGgsXG4gICAgICAgIHYwID0gY29udmV4SGVpZ2h0ZmllbGRfdjAsXG4gICAgICAgIHYxID0gY29udmV4SGVpZ2h0ZmllbGRfdjEsXG4gICAgICAgIHRpbGVQb3MgPSBjb252ZXhIZWlnaHRmaWVsZF90aWxlUG9zLFxuICAgICAgICB0aWxlQ29udmV4ID0gY29udmV4SGVpZ2h0ZmllbGRfdGVtcENvbnZleFNoYXBlO1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxuICAgIHZhciBpZHhBID0gTWF0aC5mbG9vciggKGNvbnZleEJvZHkuYWFiYi5sb3dlckJvdW5kWzBdIC0gaGZQb3NbMF0pIC8gdyApLFxuICAgICAgICBpZHhCID0gTWF0aC5jZWlsKCAgKGNvbnZleEJvZHkuYWFiYi51cHBlckJvdW5kWzBdIC0gaGZQb3NbMF0pIC8gdyApO1xuXG4gICAgaWYoaWR4QSA8IDApe1xuICAgICAgICBpZHhBID0gMDtcbiAgICB9XG4gICAgaWYoaWR4QiA+PSBkYXRhLmxlbmd0aCl7XG4gICAgICAgIGlkeEIgPSBkYXRhLmxlbmd0aC0xO1xuICAgIH1cblxuICAgIC8vIEdldCBtYXggYW5kIG1pblxuICAgIHZhciBtYXggPSBkYXRhW2lkeEFdLFxuICAgICAgICBtaW4gPSBkYXRhW2lkeEJdO1xuICAgIGZvcih2YXIgaT1pZHhBOyBpPGlkeEI7IGkrKyl7XG4gICAgICAgIGlmKGRhdGFbaV0gPCBtaW4pe1xuICAgICAgICAgICAgbWluID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZihkYXRhW2ldID4gbWF4KXtcbiAgICAgICAgICAgIG1heCA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihjb252ZXhCb2R5LmFhYmIubG93ZXJCb3VuZFsxXSA+IG1heCl7XG4gICAgICAgIHJldHVybiBqdXN0VGVzdCA/IGZhbHNlIDogMDtcbiAgICB9XG5cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICB2YXIgbnVtQ29udGFjdHMgPSAwO1xuXG4gICAgLy8gTG9vcCBvdmVyIGFsbCBlZGdlc1xuICAgIC8vIFRPRE86IElmIHBvc3NpYmxlLCBjb25zdHJ1Y3QgYSBjb252ZXggZnJvbSBzZXZlcmFsIGRhdGEgcG9pbnRzIChuZWVkIG8gY2hlY2sgaWYgdGhlIHBvaW50cyBtYWtlIGEgY29udmV4IHNoYXBlKVxuICAgIGZvcih2YXIgaT1pZHhBOyBpPGlkeEI7IGkrKyl7XG5cbiAgICAgICAgLy8gR2V0IHBvaW50c1xuICAgICAgICB2ZWMyLnNldCh2MCwgICAgIGkqdywgZGF0YVtpXSAgKTtcbiAgICAgICAgdmVjMi5zZXQodjEsIChpKzEpKncsIGRhdGFbaSsxXSk7XG4gICAgICAgIHZlYzIuYWRkKHYwLHYwLGhmUG9zKTtcbiAgICAgICAgdmVjMi5hZGQodjEsdjEsaGZQb3MpO1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBhIGNvbnZleFxuICAgICAgICB2YXIgdGlsZUhlaWdodCA9IDEwMDsgLy8gdG9kb1xuICAgICAgICB2ZWMyLnNldCh0aWxlUG9zLCAodjFbMF0gKyB2MFswXSkqMC41LCAodjFbMV0gKyB2MFsxXSAtIHRpbGVIZWlnaHQpKjAuNSk7XG5cbiAgICAgICAgdmVjMi5zdWIodGlsZUNvbnZleC52ZXJ0aWNlc1swXSwgdjEsIHRpbGVQb3MpO1xuICAgICAgICB2ZWMyLnN1Yih0aWxlQ29udmV4LnZlcnRpY2VzWzFdLCB2MCwgdGlsZVBvcyk7XG4gICAgICAgIHZlYzIuY29weSh0aWxlQ29udmV4LnZlcnRpY2VzWzJdLCB0aWxlQ29udmV4LnZlcnRpY2VzWzFdKTtcbiAgICAgICAgdmVjMi5jb3B5KHRpbGVDb252ZXgudmVydGljZXNbM10sIHRpbGVDb252ZXgudmVydGljZXNbMF0pO1xuICAgICAgICB0aWxlQ29udmV4LnZlcnRpY2VzWzJdWzFdIC09IHRpbGVIZWlnaHQ7XG4gICAgICAgIHRpbGVDb252ZXgudmVydGljZXNbM11bMV0gLT0gdGlsZUhlaWdodDtcblxuICAgICAgICAvLyBEbyBjb252ZXggY29sbGlzaW9uXG4gICAgICAgIG51bUNvbnRhY3RzICs9IHRoaXMuY29udmV4Q29udmV4KCAgIGNvbnZleEJvZHksIGNvbnZleFNoYXBlLCBjb252ZXhQb3MsIGNvbnZleEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZkJvZHksIHRpbGVDb252ZXgsIHRpbGVQb3MsIDAsIGp1c3RUZXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtQ29udGFjdHM7XG59O1xufSx7XCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MjIsXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMyxcIi4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uXCI6MjQsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL29iamVjdHMvQm9keVwiOjMyLFwiLi4vc2hhcGVzL0NpcmNsZVwiOjM4LFwiLi4vc2hhcGVzL0NvbnZleFwiOjM5LFwiLi4vc2hhcGVzL1JlY3RhbmdsZVwiOjQ0LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDUsXCIuLi91dGlscy9UdXBsZURpY3Rpb25hcnlcIjo0OSxcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFJheTtcblxudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBSYXljYXN0UmVzdWx0ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKTtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpO1xudmFyIEFBQkIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQUFCQicpO1xuXG4vKipcbiAqIEEgbGluZSB3aXRoIGEgc3RhcnQgYW5kIGVuZCBwb2ludCB0aGF0IGlzIHVzZWQgdG8gaW50ZXJzZWN0IHNoYXBlcy5cbiAqIEBjbGFzcyBSYXlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSYXkob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBmcm9tXG4gICAgICovXG4gICAgdGhpcy5mcm9tID0gb3B0aW9ucy5mcm9tID8gdmVjMi5mcm9tVmFsdWVzKG9wdGlvbnMuZnJvbVswXSwgb3B0aW9ucy5mcm9tWzFdKSA6IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSB0b1xuICAgICAqL1xuICAgIHRoaXMudG8gPSBvcHRpb25zLnRvID8gdmVjMi5mcm9tVmFsdWVzKG9wdGlvbnMudG9bMF0sIG9wdGlvbnMudG9bMV0pIDogdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gX2RpcmVjdGlvblxuICAgICAqL1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlY2lzaW9uIG9mIHRoZSByYXkuIFVzZWQgd2hlbiBjaGVja2luZyBwYXJhbGxlbGl0eSBldGMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHByZWNpc2lvblxuICAgICAqL1xuICAgIHRoaXMucHJlY2lzaW9uID0gMC4wMDAxO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdGhlIFJheSB0byB0YWtlIC5jb2xsaXNpb25SZXNwb25zZSBmbGFncyBpbnRvIGFjY291bnQgb24gYm9kaWVzIGFuZCBzaGFwZXMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjaGVja0NvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG4gICAgdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgcmF5IHNraXBzIGFueSBoaXRzIHdpdGggbm9ybWFsLmRvdChyYXlEaXJlY3Rpb24pIDwgMC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNraXBCYWNrZmFjZXNcbiAgICAgKi9cbiAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25NYXNrXG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvbk1hc2sgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25Hcm91cFxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVyc2VjdGlvbiBtb2RlLiBTaG91bGQgYmUgUmF5LkFOWSwgUmF5LkFMTCBvciBSYXkuQ0xPU0VTVC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW9kZVxuICAgICAqL1xuICAgIHRoaXMubW9kZSA9IFJheS5BTlk7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHJlc3VsdCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGR1cmluZyBpbnRlcnNlY3RXb3JsZCgpIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaGFzSGl0XG4gICAgICovXG4gICAgdGhpcy5oYXNIaXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQsIHVzZXItcHJvdmlkZWQgcmVzdWx0IGNhbGxiYWNrLiBXaWxsIGJlIHVzZWQgaWYgbW9kZSBpcyBSYXkuQUxMLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgdGhpcy5jYWxsYmFjayA9IGZ1bmN0aW9uKHJlc3VsdCl7fTtcbn1cblJheS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYXk7XG5cblJheS5DTE9TRVNUID0gMTtcblJheS5BTlkgPSAyO1xuUmF5LkFMTCA9IDQ7XG5cbnZhciB0bXBBQUJCID0gbmV3IEFBQkIoKTtcbnZhciB0bXBBcnJheSA9IFtdO1xuXG4vKipcbiAqIERvIGl0ZXJzZWN0aW9uIGFnYWluc3QgYWxsIGJvZGllcyBpbiB0aGUgZ2l2ZW4gV29ybGQuXG4gKiBAbWV0aG9kIGludGVyc2VjdFdvcmxkXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmF5IGhpdCBhbnl0aGluZywgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFdvcmxkID0gZnVuY3Rpb24gKHdvcmxkLCBvcHRpb25zKSB7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IFJheS5BTlk7XG4gICAgdGhpcy5yZXN1bHQgPSBvcHRpb25zLnJlc3VsdCB8fCBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuICAgIHRoaXMuc2tpcEJhY2tmYWNlcyA9ICEhb3B0aW9ucy5za2lwQmFja2ZhY2VzO1xuICAgIHRoaXMuY29sbGlzaW9uTWFzayA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbk1hc2spICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uTWFzayA6IC0xO1xuICAgIHRoaXMuY29sbGlzaW9uR3JvdXAgPSB0eXBlb2Yob3B0aW9ucy5jb2xsaXNpb25Hcm91cCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jb2xsaXNpb25Hcm91cCA6IC0xO1xuICAgIGlmKG9wdGlvbnMuZnJvbSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmZyb20sIG9wdGlvbnMuZnJvbSk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMudG8pe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy50bywgb3B0aW9ucy50byk7XG4gICAgfVxuICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCl7fTtcbiAgICB0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG4gICAgdGhpcy5yZXN1bHQucmVzZXQoKTtcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oKTtcblxuICAgIHRoaXMuZ2V0QUFCQih0bXBBQUJCKTtcbiAgICB0bXBBcnJheS5sZW5ndGggPSAwO1xuICAgIHdvcmxkLmJyb2FkcGhhc2UuYWFiYlF1ZXJ5KHdvcmxkLCB0bXBBQUJCLCB0bXBBcnJheSk7XG4gICAgdGhpcy5pbnRlcnNlY3RCb2RpZXModG1wQXJyYXkpO1xuXG4gICAgcmV0dXJuIHRoaXMuaGFzSGl0O1xufTtcblxudmFyIHYxID0gdmVjMi5jcmVhdGUoKSxcbiAgICB2MiA9IHZlYzIuY3JlYXRlKCk7XG5cbnZhciBpbnRlcnNlY3RCb2R5X3dvcmxkUG9zaXRpb24gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFNob290IGEgcmF5IGF0IGEgYm9keSwgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC5cbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9keVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtSYXljYXN0UmVzdWx0fSBbcmVzdWx0XSBEZXByZWNhdGVkIC0gc2V0IHRoZSByZXN1bHQgcHJvcGVydHkgb2YgdGhlIFJheSBpbnN0ZWFkLlxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZHkgPSBmdW5jdGlvbiAoYm9keSwgcmVzdWx0KSB7XG5cbiAgICBpZihyZXN1bHQpe1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgfVxuICAgIHZhciBjaGVja0NvbGxpc2lvblJlc3BvbnNlID0gdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlO1xuXG4gICAgaWYoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhYm9keS5jb2xsaXNpb25SZXNwb25zZSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZigodGhpcy5jb2xsaXNpb25Hcm91cCAmIGJvZHkuY29sbGlzaW9uTWFzayk9PT0wIHx8IChib2R5LmNvbGxpc2lvbkdyb3VwICYgdGhpcy5jb2xsaXNpb25NYXNrKT09PTApe1xuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gfVxuXG4gICAgdmFyIHdvcmxkUG9zaXRpb24gPSBpbnRlcnNlY3RCb2R5X3dvcmxkUG9zaXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMCwgTiA9IGJvZHkuc2hhcGVzLmxlbmd0aDsgaSA8IE47IGkrKykge1xuICAgICAgICB2YXIgc2hhcGUgPSBib2R5LnNoYXBlc1tpXTtcblxuICAgICAgICBpZihjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFzaGFwZS5jb2xsaXNpb25SZXNwb25zZSl7XG4gICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHdvcmxkIGFuZ2xlIGFuZCBwb3NpdGlvbiBvZiB0aGUgc2hhcGVcbiAgICAgICAgdmVjMi5jb3B5KHdvcmxkUG9zaXRpb24sIGJvZHkuc2hhcGVPZmZzZXRzW2ldKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb3NpdGlvbiwgd29ybGRQb3NpdGlvbiwgYm9keS5hbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKHdvcmxkUG9zaXRpb24sIHdvcmxkUG9zaXRpb24sIGJvZHkucG9zaXRpb24pO1xuICAgICAgICB2YXIgd29ybGRBbmdsZSA9IGJvZHkuc2hhcGVBbmdsZXNbaV0gKyBib2R5LmFuZ2xlO1xuXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0U2hhcGUoXG4gICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgIHdvcmxkQW5nbGUsXG4gICAgICAgICAgICB3b3JsZFBvc2l0aW9uLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICApO1xuXG4gICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdEJvZGllc1xuICogQHBhcmFtIHtBcnJheX0gYm9kaWVzIEFuIGFycmF5IG9mIEJvZHkgb2JqZWN0cy5cbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZFxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZGllcyA9IGZ1bmN0aW9uIChib2RpZXMsIHJlc3VsdCkge1xuICAgIGlmKHJlc3VsdCl7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oKTtcbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBib2RpZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuX3Nob3VsZFN0b3AgJiYgaSA8IGw7IGkgKysgKSB7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0Qm9keShib2RpZXNbaV0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgX2RpcmVjdGlvbiB2ZWN0b3IuXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBfdXBkYXRlRGlyZWN0aW9uXG4gKi9cblJheS5wcm90b3R5cGUuX3VwZGF0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGQgPSB0aGlzLl9kaXJlY3Rpb247XG4gICAgdmVjMi5zdWIoZCwgdGhpcy50bywgdGhpcy5mcm9tKTsgLy8gdGhpcy50by52c3ViKHRoaXMuZnJvbSwgdGhpcy5fZGlyZWN0aW9uKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShkLCBkKTsgLy8gdGhpcy5fZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFNoYXBlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIGFuZ2xlLCBwb3NpdGlvbiwgYm9keSl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG5cblxuICAgIC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlXG4gICAgdmFyIGRpc3RhbmNlID0gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKGZyb20sIHRoaXMuX2RpcmVjdGlvbiwgcG9zaXRpb24pO1xuICAgIGlmICggZGlzdGFuY2UgPiBzaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cyApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZXRob2QgPSB0aGlzW3NoYXBlLnR5cGVdO1xuICAgIGlmKG1ldGhvZCl7XG4gICAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIHNoYXBlLCBhbmdsZSwgcG9zaXRpb24sIGJvZHkpO1xuICAgIH1cbn07XG5cbnZhciB2ZWN0b3IgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIG5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UG9pbnQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG52YXIgYSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgYiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgYyA9IHZlYzIuY3JlYXRlKCk7XG52YXIgZCA9IHZlYzIuY3JlYXRlKCk7XG5cbnZhciB0bXBSYXljYXN0UmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTtcbnZhciBpbnRlcnNlY3RSZWN0YW5nbGVfZGlyZWN0aW9uID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RSZWN0YW5nbGVfcmF5U3RhcnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFJlY3RhbmdsZV93b3JsZE5vcm1hbE1pbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX3dvcmxkTm9ybWFsTWF4ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RSZWN0YW5nbGVfaGl0UG9pbnRXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX2JveE1pbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX2JveE1heCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RSZWN0YW5nbGVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcbiAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFJlY3RhbmdsZSA9IGZ1bmN0aW9uKHNoYXBlLCBhbmdsZSwgcG9zaXRpb24sIGJvZHkpe1xuICAgIHZhciB0bWluID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIHRtYXggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgdmFyIGRpcmVjdGlvbiA9IGludGVyc2VjdFJlY3RhbmdsZV9kaXJlY3Rpb247XG4gICAgdmFyIHJheVN0YXJ0ID0gaW50ZXJzZWN0UmVjdGFuZ2xlX3JheVN0YXJ0O1xuICAgIHZhciB3b3JsZE5vcm1hbE1pbiA9IGludGVyc2VjdFJlY3RhbmdsZV93b3JsZE5vcm1hbE1pbjtcbiAgICB2YXIgd29ybGROb3JtYWxNYXggPSBpbnRlcnNlY3RSZWN0YW5nbGVfd29ybGROb3JtYWxNYXg7XG4gICAgdmFyIGhpdFBvaW50V29ybGQgPSBpbnRlcnNlY3RSZWN0YW5nbGVfaGl0UG9pbnRXb3JsZDtcbiAgICB2YXIgYm94TWluID0gaW50ZXJzZWN0UmVjdGFuZ2xlX2JveE1pbjtcbiAgICB2YXIgYm94TWF4ID0gaW50ZXJzZWN0UmVjdGFuZ2xlX2JveE1heDtcblxuICAgIHZlYzIuc2V0KGJveE1pbiwgLXNoYXBlLndpZHRoICogMC41LCAtc2hhcGUuaGVpZ2h0ICogMC41KTtcbiAgICB2ZWMyLnNldChib3hNYXgsIHNoYXBlLndpZHRoICogMC41LCBzaGFwZS5oZWlnaHQgKiAwLjUpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZSByYXkgZGlyZWN0aW9uIGFuZCBzdGFydCB0byBsb2NhbCBzcGFjZVxuICAgIHZlYzIucm90YXRlKGRpcmVjdGlvbiwgdGhpcy5fZGlyZWN0aW9uLCAtYW5nbGUpO1xuICAgIGJvZHkudG9Mb2NhbEZyYW1lKHJheVN0YXJ0LCB0aGlzLmZyb20pO1xuXG4gICAgaWYgKGRpcmVjdGlvblswXSAhPT0gMCkge1xuICAgICAgICB2YXIgdHgxID0gKGJveE1pblswXSAtIHJheVN0YXJ0WzBdKSAvIGRpcmVjdGlvblswXTtcbiAgICAgICAgdmFyIHR4MiA9IChib3hNYXhbMF0gLSByYXlTdGFydFswXSkgLyBkaXJlY3Rpb25bMF07XG5cbiAgICAgICAgdmFyIHRtaW5PbGQgPSB0bWluO1xuICAgICAgICB0bWluID0gTWF0aC5tYXgodG1pbiwgTWF0aC5taW4odHgxLCB0eDIpKTtcbiAgICAgICAgaWYodG1pbiAhPT0gdG1pbk9sZCl7XG4gICAgICAgICAgICB2ZWMyLnNldCh3b3JsZE5vcm1hbE1pbiwgdHgxID4gdHgyID8gMSA6IC0xLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bWF4T2xkID0gdG1heDtcbiAgICAgICAgdG1heCA9IE1hdGgubWluKHRtYXgsIE1hdGgubWF4KHR4MSwgdHgyKSk7XG4gICAgICAgIGlmKHRtYXggIT09IHRtYXhPbGQpe1xuICAgICAgICAgICAgdmVjMi5zZXQod29ybGROb3JtYWxNYXgsIHR4MSA8IHR4MiA/IDEgOiAtMSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uWzFdICE9PSAwKSB7XG4gICAgICAgIHZhciB0eTEgPSAoYm94TWluWzFdIC0gcmF5U3RhcnRbMV0pIC8gZGlyZWN0aW9uWzFdO1xuICAgICAgICB2YXIgdHkyID0gKGJveE1heFsxXSAtIHJheVN0YXJ0WzFdKSAvIGRpcmVjdGlvblsxXTtcblxuICAgICAgICB2YXIgdG1pbk9sZCA9IHRtaW47XG4gICAgICAgIHRtaW4gPSBNYXRoLm1heCh0bWluLCBNYXRoLm1pbih0eTEsIHR5MikpO1xuICAgICAgICBpZih0bWluICE9PSB0bWluT2xkKXtcbiAgICAgICAgICAgIHZlYzIuc2V0KHdvcmxkTm9ybWFsTWluLCAwLCB0eTEgPiB0eTIgPyAxIDogLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtYXhPbGQgPSB0bWF4O1xuICAgICAgICB0bWF4ID0gTWF0aC5taW4odG1heCwgTWF0aC5tYXgodHkxLCB0eTIpKTtcbiAgICAgICAgaWYodG1heCAhPT0gdG1heE9sZCl7XG4gICAgICAgICAgICB2ZWMyLnNldCh3b3JsZE5vcm1hbE1heCwgMCwgdHkxIDwgdHkyID8gMSA6IC0xKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRtYXggPj0gdG1pbil7XG4gICAgICAgIC8vIEhpdCBwb2ludFxuICAgICAgICB2ZWMyLnNldChcbiAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICByYXlTdGFydFswXSArIGRpcmVjdGlvblswXSAqIHRtaW4sXG4gICAgICAgICAgICByYXlTdGFydFsxXSArIGRpcmVjdGlvblsxXSAqIHRtaW5cbiAgICAgICAgKTtcblxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbE1pbiwgd29ybGROb3JtYWxNaW4sIGFuZ2xlKTtcblxuICAgICAgICBib2R5LnRvV29ybGRGcmFtZShoaXRQb2ludFdvcmxkLCBoaXRQb2ludFdvcmxkKTtcblxuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbih3b3JsZE5vcm1hbE1pbiwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIC0xKTtcbiAgICAgICAgaWYodGhpcy5fc2hvdWxkU3RvcCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbE1heCwgd29ybGROb3JtYWxNYXgsIGFuZ2xlKTtcblxuICAgICAgICAvLyBIaXQgcG9pbnRcbiAgICAgICAgdmVjMi5zZXQoXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgcmF5U3RhcnRbMF0gKyBkaXJlY3Rpb25bMF0gKiB0bWF4LFxuICAgICAgICAgICAgcmF5U3RhcnRbMV0gKyBkaXJlY3Rpb25bMV0gKiB0bWF4XG4gICAgICAgICk7XG4gICAgICAgIGJvZHkudG9Xb3JsZEZyYW1lKGhpdFBvaW50V29ybGQsIGhpdFBvaW50V29ybGQpO1xuXG4gICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsTWF4LCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgLTEpO1xuICAgIH1cbn07XG5SYXkucHJvdG90eXBlW1NoYXBlLlJFQ1RBTkdMRV0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdFJlY3RhbmdsZTtcblxudmFyIGludGVyc2VjdFBsYW5lX3BsYW5lUG9pbnRUb0Zyb20gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBsYW5lX2Rpcl9zY2FsZWRfd2l0aF90ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RQbGFuZV9oaXRQb2ludFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RQbGFuZV93b3JsZE5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UGxhbmVfbGVuID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFBsYW5lXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXG4gKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RQbGFuZSA9IGZ1bmN0aW9uKHNoYXBlLCBhbmdsZSwgcG9zaXRpb24sIGJvZHkpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHZhciB0byA9IHRoaXMudG87XG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbjtcblxuICAgIHZhciBwbGFuZVBvaW50VG9Gcm9tID0gaW50ZXJzZWN0UGxhbmVfcGxhbmVQb2ludFRvRnJvbTtcbiAgICB2YXIgZGlyX3NjYWxlZF93aXRoX3QgPSBpbnRlcnNlY3RQbGFuZV9kaXJfc2NhbGVkX3dpdGhfdDtcbiAgICB2YXIgaGl0UG9pbnRXb3JsZCA9IGludGVyc2VjdFBsYW5lX2hpdFBvaW50V29ybGQ7XG4gICAgdmFyIHdvcmxkTm9ybWFsID0gaW50ZXJzZWN0UGxhbmVfd29ybGROb3JtYWw7XG4gICAgdmFyIGxlbiA9IGludGVyc2VjdFBsYW5lX2xlbjtcblxuICAgIC8vIEdldCBwbGFuZSBub3JtYWxcbiAgICB2ZWMyLnNldCh3b3JsZE5vcm1hbCwgMCwgMSk7XG4gICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsLCBhbmdsZSk7XG5cbiAgICB2ZWMyLnN1YihsZW4sIGZyb20sIHBvc2l0aW9uKTsgLy9mcm9tLnZzdWIocG9zaXRpb24sIGxlbik7XG4gICAgdmFyIHBsYW5lVG9Gcm9tID0gdmVjMi5kb3QobGVuLCB3b3JsZE5vcm1hbCk7IC8vIGxlbi5kb3Qod29ybGROb3JtYWwpO1xuICAgIHZlYzIuc3ViKGxlbiwgdG8sIHBvc2l0aW9uKTsgLy8gdG8udnN1Yihwb3NpdGlvbiwgbGVuKTtcbiAgICB2YXIgcGxhbmVUb1RvID0gdmVjMi5kb3QobGVuLCB3b3JsZE5vcm1hbCk7IC8vIGxlbi5kb3Qod29ybGROb3JtYWwpO1xuXG4gICAgaWYocGxhbmVUb0Zyb20gKiBwbGFuZVRvVG8gPiAwKXtcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBhcmUgb24gdGhlIHNhbWUgc2lkZSBvZiB0aGUgcGxhbmUuLi4gYmFpbCBvdXRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKHZlYzIuZGlzdGFuY2UoZnJvbSwgdG8pIC8qIGZyb20uZGlzdGFuY2VUbyh0bykgKi8gPCBwbGFuZVRvRnJvbSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbl9kb3RfZGlyID0gdmVjMi5kb3Qod29ybGROb3JtYWwsIGRpcmVjdGlvbik7IC8vIHdvcmxkTm9ybWFsLmRvdChkaXJlY3Rpb24pO1xuXG4gICAgLy8gaWYgKE1hdGguYWJzKG5fZG90X2RpcikgPCB0aGlzLnByZWNpc2lvbikge1xuICAgIC8vICAgICAvLyBObyBpbnRlcnNlY3Rpb25cbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vIH1cblxuICAgIHZlYzIuc3ViKHBsYW5lUG9pbnRUb0Zyb20sIGZyb20sIHBvc2l0aW9uKTsgLy8gZnJvbS52c3ViKHBvc2l0aW9uLCBwbGFuZVBvaW50VG9Gcm9tKTtcbiAgICB2YXIgdCA9IC12ZWMyLmRvdCh3b3JsZE5vcm1hbCwgcGxhbmVQb2ludFRvRnJvbSkgLyBuX2RvdF9kaXI7IC8vIC0gd29ybGROb3JtYWwuZG90KHBsYW5lUG9pbnRUb0Zyb20pIC8gbl9kb3RfZGlyO1xuICAgIHZlYzIuc2NhbGUoZGlyX3NjYWxlZF93aXRoX3QsIGRpcmVjdGlvbiwgdCk7IC8vIGRpcmVjdGlvbi5zY2FsZSh0LCBkaXJfc2NhbGVkX3dpdGhfdCk7XG4gICAgdmVjMi5hZGQoaGl0UG9pbnRXb3JsZCwgZnJvbSwgZGlyX3NjYWxlZF93aXRoX3QpOyAvLyBmcm9tLnZhZGQoZGlyX3NjYWxlZF93aXRoX3QsIGhpdFBvaW50V29ybGQpO1xuXG4gICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24od29ybGROb3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCAtMSk7XG59O1xuUmF5LnByb3RvdHlwZVtTaGFwZS5QTEFORV0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdFBsYW5lO1xuXG52YXIgUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RDaXJjbGUgPSBmdW5jdGlvbihzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbSxcbiAgICAgICAgdG8gPSB0aGlzLnRvLFxuICAgICAgICByID0gc2hhcGUucmFkaXVzO1xuXG4gICAgdmFyIGEgPSBNYXRoLnBvdyh0b1swXSAtIGZyb21bMF0sIDIpICsgTWF0aC5wb3codG9bMV0gLSBmcm9tWzFdLCAyKTtcbiAgICB2YXIgYiA9IDIgKiAoKHRvWzBdIC0gZnJvbVswXSkgKiAoZnJvbVswXSAtIHBvc2l0aW9uWzBdKSArICh0b1sxXSAtIGZyb21bMV0pICogKGZyb21bMV0gLSBwb3NpdGlvblsxXSkpO1xuICAgIHZhciBjID0gTWF0aC5wb3coZnJvbVswXSAtIHBvc2l0aW9uWzBdLCAyKSArIE1hdGgucG93KGZyb21bMV0gLSBwb3NpdGlvblsxXSwgMikgLSBNYXRoLnBvdyhyLCAyKTtcblxuICAgIHZhciBkZWx0YSA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGEgKiBjO1xuXG4gICAgdmFyIGludGVyc2VjdGlvblBvaW50ID0gUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludDtcbiAgICB2YXIgbm9ybWFsID0gUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWw7XG5cbiAgICBpZihkZWx0YSA8IDApe1xuICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb25cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgfSBlbHNlIGlmKGRlbHRhID09PSAwKXtcbiAgICAgICAgLy8gc2luZ2xlIGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgICB2ZWMyLmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkZWx0YSk7IC8vIGZyb20ubGVycCh0bywgZGVsdGEsIGludGVyc2VjdGlvblBvaW50KTtcblxuICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7IC8vIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpOyAvL25vcm1hbC5ub3JtYWxpemUoKTtcblxuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBzaGFwZSwgYm9keSwgLTEpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGQxID0gKC0gYiAtIE1hdGguc3FydChkZWx0YSkpIC8gKDIgKiBhKTtcbiAgICAgICAgdmFyIGQyID0gKC0gYiArIE1hdGguc3FydChkZWx0YSkpIC8gKDIgKiBhKTtcblxuICAgICAgICB2ZWMyLmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkMSk7IC8vIGZyb20ubGVycCh0bywgZDEsIGludGVyc2VjdGlvblBvaW50KTtcblxuICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7IC8vIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpOyAvL25vcm1hbC5ub3JtYWxpemUoKTtcblxuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBzaGFwZSwgYm9keSwgLTEpO1xuXG4gICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzIubGVycChpbnRlcnNlY3Rpb25Qb2ludCwgZnJvbSwgdG8sIGQyKTsgLy8gZnJvbS5sZXJwKHRvLCBkMiwgaW50ZXJzZWN0aW9uUG9pbnQpO1xuXG4gICAgICAgIHZlYzIuc3ViKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHBvc2l0aW9uKTsgLy8gaW50ZXJzZWN0aW9uUG9pbnQudnN1Yihwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7IC8vbm9ybWFsLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHNoYXBlLCBib2R5LCAtMSk7XG4gICAgfVxufTtcblJheS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0Q2lyY2xlO1xuXG4vKipcbiAqIEdldCB0aGUgQUFCQiBvZiB0aGUgcmF5LlxuICogQG1ldGhvZCBnZXRBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKi9cblJheS5wcm90b3R5cGUuZ2V0QUFCQiA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICByZXN1bHQubG93ZXJCb3VuZFswXSA9IE1hdGgubWluKHRvWzBdLCBmcm9tWzBdKTtcbiAgICByZXN1bHQubG93ZXJCb3VuZFsxXSA9IE1hdGgubWluKHRvWzFdLCBmcm9tWzFdKTtcbiAgICByZXN1bHQudXBwZXJCb3VuZFswXSA9IE1hdGgubWF4KHRvWzBdLCBmcm9tWzBdKTtcbiAgICByZXN1bHQudXBwZXJCb3VuZFsxXSA9IE1hdGgubWF4KHRvWzFdLCBmcm9tWzFdKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCByZXBvcnRJbnRlcnNlY3Rpb25cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHthcnJheX0gbm9ybWFsXG4gKiBAcGFyYW0gIHthcnJheX0gaGl0UG9pbnRXb3JsZFxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBpbnRlcnNlY3Rpb25zIHNob3VsZCBjb250aW51ZVxuICovXG5SYXkucHJvdG90eXBlLnJlcG9ydEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKG5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIGhpdEZhY2VJbmRleCl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgZGlzdGFuY2UgPSB2ZWMyLmRpc3RhbmNlKGZyb20sIGhpdFBvaW50V29ybGQpOyAvLyBmcm9tLmRpc3RhbmNlVG8oaGl0UG9pbnRXb3JsZCk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0O1xuXG4gICAgLy8gU2tpcCBiYWNrIGZhY2VzP1xuICAgIGlmKHRoaXMuc2tpcEJhY2tmYWNlcyAmJiAvKiBub3JtYWwuZG90KHRoaXMuX2RpcmVjdGlvbikgKi8gdmVjMi5kb3Qobm9ybWFsLCB0aGlzLl9kaXJlY3Rpb24pID4gMCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXN1bHQuaGl0RmFjZUluZGV4ID0gdHlwZW9mKGhpdEZhY2VJbmRleCkgIT09ICd1bmRlZmluZWQnID8gaGl0RmFjZUluZGV4IDogLTE7XG5cbiAgICBzd2l0Y2godGhpcy5tb2RlKXtcbiAgICBjYXNlIFJheS5BTEw6XG4gICAgICAgIHRoaXMuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIG5vcm1hbCxcbiAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICApO1xuICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgUmF5LkNMT1NFU1Q6XG5cbiAgICAgICAgLy8gU3RvcmUgaWYgY2xvc2VyIHRoYW4gY3VycmVudCBjbG9zZXN0XG4gICAgICAgIGlmKGRpc3RhbmNlIDwgcmVzdWx0LmRpc3RhbmNlIHx8ICFyZXN1bHQuaGFzSGl0KXtcbiAgICAgICAgICAgIHRoaXMuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdC5oYXNIaXQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIG5vcm1hbCxcbiAgICAgICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFJheS5BTlk6XG5cbiAgICAgICAgLy8gUmVwb3J0IGFuZCBzdG9wLlxuICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5oYXNIaXQgPSB0cnVlO1xuICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIGRpc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdC5fc2hvdWxkU3RvcCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbnZhciB2MCA9IHZlYzIuY3JlYXRlKCksXG4gICAgaW50ZXJzZWN0ID0gdmVjMi5jcmVhdGUoKTtcbmZ1bmN0aW9uIGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbihmcm9tLCBkaXJlY3Rpb24sIHBvc2l0aW9uKSB7XG5cbiAgICAvLyB2MCBpcyB2ZWN0b3IgZnJvbSBmcm9tIHRvIHBvc2l0aW9uXG4gICAgdmVjMi5zdWIodjAsIHBvc2l0aW9uLCBmcm9tKTsgLy8gcG9zaXRpb24udnN1Yihmcm9tLHYwKTtcbiAgICB2YXIgZG90ID0gdmVjMi5kb3QodjAsIGRpcmVjdGlvbik7IC8vIHYwLmRvdChkaXJlY3Rpb24pO1xuXG4gICAgLy8gaW50ZXJzZWN0ID0gZGlyZWN0aW9uKmRvdCArIGZyb21cbiAgICB2ZWMyLnNjYWxlKGludGVyc2VjdCwgZGlyZWN0aW9uLCBkb3QpOyAvL2RpcmVjdGlvbi5tdWx0KGRvdCxpbnRlcnNlY3QpO1xuICAgIHZlYzIuYWRkKGludGVyc2VjdCwgaW50ZXJzZWN0LCBmcm9tKTsgLy8gaW50ZXJzZWN0LnZhZGQoZnJvbSwgaW50ZXJzZWN0KTtcblxuICAgIHZhciBkaXN0YW5jZSA9IHZlYzIuZGlzdGFuY2UocG9zaXRpb24sIGludGVyc2VjdCk7IC8vIHBvc2l0aW9uLmRpc3RhbmNlVG8oaW50ZXJzZWN0KTtcblxuICAgIHJldHVybiBkaXN0YW5jZTtcbn1cblxuXG59LHtcIi4uL2NvbGxpc2lvbi9BQUJCXCI6NyxcIi4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0XCI6MTMsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3NoYXBlcy9TaGFwZVwiOjQ1fV0sMTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXljYXN0UmVzdWx0O1xuXG4vKipcbiAqIFN0b3JhZ2UgZm9yIFJheSBjYXN0aW5nIGRhdGEuXG4gKiBAY2xhc3MgUmF5Y2FzdFJlc3VsdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJheWNhc3RSZXN1bHQoKXtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHthcnJheX0gcmF5RnJvbVdvcmxkXG5cdCAqL1xuXHR0aGlzLnJheUZyb21Xb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7YXJyYXl9IHJheVRvV29ybGRcblx0ICovXG5cdHRoaXMucmF5VG9Xb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7YXJyYXl9IGhpdE5vcm1hbFdvcmxkXG5cdCAqL1xuXHR0aGlzLmhpdE5vcm1hbFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHthcnJheX0gaGl0UG9pbnRXb3JsZFxuXHQgKi9cblx0dGhpcy5oaXRQb2ludFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBoYXNIaXRcblx0ICovXG5cdHRoaXMuaGFzSGl0ID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFRoZSBoaXQgc2hhcGUsIG9yIG51bGwuXG5cdCAqIEBwcm9wZXJ0eSB7U2hhcGV9IHNoYXBlXG5cdCAqL1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblxuXHQvKipcblx0ICogVGhlIGhpdCBib2R5LCBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlcblx0ICovXG5cdHRoaXMuYm9keSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBpbmRleCBvZiB0aGUgaGl0IHRyaWFuZ2xlLCBpZiB0aGUgaGl0IHNoYXBlIHdhcyBhIHRyaW1lc2guXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaXRGYWNlSW5kZXhcblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuaGl0RmFjZUluZGV4ID0gLTE7XG5cblx0LyoqXG5cdCAqIERpc3RhbmNlIHRvIHRoZSBoaXQuIFdpbGwgYmUgc2V0IHRvIC0xIGlmIHRoZXJlIHdhcyBubyBoaXQuXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaXN0YW5jZVxuXHQgKiBAZGVmYXVsdCAtMVxuXHQgKi9cblx0dGhpcy5kaXN0YW5jZSA9IC0xO1xuXG5cdC8qKlxuXHQgKiBJZiB0aGUgcmF5IHNob3VsZCBzdG9wIHRyYXZlcnNpbmcgdGhlIGJvZGllcy5cblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtCb29sZWFufSBfc2hvdWxkU3RvcFxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKi9cblx0dGhpcy5fc2hvdWxkU3RvcCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlc2V0IGFsbCByZXN1bHQgZGF0YS5cbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cdHZlYzIuc2V0KHRoaXMucmF5RnJvbVdvcmxkLCAwLCAwKTtcblx0dmVjMi5zZXQodGhpcy5yYXlUb1dvcmxkLCAwLCAwKTtcblx0dmVjMi5zZXQodGhpcy5oaXROb3JtYWxXb3JsZCwgMCwgMCk7XG5cdHZlYzIuc2V0KHRoaXMuaGl0UG9pbnRXb3JsZCwgMCwgMCk7XG5cdHRoaXMuaGFzSGl0ID0gZmFsc2U7XG5cdHRoaXMuc2hhcGUgPSBudWxsO1xuXHR0aGlzLmJvZHkgPSBudWxsO1xuXHR0aGlzLmhpdEZhY2VJbmRleCA9IC0xO1xuXHR0aGlzLmRpc3RhbmNlID0gLTE7XG5cdHRoaXMuX3Nob3VsZFN0b3AgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBhYm9ydFxuICovXG5SYXljYXN0UmVzdWx0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuX3Nob3VsZFN0b3AgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHthcnJheX0gcmF5RnJvbVdvcmxkXG4gKiBAcGFyYW0ge2FycmF5fSByYXlUb1dvcmxkXG4gKiBAcGFyYW0ge2FycmF5fSBoaXROb3JtYWxXb3JsZFxuICogQHBhcmFtIHthcnJheX0gaGl0UG9pbnRXb3JsZFxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKFxuXHRyYXlGcm9tV29ybGQsXG5cdHJheVRvV29ybGQsXG5cdGhpdE5vcm1hbFdvcmxkLFxuXHRoaXRQb2ludFdvcmxkLFxuXHRzaGFwZSxcblx0Ym9keSxcblx0ZGlzdGFuY2Vcbil7XG5cdHZlYzIuY29weSh0aGlzLnJheUZyb21Xb3JsZCwgcmF5RnJvbVdvcmxkKTtcblx0dmVjMi5jb3B5KHRoaXMucmF5VG9Xb3JsZCwgcmF5VG9Xb3JsZCk7XG5cdHZlYzIuY29weSh0aGlzLmhpdE5vcm1hbFdvcmxkLCBoaXROb3JtYWxXb3JsZCk7XG5cdHZlYzIuY29weSh0aGlzLmhpdFBvaW50V29ybGQsIGhpdFBvaW50V29ybGQpO1xuXHR0aGlzLnNoYXBlID0gc2hhcGU7XG5cdHRoaXMuYm9keSA9IGJvZHk7XG5cdHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbn07XG59LHtcIi4uL21hdGgvdmVjMlwiOjMxfV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNBUEJyb2FkcGhhc2U7XG5cbi8qKlxuICogU3dlZXAgYW5kIHBydW5lIGJyb2FkcGhhc2UgYWxvbmcgb25lIGF4aXMuXG4gKlxuICogQGNsYXNzIFNBUEJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICovXG5mdW5jdGlvbiBTQVBCcm9hZHBoYXNlKCl7XG4gICAgQnJvYWRwaGFzZS5jYWxsKHRoaXMsQnJvYWRwaGFzZS5TQVApO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBib2RpZXMgY3VycmVudGx5IGluIHRoZSBicm9hZHBoYXNlLlxuICAgICAqIEBwcm9wZXJ0eSBheGlzTGlzdFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmF4aXNMaXN0ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXhpcyB0byBzb3J0IGFsb25nLiAwIG1lYW5zIHgtYXhpcyBhbmQgMSB5LWF4aXMuIElmIHlvdXIgYm9kaWVzIGFyZSBtb3JlIHNwcmVhZCBvdXQgb3ZlciB0aGUgWCBheGlzLCBzZXQgYXhpc0luZGV4IHRvIDAsIGFuZCB5b3Ugd2lsbCBnYWluIHNvbWUgcGVyZm9ybWFuY2UuXG4gICAgICogQHByb3BlcnR5IGF4aXNJbmRleFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5heGlzSW5kZXggPSAwO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMuX2FkZEJvZHlIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHRoYXQuYXhpc0xpc3QucHVzaChlLmJvZHkpO1xuICAgIH07XG5cbiAgICB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSBsaXN0XG4gICAgICAgIHZhciBpZHggPSB0aGF0LmF4aXNMaXN0LmluZGV4T2YoZS5ib2R5KTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICB0aGF0LmF4aXNMaXN0LnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTQVBCcm9hZHBoYXNlO1xuXG4vKipcbiAqIENoYW5nZSB0aGUgd29ybGRcbiAqIEBtZXRob2Qgc2V0V29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xuICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxuICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDtcblxuICAgIC8vIEFkZCBhbGwgYm9kaWVzIGZyb20gdGhlIG5ldyB3b3JsZFxuICAgIFV0aWxzLmFwcGVuZEFycmF5KHRoaXMuYXhpc0xpc3QsIHdvcmxkLmJvZGllcyk7XG5cbiAgICAvLyBSZW1vdmUgb2xkIGhhbmRsZXJzLCBpZiBhbnlcbiAgICB3b3JsZFxuICAgICAgICAub2ZmKFwiYWRkQm9keVwiLHRoaXMuX2FkZEJvZHlIYW5kbGVyKVxuICAgICAgICAub2ZmKFwicmVtb3ZlQm9keVwiLHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTtcblxuICAgIC8vIEFkZCBoYW5kbGVycyB0byB1cGRhdGUgdGhlIGxpc3Qgb2YgYm9kaWVzLlxuICAgIHdvcmxkLm9uKFwiYWRkQm9keVwiLHRoaXMuX2FkZEJvZHlIYW5kbGVyKS5vbihcInJlbW92ZUJvZHlcIix0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7XG5cbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG59O1xuXG4vKipcbiAqIFNvcnRzIGJvZGllcyBhbG9uZyBhbiBheGlzLlxuICogQG1ldGhvZCBzb3J0QXhpc0xpc3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzSW5kZXhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLnNvcnRBeGlzTGlzdCA9IGZ1bmN0aW9uKGEsIGF4aXNJbmRleCl7XG4gICAgYXhpc0luZGV4ID0gYXhpc0luZGV4fDA7XG4gICAgZm9yKHZhciBpPTEsbD1hLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgdmFyIHYgPSBhW2ldO1xuICAgICAgICBmb3IodmFyIGo9aSAtIDE7aj49MDtqLS0pIHtcbiAgICAgICAgICAgIGlmKGFbal0uYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0gPD0gdi5hYWJiLmxvd2VyQm91bmRbYXhpc0luZGV4XSl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhW2orMV0gPSBhW2pdO1xuICAgICAgICB9XG4gICAgICAgIGFbaisxXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcblxuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuc29ydExpc3QgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib2RpZXMgPSB0aGlzLmF4aXNMaXN0LFxuICAgIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuXG4gICAgLy8gU29ydCB0aGUgbGlzdHNcbiAgICBTQVBCcm9hZHBoYXNlLnNvcnRBeGlzTGlzdChib2RpZXMsIGF4aXNJbmRleCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29sbGlkaW5nIHBhaXJzXG4gKiBAbWV0aG9kIGdldENvbGxpc2lvblBhaXJzXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCxcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHQsXG4gICAgICAgIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IDA7XG5cbiAgICAvLyBVcGRhdGUgYWxsIEFBQkJzIGlmIG5lZWRlZFxuICAgIHZhciBsID0gYm9kaWVzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tsXTtcbiAgICAgICAgaWYoYi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgYi51cGRhdGVBQUJCKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb3J0IHRoZSBsaXN0c1xuICAgIHRoaXMuc29ydExpc3QoKTtcblxuICAgIC8vIExvb2sgdGhyb3VnaCB0aGUgWCBsaXN0XG4gICAgZm9yKHZhciBpPTAsIE49Ym9kaWVzLmxlbmd0aHwwOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIGZvcih2YXIgaj1pKzE7IGo8TjsgaisrKXtcbiAgICAgICAgICAgIHZhciBiaiA9IGJvZGllc1tqXTtcblxuICAgICAgICAgICAgLy8gQm91bmRzIG92ZXJsYXA/XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSAoYmouYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0gPD0gYmkuYWFiYi51cHBlckJvdW5kW2F4aXNJbmRleF0pO1xuICAgICAgICAgICAgaWYoIW92ZXJsYXBzKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoQnJvYWRwaGFzZS5jYW5Db2xsaWRlKGJpLGJqKSAmJiB0aGlzLmJvdW5kaW5nVm9sdW1lQ2hlY2soYmksYmopKXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaSxiaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxuICogQG1ldGhvZCBhYWJiUXVlcnlcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24od29ybGQsIGFhYmIsIHJlc3VsdCl7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gICAgdGhpcy5zb3J0TGlzdCgpO1xuXG4gICAgdmFyIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuICAgIHZhciBheGlzID0gJ3gnO1xuICAgIGlmKGF4aXNJbmRleCA9PT0gMSl7IGF4aXMgPSAneSc7IH1cbiAgICBpZihheGlzSW5kZXggPT09IDIpeyBheGlzID0gJ3onOyB9XG5cbiAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xuICAgIHZhciBsb3dlciA9IGFhYmIubG93ZXJCb3VuZFtheGlzXTtcbiAgICB2YXIgdXBwZXIgPSBhYWJiLnVwcGVyQm91bmRbYXhpc107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGF4aXNMaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBheGlzTGlzdFtpXTtcblxuICAgICAgICBpZihiLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiLnVwZGF0ZUFBQkIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGIuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xufSx7XCIuLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjgsXCIuLi91dGlscy9VdGlsc1wiOjUwfV0sMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50O1xuXG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG4vKipcbiAqIEJhc2UgY29uc3RyYWludCBjbGFzcy5cbiAqXG4gKiBAY2xhc3MgQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ9dHJ1ZV1cbiAqL1xuZnVuY3Rpb24gQ29uc3RyYWludChib2R5QSwgYm9keUIsIHR5cGUsIG9wdGlvbnMpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgY29uc3RyYWludC4gTWF5IGJlIG9uZSBvZiBDb25zdHJhaW50LkRJU1RBTkNFLCBDb25zdHJhaW50LkdFQVIsIENvbnN0cmFpbnQuTE9DSywgQ29uc3RyYWludC5QUklTTUFUSUMgb3IgQ29uc3RyYWludC5SRVZPTFVURS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucyx7XG4gICAgICAgIGNvbGxpZGVDb25uZWN0ZWQgOiB0cnVlLFxuICAgICAgICB3YWtlVXBCb2RpZXMgOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRXF1YXRpb25zIHRvIGJlIHNvbHZlZCBpbiB0aGlzIGNvbnN0cmFpbnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgY29uc3RyYWludC5cbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb25zdHJhaW50LlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QlxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSBjb25uZWN0ZWQgYm9kaWVzIHRvIGNvbGxpZGUuXG4gICAgICogQHByb3BlcnR5IGNvbGxpZGVDb25uZWN0ZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkO1xuXG4gICAgLy8gV2FrZSB1cCBib2RpZXMgd2hlbiBjb25uZWN0ZWRcbiAgICBpZihvcHRpb25zLndha2VVcEJvZGllcyl7XG4gICAgICAgIGlmKGJvZHlBKXtcbiAgICAgICAgICAgIGJvZHlBLndha2VVcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGJvZHlCKXtcbiAgICAgICAgICAgIGJvZHlCLndha2VVcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGludGVybmFsIGNvbnN0cmFpbnQgcGFyYW1ldGVycyBiZWZvcmUgc29sdmUuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1ldGhvZCB1cGRhdGUoKSBub3QgaW1wbG1lbWVudGVkIGluIHRoaXMgQ29uc3RyYWludCBzdWJjbGFzcyFcIik7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBESVNUQU5DRVxuICovXG5Db25zdHJhaW50LkRJU1RBTkNFID0gMTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gR0VBUlxuICovXG5Db25zdHJhaW50LkdFQVIgPSAyO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMT0NLXG4gKi9cbkNvbnN0cmFpbnQuTE9DSyA9IDM7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFBSSVNNQVRJQ1xuICovXG5Db25zdHJhaW50LlBSSVNNQVRJQyA9IDQ7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFJFVk9MVVRFXG4gKi9cbkNvbnN0cmFpbnQuUkVWT0xVVEUgPSA1O1xuXG4vKipcbiAqIFNldCBzdGlmZm5lc3MgZm9yIHRoaXMgY29uc3RyYWludC5cbiAqIEBtZXRob2Qgc2V0U3RpZmZuZXNzXG4gKiBAcGFyYW0ge051bWJlcn0gc3RpZmZuZXNzXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnNldFN0aWZmbmVzcyA9IGZ1bmN0aW9uKHN0aWZmbmVzcyl7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSBlcXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBlcXNbaV07XG4gICAgICAgIGVxLnN0aWZmbmVzcyA9IHN0aWZmbmVzcztcbiAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IHJlbGF4YXRpb24gZm9yIHRoaXMgY29uc3RyYWludC5cbiAqIEBtZXRob2Qgc2V0UmVsYXhhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJlbGF4YXRpb25cbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUuc2V0UmVsYXhhdGlvbiA9IGZ1bmN0aW9uKHJlbGF4YXRpb24pe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gZXFzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xuICAgICAgICBlcS5yZWxheGF0aW9uID0gcmVsYXhhdGlvbjtcbiAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbn0se1wiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlQ29uc3RyYWludDtcblxuLyoqXG4gKiBDb25zdHJhaW50IHRoYXQgdHJpZXMgdG8ga2VlcCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gYm9kaWVzIGNvbnN0YW50LlxuICpcbiAqIEBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRpc3RhbmNlXSBUaGUgZGlzdGFuY2UgdG8ga2VlcCBiZXR3ZWVuIHRoZSBhbmNob3IgcG9pbnRzLiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib2RpZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEFuY2hvckFdIFRoZSBhbmNob3IgcG9pbnQgZm9yIGJvZHlBLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEgZnJhbWUuIERlZmF1bHRzIHRvIFswLDBdLlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubG9jYWxBbmNob3JCXSBUaGUgYW5jaG9yIHBvaW50IGZvciBib2R5QiwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCIGZyYW1lLiBEZWZhdWx0cyB0byBbMCwwXS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tYXhGb3JjZT1OdW1iZXIuTUFYX1ZBTFVFXSBNYXhpbXVtIGZvcmNlIHRvIGFwcGx5LlxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gSWYgZGlzdGFuY2UgaXMgbm90IGdpdmVuIGFzIGFuIG9wdGlvbiwgdGhlbiB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib2RpZXMgaXMgdXNlZC5cbiAqICAgICAvLyBJbiB0aGlzIGV4YW1wbGUsIHRoZSBib2RpZXMgd2lsbCBiZSBjb25zdHJhaW5lZCB0byBoYXZlIGEgZGlzdGFuY2Ugb2YgMiBiZXR3ZWVuIHRoZWlyIGNlbnRlcnMuXG4gKiAgICAgdmFyIGJvZHlBID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWy0xLCAwXSB9KTtcbiAqICAgICB2YXIgYm9keUIgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbMSwgMF0gfSk7XG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XG4gKiAgICAgICAgIGRpc3RhbmNlOiAxLCAgICAgICAgICAvLyBEaXN0YW5jZSB0byBrZWVwIGJldHdlZW4gdGhlIHBvaW50c1xuICogICAgICAgICBsb2NhbEFuY2hvckE6IFsxLCAwXSwgLy8gUG9pbnQgb24gYm9keUFcbiAqICAgICAgICAgbG9jYWxBbmNob3JCOiBbLTEsIDBdIC8vIFBvaW50IG9uIGJvZHlCXG4gKiAgICAgfSk7XG4gKi9cbmZ1bmN0aW9uIERpc3RhbmNlQ29uc3RyYWludChib2R5QSxib2R5QixvcHRpb25zKXtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucyx7XG4gICAgICAgIGxvY2FsQW5jaG9yQTpbMCwwXSxcbiAgICAgICAgbG9jYWxBbmNob3JCOlswLDBdXG4gICAgfSk7XG5cbiAgICBDb25zdHJhaW50LmNhbGwodGhpcyxib2R5QSxib2R5QixDb25zdHJhaW50LkRJU1RBTkNFLG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogTG9jYWwgYW5jaG9yIGluIGJvZHkgQS5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JBID0gdmVjMi5mcm9tVmFsdWVzKG9wdGlvbnMubG9jYWxBbmNob3JBWzBdLCBvcHRpb25zLmxvY2FsQW5jaG9yQVsxXSk7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCBhbmNob3IgaW4gYm9keSBCLlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSB2ZWMyLmZyb21WYWx1ZXMob3B0aW9ucy5sb2NhbEFuY2hvckJbMF0sIG9wdGlvbnMubG9jYWxBbmNob3JCWzFdKTtcblxuICAgIHZhciBsb2NhbEFuY2hvckEgPSB0aGlzLmxvY2FsQW5jaG9yQTtcbiAgICB2YXIgbG9jYWxBbmNob3JCID0gdGhpcy5sb2NhbEFuY2hvckI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2UgdG8ga2VlcC5cbiAgICAgKiBAcHJvcGVydHkgZGlzdGFuY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xuXG4gICAgaWYodHlwZW9mKG9wdGlvbnMuZGlzdGFuY2UpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzZSB0aGUgY3VycmVudCB3b3JsZCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB3b3JsZCBhbmNob3IgcG9pbnRzLlxuICAgICAgICB2YXIgd29ybGRBbmNob3JBID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgICAgIHdvcmxkQW5jaG9yQiA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgICAgICByID0gdmVjMi5jcmVhdGUoKTtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gbG9jYWwgYW5jaG9ycyB0byB3b3JsZFxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZEFuY2hvckEsIGxvY2FsQW5jaG9yQSwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZEFuY2hvckIsIGxvY2FsQW5jaG9yQiwgYm9keUIuYW5nbGUpO1xuXG4gICAgICAgIHZlYzIuYWRkKHIsIGJvZHlCLnBvc2l0aW9uLCB3b3JsZEFuY2hvckIpO1xuICAgICAgICB2ZWMyLnN1YihyLCByLCB3b3JsZEFuY2hvckEpO1xuICAgICAgICB2ZWMyLnN1YihyLCByLCBib2R5QS5wb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHZlYzIubGVuZ3RoKHIpO1xuICAgIH1cblxuICAgIHZhciBtYXhGb3JjZTtcbiAgICBpZih0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSk9PT1cInVuZGVmaW5lZFwiICl7XG4gICAgICAgIG1heEZvcmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtYXhGb3JjZSA9IG9wdGlvbnMubWF4Rm9yY2U7XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbCA9IG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpOyAvLyBKdXN0IGluIHRoZSBub3JtYWwgZGlyZWN0aW9uXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbIG5vcm1hbCBdO1xuXG4gICAgLyoqXG4gICAgICogTWF4IGZvcmNlIHRvIGFwcGx5LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhGb3JjZVxuICAgICAqL1xuICAgIHRoaXMubWF4Rm9yY2UgPSBtYXhGb3JjZTtcblxuICAgIC8vIGcgPSAoeGkgLSB4aikuZG90KG4pXG4gICAgLy8gZGcvZHQgPSAodmkgLSB2aikuZG90KG4pID0gRypXID0gW24gMCAtbiAwXSAqIFt2aSB3aSB2aiB3al0nXG5cbiAgICAvLyAuLi5hbmQgaWYgd2Ugd2VyZSB0byBpbmNsdWRlIG9mZnNldCBwb2ludHMgKFRPRE8gZm9yIG5vdyk6XG4gICAgLy8gZyA9XG4gICAgLy8gICAgICAoeGogKyByaiAtIHhpIC0gcmkpLmRvdChuKSAtIGRpc3RhbmNlXG4gICAgLy9cbiAgICAvLyBkZy9kdCA9XG4gICAgLy8gICAgICAodmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpKS5kb3QobikgPVxuICAgIC8vICAgICAgeyB0ZXJtIDIgaXMgbmVhciB6ZXJvIH0gPVxuICAgIC8vICAgICAgWy1uICAgLXJpIHggbiAgIG4gICByaiB4IG5dICogW3ZpIHdpIHZqIHdqXScgPVxuICAgIC8vICAgICAgRyAqIFdcbiAgICAvL1xuICAgIC8vID0+IEcgPSBbLW4gLXJpeG4gbiByanhuXVxuXG4gICAgdmFyIHIgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHZhciByaSA9IHZlYzIuY3JlYXRlKCk7IC8vIHdvcmxkQW5jaG9yQVxuICAgIHZhciByaiA9IHZlYzIuY3JlYXRlKCk7IC8vIHdvcmxkQW5jaG9yQlxuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBub3JtYWwuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgICAgIHhpID0gYm9keUEucG9zaXRpb24sXG4gICAgICAgICAgICB4aiA9IGJvZHlCLnBvc2l0aW9uO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSBsb2NhbCBhbmNob3JzIHRvIHdvcmxkXG4gICAgICAgIHZlYzIucm90YXRlKHJpLCBsb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUocmosIGxvY2FsQW5jaG9yQiwgYm9keUIuYW5nbGUpO1xuXG4gICAgICAgIHZlYzIuYWRkKHIsIHhqLCByaik7XG4gICAgICAgIHZlYzIuc3ViKHIsIHIsIHJpKTtcbiAgICAgICAgdmVjMi5zdWIociwgciwgeGkpO1xuXG4gICAgICAgIC8vdmVjMi5zdWIociwgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHZlYzIubGVuZ3RoKHIpIC0gdGhhdC5kaXN0YW5jZTtcbiAgICB9O1xuXG4gICAgLy8gTWFrZSB0aGUgY29udGFjdCBjb25zdHJhaW50IGJpbGF0ZXJhbFxuICAgIHRoaXMuc2V0TWF4Rm9yY2UobWF4Rm9yY2UpO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHVwcGVyIGxpbWl0IGlzIGVuYWJsZWQgb3Igbm90LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdXBwZXJMaW1pdEVuYWJsZWRcbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXBwZXIgY29uc3RyYWludCBsaW1pdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdXBwZXJMaW1pdFxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbG93ZXIgbGltaXQgaXMgZW5hYmxlZCBvciBub3QuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBsb3dlckxpbWl0RW5hYmxlZFxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb3dlciBjb25zdHJhaW50IGxpbWl0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3dlckxpbWl0XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgY29uc3RyYWludCBwb3NpdGlvbi4gVGhpcyBpcyBlcXVhbCB0byB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB3b3JsZCBhbmNob3IgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwb3NpdGlvblxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSAwO1xufVxuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlzdGFuY2VDb25zdHJhaW50O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY29uc3RyYWludCBlcXVhdGlvbnMuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgYm9kaWVzIGNoYW5nZWQgcG9zaXRpb24sIGJlZm9yZSBzb2x2aW5nLlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xudmFyIG4gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJpID0gdmVjMi5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JBXG52YXIgcmogPSB2ZWMyLmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckJcbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbm9ybWFsID0gdGhpcy5lcXVhdGlvbnNbMF0sXG4gICAgICAgIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICBkaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UsXG4gICAgICAgIHhpID0gYm9keUEucG9zaXRpb24sXG4gICAgICAgIHhqID0gYm9keUIucG9zaXRpb24sXG4gICAgICAgIG5vcm1hbEVxdWF0aW9uID0gdGhpcy5lcXVhdGlvbnNbMF0sXG4gICAgICAgIEcgPSBub3JtYWwuRztcblxuICAgIC8vIFRyYW5zZm9ybSBsb2NhbCBhbmNob3JzIHRvIHdvcmxkXG4gICAgdmVjMi5yb3RhdGUocmksIHRoaXMubG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUocmosIHRoaXMubG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAvLyBHZXQgd29ybGQgYW5jaG9yIHBvaW50cyBhbmQgbm9ybWFsXG4gICAgdmVjMi5hZGQobiwgeGosIHJqKTtcbiAgICB2ZWMyLnN1YihuLCBuLCByaSk7XG4gICAgdmVjMi5zdWIobiwgbiwgeGkpO1xuICAgIHRoaXMucG9zaXRpb24gPSB2ZWMyLmxlbmd0aChuKTtcblxuICAgIHZhciB2aW9sYXRpbmcgPSBmYWxzZTtcbiAgICBpZih0aGlzLnVwcGVyTGltaXRFbmFibGVkKXtcbiAgICAgICAgaWYodGhpcy5wb3NpdGlvbiA+IHRoaXMudXBwZXJMaW1pdCl7XG4gICAgICAgICAgICBub3JtYWxFcXVhdGlvbi5tYXhGb3JjZSA9IDA7XG4gICAgICAgICAgICBub3JtYWxFcXVhdGlvbi5taW5Gb3JjZSA9IC10aGlzLm1heEZvcmNlO1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHRoaXMudXBwZXJMaW1pdDtcbiAgICAgICAgICAgIHZpb2xhdGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmxvd2VyTGltaXRFbmFibGVkKXtcbiAgICAgICAgaWYodGhpcy5wb3NpdGlvbiA8IHRoaXMubG93ZXJMaW1pdCl7XG4gICAgICAgICAgICBub3JtYWxFcXVhdGlvbi5tYXhGb3JjZSA9IHRoaXMubWF4Rm9yY2U7XG4gICAgICAgICAgICBub3JtYWxFcXVhdGlvbi5taW5Gb3JjZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gdGhpcy5sb3dlckxpbWl0O1xuICAgICAgICAgICAgdmlvbGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKCh0aGlzLmxvd2VyTGltaXRFbmFibGVkIHx8IHRoaXMudXBwZXJMaW1pdEVuYWJsZWQpICYmICF2aW9sYXRpbmcpe1xuICAgICAgICAvLyBObyBjb25zdHJhaW50IG5lZWRlZC5cbiAgICAgICAgbm9ybWFsRXF1YXRpb24uZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbm9ybWFsRXF1YXRpb24uZW5hYmxlZCA9IHRydWU7XG5cbiAgICB2ZWMyLm5vcm1hbGl6ZShuLG4pO1xuXG4gICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXG4gICAgdmFyIHJpeG4gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJpLCBuKSxcbiAgICAgICAgcmp4biA9IHZlYzIuY3Jvc3NMZW5ndGgocmosIG4pO1xuXG4gICAgLy8gRyA9IFstbiAtcml4biBuIHJqeG5dXG4gICAgR1swXSA9IC1uWzBdO1xuICAgIEdbMV0gPSAtblsxXTtcbiAgICBHWzJdID0gLXJpeG47XG4gICAgR1szXSA9IG5bMF07XG4gICAgR1s0XSA9IG5bMV07XG4gICAgR1s1XSA9IHJqeG47XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4IGZvcmNlIHRvIGJlIHVzZWRcbiAqIEBtZXRob2Qgc2V0TWF4Rm9yY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBmXG4gKi9cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbihmKXtcbiAgICB2YXIgbm9ybWFsID0gdGhpcy5lcXVhdGlvbnNbMF07XG4gICAgbm9ybWFsLm1pbkZvcmNlID0gLWY7XG4gICAgbm9ybWFsLm1heEZvcmNlID0gIGY7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IGZvcmNlXG4gKiBAbWV0aG9kIGdldE1heEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TWF4Rm9yY2UgPSBmdW5jdGlvbihmKXtcbiAgICB2YXIgbm9ybWFsID0gdGhpcy5lcXVhdGlvbnNbMF07XG4gICAgcmV0dXJuIG5vcm1hbC5tYXhGb3JjZTtcbn07XG5cbn0se1wiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjMsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3V0aWxzL1V0aWxzXCI6NTAsXCIuL0NvbnN0cmFpbnRcIjoxNX1dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgQW5nbGVMb2NrRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQW5nbGVMb2NrRXF1YXRpb24nKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZWFyQ29uc3RyYWludDtcblxuLyoqXG4gKiBDb25uZWN0cyB0d28gYm9kaWVzIGF0IGdpdmVuIG9mZnNldCBwb2ludHMsIGxldHRpbmcgdGhlbSByb3RhdGUgcmVsYXRpdmUgdG8gZWFjaCBvdGhlciBhcm91bmQgdGhpcyBwb2ludC5cbiAqIEBjbGFzcyBHZWFyQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9ICAgICAgICAgICAgYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gICAgICAgICAgICBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLmFuZ2xlPTBdIFJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdGhlIGJvZGllcy4gV2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzICh0aGUgZ2VhciByYXRpbyBpcyBhY2NvdW50ZWQgZm9yKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICBbb3B0aW9ucy5yYXRpbz0xXSBHZWFyIHJhdGlvLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLm1heFRvcnF1ZV0gTWF4aW11bSB0b3JxdWUgdG8gYXBwbHkuXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKiBAdG9kbyBBYmlsaXR5IHRvIHNwZWNpZnkgd29ybGQgcG9pbnRzXG4gKi9cbmZ1bmN0aW9uIEdlYXJDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBDb25zdHJhaW50LkdFQVIsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdlYXIgcmF0aW8uXG4gICAgICogQHByb3BlcnR5IHJhdGlvXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJhdGlvID0gdHlwZW9mKG9wdGlvbnMucmF0aW8pID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5yYXRpbyA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVsYXRpdmUgYW5nbGVcbiAgICAgKiBAcHJvcGVydHkgYW5nbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSB0eXBlb2Yob3B0aW9ucy5hbmdsZSkgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLmFuZ2xlIDogYm9keUIuYW5nbGUgLSB0aGlzLnJhdGlvICogYm9keUEuYW5nbGU7XG5cbiAgICAvLyBTZW5kIHNhbWUgcGFyYW1ldGVycyB0byB0aGUgZXF1YXRpb25cbiAgICBvcHRpb25zLmFuZ2xlID0gdGhpcy5hbmdsZTtcbiAgICBvcHRpb25zLnJhdGlvID0gdGhpcy5yYXRpbztcblxuICAgIHRoaXMuZXF1YXRpb25zID0gW1xuICAgICAgICBuZXcgQW5nbGVMb2NrRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyksXG4gICAgXTtcblxuICAgIC8vIFNldCBtYXggdG9ycXVlXG4gICAgaWYodHlwZW9mKG9wdGlvbnMubWF4VG9ycXVlKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICAgIHRoaXMuc2V0TWF4VG9ycXVlKG9wdGlvbnMubWF4VG9ycXVlKTtcbiAgICB9XG59XG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VhckNvbnN0cmFpbnQ7XG5cbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlcSA9IHRoaXMuZXF1YXRpb25zWzBdO1xuICAgIGlmKGVxLnJhdGlvICE9PSB0aGlzLnJhdGlvKXtcbiAgICAgICAgZXEuc2V0UmF0aW8odGhpcy5yYXRpbyk7XG4gICAgfVxuICAgIGVxLmFuZ2xlID0gdGhpcy5hbmdsZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggdG9ycXVlIGZvciB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2Qgc2V0TWF4VG9ycXVlXG4gKiBAcGFyYW0ge051bWJlcn0gdG9ycXVlXG4gKi9cbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNYXhUb3JxdWUgPSBmdW5jdGlvbih0b3JxdWUpe1xuICAgIHRoaXMuZXF1YXRpb25zWzBdLnNldE1heFRvcnF1ZSh0b3JxdWUpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1heCB0b3JxdWUgZm9yIHRoZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBnZXRNYXhUb3JxdWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLmdldE1heFRvcnF1ZSA9IGZ1bmN0aW9uKHRvcnF1ZSl7XG4gICAgcmV0dXJuIHRoaXMuZXF1YXRpb25zWzBdLm1heEZvcmNlO1xufTtcbn0se1wiLi4vZXF1YXRpb25zL0FuZ2xlTG9ja0VxdWF0aW9uXCI6MjEsXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMyxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9Db25zdHJhaW50XCI6MTV9XSwxODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NrQ29uc3RyYWludDtcblxuLyoqXG4gKiBMb2NrcyB0aGUgcmVsYXRpdmUgcG9zaXRpb24gYmV0d2VlbiB0d28gYm9kaWVzLlxuICpcbiAqIEBjbGFzcyBMb2NrQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxPZmZzZXRCXSBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuIElmIG5vdCBnaXZlbiB0aGUgb2Zmc2V0IGlzIGNvbXB1dGVkIGZyb20gY3VycmVudCBwb3NpdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9jYWxBbmdsZUJdIFRoZSBhbmdsZSBvZiBib2R5QiBpbiBib2R5QSdzIGZyYW1lLiBJZiBub3QgZ2l2ZW4sIHRoZSBhbmdsZSBpcyBjb21wdXRlZCBmcm9tIGN1cnJlbnQgYW5nbGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlXVxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICovXG5mdW5jdGlvbiBMb2NrQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIsQ29uc3RyYWludC5MT0NLLG9wdGlvbnMpO1xuXG4gICAgdmFyIG1heEZvcmNlID0gKCB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSk9PT1cInVuZGVmaW5lZFwiID8gTnVtYmVyLk1BWF9WQUxVRSA6IG9wdGlvbnMubWF4Rm9yY2UgKTtcblxuICAgIHZhciBsb2NhbEFuZ2xlQiA9IG9wdGlvbnMubG9jYWxBbmdsZUIgfHwgMDtcblxuICAgIC8vIFVzZSAzIGVxdWF0aW9uczpcbiAgICAvLyBneCA9ICAgKHhqIC0geGkgLSBsKSAqIHhoYXQgPSAwXG4gICAgLy8gZ3kgPSAgICh4aiAtIHhpIC0gbCkgKiB5aGF0ID0gMFxuICAgIC8vIGdyID0gICAoeGkgLSB4aiArIHIpICogdGhhdCA9IDBcbiAgICAvL1xuICAgIC8vIC4uLndoZXJlOlxuICAgIC8vICAgbCBpcyB0aGUgbG9jYWxPZmZzZXRCIHZlY3RvciByb3RhdGVkIHRvIHdvcmxkIGluIGJvZHlBIGZyYW1lXG4gICAgLy8gICByIGlzIHRoZSBzYW1lIHZlY3RvciBidXQgcmV2ZXJzZWQgYW5kIHJvdGF0ZWQgZnJvbSBib2R5QiBmcmFtZVxuICAgIC8vICAgeGhhdCwgeWhhdCBhcmUgd29ybGQgYXhpcyB2ZWN0b3JzXG4gICAgLy8gICB0aGF0IGlzIHRoZSB0YW5nZW50IG9mIHJcbiAgICAvL1xuICAgIC8vIEZvciB0aGUgZmlyc3QgdHdvIGNvbnN0cmFpbnRzLCB3ZSBnZXRcbiAgICAvLyBHKlcgPSAodmogLSB2aSAtIGxkb3QgICkgKiB4aGF0XG4gICAgLy8gICAgID0gKHZqIC0gdmkgLSB3aSB4IGwpICogeGhhdFxuICAgIC8vXG4gICAgLy8gU2luY2UgKHdpIHggbCkgKiB4aGF0ID0gKGwgeCB4aGF0KSAqIHdpLCB3ZSBnZXRcbiAgICAvLyBHKlcgPSBbIC0xICAgMCAgICgtbCB4IHhoYXQpICAxICAgMCAgIDBdICogW3ZpIHdpIHZqIHdqXVxuICAgIC8vXG4gICAgLy8gVGhlIGxhc3QgY29uc3RyYWludCBnaXZlc1xuICAgIC8vIEdXID0gKHZpIC0gdmogKyB3aiB4IHIpICogdGhhdFxuICAgIC8vICAgID0gWyAgdGhhdCAgIDAgIC10aGF0ICAociB4IHQpIF1cblxuICAgIHZhciB4ID0gICAgIG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpLFxuICAgICAgICB5ID0gICAgIG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpLFxuICAgICAgICByb3QgPSAgIG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpO1xuXG4gICAgdmFyIGwgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICBnID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgeC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZShsLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnN1YihnLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBsKTtcbiAgICAgICAgcmV0dXJuIGdbMF07XG4gICAgfTtcbiAgICB5LmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZlYzIucm90YXRlKGwsIHRoYXQubG9jYWxPZmZzZXRCLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIuc3ViKGcsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIGwpO1xuICAgICAgICByZXR1cm4gZ1sxXTtcbiAgICB9O1xuICAgIHZhciByID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgdCA9IHZlYzIuY3JlYXRlKCk7XG4gICAgcm90LmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZlYzIucm90YXRlKHIsIHRoYXQubG9jYWxPZmZzZXRCLCBib2R5Qi5hbmdsZSAtIHRoYXQubG9jYWxBbmdsZUIpO1xuICAgICAgICB2ZWMyLnNjYWxlKHIsciwtMSk7XG4gICAgICAgIHZlYzIuc3ViKGcsYm9keUEucG9zaXRpb24sYm9keUIucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLmFkZChnLGcscik7XG4gICAgICAgIHZlYzIucm90YXRlKHQsciwtTWF0aC5QSS8yKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUodCx0KTtcbiAgICAgICAgcmV0dXJuIHZlYzIuZG90KGcsdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvZmZzZXQgb2YgYm9keUIgaW4gYm9keUEncyBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBsb2NhbE9mZnNldEJcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsT2Zmc2V0QiA9IHZlYzIuY3JlYXRlKCk7XG4gICAgaWYob3B0aW9ucy5sb2NhbE9mZnNldEIpe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5sb2NhbE9mZnNldEIsIG9wdGlvbnMubG9jYWxPZmZzZXRCKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgZnJvbSBjdXJyZW50IHBvc2l0aW9uc1xuICAgICAgICB2ZWMyLnN1Yih0aGlzLmxvY2FsT2Zmc2V0QiwgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5yb3RhdGUodGhpcy5sb2NhbE9mZnNldEIsIHRoaXMubG9jYWxPZmZzZXRCLCAtYm9keUEuYW5nbGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvZmZzZXQgYW5nbGUgb2YgYm9keUIgaW4gYm9keUEncyBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbG9jYWxBbmdsZUJcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5nbGVCID0gMDtcbiAgICBpZih0eXBlb2Yob3B0aW9ucy5sb2NhbEFuZ2xlQikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy5sb2NhbEFuZ2xlQiA9IG9wdGlvbnMubG9jYWxBbmdsZUI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0XG4gICAgICAgIHRoaXMubG9jYWxBbmdsZUIgPSBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlO1xuICAgIH1cblxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2goeCwgeSwgcm90KTtcbiAgICB0aGlzLnNldE1heEZvcmNlKG1heEZvcmNlKTtcbn1cbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5Mb2NrQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2NrQ29uc3RyYWludDtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZm9yY2UgdG8gYmUgYXBwbGllZC5cbiAqIEBtZXRob2Qgc2V0TWF4Rm9yY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBmb3JjZVxuICovXG5Mb2NrQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbihmb3JjZSl7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuZXF1YXRpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZXFzW2ldLm1heEZvcmNlID0gIGZvcmNlO1xuICAgICAgICBlcXNbaV0ubWluRm9yY2UgPSAtZm9yY2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1heCBmb3JjZS5cbiAqIEBtZXRob2QgZ2V0TWF4Rm9yY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLmdldE1heEZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5lcXVhdGlvbnNbMF0ubWF4Rm9yY2U7XG59O1xuXG52YXIgbCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgciA9IHZlYzIuY3JlYXRlKCk7XG52YXIgdCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgeEF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMSwwKTtcbnZhciB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHggPSAgIHRoaXMuZXF1YXRpb25zWzBdLFxuICAgICAgICB5ID0gICB0aGlzLmVxdWF0aW9uc1sxXSxcbiAgICAgICAgcm90ID0gdGhpcy5lcXVhdGlvbnNbMl0sXG4gICAgICAgIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCO1xuXG4gICAgdmVjMi5yb3RhdGUobCx0aGlzLmxvY2FsT2Zmc2V0Qixib2R5QS5hbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUocix0aGlzLmxvY2FsT2Zmc2V0Qixib2R5Qi5hbmdsZSAtIHRoaXMubG9jYWxBbmdsZUIpO1xuICAgIHZlYzIuc2NhbGUocixyLC0xKTtcblxuICAgIHZlYzIucm90YXRlKHQscixNYXRoLlBJLzIpO1xuICAgIHZlYzIubm9ybWFsaXplKHQsdCk7XG5cbiAgICB4LkdbMF0gPSAtMTtcbiAgICB4LkdbMV0gPSAgMDtcbiAgICB4LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChsLHhBeGlzKTtcbiAgICB4LkdbM10gPSAgMTtcblxuICAgIHkuR1swXSA9ICAwO1xuICAgIHkuR1sxXSA9IC0xO1xuICAgIHkuR1syXSA9IC12ZWMyLmNyb3NzTGVuZ3RoKGwseUF4aXMpO1xuICAgIHkuR1s0XSA9ICAxO1xuXG4gICAgcm90LkdbMF0gPSAgLXRbMF07XG4gICAgcm90LkdbMV0gPSAgLXRbMV07XG4gICAgcm90LkdbM10gPSAgdFswXTtcbiAgICByb3QuR1s0XSA9ICB0WzFdO1xuICAgIHJvdC5HWzVdID0gIHZlYzIuY3Jvc3NMZW5ndGgocix0KTtcbn07XG5cbn0se1wiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjMsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vQ29uc3RyYWludFwiOjE1fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKVxuLCAgIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKVxuLCAgIEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0VxdWF0aW9uJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxMb2NrRXF1YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcmlzbWF0aWNDb25zdHJhaW50O1xuXG4vKipcbiAqIENvbnN0cmFpbnQgdGhhdCBvbmx5IGFsbG93cyBib2RpZXMgdG8gbW92ZSBhbG9uZyBhIGxpbmUsIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIuIFNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy5pZm9yY2UyZC5uZXQvYjJkdHV0L2pvaW50cy1wcmlzbWF0aWNcIj50aGlzIHR1dG9yaWFsPC9hPi5cbiAqXG4gKiBAY2xhc3MgUHJpc21hdGljQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy5tYXhGb3JjZV0gICAgICAgICAgICAgICAgTWF4IGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnRcbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgICAgICAgICAgIEJvZHkgQSdzIGFuY2hvciBwb2ludCwgZGVmaW5lZCBpbiBpdHMgb3duIGxvY2FsIGZyYW1lLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdICAgICAgICAgICAgQm9keSBCJ3MgYW5jaG9yIHBvaW50LCBkZWZpbmVkIGluIGl0cyBvd24gbG9jYWwgZnJhbWUuXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsQXhpc0FdICAgICAgICAgICAgICBBbiBheGlzLCBkZWZpbmVkIGluIGJvZHkgQSBmcmFtZSwgdGhhdCBib2R5IEIncyBhbmNob3IgcG9pbnQgbWF5IHNsaWRlIGFsb25nLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kaXNhYmxlUm90YXRpb25hbExvY2tdICAgSWYgc2V0IHRvIHRydWUsIGJvZHlCIHdpbGwgYmUgZnJlZSB0byByb3RhdGUgYXJvdW5kIGl0cyBhbmNob3IgcG9pbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLnVwcGVyTGltaXRdXG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLmxvd2VyTGltaXRdXG4gKiBAdG9kbyBBYmlsaXR5IHRvIGNyZWF0ZSB1c2luZyBvbmx5IGEgcG9pbnQgYW5kIGEgd29ybGRBeGlzXG4gKi9cbmZ1bmN0aW9uIFByaXNtYXRpY0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBDb25zdHJhaW50LmNhbGwodGhpcyxib2R5QSxib2R5QixDb25zdHJhaW50LlBSSVNNQVRJQyxvcHRpb25zKTtcblxuICAgIC8vIEdldCBhbmNob3JzXG4gICAgdmFyIGxvY2FsQW5jaG9yQSA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgICAgICBsb2NhbEF4aXNBID0gdmVjMi5mcm9tVmFsdWVzKDEsMCksXG4gICAgICAgIGxvY2FsQW5jaG9yQiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JBKXsgdmVjMi5jb3B5KGxvY2FsQW5jaG9yQSwgb3B0aW9ucy5sb2NhbEFuY2hvckEpOyB9XG4gICAgaWYob3B0aW9ucy5sb2NhbEF4aXNBKXsgdmVjMi5jb3B5KGxvY2FsQXhpc0EsICAgb3B0aW9ucy5sb2NhbEF4aXNBKTsgfVxuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JCKXsgdmVjMi5jb3B5KGxvY2FsQW5jaG9yQiwgb3B0aW9ucy5sb2NhbEFuY2hvckIpOyB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JBID0gbG9jYWxBbmNob3JBO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IGxvY2FsQW5jaG9yQjtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEF4aXNBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBeGlzQSA9IGxvY2FsQXhpc0E7XG5cbiAgICAvKlxuXG4gICAgVGhlIGNvbnN0cmFpbnQgdmlvbGF0aW9uIGZvciB0aGUgY29tbW9uIGF4aXMgcG9pbnQgaXNcblxuICAgICAgICBnID0gKCB4aiArIHJqIC0geGkgLSByaSApICogdCAgIDo9ICBnZyp0XG5cbiAgICB3aGVyZSByIGFyZSBib2R5LWxvY2FsIGFuY2hvciBwb2ludHMsIGFuZCB0IGlzIGEgdGFuZ2VudCB0byB0aGUgY29uc3RyYWludCBheGlzIGRlZmluZWQgaW4gYm9keSBpIGZyYW1lLlxuXG4gICAgICAgIGdkb3QgPSAgKCB2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmkgKSAqIHQgKyAoIHhqICsgcmogLSB4aSAtIHJpICkgKiAoIHdpIHggdCApXG5cbiAgICBOb3RlIHRoZSB1c2Ugb2YgdGhlIGNoYWluIHJ1bGUuIE5vdyB3ZSBpZGVudGlmeSB0aGUgamFjb2JpYW5cblxuICAgICAgICBHKlcgPSBbIC10ICAgICAgLXJpIHggdCArIHQgeCBnZyAgICAgdCAgICByaiB4IHQgXSAqIFt2aSB3aSB2aiB3al1cblxuICAgIFRoZSByb3RhdGlvbmFsIHBhcnQgaXMganVzdCBhIHJvdGF0aW9uIGxvY2suXG5cbiAgICAgKi9cblxuICAgIHZhciBtYXhGb3JjZSA9IHRoaXMubWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkhPT1cInVuZGVmaW5lZFwiID8gb3B0aW9ucy5tYXhGb3JjZSA6IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAvLyBUcmFuc2xhdGlvbmFsIHBhcnRcbiAgICB2YXIgdHJhbnMgPSBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcbiAgICB2YXIgcmkgPSBuZXcgdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgcmogPSBuZXcgdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgZ2cgPSBuZXcgdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgdCA9ICBuZXcgdmVjMi5jcmVhdGUoKTtcbiAgICB0cmFucy5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyBnID0gKCB4aiArIHJqIC0geGkgLSByaSApICogdFxuICAgICAgICByZXR1cm4gdmVjMi5kb3QoZ2csdCk7XG4gICAgfTtcbiAgICB0cmFucy51cGRhdGVKYWNvYmlhbiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICAgICAgeGkgPSBib2R5QS5wb3NpdGlvbixcbiAgICAgICAgICAgIHhqID0gYm9keUIucG9zaXRpb247XG4gICAgICAgIHZlYzIucm90YXRlKHJpLGxvY2FsQW5jaG9yQSxib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHJqLGxvY2FsQW5jaG9yQixib2R5Qi5hbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKGdnLHhqLHJqKTtcbiAgICAgICAgdmVjMi5zdWIoZ2csZ2cseGkpO1xuICAgICAgICB2ZWMyLnN1YihnZyxnZyxyaSk7XG4gICAgICAgIHZlYzIucm90YXRlKHQsbG9jYWxBeGlzQSxib2R5QS5hbmdsZStNYXRoLlBJLzIpO1xuXG4gICAgICAgIEdbMF0gPSAtdFswXTtcbiAgICAgICAgR1sxXSA9IC10WzFdO1xuICAgICAgICBHWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgocmksdCkgKyB2ZWMyLmNyb3NzTGVuZ3RoKHQsZ2cpO1xuICAgICAgICBHWzNdID0gdFswXTtcbiAgICAgICAgR1s0XSA9IHRbMV07XG4gICAgICAgIEdbNV0gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJqLHQpO1xuICAgIH07XG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaCh0cmFucyk7XG5cbiAgICAvLyBSb3RhdGlvbmFsIHBhcnRcbiAgICBpZighb3B0aW9ucy5kaXNhYmxlUm90YXRpb25hbExvY2spe1xuICAgICAgICB2YXIgcm90ID0gbmV3IFJvdGF0aW9uYWxMb2NrRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcbiAgICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChyb3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiBhbmNob3IgQSByZWxhdGl2ZSB0byBhbmNob3IgQiwgYWxvbmcgdGhlIGNvbnN0cmFpbnQgYXhpcy5cbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSAwO1xuXG4gICAgLy8gSXMgdGhpcyBvbmUgdXNlZCBhdCBhbGw/XG4gICAgdGhpcy52ZWxvY2l0eSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgbG93ZXIgbGltaXQuXG4gICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IHR5cGVvZihvcHRpb25zLmxvd2VyTGltaXQpIT09XCJ1bmRlZmluZWRcIiA/IHRydWUgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSB1cHBlciBsaW1pdC5cbiAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdEVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gdHlwZW9mKG9wdGlvbnMudXBwZXJMaW1pdCkhPT1cInVuZGVmaW5lZFwiID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTG93ZXIgY29uc3RyYWludCBsaW1pdC4gVGhlIGNvbnN0cmFpbnQgcG9zaXRpb24gaXMgZm9yY2VkIHRvIGJlIGxhcmdlciB0aGFuIHRoaXMgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdCA9IHR5cGVvZihvcHRpb25zLmxvd2VyTGltaXQpIT09XCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubG93ZXJMaW1pdCA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBVcHBlciBjb25zdHJhaW50IGxpbWl0LiBUaGUgY29uc3RyYWludCBwb3NpdGlvbiBpcyBmb3JjZWQgdG8gYmUgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdCA9IHR5cGVvZihvcHRpb25zLnVwcGVyTGltaXQpIT09XCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMudXBwZXJMaW1pdCA6IDE7XG5cbiAgICAvLyBFcXVhdGlvbnMgdXNlZCBmb3IgbGltaXRzXG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbiA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIpO1xuXG4gICAgLy8gU2V0IG1heC9taW4gZm9yY2VzXG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24ubWluRm9yY2UgPSB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbi5taW5Gb3JjZSA9IDA7XG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24ubWF4Rm9yY2UgPSB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbi5tYXhGb3JjZSA9IG1heEZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogRXF1YXRpb24gdXNlZCBmb3IgdGhlIG1vdG9yLlxuICAgICAqIEBwcm9wZXJ0eSBtb3RvckVxdWF0aW9uXG4gICAgICogQHR5cGUge0VxdWF0aW9ufVxuICAgICAqL1xuICAgIHRoaXMubW90b3JFcXVhdGlvbiA9IG5ldyBFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBtb3RvciBzdGF0ZS4gRW5hYmxlIG9yIGRpc2FibGUgdGhlIG1vdG9yIHVzaW5nIC5lbmFibGVNb3RvclxuICAgICAqIEBwcm9wZXJ0eSBtb3RvckVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0YXJnZXQgc3BlZWQgZm9yIHRoZSBtb3Rvci5cbiAgICAgKiBAcHJvcGVydHkgbW90b3JTcGVlZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tb3RvclNwZWVkID0gMDtcblxuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgbW90b3JFcXVhdGlvbiA9IHRoaXMubW90b3JFcXVhdGlvbjtcbiAgICB2YXIgb2xkID0gbW90b3JFcXVhdGlvbi5jb21wdXRlR1c7XG4gICAgbW90b3JFcXVhdGlvbi5jb21wdXRlR3EgPSBmdW5jdGlvbigpeyByZXR1cm4gMDsgfTtcbiAgICBtb3RvckVxdWF0aW9uLmNvbXB1dGVHVyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICAgICAgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICAgICAgdmkgPSBiaS52ZWxvY2l0eSxcbiAgICAgICAgICAgIHZqID0gYmoudmVsb2NpdHksXG4gICAgICAgICAgICB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgICAgIHdqID0gYmouYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICByZXR1cm4gdGhpcy5nbXVsdChHLHZpLHdpLHZqLHdqKSArIHRoYXQubW90b3JTcGVlZDtcbiAgICB9O1xufVxuXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByaXNtYXRpY0NvbnN0cmFpbnQ7XG5cbnZhciB3b3JsZEF4aXNBID0gdmVjMi5jcmVhdGUoKSxcbiAgICB3b3JsZEFuY2hvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHdvcmxkQW5jaG9yQiA9IHZlYzIuY3JlYXRlKCksXG4gICAgb3JpZW50ZWRBbmNob3JBID0gdmVjMi5jcmVhdGUoKSxcbiAgICBvcmllbnRlZEFuY2hvckIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHRtcCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25zdHJhaW50IGVxdWF0aW9ucy4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBib2RpZXMgY2hhbmdlZCBwb3NpdGlvbiwgYmVmb3JlIHNvbHZpbmcuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgdHJhbnMgPSBlcXNbMF0sXG4gICAgICAgIHVwcGVyTGltaXQgPSB0aGlzLnVwcGVyTGltaXQsXG4gICAgICAgIGxvd2VyTGltaXQgPSB0aGlzLmxvd2VyTGltaXQsXG4gICAgICAgIHVwcGVyTGltaXRFcXVhdGlvbiA9IHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLFxuICAgICAgICBsb3dlckxpbWl0RXF1YXRpb24gPSB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbixcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGxvY2FsQXhpc0EgPSB0aGlzLmxvY2FsQXhpc0EsXG4gICAgICAgIGxvY2FsQW5jaG9yQSA9IHRoaXMubG9jYWxBbmNob3JBLFxuICAgICAgICBsb2NhbEFuY2hvckIgPSB0aGlzLmxvY2FsQW5jaG9yQjtcblxuICAgIHRyYW5zLnVwZGF0ZUphY29iaWFuKCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gbG9jYWwgdGhpbmdzIHRvIHdvcmxkXG4gICAgdmVjMi5yb3RhdGUod29ybGRBeGlzQSwgICAgICBsb2NhbEF4aXNBLCAgICAgIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZShvcmllbnRlZEFuY2hvckEsIGxvY2FsQW5jaG9yQSwgICAgYm9keUEuYW5nbGUpO1xuICAgIHZlYzIuYWRkKHdvcmxkQW5jaG9yQSwgICAgICAgb3JpZW50ZWRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XG4gICAgdmVjMi5yb3RhdGUob3JpZW50ZWRBbmNob3JCLCBsb2NhbEFuY2hvckIsICAgIGJvZHlCLmFuZ2xlKTtcbiAgICB2ZWMyLmFkZCh3b3JsZEFuY2hvckIsICAgICAgIG9yaWVudGVkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xuXG4gICAgdmFyIHJlbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9IHZlYzIuZG90KHdvcmxkQW5jaG9yQix3b3JsZEF4aXNBKSAtIHZlYzIuZG90KHdvcmxkQW5jaG9yQSx3b3JsZEF4aXNBKTtcblxuICAgIC8vIE1vdG9yXG4gICAgaWYodGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICAvLyBHID0gWyBhICAgICBhIHggcmkgICAtYSAgIC1hIHggcmogXVxuICAgICAgICB2YXIgRyA9IHRoaXMubW90b3JFcXVhdGlvbi5HO1xuICAgICAgICBHWzBdID0gd29ybGRBeGlzQVswXTtcbiAgICAgICAgR1sxXSA9IHdvcmxkQXhpc0FbMV07XG4gICAgICAgIEdbMl0gPSB2ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkQXhpc0Esb3JpZW50ZWRBbmNob3JCKTtcbiAgICAgICAgR1szXSA9IC13b3JsZEF4aXNBWzBdO1xuICAgICAgICBHWzRdID0gLXdvcmxkQXhpc0FbMV07XG4gICAgICAgIEdbNV0gPSAtdmVjMi5jcm9zc0xlbmd0aCh3b3JsZEF4aXNBLG9yaWVudGVkQW5jaG9yQSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgICAgTGltaXRzIHN0cmF0ZWd5OlxuICAgICAgICBBZGQgY29udGFjdCBlcXVhdGlvbiwgd2l0aCBub3JtYWwgYWxvbmcgdGhlIGNvbnN0cmFpbnQgYXhpcy5cbiAgICAgICAgbWluL21heEZvcmNlIGlzIHNldCBzbyB0aGUgY29uc3RyYWludCBpcyByZXB1bHNpdmUgaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uLlxuICAgICAgICBTb21lIG9mZnNldCBpcyBhZGRlZCB0byBlaXRoZXIgZXF1YXRpb24uY29udGFjdFBvaW50QSBvciAuY29udGFjdFBvaW50QiB0byBnZXQgdGhlIGNvcnJlY3QgdXBwZXIvbG93ZXIgbGltaXQuXG5cbiAgICAgICAgICAgICAgICAgXlxuICAgICAgICAgICAgICAgICB8XG4gICAgICB1cHBlckxpbWl0IHhcbiAgICAgICAgICAgICAgICAgfCAgICAtLS0tLS1cbiAgICAgICAgIGFuY2hvckIgeDwtLS18ICBCIHxcbiAgICAgICAgICAgICAgICAgfCAgICB8ICAgIHxcbiAgICAgICAgLS0tLS0tICAgfCAgICAtLS0tLS1cbiAgICAgICAgfCAgICB8ICAgfFxuICAgICAgICB8ICBBIHwtLT54IGFuY2hvckFcbiAgICAgICAgLS0tLS0tICAgfFxuICAgICAgICAgICAgICAgICB4IGxvd2VyTGltaXRcbiAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgIGF4aXNcbiAgICAgKi9cblxuXG4gICAgaWYodGhpcy51cHBlckxpbWl0RW5hYmxlZCAmJiByZWxQb3NpdGlvbiA+IHVwcGVyTGltaXQpe1xuICAgICAgICAvLyBVcGRhdGUgY29udGFjdCBjb25zdHJhaW50IG5vcm1hbCwgZXRjXG4gICAgICAgIHZlYzIuc2NhbGUodXBwZXJMaW1pdEVxdWF0aW9uLm5vcm1hbEEsIHdvcmxkQXhpc0EsIC0xKTtcbiAgICAgICAgdmVjMi5zdWIodXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1Yih1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qiwgd29ybGRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc2NhbGUodG1wLHdvcmxkQXhpc0EsdXBwZXJMaW1pdCk7XG4gICAgICAgIHZlYzIuYWRkKHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLHRtcCk7XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbikgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKHVwcGVyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YodXBwZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgJiYgcmVsUG9zaXRpb24gPCBsb3dlckxpbWl0KXtcbiAgICAgICAgLy8gVXBkYXRlIGNvbnRhY3QgY29uc3RyYWludCBub3JtYWwsIGV0Y1xuICAgICAgICB2ZWMyLnNjYWxlKGxvd2VyTGltaXRFcXVhdGlvbi5ub3JtYWxBLCB3b3JsZEF4aXNBLCAxKTtcbiAgICAgICAgdmVjMi5zdWIobG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1Yihsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qiwgd29ybGRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc2NhbGUodG1wLHdvcmxkQXhpc0EsbG93ZXJMaW1pdCk7XG4gICAgICAgIHZlYzIuc3ViKGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLHRtcCk7XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKGxvd2VyTGltaXRFcXVhdGlvbikgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKGxvd2VyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIHRoZSBtb3RvclxuICogQG1ldGhvZCBlbmFibGVNb3RvclxuICovXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2godGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIERpc2FibGUgdGhlIHJvdGF0aW9uYWwgbW90b3JcbiAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXG4gKi9cblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLmRpc2FibGVNb3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwxKTtcbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbnN0cmFpbnQgbGltaXRzLlxuICogQG1ldGhvZCBzZXRMaW1pdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBMb3dlciBsaW1pdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBVcHBlciBsaW1pdC5cbiAqL1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TGltaXRzID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xuICAgIGlmKHR5cGVvZihsb3dlcikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXI7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdCA9IGxvd2VyO1xuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mKHVwcGVyKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5cbn0se1wiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIyLFwiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjMsXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbExvY2tFcXVhdGlvblwiOjI1LFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0NvbnN0cmFpbnRcIjoxNX1dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24nKVxuLCAgIFJvdGF0aW9uYWxMb2NrRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbExvY2tFcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJldm9sdXRlQ29uc3RyYWludDtcblxudmFyIHdvcmxkUGl2b3RBID0gdmVjMi5jcmVhdGUoKSxcbiAgICB3b3JsZFBpdm90QiA9IHZlYzIuY3JlYXRlKCksXG4gICAgeEF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMSwwKSxcbiAgICB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpLFxuICAgIGcgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIENvbm5lY3RzIHR3byBib2RpZXMgYXQgZ2l2ZW4gb2Zmc2V0IHBvaW50cywgbGV0dGluZyB0aGVtIHJvdGF0ZSByZWxhdGl2ZSB0byBlYWNoIG90aGVyIGFyb3VuZCB0aGlzIHBvaW50LlxuICogQGNsYXNzIFJldm9sdXRlQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy53b3JsZFBpdm90XSBBIHBpdm90IHBvaW50IGdpdmVuIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBJZiBzcGVjaWZpZWQsIGxvY2FsUGl2b3RBIGFuZCBsb2NhbFBpdm90QiBhcmUgYXV0b21hdGljYWxseSBjb21wdXRlZCBmcm9tIHRoaXMgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsUGl2b3RBXSBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzIG9mIGJvZHlBIHdoaWNoIGJvZHlBIGlzIGNvbnN0cmFpbmVkIHRvLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbFBpdm90Ql0gU2VlIGxvY2FsUGl2b3RBLlxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy5tYXhGb3JjZV0gVGhlIG1heGltdW0gZm9yY2UgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBjb25zdHJhaW4gdGhlIGJvZGllcy5cbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIFRoaXMgd2lsbCBjcmVhdGUgYSByZXZvbHV0ZSBjb25zdHJhaW50IGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIHBpdm90IHBvaW50IGluIGJldHdlZW4gdGhlbS5cbiAqICAgICB2YXIgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbLTEsIDBdIH0pO1xuICogICAgIHZhciBib2R5QiA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFsxLCAwXSB9KTtcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBSZXZvbHV0ZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XG4gKiAgICAgICAgIHdvcmxkUGl2b3Q6IFswLCAwXVxuICogICAgIH0pO1xuICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG4gKlxuICogICAgIC8vIFVzaW5nIGJvZHktbG9jYWwgcGl2b3QgcG9pbnRzLCB0aGUgY29uc3RyYWludCBjb3VsZCBoYXZlIGJlZW4gY29uc3RydWN0ZWQgbGlrZSB0aGlzOlxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFJldm9sdXRlQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcbiAqICAgICAgICAgbG9jYWxQaXZvdEE6IFsxLCAwXSxcbiAqICAgICAgICAgbG9jYWxQaXZvdEI6IFstMSwgMF1cbiAqICAgICB9KTtcbiAqL1xuZnVuY3Rpb24gUmV2b2x1dGVDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIsQ29uc3RyYWludC5SRVZPTFVURSxvcHRpb25zKTtcblxuICAgIHZhciBtYXhGb3JjZSA9IHRoaXMubWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLm1heEZvcmNlIDogTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHBpdm90QVxuICAgICAqL1xuICAgIHRoaXMucGl2b3RBID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHBpdm90QlxuICAgICAqL1xuICAgIHRoaXMucGl2b3RCID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIGlmKG9wdGlvbnMud29ybGRQaXZvdCl7XG4gICAgICAgIC8vIENvbXB1dGUgcGl2b3RBIGFuZCBwaXZvdEJcbiAgICAgICAgdmVjMi5zdWIodGhpcy5waXZvdEEsIG9wdGlvbnMud29ybGRQaXZvdCwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1Yih0aGlzLnBpdm90Qiwgb3B0aW9ucy53b3JsZFBpdm90LCBib2R5Qi5wb3NpdGlvbik7XG4gICAgICAgIC8vIFJvdGF0ZSB0byBsb2NhbCBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICB2ZWMyLnJvdGF0ZSh0aGlzLnBpdm90QSwgdGhpcy5waXZvdEEsIC1ib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHRoaXMucGl2b3RCLCB0aGlzLnBpdm90QiwgLWJvZHlCLmFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgcGl2b3RBIGFuZCBwaXZvdEJcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucGl2b3RBLCBvcHRpb25zLmxvY2FsUGl2b3RBKTtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucGl2b3RCLCBvcHRpb25zLmxvY2FsUGl2b3RCKTtcbiAgICB9XG5cbiAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnMgPSBbXG4gICAgICAgIG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpLFxuICAgICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICBdO1xuXG4gICAgdmFyIHggPSBlcXNbMF07XG4gICAgdmFyIHkgPSBlcXNbMV07XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgeC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QSwgdGhhdC5waXZvdEEsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEIsIHRoYXQucGl2b3RCLCBib2R5Qi5hbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKGcsIGJvZHlCLnBvc2l0aW9uLCB3b3JsZFBpdm90Qik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgd29ybGRQaXZvdEEpO1xuICAgICAgICByZXR1cm4gdmVjMi5kb3QoZyx4QXhpcyk7XG4gICAgfTtcblxuICAgIHkuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEEsIHRoYXQucGl2b3RBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RCLCB0aGF0LnBpdm90QiwgYm9keUIuYW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZChnLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRQaXZvdEIpO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIHdvcmxkUGl2b3RBKTtcbiAgICAgICAgcmV0dXJuIHZlYzIuZG90KGcseUF4aXMpO1xuICAgIH07XG5cbiAgICB5Lm1pbkZvcmNlID0geC5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcbiAgICB5Lm1heEZvcmNlID0geC5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcblxuICAgIHRoaXMubW90b3JFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbW90b3IgaXMgZW5hYmxlZC4gVXNlIC5lbmFibGVNb3RvcigpIHRvIGVuYWJsZSB0aGUgY29uc3RyYWludCBtb3Rvci5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG1vdG9yRW5hYmxlZFxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RyYWludCBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgYW5nbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIGxvd2VyIGxpbWl0XG4gICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIHVwcGVyIGxpbWl0XG4gICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGxpbWl0IG9uIHRoZSBjb25zdHJhaW50IGFuZ2xlLlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cHBlciBsaW1pdCBvbiB0aGUgY29uc3RyYWludCBhbmdsZS5cbiAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdCA9IDA7XG5cbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbi5taW5Gb3JjZSA9IDA7XG4gICAgdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWF4Rm9yY2UgPSAwO1xufVxuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmV2b2x1dGVDb25zdHJhaW50O1xuXG4vKipcbiAqIFNldCB0aGUgY29uc3RyYWludCBhbmdsZSBsaW1pdHMuXG4gKiBAbWV0aG9kIHNldExpbWl0c1xuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIExvd2VyIGFuZ2xlIGxpbWl0LlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFVwcGVyIGFuZ2xlIGxpbWl0LlxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcbiAgICBpZih0eXBlb2YobG93ZXIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdCA9IGxvd2VyO1xuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZih1cHBlcikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xuICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib2R5QSA9ICB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9ICB0aGlzLmJvZHlCLFxuICAgICAgICBwaXZvdEEgPSB0aGlzLnBpdm90QSxcbiAgICAgICAgcGl2b3RCID0gdGhpcy5waXZvdEIsXG4gICAgICAgIGVxcyA9ICAgIHRoaXMuZXF1YXRpb25zLFxuICAgICAgICBub3JtYWwgPSBlcXNbMF0sXG4gICAgICAgIHRhbmdlbnQ9IGVxc1sxXSxcbiAgICAgICAgeCA9IGVxc1swXSxcbiAgICAgICAgeSA9IGVxc1sxXSxcbiAgICAgICAgdXBwZXJMaW1pdCA9IHRoaXMudXBwZXJMaW1pdCxcbiAgICAgICAgbG93ZXJMaW1pdCA9IHRoaXMubG93ZXJMaW1pdCxcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uID0gdGhpcy51cHBlckxpbWl0RXF1YXRpb24sXG4gICAgICAgIGxvd2VyTGltaXRFcXVhdGlvbiA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uO1xuXG4gICAgdmFyIHJlbEFuZ2xlID0gdGhpcy5hbmdsZSA9IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XG5cbiAgICBpZih0aGlzLnVwcGVyTGltaXRFbmFibGVkICYmIHJlbEFuZ2xlID4gdXBwZXJMaW1pdCl7XG4gICAgICAgIHVwcGVyTGltaXRFcXVhdGlvbi5hbmdsZSA9IHVwcGVyTGltaXQ7XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbikgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKHVwcGVyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YodXBwZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgJiYgcmVsQW5nbGUgPCBsb3dlckxpbWl0KXtcbiAgICAgICAgbG93ZXJMaW1pdEVxdWF0aW9uLmFuZ2xlID0gbG93ZXJMaW1pdDtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpe1xuICAgICAgICAgICAgZXFzLnB1c2gobG93ZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcblxuICAgIFRoZSBjb25zdHJhaW50IHZpb2xhdGlvbiBpc1xuXG4gICAgICAgIGcgPSB4aiArIHJqIC0geGkgLSByaVxuXG4gICAgLi4ud2hlcmUgeGkgYW5kIHhqIGFyZSB0aGUgYm9keSBwb3NpdGlvbnMgYW5kIHJpIGFuZCByaiB3b3JsZC1vcmllbnRlZCBvZmZzZXQgdmVjdG9ycy4gRGlmZmVyZW50aWF0ZTpcblxuICAgICAgICBnZG90ID0gdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpXG5cbiAgICBXZSBzcGxpdCB0aGlzIGludG8geCBhbmQgeSBkaXJlY3Rpb25zLiAobGV0IHggYW5kIHkgYmUgdW5pdCB2ZWN0b3JzIGFsb25nIHRoZSByZXNwZWN0aXZlIGF4ZXMpXG5cbiAgICAgICAgZ2RvdCAqIHggPSAoIHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaSApICogeFxuICAgICAgICAgICAgICAgICA9ICggdmoqeCArICh3aiB4IHJqKSp4IC12aSp4IC0od2kgeCByaSkqeFxuICAgICAgICAgICAgICAgICA9ICggdmoqeCArIChyaiB4IHgpKndqIC12aSp4IC0ocmkgeCB4KSp3aVxuICAgICAgICAgICAgICAgICA9IFsgLXggICAtKHJpIHggeCkgICB4ICAgKHJqIHggeCldICogW3ZpIHdpIHZqIHdqXVxuICAgICAgICAgICAgICAgICA9IEcqV1xuXG4gICAgLi4uYW5kIHNpbWlsYXIgZm9yIHkuIFdlIGhhdmUgdGhlbiBpZGVudGlmaWVkIHRoZSBqYWNvYmlhbiBlbnRyaWVzIGZvciB4IGFuZCB5IGRpcmVjdGlvbnM6XG5cbiAgICAgICAgR3ggPSBbIHggICAocmogeCB4KSAgIC14ICAgLShyaSB4IHgpXVxuICAgICAgICBHeSA9IFsgeSAgIChyaiB4IHkpICAgLXkgICAtKHJpIHggeSldXG5cbiAgICAgKi9cblxuICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RBLCBwaXZvdEEsIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QiwgcGl2b3RCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAvLyB0b2RvOiB0aGVzZSBhcmUgYSBiaXQgc3BhcnNlLiBXZSBjb3VsZCBzYXZlIHNvbWUgY29tcHV0YXRpb25zIG9uIG1ha2luZyBjdXN0b20gZXEuY29tcHV0ZUdXIGZ1bmN0aW9ucywgZXRjXG5cbiAgICB4LkdbMF0gPSAtMTtcbiAgICB4LkdbMV0gPSAgMDtcbiAgICB4LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aCh3b3JsZFBpdm90QSx4QXhpcyk7XG4gICAgeC5HWzNdID0gIDE7XG4gICAgeC5HWzRdID0gIDA7XG4gICAgeC5HWzVdID0gIHZlYzIuY3Jvc3NMZW5ndGgod29ybGRQaXZvdEIseEF4aXMpO1xuXG4gICAgeS5HWzBdID0gIDA7XG4gICAgeS5HWzFdID0gLTE7XG4gICAgeS5HWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgod29ybGRQaXZvdEEseUF4aXMpO1xuICAgIHkuR1szXSA9ICAwO1xuICAgIHkuR1s0XSA9ICAxO1xuICAgIHkuR1s1XSA9ICB2ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RCLHlBeGlzKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIHRoZSByb3RhdGlvbmFsIG1vdG9yXG4gKiBAbWV0aG9kIGVuYWJsZU1vdG9yXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuZW5hYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIHRoZSByb3RhdGlvbmFsIG1vdG9yXG4gKiBAbWV0aG9kIGRpc2FibGVNb3RvclxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLmRpc2FibGVNb3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwxKTtcbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgbW90b3IgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2QgbW90b3JJc0VuYWJsZWRcbiAqIEBkZXByZWNhdGVkIHVzZSBwcm9wZXJ0eSBtb3RvckVuYWJsZWQgaW5zdGVhZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUubW90b3JJc0VuYWJsZWQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIXRoaXMubW90b3JFbmFibGVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNwZWVkIG9mIHRoZSByb3RhdGlvbmFsIGNvbnN0cmFpbnQgbW90b3JcbiAqIEBtZXRob2Qgc2V0TW90b3JTcGVlZFxuICogQHBhcmFtICB7TnVtYmVyfSBzcGVlZFxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbihzcGVlZCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLmVxdWF0aW9uc1tpXS5yZWxhdGl2ZVZlbG9jaXR5ID0gc3BlZWQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3BlZWQgb2YgdGhlIHJvdGF0aW9uYWwgY29uc3RyYWludCBtb3RvclxuICogQG1ldGhvZCBnZXRNb3RvclNwZWVkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHNwZWVkLCBvciBmYWxzZSBpZiB0aGUgbW90b3IgaXMgbm90IGVuYWJsZWQuXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tb3RvckVxdWF0aW9uLnJlbGF0aXZlVmVsb2NpdHk7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxMb2NrRXF1YXRpb25cIjoyNSxcIi4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvblwiOjI2LFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0NvbnN0cmFpbnRcIjoxNX1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmdsZUxvY2tFcXVhdGlvbjtcblxuLyoqXG4gKiBMb2NrcyB0aGUgcmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0d28gYm9kaWVzLiBUaGUgY29uc3RyYWludCB0cmllcyB0byBrZWVwIHRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIHR3byB2ZWN0b3JzLCBsb2NhbCBpbiBlYWNoIGJvZHksIHRvIHplcm8uIFRoZSBsb2NhbCBhbmdsZSBpbiBib2R5IGkgaXMgYSBwYXJhbWV0ZXIuXG4gKlxuICogQGNsYXNzIEFuZ2xlTG9ja0VxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5nbGVdIEFuZ2xlIHRvIGFkZCB0byB0aGUgbG9jYWwgdmVjdG9yIGluIGJvZHkgQS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYXRpb10gR2VhciByYXRpb1xuICovXG5mdW5jdGlvbiBBbmdsZUxvY2tFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcyxib2R5QSxib2R5QiwtTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdlYXIgcmF0aW8uXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJhdGlvXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHNldFJhdGlvXG4gICAgICovXG4gICAgdGhpcy5yYXRpbyA9IHR5cGVvZihvcHRpb25zLnJhdGlvKT09PVwibnVtYmVyXCIgPyBvcHRpb25zLnJhdGlvIDogMTtcblxuICAgIHRoaXMuc2V0UmF0aW8odGhpcy5yYXRpbyk7XG59XG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFuZ2xlTG9ja0VxdWF0aW9uO1xuXG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5yYXRpbyAqIHRoaXMuYm9keUEuYW5nbGUgLSB0aGlzLmJvZHlCLmFuZ2xlICsgdGhpcy5hbmdsZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBnZWFyIHJhdGlvIGZvciB0aGlzIGVxdWF0aW9uXG4gKiBAbWV0aG9kIHNldFJhdGlvXG4gKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cbiAqL1xuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLnNldFJhdGlvID0gZnVuY3Rpb24ocmF0aW8pe1xuICAgIHZhciBHID0gdGhpcy5HO1xuICAgIEdbMl0gPSAgcmF0aW87XG4gICAgR1s1XSA9IC0xO1xuICAgIHRoaXMucmF0aW8gPSByYXRpbztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggZm9yY2UgZm9yIHRoZSBlcXVhdGlvbi5cbiAqIEBtZXRob2Qgc2V0TWF4VG9ycXVlXG4gKiBAcGFyYW0ge051bWJlcn0gdG9ycXVlXG4gKi9cbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5zZXRNYXhUb3JxdWUgPSBmdW5jdGlvbih0b3JxdWUpe1xuICAgIHRoaXMubWF4Rm9yY2UgPSAgdG9ycXVlO1xuICAgIHRoaXMubWluRm9yY2UgPSAtdG9ycXVlO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vRXF1YXRpb25cIjoyM31dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWN0RXF1YXRpb247XG5cbi8qKlxuICogTm9uLXBlbmV0cmF0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb24uIFRyaWVzIHRvIG1ha2UgdGhlIGNvbnRhY3RQb2ludEEgYW5kIGNvbnRhY3RQb2ludEIgdmVjdG9ycyBjb2luY2lkZSwgd2hpbGUga2VlcGluZyB0aGUgYXBwbGllZCBmb3JjZSByZXB1bHNpdmUuXG4gKlxuICogQGNsYXNzIENvbnRhY3RFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5mdW5jdGlvbiBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKXtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgMCwgTnVtYmVyLk1BWF9WQUxVRSk7XG5cbiAgICAvKipcbiAgICAgKiBWZWN0b3IgZnJvbSBib2R5IGkgY2VudGVyIG9mIG1hc3MgdG8gdGhlIGNvbnRhY3QgcG9pbnQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRBID0gdmVjMi5jcmVhdGUoKTtcbiAgICB0aGlzLnBlbmV0cmF0aW9uVmVjID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFdvcmxkLW9yaWVudGVkIHZlY3RvciBmcm9tIGJvZHkgQSBjZW50ZXIgb2YgbWFzcyB0byB0aGUgY29udGFjdCBwb2ludC5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RQb2ludEIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5vcm1hbCB2ZWN0b3IsIHBvaW50aW5nIG91dCBvZiBib2R5IGlcbiAgICAgKiBAcHJvcGVydHkgbm9ybWFsQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLm5vcm1hbEEgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3RpdHV0aW9uIHRvIHVzZSAoMD1ubyBib3VuY2luZXNzLCAxPW1heCBib3VuY2luZXNzKS5cbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gdHJ1ZSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBpbXBhY3QgYmV0d2VlbiB0aGUgYm9kaWVzIChub3QgcGVyc2lzdGFudCBjb250YWN0KS5cbiAgICAgKiBAcHJvcGVydHkgZmlyc3RJbXBhY3RcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmZpcnN0SW1wYWN0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY29udGFjdC5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVBXG4gICAgICogQHR5cGUge1NoYXBlfVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVBID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBpbiBib2R5IGogdGhhdCB0cmlnZ2VyZWQgdGhpcyBjb250YWN0LlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUJcbiAgICAgKiBAdHlwZSB7U2hhcGV9XG4gICAgICovXG4gICAgdGhpcy5zaGFwZUIgPSBudWxsO1xufVxuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhY3RFcXVhdGlvbjtcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICByaSA9IHRoaXMuY29udGFjdFBvaW50QSxcbiAgICAgICAgcmogPSB0aGlzLmNvbnRhY3RQb2ludEIsXG4gICAgICAgIHhpID0gYmkucG9zaXRpb24sXG4gICAgICAgIHhqID0gYmoucG9zaXRpb247XG5cbiAgICB2YXIgcGVuZXRyYXRpb25WZWMgPSB0aGlzLnBlbmV0cmF0aW9uVmVjLFxuICAgICAgICBuID0gdGhpcy5ub3JtYWxBLFxuICAgICAgICBHID0gdGhpcy5HO1xuXG4gICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXG4gICAgdmFyIHJpeG4gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJpLG4pLFxuICAgICAgICByanhuID0gdmVjMi5jcm9zc0xlbmd0aChyaixuKTtcblxuICAgIC8vIEcgPSBbLW4gLXJpeG4gbiByanhuXVxuICAgIEdbMF0gPSAtblswXTtcbiAgICBHWzFdID0gLW5bMV07XG4gICAgR1syXSA9IC1yaXhuO1xuICAgIEdbM10gPSBuWzBdO1xuICAgIEdbNF0gPSBuWzFdO1xuICAgIEdbNV0gPSByanhuO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHEgPSB4aityaiAtKHhpK3JpKSBpLmUuIHRoZSBwZW5ldHJhdGlvbiB2ZWN0b3JcbiAgICB2ZWMyLmFkZChwZW5ldHJhdGlvblZlYyx4aixyaik7XG4gICAgdmVjMi5zdWIocGVuZXRyYXRpb25WZWMscGVuZXRyYXRpb25WZWMseGkpO1xuICAgIHZlYzIuc3ViKHBlbmV0cmF0aW9uVmVjLHBlbmV0cmF0aW9uVmVjLHJpKTtcblxuICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXG4gICAgdmFyIEdXLCBHcTtcbiAgICBpZih0aGlzLmZpcnN0SW1wYWN0ICYmIHRoaXMucmVzdGl0dXRpb24gIT09IDApe1xuICAgICAgICBHcSA9IDA7XG4gICAgICAgIEdXID0gKDEvYikqKDErdGhpcy5yZXN0aXR1dGlvbikgKiB0aGlzLmNvbXB1dGVHVygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIEdxID0gdmVjMi5kb3QobixwZW5ldHJhdGlvblZlYykgKyB0aGlzLm9mZnNldDtcbiAgICAgICAgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xuICAgIH1cblxuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIHZhciBCID0gLSBHcSAqIGEgLSBHVyAqIGIgLSBoKkdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0VxdWF0aW9uXCI6MjN9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEVxdWF0aW9uO1xuXG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpLFxuICAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKSxcbiAgICBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29uc3RyYWludCBlcXVhdGlvbnMuXG4gKiBAY2xhc3MgRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QSBGaXJzdCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCIFNlY29uZCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGVxdWF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbWluRm9yY2UgTWluaW11bSBmb3JjZSB0byBhcHBseS4gRGVmYXVsdDogLU51bWJlci5NQVhfVkFMVUVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGb3JjZSBNYXhpbXVtIGZvcmNlIHRvIGFwcGx5LiBEZWZhdWx0OiBOdW1iZXIuTUFYX1ZBTFVFXG4gKi9cbmZ1bmN0aW9uIEVxdWF0aW9uKGJvZHlBLCBib2R5QiwgbWluRm9yY2UsIG1heEZvcmNlKXtcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gZm9yY2UgdG8gYXBwbHkgd2hlbiBzb2x2aW5nLlxuICAgICAqIEBwcm9wZXJ0eSBtaW5Gb3JjZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5taW5Gb3JjZSA9IHR5cGVvZihtaW5Gb3JjZSk9PT1cInVuZGVmaW5lZFwiID8gLU51bWJlci5NQVhfVkFMVUUgOiBtaW5Gb3JjZTtcblxuICAgIC8qKlxuICAgICAqIE1heCBmb3JjZSB0byBhcHBseSB3aGVuIHNvbHZpbmcuXG4gICAgICogQHByb3BlcnR5IG1heEZvcmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heEZvcmNlID0gdHlwZW9mKG1heEZvcmNlKT09PVwidW5kZWZpbmVkXCIgPyBOdW1iZXIuTUFYX1ZBTFVFIDogbWF4Rm9yY2U7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbnN0cmFpbnRcbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb25zdHJhaW50XG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0aWZmbmVzcyBvZiB0aGlzIGVxdWF0aW9uLiBUeXBpY2FsbHkgY2hvc2VuIHRvIGEgbGFyZ2UgbnVtYmVyICh+MWU3KSwgYnV0IGNhbiBiZSBjaG9zZW4gc29tZXdoYXQgZnJlZWx5IHRvIGdldCBhIHN0YWJsZSBzaW11bGF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRpbWUgc3RlcHMgbmVlZGVkIHRvIHN0YWJpbGl6ZSB0aGUgY29uc3RyYWludCBlcXVhdGlvbi4gVHlwaWNhbGx5IGJldHdlZW4gMyBhbmQgNSB0aW1lIHN0ZXBzLlxuICAgICAqIEBwcm9wZXJ0eSByZWxheGF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbGF4YXRpb24gPSBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBUaGUgSmFjb2JpYW4gZW50cnkgb2YgdGhpcyBlcXVhdGlvbi4gNiBudW1iZXJzLCAzIHBlciBib2R5ICh4LHksYW5nbGUpLlxuICAgICAqIEBwcm9wZXJ0eSBHXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuRyA9IG5ldyBVdGlscy5BUlJBWV9UWVBFKDYpO1xuICAgIGZvcih2YXIgaT0wOyBpPDY7IGkrKyl7XG4gICAgICAgIHRoaXMuR1tpXT0wO1xuICAgIH1cblxuICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuYSA9IDA7XG4gICAgdGhpcy5iID0gMDtcbiAgICB0aGlzLmVwc2lsb24gPSAwO1xuICAgIHRoaXMudGltZVN0ZXAgPSAxLzYwO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHN0aWZmbmVzcyBvciByZWxheGF0aW9uIHdhcyBjaGFuZ2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbmVlZHNVcGRhdGVcbiAgICAgKi9cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcgY29uc3RyYWludCBtdWx0aXBsaWVyIGZyb20gdGhlIGxhc3Qgc29sdmUuIFRoaXMgaXMgbW9zdGx5IGVxdWl2YWxlbnQgdG8gdGhlIGZvcmNlIHByb2R1Y2VkIGJ5IHRoZSBjb25zdHJhaW50LlxuICAgICAqIEBwcm9wZXJ0eSBtdWx0aXBsaWVyXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm11bHRpcGxpZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgdmVsb2NpdHkuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJlbGF0aXZlVmVsb2NpdHlcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF0aXZlVmVsb2NpdHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGVxdWF0aW9uIGlzIGVuYWJsZWQgb3Igbm90LiBJZiB0cnVlLCBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzb2x2ZXIuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBlbmFibGVkXG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbn1cbkVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVxdWF0aW9uO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0aWZmbmVzcyB3aGVuIGNyZWF0aW5nIGEgbmV3IEVxdWF0aW9uLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IERFRkFVTFRfU1RJRkZORVNTXG4gKiBAZGVmYXVsdCAxZTZcbiAqL1xuRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1MgPSAxZTY7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgcmVsYXhhdGlvbiB3aGVuIGNyZWF0aW5nIGEgbmV3IEVxdWF0aW9uLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IERFRkFVTFRfUkVMQVhBVElPTlxuICogQGRlZmF1bHQgNFxuICovXG5FcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT04gPSA0O1xuXG4vKipcbiAqIENvbXB1dGUgU1BPT0sgcGFyYW1ldGVycyAuYSwgLmIgYW5kIC5lcHNpbG9uIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYXJhbWV0ZXJzLiBTZWUgZXF1YXRpb25zIDksIDEwIGFuZCAxMSBpbiB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3c4LmNzLnVtdS5zZS9rdXJzZXIvNURWMDU4L1ZUMDkvbGVjdHVyZXMvc3Bvb2tub3Rlcy5wZGZcIj5TUE9PSyBub3RlczwvYT4uXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5yZWxheGF0aW9uLFxuICAgICAgICBoID0gdGhpcy50aW1lU3RlcDtcblxuICAgIHRoaXMuYSA9IDQuMCAvIChoICogKDEgKyA0ICogZCkpO1xuICAgIHRoaXMuYiA9ICg0LjAgKiBkKSAvICgxICsgNCAqIGQpO1xuICAgIHRoaXMuZXBzaWxvbiA9IDQuMCAvIChoICogaCAqIGsgKiAoMSArIDQgKiBkKSk7XG5cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGEgamFjb2JpYW4gZW50cnkgd2l0aCBjb3JyZXNwb25kaW5nIHBvc2l0aW9ucyBvciB2ZWxvY2l0aWVzXG4gKiBAbWV0aG9kIGdtdWx0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5nbXVsdCA9IGZ1bmN0aW9uKEcsdmksd2ksdmosd2ope1xuICAgIHJldHVybiAgR1swXSAqIHZpWzBdICtcbiAgICAgICAgICAgIEdbMV0gKiB2aVsxXSArXG4gICAgICAgICAgICBHWzJdICogd2kgK1xuICAgICAgICAgICAgR1szXSAqIHZqWzBdICtcbiAgICAgICAgICAgIEdbNF0gKiB2alsxXSArXG4gICAgICAgICAgICBHWzVdICogd2o7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBSSFMgb2YgdGhlIFNQT09LIGVxdWF0aW9uXG4gKiBAbWV0aG9kIGNvbXB1dGVCXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xuICAgIHZhciBHcSA9IHRoaXMuY29tcHV0ZUdxKCk7XG4gICAgdmFyIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG4gICAgcmV0dXJuIC0gR3EgKiBhIC0gR1cgKiBiIC0gR2lNZipoO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqcSwgd2hlcmUgcSBhcmUgdGhlIGdlbmVyYWxpemVkIGJvZHkgY29vcmRpbmF0ZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdxXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZhciBxaSA9IHZlYzIuY3JlYXRlKCksXG4gICAgcWogPSB2ZWMyLmNyZWF0ZSgpO1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEcgPSB0aGlzLkcsXG4gICAgICAgIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICB4aSA9IGJpLnBvc2l0aW9uLFxuICAgICAgICB4aiA9IGJqLnBvc2l0aW9uLFxuICAgICAgICBhaSA9IGJpLmFuZ2xlLFxuICAgICAgICBhaiA9IGJqLmFuZ2xlO1xuXG4gICAgcmV0dXJuIHRoaXMuZ211bHQoRywgcWksIGFpLCBxaiwgYWopICsgdGhpcy5vZmZzZXQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCpXLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzXG4gKiBAbWV0aG9kIGNvbXB1dGVHV1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdXID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHZpID0gYmkudmVsb2NpdHksXG4gICAgICAgIHZqID0gYmoudmVsb2NpdHksXG4gICAgICAgIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICByZXR1cm4gdGhpcy5nbXVsdChHLHZpLHdpLHZqLHdqKSArIHRoaXMucmVsYXRpdmVWZWxvY2l0eTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgR1xcKldsYW1iZGEsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdXbGFtYmRhXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1dsYW1iZGEgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgdmkgPSBiaS52bGFtYmRhLFxuICAgICAgICB2aiA9IGJqLnZsYW1iZGEsXG4gICAgICAgIHdpID0gYmkud2xhbWJkYSxcbiAgICAgICAgd2ogPSBiai53bGFtYmRhO1xuICAgIHJldHVybiB0aGlzLmdtdWx0KEcsdmksd2ksdmosd2opO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqaW52KE0pXFwqZiwgd2hlcmUgTSBpcyB0aGUgbWFzcyBtYXRyaXggd2l0aCBkaWFnb25hbCBibG9ja3MgZm9yIGVhY2ggYm9keSwgYW5kIGYgYXJlIHRoZSBmb3JjZXMgb24gdGhlIGJvZGllcy5cbiAqIEBtZXRob2QgY29tcHV0ZUdpTWZcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIGlNZmkgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGlNZmogPSB2ZWMyLmNyZWF0ZSgpO1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1mID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGZpID0gYmkuZm9yY2UsXG4gICAgICAgIHRpID0gYmkuYW5ndWxhckZvcmNlLFxuICAgICAgICBmaiA9IGJqLmZvcmNlLFxuICAgICAgICB0aiA9IGJqLmFuZ3VsYXJGb3JjZSxcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZJaSA9IGJpLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIEcgPSB0aGlzLkc7XG5cbiAgICB2ZWMyLnNjYWxlKGlNZmksIGZpLGludk1hc3NpKTtcbiAgICB2ZWMyLnNjYWxlKGlNZmosIGZqLGludk1hc3NqKTtcblxuICAgIHJldHVybiB0aGlzLmdtdWx0KEcsaU1maSx0aSppbnZJaSxpTWZqLHRqKmludklqKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgR1xcKmludihNKVxcKkcnXG4gKiBAbWV0aG9kIGNvbXB1dGVHaU1HdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdpTUd0ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52SWkgPSBiaS5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIGludklqID0gYmouaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBHID0gdGhpcy5HO1xuXG4gICAgcmV0dXJuICBHWzBdICogR1swXSAqIGludk1hc3NpICtcbiAgICAgICAgICAgIEdbMV0gKiBHWzFdICogaW52TWFzc2kgK1xuICAgICAgICAgICAgR1syXSAqIEdbMl0gKiAgICBpbnZJaSArXG4gICAgICAgICAgICBHWzNdICogR1szXSAqIGludk1hc3NqICtcbiAgICAgICAgICAgIEdbNF0gKiBHWzRdICogaW52TWFzc2ogK1xuICAgICAgICAgICAgR1s1XSAqIEdbNV0gKiAgICBpbnZJajtcbn07XG5cbnZhciBhZGRUb1dsYW1iZGFfdGVtcCA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX0dpID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfR2ogPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9yaSA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX3JqID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfTWRpYWcgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEFkZCBjb25zdHJhaW50IHZlbG9jaXR5IHRvIHRoZSBib2RpZXMuXG4gKiBAbWV0aG9kIGFkZFRvV2xhbWJkYVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhbGFtYmRhXG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5hZGRUb1dsYW1iZGEgPSBmdW5jdGlvbihkZWx0YWxhbWJkYSl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICB0ZW1wID0gYWRkVG9XbGFtYmRhX3RlbXAsXG4gICAgICAgIEdpID0gYWRkVG9XbGFtYmRhX0dpLFxuICAgICAgICBHaiA9IGFkZFRvV2xhbWJkYV9HaixcbiAgICAgICAgcmkgPSBhZGRUb1dsYW1iZGFfcmksXG4gICAgICAgIHJqID0gYWRkVG9XbGFtYmRhX3JqLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBpbnZJaiA9IGJqLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgTWRpYWcgPSBhZGRUb1dsYW1iZGFfTWRpYWcsXG4gICAgICAgIEcgPSB0aGlzLkc7XG5cbiAgICBHaVswXSA9IEdbMF07XG4gICAgR2lbMV0gPSBHWzFdO1xuICAgIEdqWzBdID0gR1szXTtcbiAgICBHalsxXSA9IEdbNF07XG5cbiAgICAvLyBBZGQgdG8gbGluZWFyIHZlbG9jaXR5XG4gICAgLy8gdl9sYW1iZGEgKz0gaW52KE0pICogZGVsdGFfbGFtYmEgKiBHXG4gICAgdmVjMi5zY2FsZSh0ZW1wLCBHaSwgaW52TWFzc2kqZGVsdGFsYW1iZGEpO1xuICAgIHZlYzIuYWRkKCBiaS52bGFtYmRhLCBiaS52bGFtYmRhLCB0ZW1wKTtcbiAgICAvLyBUaGlzIGltcHVsc2UgaXMgaW4gdGhlIG9mZnNldCBmcmFtZVxuICAgIC8vIEFsc28gYWRkIGNvbnRyaWJ1dGlvbiB0byBhbmd1bGFyXG4gICAgLy9iaS53bGFtYmRhIC09IHZlYzIuY3Jvc3NMZW5ndGgodGVtcCxyaSk7XG4gICAgYmkud2xhbWJkYSArPSBpbnZJaSAqIEdbMl0gKiBkZWx0YWxhbWJkYTtcblxuXG4gICAgdmVjMi5zY2FsZSh0ZW1wLCBHaiwgaW52TWFzc2oqZGVsdGFsYW1iZGEpO1xuICAgIHZlYzIuYWRkKCBiai52bGFtYmRhLCBiai52bGFtYmRhLCB0ZW1wKTtcbiAgICAvL2JqLndsYW1iZGEgLT0gdmVjMi5jcm9zc0xlbmd0aCh0ZW1wLHJqKTtcbiAgICBiai53bGFtYmRhICs9IGludklqICogR1s1XSAqIGRlbHRhbGFtYmRhO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBkZW5vbWluYXRvciBwYXJ0IG9mIHRoZSBTUE9PSyBlcXVhdGlvbjogQyA9IEdcXCppbnYoTSlcXCpHJyArIGVwc1xuICogQG1ldGhvZCBjb21wdXRlSW52Q1xuICogQHBhcmFtICB7TnVtYmVyfSBlcHNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVJbnZDID0gZnVuY3Rpb24oZXBzKXtcbiAgICByZXR1cm4gMS4wIC8gKHRoaXMuY29tcHV0ZUdpTUd0KCkgKyBlcHMpO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL29iamVjdHMvQm9keVwiOjMyLFwiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4vRXF1YXRpb24nKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGcmljdGlvbkVxdWF0aW9uO1xuXG4vKipcbiAqIENvbnN0cmFpbnMgdGhlIHNsaXBwaW5nIGluIGEgY29udGFjdCBhbG9uZyBhIHRhbmdlbnRcbiAqXG4gKiBAY2xhc3MgRnJpY3Rpb25FcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge051bWJlcn0gc2xpcEZvcmNlXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKXtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgLXNsaXBGb3JjZSwgc2xpcEZvcmNlKTtcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHZlY3RvciBmcm9tIGNlbnRlciBvZiBib2R5IEEgdG8gdGhlIGNvbnRhY3QgcG9pbnQsIHdvcmxkIG9yaWVudGVkLlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFBvaW50QSA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSB2ZWN0b3IgZnJvbSBjZW50ZXIgb2YgYm9keSBCIHRvIHRoZSBjb250YWN0IHBvaW50LCB3b3JsZCBvcmllbnRlZC5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RQb2ludEIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGFuZ2VudCB2ZWN0b3IgdGhhdCB0aGUgZnJpY3Rpb24gZm9yY2Ugd2lsbCBhY3QgYWxvbmcuIFdvcmxkIG9yaWVudGVkLlxuICAgICAqIEBwcm9wZXJ0eSB0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudCA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBBIENvbnRhY3RFcXVhdGlvbiBjb25uZWN0ZWQgdG8gdGhpcyBmcmljdGlvbi4gVGhlIGNvbnRhY3QgZXF1YXRpb25zIGNhbiBiZSB1c2VkIHRvIHJlc2NhbGUgdGhlIG1heCBmb3JjZSBmb3IgdGhlIGZyaWN0aW9uLiBJZiBtb3JlIHRoYW4gb25lIGNvbnRhY3QgZXF1YXRpb24gaXMgZ2l2ZW4sIHRoZW4gdGhlIG1heCBmb3JjZSBjYW4gYmUgc2V0IHRvIHRoZSBhdmVyYWdlLlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0RXF1YXRpb25zXG4gICAgICogQHR5cGUge0NvbnRhY3RFcXVhdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBpbiBib2R5IGkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmcmljdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVBXG4gICAgICogQHR5cGUge1NoYXBlfVxuICAgICAqIEB0b2RvIE5lZWRlZD8gVGhlIHNoYXBlIGNhbiBiZSBsb29rZWQgdXAgdmlhIGNvbnRhY3RFcXVhdGlvbi5zaGFwZUEuLi5cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBqIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnJpY3Rpb24uXG4gICAgICogQHByb3BlcnR5IHNoYXBlQlxuICAgICAqIEB0eXBlIHtTaGFwZX1cbiAgICAgKiBAdG9kbyBOZWVkZWQ/IFRoZSBzaGFwZSBjYW4gYmUgbG9va2VkIHVwIHZpYSBjb250YWN0RXF1YXRpb24uc2hhcGVCLi4uXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyaWN0aW9uIGNvZWZmaWNpZW50IHRvIHVzZS5cbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25Db2VmZmljaWVudFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkNvZWZmaWNpZW50ID0gMC4zO1xufVxuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJpY3Rpb25FcXVhdGlvbjtcblxuLyoqXG4gKiBTZXQgdGhlIHNsaXBwaW5nIGNvbmRpdGlvbiBmb3IgdGhlIGNvbnN0cmFpbnQuIFRoZSBmcmljdGlvbiBmb3JjZSBjYW5ub3QgYmVcbiAqIGxhcmdlciB0aGFuIHRoaXMgdmFsdWUuXG4gKiBAbWV0aG9kIHNldFNsaXBGb3JjZVxuICogQHBhcmFtICB7TnVtYmVyfSBzbGlwRm9yY2VcbiAqL1xuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuc2V0U2xpcEZvcmNlID0gZnVuY3Rpb24oc2xpcEZvcmNlKXtcbiAgICB0aGlzLm1heEZvcmNlID0gc2xpcEZvcmNlO1xuICAgIHRoaXMubWluRm9yY2UgPSAtc2xpcEZvcmNlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1heCBmb3JjZSBmb3IgdGhlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIGdldFNsaXBGb3JjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5nZXRTbGlwRm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLm1heEZvcmNlO1xufTtcblxuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICByaSA9IHRoaXMuY29udGFjdFBvaW50QSxcbiAgICAgICAgcmogPSB0aGlzLmNvbnRhY3RQb2ludEIsXG4gICAgICAgIHQgPSB0aGlzLnQsXG4gICAgICAgIEcgPSB0aGlzLkc7XG5cbiAgICAvLyBHID0gWy10IC1yaXh0IHQgcmp4dF1cbiAgICAvLyBBbmQgcmVtZW1iZXIsIHRoaXMgaXMgYSBwdXJlIHZlbG9jaXR5IGNvbnN0cmFpbnQsIGcgaXMgYWx3YXlzIHplcm8hXG4gICAgR1swXSA9IC10WzBdO1xuICAgIEdbMV0gPSAtdFsxXTtcbiAgICBHWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgocmksdCk7XG4gICAgR1szXSA9IHRbMF07XG4gICAgR1s0XSA9IHRbMV07XG4gICAgR1s1XSA9IHZlYzIuY3Jvc3NMZW5ndGgocmosdCk7XG5cbiAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpLFxuICAgICAgICBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuXG4gICAgdmFyIEIgPSAvKiAtIGcgKiBhICAqLyAtIEdXICogYiAtIGgqR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3V0aWxzL1V0aWxzXCI6NTAsXCIuL0VxdWF0aW9uXCI6MjN9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKFwiLi9FcXVhdGlvblwiKSxcbiAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUm90YXRpb25hbExvY2tFcXVhdGlvbjtcblxuLyoqXG4gKiBMb2NrcyB0aGUgcmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0d28gYm9kaWVzLiBUaGUgY29uc3RyYWludCB0cmllcyB0byBrZWVwIHRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIHR3byB2ZWN0b3JzLCBsb2NhbCBpbiBlYWNoIGJvZHksIHRvIHplcm8uIFRoZSBsb2NhbCBhbmdsZSBpbiBib2R5IGkgaXMgYSBwYXJhbWV0ZXIuXG4gKlxuICogQGNsYXNzIFJvdGF0aW9uYWxMb2NrRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZV0gQW5nbGUgdG8gYWRkIHRvIHRoZSBsb2NhbCB2ZWN0b3IgaW4gYm9keUEuXG4gKi9cbmZ1bmN0aW9uIFJvdGF0aW9uYWxMb2NrRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgLU51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGUgfHwgMDtcblxuICAgIHZhciBHID0gdGhpcy5HO1xuICAgIEdbMl0gPSAgMTtcbiAgICBHWzVdID0gLTE7XG59XG5Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuUm90YXRpb25hbExvY2tFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uO1xuXG52YXIgd29ybGRWZWN0b3JBID0gdmVjMi5jcmVhdGUoKSxcbiAgICB3b3JsZFZlY3RvckIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHhBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDEsMCksXG4gICAgeUF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwxKTtcblJvdGF0aW9uYWxMb2NrRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgdmVjMi5yb3RhdGUod29ybGRWZWN0b3JBLHhBeGlzLHRoaXMuYm9keUEuYW5nbGUrdGhpcy5hbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUod29ybGRWZWN0b3JCLHlBeGlzLHRoaXMuYm9keUIuYW5nbGUpO1xuICAgIHJldHVybiB2ZWMyLmRvdCh3b3JsZFZlY3RvckEsd29ybGRWZWN0b3JCKTtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0VxdWF0aW9uXCI6MjN9XSwyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKFwiLi9FcXVhdGlvblwiKSxcbiAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb247XG5cbi8qKlxuICogU3luY3Mgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0d28gYm9kaWVzLCBvciBzZXRzIGEgcmVsYXRpdmUgdmVsb2NpdHkgKG1vdG9yKS5cbiAqXG4gKiBAY2xhc3MgUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24oYm9keUEsIGJvZHlCKXtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgLU51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgIHRoaXMucmVsYXRpdmVWZWxvY2l0eSA9IDE7XG4gICAgdGhpcy5yYXRpbyA9IDE7XG59XG5Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcblJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uO1xuUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oYSxiLGgpe1xuICAgIHZhciBHID0gdGhpcy5HO1xuICAgIEdbMl0gPSAtMTtcbiAgICBHWzVdID0gdGhpcy5yYXRpbztcblxuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCk7XG4gICAgdmFyIEIgPSAtIEdXICogYiAtIGgqR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vRXF1YXRpb25cIjoyM31dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igb2JqZWN0cyB0aGF0IGRpc3BhdGNoZXMgZXZlbnRzLlxuICogQGNsYXNzIEV2ZW50RW1pdHRlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IEV2ZW50RW1pdHRlcixcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lclxuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciwgY29udGV4dCApIHtcbiAgICAgICAgbGlzdGVuZXIuY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGV2ZW50IGxpc3RlbmVyIGlzIGFkZGVkXG4gICAgICogQG1ldGhvZCBoYXNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhczogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmKGxpc3RlbmVyKXtcbiAgICAgICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDEgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lclxuICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApO1xuICAgICAgICBpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5zcGxpY2UoIGluZGV4LCAxICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVtaXQgYW4gZXZlbnQuXG4gICAgICogQG1ldGhvZCBlbWl0XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBldmVudFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnQudHlwZVxuICAgICAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XG4gICAgICAgIGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGxpc3RlbmVyQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckFycmF5WyBpIF07XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCggbGlzdGVuZXIuY29udGV4dCwgZXZlbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG59LHt9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTWF0ZXJpYWwgPSBfZGVyZXFfKCcuL01hdGVyaWFsJyk7XG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWN0TWF0ZXJpYWw7XG5cbi8qKlxuICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB0d28gbWF0ZXJpYWxzIG1lZXQsIHN1Y2ggYXMgd2hhdCBmcmljdGlvbiBjb2VmZmljaWVudCB0byB1c2UuIFlvdSBjYW4gYWxzbyBzZXQgb3RoZXIgdGhpbmdzIHN1Y2ggYXMgcmVzdGl0dXRpb24sIHN1cmZhY2UgdmVsb2NpdHkgYW5kIGNvbnN0cmFpbnQgcGFyYW1ldGVycy5cbiAqIEBjbGFzcyBDb250YWN0TWF0ZXJpYWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxBXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEJcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuZnJpY3Rpb249MC4zXSAgICAgICBGcmljdGlvbiBjb2VmZmljaWVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnJlc3RpdHV0aW9uPTBdICAgICAgUmVzdGl0dXRpb24gY29lZmZpY2llbnQgYWthIFwiYm91bmNpbmVzc1wiLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuc3RpZmZuZXNzXSAgICAgICAgICBDb250YWN0RXF1YXRpb24gc3RpZmZuZXNzLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMucmVsYXhhdGlvbl0gICAgICAgICBDb250YWN0RXF1YXRpb24gcmVsYXhhdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLmZyaWN0aW9uU3RpZmZuZXNzXSAgRnJpY3Rpb25FcXVhdGlvbiBzdGlmZm5lc3MuXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5mcmljdGlvblJlbGF4YXRpb25dIEZyaWN0aW9uRXF1YXRpb24gcmVsYXhhdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnN1cmZhY2VWZWxvY2l0eT0wXSAgU3VyZmFjZSB2ZWxvY2l0eS5cbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gQ29udGFjdE1hdGVyaWFsKG1hdGVyaWFsQSwgbWF0ZXJpYWxCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmKCEobWF0ZXJpYWxBIGluc3RhbmNlb2YgTWF0ZXJpYWwpIHx8ICEobWF0ZXJpYWxCIGluc3RhbmNlb2YgTWF0ZXJpYWwpKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgdHdvIGFyZ3VtZW50cyBtdXN0IGJlIE1hdGVyaWFsIGluc3RhbmNlcy5cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRhY3QgbWF0ZXJpYWwgaWRlbnRpZmllclxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IENvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIrKztcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IG1hdGVyaWFsIHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbnRhY3QgbWF0ZXJpYWxcbiAgICAgKiBAcHJvcGVydHkgbWF0ZXJpYWxBXG4gICAgICogQHR5cGUge01hdGVyaWFsfVxuICAgICAqL1xuICAgIHRoaXMubWF0ZXJpYWxBID0gbWF0ZXJpYWxBO1xuXG4gICAgLyoqXG4gICAgICogU2Vjb25kIG1hdGVyaWFsIHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbnRhY3QgbWF0ZXJpYWxcbiAgICAgKiBAcHJvcGVydHkgbWF0ZXJpYWxCXG4gICAgICogQHR5cGUge01hdGVyaWFsfVxuICAgICAqL1xuICAgIHRoaXMubWF0ZXJpYWxCID0gbWF0ZXJpYWxCO1xuXG4gICAgLyoqXG4gICAgICogRnJpY3Rpb24gdG8gdXNlIGluIHRoZSBjb250YWN0IG9mIHRoZXNlIHR3byBtYXRlcmlhbHNcbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb24gICAgPSAgdHlwZW9mKG9wdGlvbnMuZnJpY3Rpb24pICAgICE9PSBcInVuZGVmaW5lZFwiID8gICBOdW1iZXIob3B0aW9ucy5mcmljdGlvbikgICAgOiAwLjM7XG5cbiAgICAvKipcbiAgICAgKiBSZXN0aXR1dGlvbiB0byB1c2UgaW4gdGhlIGNvbnRhY3Qgb2YgdGhlc2UgdHdvIG1hdGVyaWFsc1xuICAgICAqIEBwcm9wZXJ0eSByZXN0aXR1dGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9ICB0eXBlb2Yob3B0aW9ucy5yZXN0aXR1dGlvbikgIT09IFwidW5kZWZpbmVkXCIgPyAgIE51bWJlcihvcHRpb25zLnJlc3RpdHV0aW9uKSA6IDAuMDtcblxuICAgIC8qKlxuICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgcmVzdWx0aW5nIENvbnRhY3RFcXVhdGlvbiB0aGF0IHRoaXMgQ29udGFjdE1hdGVyaWFsIGdlbmVyYXRlXG4gICAgICogQHByb3BlcnR5IHN0aWZmbmVzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdGlmZm5lc3MgPSAgICAgICAgICAgIHR5cGVvZihvcHRpb25zLnN0aWZmbmVzcykgICAgICAgICAgICE9PSBcInVuZGVmaW5lZFwiID8gICBOdW1iZXIob3B0aW9ucy5zdGlmZm5lc3MpICAgOiBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFJlbGF4YXRpb24gb2YgdGhlIHJlc3VsdGluZyBDb250YWN0RXF1YXRpb24gdGhhdCB0aGlzIENvbnRhY3RNYXRlcmlhbCBnZW5lcmF0ZVxuICAgICAqIEBwcm9wZXJ0eSByZWxheGF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbGF4YXRpb24gPSAgICAgICAgICAgdHlwZW9mKG9wdGlvbnMucmVsYXhhdGlvbikgICAgICAgICAgIT09IFwidW5kZWZpbmVkXCIgPyAgIE51bWJlcihvcHRpb25zLnJlbGF4YXRpb24pICA6IEVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTjtcblxuICAgIC8qKlxuICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgcmVzdWx0aW5nIEZyaWN0aW9uRXF1YXRpb24gdGhhdCB0aGlzIENvbnRhY3RNYXRlcmlhbCBnZW5lcmF0ZVxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblN0aWZmbmVzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblN0aWZmbmVzcyA9ICAgIHR5cGVvZihvcHRpb25zLmZyaWN0aW9uU3RpZmZuZXNzKSAgICE9PSBcInVuZGVmaW5lZFwiID8gICBOdW1iZXIob3B0aW9ucy5mcmljdGlvblN0aWZmbmVzcykgICA6IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXhhdGlvbiBvZiB0aGUgcmVzdWx0aW5nIEZyaWN0aW9uRXF1YXRpb24gdGhhdCB0aGlzIENvbnRhY3RNYXRlcmlhbCBnZW5lcmF0ZVxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblJlbGF4YXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25SZWxheGF0aW9uID0gICB0eXBlb2Yob3B0aW9ucy5mcmljdGlvblJlbGF4YXRpb24pICAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMuZnJpY3Rpb25SZWxheGF0aW9uKSAgOiBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGFkZCBzdXJmYWNlIHZlbG9jaXR5IHRvIHRoaXMgbWF0ZXJpYWwuIElmIGJvZHlBIHJlc3RzIG9uIHRvcCBpZiBib2R5QiwgYW5kIHRoZSBzdXJmYWNlIHZlbG9jaXR5IGlzIHBvc2l0aXZlLCBib2R5QSB3aWxsIHNsaWRlIHRvIHRoZSByaWdodC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3VyZmFjZVZlbG9jaXR5XG4gICAgICovXG4gICAgdGhpcy5zdXJmYWNlVmVsb2NpdHkgPSB0eXBlb2Yob3B0aW9ucy5zdXJmYWNlVmVsb2NpdHkpICAgICE9PSBcInVuZGVmaW5lZFwiID8gICBOdW1iZXIob3B0aW9ucy5zdXJmYWNlVmVsb2NpdHkpICAgIDogMDtcblxuICAgIC8qKlxuICAgICAqIE9mZnNldCB0byBiZSBzZXQgb24gQ29udGFjdEVxdWF0aW9ucy4gQSBwb3NpdGl2ZSB2YWx1ZSB3aWxsIG1ha2UgdGhlIGJvZGllcyBwZW5ldHJhdGUgbW9yZSBpbnRvIGVhY2ggb3RoZXIuIENhbiBiZSB1c2VmdWwgaW4gc2NlbmVzIHdoZXJlIGNvbnRhY3RzIG5lZWQgdG8gYmUgbW9yZSBwZXJzaXN0ZW50LCBmb3IgZXhhbXBsZSB3aGVuIHN0YWNraW5nLiBBa2EgXCJjdXJlIGZvciBuZXJ2b3VzIGNvbnRhY3RzXCIuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RTa2luU2l6ZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0U2tpblNpemUgPSAwLjAwNTtcbn1cblxuQ29udGFjdE1hdGVyaWFsLmlkQ291bnRlciA9IDA7XG5cbn0se1wiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjMsXCIuL01hdGVyaWFsXCI6Mjl9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IE1hdGVyaWFsO1xuXG4vKipcbiAqIERlZmluZXMgYSBwaHlzaWNzIG1hdGVyaWFsLlxuICogQGNsYXNzIE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBNYXRlcmlhbCBpZGVudGlmaWVyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIE1hdGVyaWFsKGlkKXtcbiAgICAvKipcbiAgICAgKiBUaGUgbWF0ZXJpYWwgaWRlbnRpZmllclxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGlkIHx8IE1hdGVyaWFsLmlkQ291bnRlcisrO1xufVxuXG5NYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xuXG59LHt9XSwzMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbiAgICAvKlxuICAgICAgICBQb2x5SyBsaWJyYXJ5XG4gICAgICAgIHVybDogaHR0cDovL3BvbHlrLml2YW5rLm5ldFxuICAgICAgICBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5jZS5cblxuICAgICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgSXZhbiBLdWNraXJcblxuICAgICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgICAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICAgICAgICBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAgICAgICAgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gICAgICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICAgICAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICAgICAgICBjb25kaXRpb25zOlxuXG4gICAgICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICAgICAgICBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgICAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICAgICAgICBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAgICAgICAgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gICAgICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAgICAgICAgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgICovXG5cbiAgICB2YXIgUG9seUsgPSB7fTtcblxuICAgIC8qXG4gICAgICAgIElzIFBvbHlnb24gc2VsZi1pbnRlcnNlY3Rpbmc/XG5cbiAgICAgICAgTyhuXjIpXG4gICAgKi9cbiAgICAvKlxuICAgIFBvbHlLLklzU2ltcGxlID0gZnVuY3Rpb24ocClcbiAgICB7XG4gICAgICAgIHZhciBuID0gcC5sZW5ndGg+PjE7XG4gICAgICAgIGlmKG48NCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBhMSA9IG5ldyBQb2x5Sy5fUCgpLCBhMiA9IG5ldyBQb2x5Sy5fUCgpO1xuICAgICAgICB2YXIgYjEgPSBuZXcgUG9seUsuX1AoKSwgYjIgPSBuZXcgUG9seUsuX1AoKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgUG9seUsuX1AoKTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGExLnggPSBwWzIqaSAgXTtcbiAgICAgICAgICAgIGExLnkgPSBwWzIqaSsxXTtcbiAgICAgICAgICAgIGlmKGk9PW4tMSkgIHsgYTIueCA9IHBbMCAgICBdOyAgYTIueSA9IHBbMSAgICBdOyB9XG4gICAgICAgICAgICBlbHNlICAgICAgICB7IGEyLnggPSBwWzIqaSsyXTsgIGEyLnkgPSBwWzIqaSszXTsgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGo9MDsgajxuOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoaS1qKSA8IDIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmKGo9PW4tMSAmJiBpPT0wKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZihpPT1uLTEgJiYgaj09MCkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBiMS54ID0gcFsyKmogIF07XG4gICAgICAgICAgICAgICAgYjEueSA9IHBbMipqKzFdO1xuICAgICAgICAgICAgICAgIGlmKGo9PW4tMSkgIHsgYjIueCA9IHBbMCAgICBdOyAgYjIueSA9IHBbMSAgICBdOyB9XG4gICAgICAgICAgICAgICAgZWxzZSAgICAgICAgeyBiMi54ID0gcFsyKmorMl07ICBiMi55ID0gcFsyKmorM107IH1cblxuICAgICAgICAgICAgICAgIGlmKFBvbHlLLl9HZXRMaW5lSW50ZXJzZWN0aW9uKGExLGEyLGIxLGIyLGMpICE9IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBQb2x5Sy5Jc0NvbnZleCA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICBpZihwLmxlbmd0aDw2KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDQ7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgICAgICBpZighUG9seUsuX2NvbnZleChwW2ldLCBwW2krMV0sIHBbaSsyXSwgcFtpKzNdLCBwW2krNF0sIHBbaSs1XSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYoIVBvbHlLLl9jb252ZXgocFtsICBdLCBwW2wrMV0sIHBbbCsyXSwgcFtsKzNdLCBwWzBdLCBwWzFdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZighUG9seUsuX2NvbnZleChwW2wrMl0sIHBbbCszXSwgcFswICBdLCBwWzEgIF0sIHBbMl0sIHBbM10pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAqL1xuICAgIFBvbHlLLkdldEFyZWEgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgaWYocC5sZW5ndGggPDYpIHJldHVybiAwO1xuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgICAgICBzdW0gKz0gKHBbaSsyXS1wW2ldKSAqIChwW2krMV0rcFtpKzNdKTtcbiAgICAgICAgc3VtICs9IChwWzBdLXBbbF0pICogKHBbbCsxXStwWzFdKTtcbiAgICAgICAgcmV0dXJuIC0gc3VtICogMC41O1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLkdldEFBQkIgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgdmFyIG1pbnggPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1pbnkgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1heHggPSAtbWlueDtcbiAgICAgICAgdmFyIG1heHkgPSAtbWlueTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1pbnggPSBNYXRoLm1pbihtaW54LCBwW2kgIF0pO1xuICAgICAgICAgICAgbWF4eCA9IE1hdGgubWF4KG1heHgsIHBbaSAgXSk7XG4gICAgICAgICAgICBtaW55ID0gTWF0aC5taW4obWlueSwgcFtpKzFdKTtcbiAgICAgICAgICAgIG1heHkgPSBNYXRoLm1heChtYXh5LCBwW2krMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eDptaW54LCB5Om1pbnksIHdpZHRoOm1heHgtbWlueCwgaGVpZ2h0Om1heHktbWlueX07XG4gICAgfVxuICAgICovXG5cbiAgICBQb2x5Sy5Ucmlhbmd1bGF0ZSA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xuICAgICAgICBpZihuPDMpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIHRncyA9IFtdO1xuICAgICAgICB2YXIgYXZsID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKykgYXZsLnB1c2goaSk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgYWwgPSBuO1xuICAgICAgICB3aGlsZShhbCA+IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpMCA9IGF2bFsoaSswKSVhbF07XG4gICAgICAgICAgICB2YXIgaTEgPSBhdmxbKGkrMSklYWxdO1xuICAgICAgICAgICAgdmFyIGkyID0gYXZsWyhpKzIpJWFsXTtcblxuICAgICAgICAgICAgdmFyIGF4ID0gcFsyKmkwXSwgIGF5ID0gcFsyKmkwKzFdO1xuICAgICAgICAgICAgdmFyIGJ4ID0gcFsyKmkxXSwgIGJ5ID0gcFsyKmkxKzFdO1xuICAgICAgICAgICAgdmFyIGN4ID0gcFsyKmkyXSwgIGN5ID0gcFsyKmkyKzFdO1xuXG4gICAgICAgICAgICB2YXIgZWFyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKFBvbHlLLl9jb252ZXgoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWFyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPGFsOyBqKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmkgPSBhdmxbal07XG4gICAgICAgICAgICAgICAgICAgIGlmKHZpPT1pMCB8fCB2aT09aTEgfHwgdmk9PWkyKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYoUG9seUsuX1BvaW50SW5UcmlhbmdsZShwWzIqdmldLCBwWzIqdmkrMV0sIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKSB7ZWFyRm91bmQgPSBmYWxzZTsgYnJlYWs7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGVhckZvdW5kKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRncy5wdXNoKGkwLCBpMSwgaTIpO1xuICAgICAgICAgICAgICAgIGF2bC5zcGxpY2UoKGkrMSklYWwsIDEpO1xuICAgICAgICAgICAgICAgIGFsLS07XG4gICAgICAgICAgICAgICAgaT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaSsrID4gMyphbCkgYnJlYWs7ICAgICAgLy8gbm8gY29udmV4IGFuZ2xlcyA6KFxuICAgICAgICB9XG4gICAgICAgIHRncy5wdXNoKGF2bFswXSwgYXZsWzFdLCBhdmxbMl0pO1xuICAgICAgICByZXR1cm4gdGdzO1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLkNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbihwLCBweCwgcHkpXG4gICAge1xuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xuICAgICAgICB2YXIgYXgsIGF5LCBieCA9IHBbMipuLTJdLXB4LCBieSA9IHBbMipuLTFdLXB5O1xuICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF4ID0gYng7ICBheSA9IGJ5O1xuICAgICAgICAgICAgYnggPSBwWzIqaSAgXSAtIHB4O1xuICAgICAgICAgICAgYnkgPSBwWzIqaSsxXSAtIHB5O1xuICAgICAgICAgICAgaWYoYXk8IDAgJiYgYnk8IDApIGNvbnRpbnVlOyAgICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG9ud1wiXG4gICAgICAgICAgICBpZihheT49MCAmJiBieT49MCkgY29udGludWU7ICAgIC8vIGJvdGggXCJ1cFwiIG9yIGJvdGggXCJkb253XCJcbiAgICAgICAgICAgIGlmKGF4PCAwICYmIGJ4PCAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGx4ID0gYXggKyAoYngtYXgpKigtYXkpLyhieS1heSk7XG4gICAgICAgICAgICBpZihseD4wKSBkZXB0aCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZGVwdGggJiAxKSA9PSAxO1xuICAgIH1cblxuICAgIFBvbHlLLlNsaWNlID0gZnVuY3Rpb24ocCwgYXgsIGF5LCBieCwgYnkpXG4gICAge1xuICAgICAgICBpZihQb2x5Sy5Db250YWluc1BvaW50KHAsIGF4LCBheSkgfHwgUG9seUsuQ29udGFpbnNQb2ludChwLCBieCwgYnkpKSByZXR1cm4gW3Auc2xpY2UoMCldO1xuXG4gICAgICAgIHZhciBhID0gbmV3IFBvbHlLLl9QKGF4LCBheSk7XG4gICAgICAgIHZhciBiID0gbmV3IFBvbHlLLl9QKGJ4LCBieSk7XG4gICAgICAgIHZhciBpc2NzID0gW107ICAvLyBpbnRlcnNlY3Rpb25zXG4gICAgICAgIHZhciBwcyA9IFtdOyAgICAvLyBwb2ludHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpIHBzLnB1c2gobmV3IFBvbHlLLl9QKHBbaV0sIHBbaSsxXSkpO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaXNjID0gbmV3IFBvbHlLLl9QKDAsMCk7XG4gICAgICAgICAgICBpc2MgPSBQb2x5Sy5fR2V0TGluZUludGVyc2VjdGlvbihhLCBiLCBwc1tpXSwgcHNbKGkrMSklcHMubGVuZ3RoXSwgaXNjKTtcblxuICAgICAgICAgICAgaWYoaXNjKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlzYy5mbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpc2NzLnB1c2goaXNjKTtcbiAgICAgICAgICAgICAgICBwcy5zcGxpY2UoaSsxLDAsaXNjKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNjcy5sZW5ndGggPT0gMCkgcmV0dXJuIFtwLnNsaWNlKDApXTtcbiAgICAgICAgdmFyIGNvbXAgPSBmdW5jdGlvbih1LHYpIHtyZXR1cm4gUG9seUsuX1AuZGlzdChhLHUpIC0gUG9seUsuX1AuZGlzdChhLHYpOyB9XG4gICAgICAgIGlzY3Muc29ydChjb21wKTtcblxuICAgICAgICB2YXIgcGdzID0gW107XG4gICAgICAgIHZhciBkaXIgPSAwO1xuICAgICAgICB3aGlsZShpc2NzLmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGkwID0gaXNjc1swXTtcbiAgICAgICAgICAgIHZhciBpMSA9IGlzY3NbMV07XG4gICAgICAgICAgICB2YXIgaW5kMCA9IHBzLmluZGV4T2YoaTApO1xuICAgICAgICAgICAgdmFyIGluZDEgPSBwcy5pbmRleE9mKGkxKTtcbiAgICAgICAgICAgIHZhciBzb2x2ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYoUG9seUsuX2ZpcnN0V2l0aEZsYWcocHMsIGluZDApID09IGluZDEpIHNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaTAgPSBpc2NzWzFdO1xuICAgICAgICAgICAgICAgIGkxID0gaXNjc1swXTtcbiAgICAgICAgICAgICAgICBpbmQwID0gcHMuaW5kZXhPZihpMCk7XG4gICAgICAgICAgICAgICAgaW5kMSA9IHBzLmluZGV4T2YoaTEpO1xuICAgICAgICAgICAgICAgIGlmKFBvbHlLLl9maXJzdFdpdGhGbGFnKHBzLCBpbmQwKSA9PSBpbmQxKSBzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc29sdmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpci0tO1xuICAgICAgICAgICAgICAgIHZhciBwZ24gPSBQb2x5Sy5fZ2V0UG9pbnRzKHBzLCBpbmQwLCBpbmQxKTtcbiAgICAgICAgICAgICAgICBwZ3MucHVzaChwZ24pO1xuICAgICAgICAgICAgICAgIHBzID0gUG9seUsuX2dldFBvaW50cyhwcywgaW5kMSwgaW5kMCk7XG4gICAgICAgICAgICAgICAgaTAuZmxhZyA9IGkxLmZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc2NzLnNwbGljZSgwLDIpO1xuICAgICAgICAgICAgICAgIGlmKGlzY3MubGVuZ3RoID09IDApIHBncy5wdXNoKHBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyBkaXIrKzsgaXNjcy5yZXZlcnNlKCk7IH1cbiAgICAgICAgICAgIGlmKGRpcj4xKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBncy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBnID0gcGdzW2ldO1xuICAgICAgICAgICAgdmFyIG5wZyA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8cGcubGVuZ3RoOyBqKyspIG5wZy5wdXNoKHBnW2pdLngsIHBnW2pdLnkpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnBnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIFBvbHlLLlJheWNhc3QgPSBmdW5jdGlvbihwLCB4LCB5LCBkeCwgZHksIGlzYylcbiAgICB7XG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICAgICAgICB2YXIgdHAgPSBQb2x5Sy5fdHA7XG4gICAgICAgIHZhciBhMSA9IHRwWzBdLCBhMiA9IHRwWzFdLFxuICAgICAgICBiMSA9IHRwWzJdLCBiMiA9IHRwWzNdLCBjID0gdHBbNF07XG4gICAgICAgIGExLnggPSB4OyBhMS55ID0geTtcbiAgICAgICAgYTIueCA9IHgrZHg7IGEyLnkgPSB5K2R5O1xuXG4gICAgICAgIGlmKGlzYz09bnVsbCkgaXNjID0ge2Rpc3Q6MCwgZWRnZTowLCBub3JtOnt4OjAsIHk6MH0sIHJlZmw6e3g6MCwgeTowfX07XG4gICAgICAgIGlzYy5kaXN0ID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bDsgaSs9MilcbiAgICAgICAge1xuICAgICAgICAgICAgYjEueCA9IHBbaSAgXTsgIGIxLnkgPSBwW2krMV07XG4gICAgICAgICAgICBiMi54ID0gcFtpKzJdOyAgYjIueSA9IHBbaSszXTtcbiAgICAgICAgICAgIHZhciBuaXNjID0gUG9seUsuX1JheUxpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpO1xuICAgICAgICAgICAgaWYobmlzYykgUG9seUsuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIGkvMiwgaXNjKTtcbiAgICAgICAgfVxuICAgICAgICBiMS54ID0gYjIueDsgIGIxLnkgPSBiMi55O1xuICAgICAgICBiMi54ID0gcFswXTsgIGIyLnkgPSBwWzFdO1xuICAgICAgICB2YXIgbmlzYyA9IFBvbHlLLl9SYXlMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKTtcbiAgICAgICAgaWYobmlzYykgUG9seUsuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIHAubGVuZ3RoLzIsIGlzYyk7XG5cbiAgICAgICAgcmV0dXJuIChpc2MuZGlzdCAhPSBJbmZpbml0eSkgPyBpc2MgOiBudWxsO1xuICAgIH1cblxuICAgIFBvbHlLLkNsb3Nlc3RFZGdlID0gZnVuY3Rpb24ocCwgeCwgeSwgaXNjKVxuICAgIHtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gICAgICAgIHZhciB0cCA9IFBvbHlLLl90cDtcbiAgICAgICAgdmFyIGExID0gdHBbMF0sXG4gICAgICAgIGIxID0gdHBbMl0sIGIyID0gdHBbM10sIGMgPSB0cFs0XTtcbiAgICAgICAgYTEueCA9IHg7IGExLnkgPSB5O1xuXG4gICAgICAgIGlmKGlzYz09bnVsbCkgaXNjID0ge2Rpc3Q6MCwgZWRnZTowLCBwb2ludDp7eDowLCB5OjB9LCBub3JtOnt4OjAsIHk6MH19O1xuICAgICAgICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGIxLnggPSBwW2kgIF07ICBiMS55ID0gcFtpKzFdO1xuICAgICAgICAgICAgYjIueCA9IHBbaSsyXTsgIGIyLnkgPSBwW2krM107XG4gICAgICAgICAgICBQb2x5Sy5fcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBpPj4xLCBpc2MpO1xuICAgICAgICB9XG4gICAgICAgIGIxLnggPSBiMi54OyAgYjEueSA9IGIyLnk7XG4gICAgICAgIGIyLnggPSBwWzBdOyAgYjIueSA9IHBbMV07XG4gICAgICAgIFBvbHlLLl9wb2ludExpbmVEaXN0KGExLCBiMSwgYjIsIGw+PjEsIGlzYyk7XG5cbiAgICAgICAgdmFyIGlkc3QgPSAxL2lzYy5kaXN0O1xuICAgICAgICBpc2Mubm9ybS54ID0gKHgtaXNjLnBvaW50LngpKmlkc3Q7XG4gICAgICAgIGlzYy5ub3JtLnkgPSAoeS1pc2MucG9pbnQueSkqaWRzdDtcbiAgICAgICAgcmV0dXJuIGlzYztcbiAgICB9XG5cbiAgICBQb2x5Sy5fcG9pbnRMaW5lRGlzdCA9IGZ1bmN0aW9uKHAsIGEsIGIsIGVkZ2UsIGlzYylcbiAgICB7XG4gICAgICAgIHZhciB4ID0gcC54LCB5ID0gcC55LCB4MSA9IGEueCwgeTEgPSBhLnksIHgyID0gYi54LCB5MiA9IGIueTtcblxuICAgICAgICB2YXIgQSA9IHggLSB4MTtcbiAgICAgICAgdmFyIEIgPSB5IC0geTE7XG4gICAgICAgIHZhciBDID0geDIgLSB4MTtcbiAgICAgICAgdmFyIEQgPSB5MiAtIHkxO1xuXG4gICAgICAgIHZhciBkb3QgPSBBICogQyArIEIgKiBEO1xuICAgICAgICB2YXIgbGVuX3NxID0gQyAqIEMgKyBEICogRDtcbiAgICAgICAgdmFyIHBhcmFtID0gZG90IC8gbGVuX3NxO1xuXG4gICAgICAgIHZhciB4eCwgeXk7XG5cbiAgICAgICAgaWYgKHBhcmFtIDwgMCB8fCAoeDEgPT0geDIgJiYgeTEgPT0geTIpKSB7XG4gICAgICAgICAgICB4eCA9IHgxO1xuICAgICAgICAgICAgeXkgPSB5MTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbSA+IDEpIHtcbiAgICAgICAgICAgIHh4ID0geDI7XG4gICAgICAgICAgICB5eSA9IHkyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeHggPSB4MSArIHBhcmFtICogQztcbiAgICAgICAgICAgIHl5ID0geTEgKyBwYXJhbSAqIEQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSB4IC0geHg7XG4gICAgICAgIHZhciBkeSA9IHkgLSB5eTtcbiAgICAgICAgdmFyIGRzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGlmKGRzdDxpc2MuZGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgaXNjLmRpc3QgPSBkc3Q7XG4gICAgICAgICAgICBpc2MuZWRnZSA9IGVkZ2U7XG4gICAgICAgICAgICBpc2MucG9pbnQueCA9IHh4O1xuICAgICAgICAgICAgaXNjLnBvaW50LnkgPSB5eTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFBvbHlLLl91cGRhdGVJU0MgPSBmdW5jdGlvbihkeCwgZHksIGExLCBiMSwgYjIsIGMsIGVkZ2UsIGlzYylcbiAgICB7XG4gICAgICAgIHZhciBucmwgPSBQb2x5Sy5fUC5kaXN0KGExLCBjKTtcbiAgICAgICAgaWYobnJsPGlzYy5kaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaWJsID0gMS9Qb2x5Sy5fUC5kaXN0KGIxLCBiMik7XG4gICAgICAgICAgICB2YXIgbnggPSAtKGIyLnktYjEueSkqaWJsO1xuICAgICAgICAgICAgdmFyIG55ID0gIChiMi54LWIxLngpKmlibDtcbiAgICAgICAgICAgIHZhciBkZG90ID0gMiooZHgqbngrZHkqbnkpO1xuICAgICAgICAgICAgaXNjLmRpc3QgPSBucmw7XG4gICAgICAgICAgICBpc2Mubm9ybS54ID0gbng7XG4gICAgICAgICAgICBpc2Mubm9ybS55ID0gbnk7XG4gICAgICAgICAgICBpc2MucmVmbC54ID0gLWRkb3QqbngrZHg7XG4gICAgICAgICAgICBpc2MucmVmbC55ID0gLWRkb3QqbnkrZHk7XG4gICAgICAgICAgICBpc2MuZWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBQb2x5Sy5fZ2V0UG9pbnRzID0gZnVuY3Rpb24ocHMsIGluZDAsIGluZDEpXG4gICAge1xuICAgICAgICB2YXIgbiA9IHBzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5wcyA9IFtdO1xuICAgICAgICBpZihpbmQxPGluZDApIGluZDEgKz0gbjtcbiAgICAgICAgZm9yKHZhciBpPWluZDA7IGk8PSBpbmQxOyBpKyspIG5wcy5wdXNoKHBzW2klbl0pO1xuICAgICAgICByZXR1cm4gbnBzO1xuICAgIH1cblxuICAgIFBvbHlLLl9maXJzdFdpdGhGbGFnID0gZnVuY3Rpb24ocHMsIGluZClcbiAgICB7XG4gICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSh0cnVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbmQgPSAoaW5kKzEpJW47XG4gICAgICAgICAgICBpZihwc1tpbmRdLmZsYWcpIHJldHVybiBpbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKi9cbiAgICBQb2x5Sy5fUG9pbnRJblRyaWFuZ2xlID0gZnVuY3Rpb24ocHgsIHB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KVxuICAgIHtcbiAgICAgICAgdmFyIHYweCA9IGN4LWF4O1xuICAgICAgICB2YXIgdjB5ID0gY3ktYXk7XG4gICAgICAgIHZhciB2MXggPSBieC1heDtcbiAgICAgICAgdmFyIHYxeSA9IGJ5LWF5O1xuICAgICAgICB2YXIgdjJ4ID0gcHgtYXg7XG4gICAgICAgIHZhciB2MnkgPSBweS1heTtcblxuICAgICAgICB2YXIgZG90MDAgPSB2MHgqdjB4K3YweSp2MHk7XG4gICAgICAgIHZhciBkb3QwMSA9IHYweCp2MXgrdjB5KnYxeTtcbiAgICAgICAgdmFyIGRvdDAyID0gdjB4KnYyeCt2MHkqdjJ5O1xuICAgICAgICB2YXIgZG90MTEgPSB2MXgqdjF4K3YxeSp2MXk7XG4gICAgICAgIHZhciBkb3QxMiA9IHYxeCp2MngrdjF5KnYyeTtcblxuICAgICAgICB2YXIgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKTtcbiAgICAgICAgdmFyIHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gICAgICAgIHZhciB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHBvaW50IGlzIGluIHRyaWFuZ2xlXG4gICAgICAgIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKTtcbiAgICB9XG4gICAgLypcbiAgICBQb2x5Sy5fUmF5TGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKVxuICAgIHtcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcbiAgICAgICAgdmFyIGRheSA9IChhMS55LWEyLnkpLCBkYnkgPSAoYjEueS1iMi55KTtcblxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XG4gICAgICAgIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGw7ICAvLyBwYXJhbGxlbFxuXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xuICAgICAgICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcblxuICAgICAgICB2YXIgSSA9IGM7XG4gICAgICAgIHZhciBpRGVuID0gMS9EZW47XG4gICAgICAgIEkueCA9ICggQSpkYnggLSBkYXgqQiApICogaURlbjtcbiAgICAgICAgSS55ID0gKCBBKmRieSAtIGRheSpCICkgKiBpRGVuO1xuXG4gICAgICAgIGlmKCFQb2x5Sy5fSW5SZWN0KEksIGIxLCBiMikpIHJldHVybiBudWxsO1xuICAgICAgICBpZigoZGF5PjAgJiYgSS55PmExLnkpIHx8IChkYXk8MCAmJiBJLnk8YTEueSkpIHJldHVybiBudWxsO1xuICAgICAgICBpZigoZGF4PjAgJiYgSS54PmExLngpIHx8IChkYXg8MCAmJiBJLng8YTEueCkpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gSTtcbiAgICB9XG5cbiAgICBQb2x5Sy5fR2V0TGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKVxuICAgIHtcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcbiAgICAgICAgdmFyIGRheSA9IChhMS55LWEyLnkpLCBkYnkgPSAoYjEueS1iMi55KTtcblxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XG4gICAgICAgIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGw7ICAvLyBwYXJhbGxlbFxuXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xuICAgICAgICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcblxuICAgICAgICB2YXIgSSA9IGM7XG4gICAgICAgIEkueCA9ICggQSpkYnggLSBkYXgqQiApIC8gRGVuO1xuICAgICAgICBJLnkgPSAoIEEqZGJ5IC0gZGF5KkIgKSAvIERlbjtcblxuICAgICAgICBpZihQb2x5Sy5fSW5SZWN0KEksIGExLCBhMikgJiYgUG9seUsuX0luUmVjdChJLCBiMSwgYjIpKSByZXR1cm4gSTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgUG9seUsuX0luUmVjdCA9IGZ1bmN0aW9uKGEsIGIsIGMpXG4gICAge1xuICAgICAgICBpZiAgKGIueCA9PSBjLngpIHJldHVybiAoYS55Pj1NYXRoLm1pbihiLnksIGMueSkgJiYgYS55PD1NYXRoLm1heChiLnksIGMueSkpO1xuICAgICAgICBpZiAgKGIueSA9PSBjLnkpIHJldHVybiAoYS54Pj1NYXRoLm1pbihiLngsIGMueCkgJiYgYS54PD1NYXRoLm1heChiLngsIGMueCkpO1xuXG4gICAgICAgIGlmKGEueCA+PSBNYXRoLm1pbihiLngsIGMueCkgJiYgYS54IDw9IE1hdGgubWF4KGIueCwgYy54KVxuICAgICAgICAmJiBhLnkgPj0gTWF0aC5taW4oYi55LCBjLnkpICYmIGEueSA8PSBNYXRoLm1heChiLnksIGMueSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgICovXG4gICAgUG9seUsuX2NvbnZleCA9IGZ1bmN0aW9uKGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpXG4gICAge1xuICAgICAgICByZXR1cm4gKGF5LWJ5KSooY3gtYngpICsgKGJ4LWF4KSooY3ktYnkpID49IDA7XG4gICAgfVxuICAgIC8qXG4gICAgUG9seUsuX1AgPSBmdW5jdGlvbih4LHkpXG4gICAge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLmZsYWcgPSBmYWxzZTtcbiAgICB9XG4gICAgUG9seUsuX1AucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFwiUG9pbnQgW1wiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiXVwiO1xuICAgIH1cbiAgICBQb2x5Sy5fUC5kaXN0ID0gZnVuY3Rpb24oYSxiKVxuICAgIHtcbiAgICAgICAgdmFyIGR4ID0gYi54LWEueDtcbiAgICAgICAgdmFyIGR5ID0gYi55LWEueTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcbiAgICB9XG5cbiAgICBQb2x5Sy5fdHAgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTwxMDsgaSsrKSBQb2x5Sy5fdHAucHVzaChuZXcgUG9seUsuX1AoMCwwKSk7XG4gICAgICAgICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9seUs7XG5cbn0se31dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIFRoZSB2ZWMyIG9iamVjdCBmcm9tIGdsTWF0cml4LCB3aXRoIHNvbWUgZXh0ZW5zaW9ucyBhbmQgc29tZSByZW1vdmVkIG1ldGhvZHMuIFNlZSBodHRwOi8vZ2xtYXRyaXgubmV0LlxuICogQGNsYXNzIHZlYzJcbiAqL1xuXG52YXIgdmVjMiA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbi8qKlxuICogTWFrZSBhIGNyb3NzIHByb2R1Y3QgYW5kIG9ubHkgcmV0dXJuIHRoZSB6IGNvbXBvbmVudFxuICogQG1ldGhvZCBjcm9zc0xlbmd0aFxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge0FycmF5fSBiXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZlYzIuY3Jvc3NMZW5ndGggPSBmdW5jdGlvbihhLGIpe1xuICAgIHJldHVybiBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xufTtcblxuLyoqXG4gKiBDcm9zcyBwcm9kdWN0IGJldHdlZW4gYSB2ZWN0b3IgYW5kIHRoZSBaIGNvbXBvbmVudCBvZiBhIHZlY3RvclxuICogQG1ldGhvZCBjcm9zc1ZaXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gdmVjXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHpjb21wXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZlYzIuY3Jvc3NWWiA9IGZ1bmN0aW9uKG91dCwgdmVjLCB6Y29tcCl7XG4gICAgdmVjMi5yb3RhdGUob3V0LHZlYywtTWF0aC5QSS8yKTsvLyBSb3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByaWdodCBoYW5kIHJ1bGVcbiAgICB2ZWMyLnNjYWxlKG91dCxvdXQsemNvbXApOyAgICAgIC8vIFNjYWxlIHdpdGggelxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyb3NzIHByb2R1Y3QgYmV0d2VlbiBhIHZlY3RvciBhbmQgdGhlIFogY29tcG9uZW50IG9mIGEgdmVjdG9yXG4gKiBAbWV0aG9kIGNyb3NzWlZcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge051bWJlcn0gemNvbXBcbiAqIEBwYXJhbSAge0FycmF5fSB2ZWNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmVjMi5jcm9zc1pWID0gZnVuY3Rpb24ob3V0LCB6Y29tcCwgdmVjKXtcbiAgICB2ZWMyLnJvdGF0ZShvdXQsdmVjLE1hdGguUEkvMik7IC8vIFJvdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIHJpZ2h0IGhhbmQgcnVsZVxuICAgIHZlYzIuc2NhbGUob3V0LG91dCx6Y29tcCk7ICAgICAgLy8gU2NhbGUgd2l0aCB6XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIGJ5IGFuIGFuZ2xlXG4gKiBAbWV0aG9kIHJvdGF0ZVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xudmVjMi5yb3RhdGUgPSBmdW5jdGlvbihvdXQsYSxhbmdsZSl7XG4gICAgaWYoYW5nbGUgIT09IDApe1xuICAgICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHMgPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICB4ID0gYVswXSxcbiAgICAgICAgICAgIHkgPSBhWzFdO1xuICAgICAgICBvdXRbMF0gPSBjKnggLXMqeTtcbiAgICAgICAgb3V0WzFdID0gcyp4ICtjKnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVsxXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciA5MCBkZWdyZWVzIGNsb2Nrd2lzZVxuICogQG1ldGhvZCByb3RhdGU5MGN3XG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG52ZWMyLnJvdGF0ZTkwY3cgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF07XG4gICAgdmFyIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IHk7XG4gICAgb3V0WzFdID0gLXg7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHBvaW50IHBvc2l0aW9uIHRvIGxvY2FsIGZyYW1lLlxuICogQG1ldGhvZCB0b0xvY2FsRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFBvaW50XG4gKiBAcGFyYW0gIHtBcnJheX0gZnJhbWVQb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXG4gKi9cbnZlYzIudG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ob3V0LCB3b3JsZFBvaW50LCBmcmFtZVBvc2l0aW9uLCBmcmFtZUFuZ2xlKXtcbiAgICB2ZWMyLmNvcHkob3V0LCB3b3JsZFBvaW50KTtcbiAgICB2ZWMyLnN1YihvdXQsIG91dCwgZnJhbWVQb3NpdGlvbik7XG4gICAgdmVjMi5yb3RhdGUob3V0LCBvdXQsIC1mcmFtZUFuZ2xlKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcG9pbnQgcG9zaXRpb24gdG8gZ2xvYmFsIGZyYW1lLlxuICogQG1ldGhvZCB0b0dsb2JhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxQb2ludFxuICogQHBhcmFtICB7QXJyYXl9IGZyYW1lUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxuICovXG52ZWMyLnRvR2xvYmFsRnJhbWUgPSBmdW5jdGlvbihvdXQsIGxvY2FsUG9pbnQsIGZyYW1lUG9zaXRpb24sIGZyYW1lQW5nbGUpe1xuICAgIHZlYzIuY29weShvdXQsIGxvY2FsUG9pbnQpO1xuICAgIHZlYzIucm90YXRlKG91dCwgb3V0LCBmcmFtZUFuZ2xlKTtcbiAgICB2ZWMyLmFkZChvdXQsIG91dCwgZnJhbWVQb3NpdGlvbik7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgY2VudHJvaWQgb2YgYSB0cmlhbmdsZSBzcGFubmVkIGJ5IHZlY3RvcnMgYSxiLGMuIFNlZSBodHRwOi8vZWFzeWNhbGN1bGF0aW9uLmNvbS9hbmFseXRpY2FsL2xlYXJuLWNlbnRyb2lkLnBocFxuICogQG1ldGhvZCBjZW50cm9pZFxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge0FycmF5fSBiXG4gKiBAcGFyYW0gIHtBcnJheX0gY1xuICogQHJldHVybiAge0FycmF5fSBUaGUgb3V0IG9iamVjdFxuICovXG52ZWMyLmNlbnRyb2lkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgICB2ZWMyLmFkZChvdXQsIGEsIGIpO1xuICAgIHZlYzIuYWRkKG91dCwgb3V0LCBjKTtcbiAgICB2ZWMyLnNjYWxlKG91dCwgb3V0LCAxLzMpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY3JlYXRlXG4gKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBVdGlscy5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBVdGlscy5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGZyb21WYWx1ZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybiB7QXJyYXl9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBVdGlscy5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHN1YnRyYWN0XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5zdWJ0cmFjdFxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzdWJcbiAqL1xudmVjMi5zdWIgPSB2ZWMyLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBtdWx0aXBseVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIubXVsdGlwbHlcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbXVsXG4gKi9cbnZlYzIubXVsID0gdmVjMi5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGl2aWRlXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuZGl2aWRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRpdlxuICovXG52ZWMyLmRpdiA9IHZlYzIuZGl2aWRlO1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHNjYWxlXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGlzdGFuY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLmRpc3RhbmNlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRpc3RcbiAqL1xudmVjMi5kaXN0ID0gdmVjMi5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3F1YXJlZERpc3RhbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuc3F1YXJlZERpc3RhbmNlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHNxckRpc3RcbiAqL1xudmVjMi5zcXJEaXN0ID0gdmVjMi5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBsZW5ndGhcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm4ge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5sZW5ndGhcbiAqIEBtZXRob2QgbGVuXG4gKiBAc3RhdGljXG4gKi9cbnZlYzIubGVuID0gdmVjMi5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHNxdWFyZWRMZW5ndGhcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybiB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5zcXVhcmVkTGVuZ3RoXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHNxckxlblxuICovXG52ZWMyLnNxckxlbiA9IHZlYzIuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBuZWdhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBub3JtYWxpemVcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBkb3RcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMi5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHN0clxuICogQHBhcmFtIHtBcnJheX0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjMignICsgYVswXSArICcsICcgKyBhWzFdICsgJyknO1xufTtcblxudmVjMi5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxufSx7XCIuLi91dGlscy9VdGlsc1wiOjUwfV0sMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIGRlY29tcCA9IF9kZXJlcV8oJ3BvbHktZGVjb21wJylcbiwgICBDb252ZXggPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ29udmV4JylcbiwgICBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKVxuLCAgIEV2ZW50RW1pdHRlciA9IF9kZXJlcV8oJy4uL2V2ZW50cy9FdmVudEVtaXR0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb2R5O1xuXG4vKipcbiAqIEEgcmlnaWQgYm9keS4gSGFzIGdvdCBhIGNlbnRlciBvZiBtYXNzLCBwb3NpdGlvbiwgdmVsb2NpdHkgYW5kIGEgbnVtYmVyIG9mXG4gKiBzaGFwZXMgdGhhdCBhcmUgdXNlZCBmb3IgY29sbGlzaW9ucy5cbiAqXG4gKiBAY2xhc3MgQm9keVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgIFtvcHRpb25zLm1hc3M9MF0gICAgQSBudW1iZXIgPj0gMC4gSWYgemVybywgdGhlIC50eXBlIHdpbGwgYmUgc2V0IHRvIEJvZHkuU1RBVElDLlxuICogQHBhcmFtIHtBcnJheX0gICAgICAgICAgICAgICBbb3B0aW9ucy5wb3NpdGlvbl1cbiAqIEBwYXJhbSB7QXJyYXl9ICAgICAgICAgICAgICAgW29wdGlvbnMudmVsb2NpdHldXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgIFtvcHRpb25zLmFuZ2xlPTBdXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgIFtvcHRpb25zLmFuZ3VsYXJWZWxvY2l0eT0wXVxuICogQHBhcmFtIHtBcnJheX0gICAgICAgICAgICAgICBbb3B0aW9ucy5mb3JjZV1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMuYW5ndWxhckZvcmNlPTBdXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgIFtvcHRpb25zLmZpeGVkUm90YXRpb249ZmFsc2VdXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgIFtvcHRpb25zLmNjZFNwZWVkVGhyZXNob2xkPS0xXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5jY2RJdGVyYXRpb25zPTEwXVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIC8vIENyZWF0ZSBhIHR5cGljYWwgZHluYW1pYyBib2R5XG4gKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7XG4gKiAgICAgICAgIG1hc3M6IDEsXG4gKiAgICAgICAgIHBvc2l0aW9uOiBbMCwgMF0sXG4gKiAgICAgICAgIGFuZ2xlOiAwLFxuICogICAgICAgICB2ZWxvY2l0eTogWzAsIDBdLFxuICogICAgICAgICBhbmd1bGFyVmVsb2NpdHk6IDBcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gQWRkIGEgY2lyY3VsYXIgc2hhcGUgdG8gdGhlIGJvZHlcbiAqICAgICBib2R5LmFkZFNoYXBlKG5ldyBDaXJjbGUoMSkpO1xuICpcbiAqICAgICAvLyBBZGQgdGhlIGJvZHkgdG8gdGhlIHdvcmxkXG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcbiAqL1xuZnVuY3Rpb24gQm9keShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvZHkgaWRlbnRpZnllclxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZCA9ICsrQm9keS5faWRDb3VudGVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdvcmxkIHRoYXQgdGhpcyBib2R5IGlzIGFkZGVkIHRvLiBUaGlzIHByb3BlcnR5IGlzIHNldCB0byBOVUxMIGlmIHRoZSBib2R5IGlzIG5vdCBhZGRlZCB0byBhbnkgd29ybGQuXG4gICAgICogQHByb3BlcnR5IHdvcmxkXG4gICAgICogQHR5cGUge1dvcmxkfVxuICAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlcyBvZiB0aGUgYm9keS4gVGhlIGxvY2FsIHRyYW5zZm9ybSBvZiB0aGUgc2hhcGUgaW4gLnNoYXBlc1tpXSBpc1xuICAgICAqIGRlZmluZWQgYnkgLnNoYXBlT2Zmc2V0c1tpXSBhbmQgLnNoYXBlQW5nbGVzW2ldLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNoYXBlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvY2FsIHNoYXBlIG9mZnNldHMsIHJlbGF0aXZlIHRvIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzLiBUaGlzIGlzIGFuXG4gICAgICogYXJyYXkgb2YgQXJyYXkuXG4gICAgICogQHByb3BlcnR5IHNoYXBlT2Zmc2V0c1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlT2Zmc2V0cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvZHktbG9jYWwgc2hhcGUgYW5nbGUgdHJhbnNmb3Jtcy4gVGhpcyBpcyBhbiBhcnJheSBvZiBudW1iZXJzIChhbmdsZXMpLlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUFuZ2xlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQW5nbGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFzcyBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgbWFzc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXNzID0gb3B0aW9ucy5tYXNzIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBtYXNzIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBpbnZNYXNzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludk1hc3MgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGluZXJ0aWEgb2YgdGhlIGJvZHkgYXJvdW5kIHRoZSBaIGF4aXMuXG4gICAgICogQHByb3BlcnR5IGluZXJ0aWFcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW5lcnRpYSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBpbmVydGlhIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBpbnZJbmVydGlhXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludkluZXJ0aWEgPSAwO1xuXG4gICAgdGhpcy5pbnZNYXNzU29sdmUgPSAwO1xuICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGZpeCB0aGUgcm90YXRpb24gb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGZpeGVkUm90YXRpb25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmZpeGVkUm90YXRpb24gPSAhIW9wdGlvbnMuZml4ZWRSb3RhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keVxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG4gICAgaWYob3B0aW9ucy5wb3NpdGlvbil7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLnBvc2l0aW9uLCBvcHRpb25zLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJwb2xhdGVkIHBvc2l0aW9uIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBpbnRlcnBvbGF0ZWRQb3NpdGlvblxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmludGVycG9sYXRlZFBvc2l0aW9uID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJwb2xhdGVkIGFuZ2xlIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBpbnRlcnBvbGF0ZWRBbmdsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbnRlcnBvbGF0ZWRBbmdsZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJldmlvdXMgcG9zaXRpb24gb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IHByZXZpb3VzUG9zaXRpb25cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5wcmV2aW91c1Bvc2l0aW9uID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJldmlvdXMgYW5nbGUgb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IHByZXZpb3VzQW5nbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNBbmdsZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVsb2NpdHkgb2YgdGhlIGJvZHlcbiAgICAgKiBAcHJvcGVydHkgdmVsb2NpdHlcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52ZWxvY2l0eSA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuICAgIGlmKG9wdGlvbnMudmVsb2NpdHkpe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy52ZWxvY2l0eSwgb3B0aW9ucy52ZWxvY2l0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RyYWludCB2ZWxvY2l0eSB0aGF0IHdhcyBhZGRlZCB0byB0aGUgYm9keSBkdXJpbmcgdGhlIGxhc3Qgc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgdmxhbWJkYVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZsYW1iZGEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgY29uc3RyYWludCB2ZWxvY2l0eSB0aGF0IHdhcyBhZGRlZCB0byB0aGUgYm9keSBkdXJpbmcgbGFzdCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSB3bGFtYmRhXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMud2xhbWJkYSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5nbGUgb2YgdGhlIGJvZHksIGluIHJhZGlhbnMuXG4gICAgICogQHByb3BlcnR5IGFuZ2xlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBUaGUgYW5nbGUgcHJvcGVydHkgaXMgbm90IG5vcm1hbGl6ZWQgdG8gdGhlIGludGVydmFsIDAgdG8gMipwaSwgaXQgY2FuIGJlIGFueSB2YWx1ZS5cbiAgICAgKiAgICAgLy8gSWYgeW91IG5lZWQgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDIqcGksIHVzZSB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uIHRvIG5vcm1hbGl6ZSBpdC5cbiAgICAgKiAgICAgZnVuY3Rpb24gbm9ybWFsaXplQW5nbGUoYW5nbGUpe1xuICAgICAqICAgICAgICAgYW5nbGUgPSBhbmdsZSAlICgyKk1hdGguUEkpO1xuICAgICAqICAgICAgICAgaWYoYW5nbGUgPCAwKXtcbiAgICAgKiAgICAgICAgICAgICBhbmdsZSArPSAoMipNYXRoLlBJKTtcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmFuZ2xlIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgYm9keSwgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxuICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyVmVsb2NpdHlcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gb3B0aW9ucy5hbmd1bGFyVmVsb2NpdHkgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JjZSBhY3Rpbmcgb24gdGhlIGJvZHkuIFNpbmNlIHRoZSBib2R5IGZvcmNlIChhbmQge3sjY3Jvc3NMaW5rIFwiQm9keS9hbmd1bGFyRm9yY2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0pIHdpbGwgYmUgemVyb2VkIGFmdGVyIGVhY2ggc3RlcCwgc28geW91IG5lZWQgdG8gc2V0IHRoZSBmb3JjZSBiZWZvcmUgZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBmb3JjZVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIFRoaXMgcHJvZHVjZXMgYSBmb3JjZWZpZWxkIG9mIDEgTmV3dG9uIGluIHRoZSBwb3NpdGl2ZSB4IGRpcmVjdGlvbi5cbiAgICAgKiAgICAgZm9yKHZhciBpPTA7IGk8bnVtU3RlcHM7IGkrKyl7XG4gICAgICogICAgICAgICBib2R5LmZvcmNlWzBdID0gMTtcbiAgICAgKiAgICAgICAgIHdvcmxkLnN0ZXAoMS82MCk7XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIFRoaXMgd2lsbCBhcHBseSBhIHJvdGF0aW9uYWwgZm9yY2Ugb24gdGhlIGJvZHlcbiAgICAgKiAgICAgZm9yKHZhciBpPTA7IGk8bnVtU3RlcHM7IGkrKyl7XG4gICAgICogICAgICAgICBib2R5LmFuZ3VsYXJGb3JjZSA9IC0zO1xuICAgICAqICAgICAgICAgd29ybGQuc3RlcCgxLzYwKTtcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIHRoaXMuZm9yY2UgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIGlmKG9wdGlvbnMuZm9yY2Upe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5mb3JjZSwgb3B0aW9ucy5mb3JjZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ3VsYXIgZm9yY2UgYWN0aW5nIG9uIHRoZSBib2R5LiBTZWUge3sjY3Jvc3NMaW5rIFwiQm9keS9mb3JjZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhckZvcmNlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ3VsYXJGb3JjZSA9IG9wdGlvbnMuYW5ndWxhckZvcmNlIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGluZWFyIGRhbXBpbmcgYWN0aW5nIG9uIHRoZSBib2R5IGluIHRoZSB2ZWxvY2l0eSBkaXJlY3Rpb24uIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcHJvcGVydHkgZGFtcGluZ1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4xXG4gICAgICovXG4gICAgdGhpcy5kYW1waW5nID0gdHlwZW9mKG9wdGlvbnMuZGFtcGluZykgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLmRhbXBpbmcgOiAwLjE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5ndWxhciBmb3JjZSBhY3Rpbmcgb24gdGhlIGJvZHkuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhckRhbXBpbmdcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMVxuICAgICAqL1xuICAgIHRoaXMuYW5ndWxhckRhbXBpbmcgPSB0eXBlb2Yob3B0aW9ucy5hbmd1bGFyRGFtcGluZykgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLmFuZ3VsYXJEYW1waW5nIDogMC4xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgbW90aW9uIHRoaXMgYm9keSBoYXMuIFNob3VsZCBiZSBvbmUgb2Y6IHt7I2Nyb3NzTGluayBcIkJvZHkvU1RBVElDOnByb3BlcnR5XCJ9fUJvZHkuU1RBVElDe3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkJvZHkvRFlOQU1JQzpwcm9wZXJ0eVwifX1Cb2R5LkRZTkFNSUN7ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiQm9keS9LSU5FTUFUSUM6cHJvcGVydHlcIn19Qm9keS5LSU5FTUFUSUN7ey9jcm9zc0xpbmt9fS5cbiAgICAgKlxuICAgICAqICogU3RhdGljIGJvZGllcyBkbyBub3QgbW92ZSwgYW5kIHRoZXkgZG8gbm90IHJlc3BvbmQgdG8gZm9yY2VzIG9yIGNvbGxpc2lvbi5cbiAgICAgKiAqIER5bmFtaWMgYm9kaWVzIGJvZHkgY2FuIG1vdmUgYW5kIHJlc3BvbmQgdG8gY29sbGlzaW9ucyBhbmQgZm9yY2VzLlxuICAgICAqICogS2luZW1hdGljIGJvZGllcyBvbmx5IG1vdmVzIGFjY29yZGluZyB0byBpdHMgLnZlbG9jaXR5LCBhbmQgZG9lcyBub3QgcmVzcG9uZCB0byBjb2xsaXNpb25zIG9yIGZvcmNlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gQm9kaWVzIGFyZSBzdGF0aWMgYnkgZGVmYXVsdC4gU3RhdGljIGJvZGllcyB3aWxsIG5ldmVyIG1vdmUuXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoKTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS50eXBlID09IEJvZHkuU1RBVElDKTsgLy8gdHJ1ZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gQnkgc2V0dGluZyB0aGUgbWFzcyBvZiBhIGJvZHkgdG8gYSBub256ZXJvIG51bWJlciwgdGhlIGJvZHlcbiAgICAgKiAgICAgLy8gd2lsbCBiZWNvbWUgZHluYW1pYyBhbmQgd2lsbCBtb3ZlIGFuZCBpbnRlcmFjdCB3aXRoIG90aGVyIGJvZGllcy5cbiAgICAgKiAgICAgdmFyIGR5bmFtaWNCb2R5ID0gbmV3IEJvZHkoe1xuICAgICAqICAgICAgICAgbWFzcyA6IDFcbiAgICAgKiAgICAgfSk7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGR5bmFtaWNCb2R5LnR5cGUgPT0gQm9keS5EWU5BTUlDKTsgLy8gdHJ1ZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gS2luZW1hdGljIGJvZGllcyB3aWxsIG9ubHkgbW92ZSBpZiB5b3UgY2hhbmdlIHRoZWlyIHZlbG9jaXR5LlxuICAgICAqICAgICB2YXIga2luZW1hdGljQm9keSA9IG5ldyBCb2R5KHtcbiAgICAgKiAgICAgICAgIHR5cGU6IEJvZHkuS0lORU1BVElDIC8vIFR5cGUgY2FuIGJlIHNldCB2aWEgdGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqICAgICB9KTtcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBCb2R5LlNUQVRJQztcblxuICAgIGlmKHR5cGVvZihvcHRpb25zLnR5cGUpICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICB9IGVsc2UgaWYoIW9wdGlvbnMubWFzcyl7XG4gICAgICAgIHRoaXMudHlwZSA9IEJvZHkuU1RBVElDO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHlwZSA9IEJvZHkuRFlOQU1JQztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCb3VuZGluZyBjaXJjbGUgcmFkaXVzLlxuICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBCb3VuZGluZyBib3ggb2YgdGhpcyBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBhYWJiXG4gICAgICogQHR5cGUge0FBQkJ9XG4gICAgICovXG4gICAgdGhpcy5hYWJiID0gbmV3IEFBQkIoKTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgQUFCQiBuZWVkcyB1cGRhdGUuIFVwZGF0ZSBpdCB3aXRoIHt7I2Nyb3NzTGluayBcIkJvZHkvdXBkYXRlQUFCQjptZXRob2RcIn19LnVwZGF0ZUFBQkIoKXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSBhYWJiTmVlZHNVcGRhdGVcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIHVwZGF0ZUFBQkJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEZvcmNlIHVwZGF0ZSB0aGUgQUFCQlxuICAgICAqICAgICBib2R5LmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICogICAgIGJvZHkudXBkYXRlQUFCQigpO1xuICAgICAqICAgICBjb25zb2xlLmxvZyhib2R5LmFhYmJOZWVkc1VwZGF0ZSk7IC8vIGZhbHNlXG4gICAgICovXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGJvZHkgd2lsbCBhdXRvbWF0aWNhbGx5IGZhbGwgdG8gc2xlZXAuIE5vdGUgdGhhdCB5b3UgbmVlZCB0byBlbmFibGUgc2xlZXBpbmcgaW4gdGhlIHt7I2Nyb3NzTGluayBcIldvcmxkXCJ9fXt7L2Nyb3NzTGlua319IGJlZm9yZSBhbnl0aGluZyB3aWxsIGhhcHBlbi5cbiAgICAgKiBAcHJvcGVydHkgYWxsb3dTbGVlcFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmFsbG93U2xlZXAgPSB0cnVlO1xuXG4gICAgdGhpcy53YW50c1RvU2xlZXAgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE9uZSBvZiB7eyNjcm9zc0xpbmsgXCJCb2R5L0FXQUtFOnByb3BlcnR5XCJ9fUJvZHkuQVdBS0V7ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQm9keS9TTEVFUFk6cHJvcGVydHlcIn19Qm9keS5TTEVFUFl7ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiQm9keS9TTEVFUElORzpwcm9wZXJ0eVwifX1Cb2R5LlNMRUVQSU5He3svY3Jvc3NMaW5rfX0uXG4gICAgICpcbiAgICAgKiBUaGUgYm9keSBpcyBpbml0aWFsbHkgQm9keS5BV0FLRS4gSWYgaXRzIHZlbG9jaXR5IG5vcm0gaXMgYmVsb3cgLnNsZWVwU3BlZWRMaW1pdCwgdGhlIHNsZWVwU3RhdGUgd2lsbCBiZWNvbWUgQm9keS5TTEVFUFkuIElmIHRoZSBib2R5IGNvbnRpbnVlcyB0byBiZSBCb2R5LlNMRUVQWSBmb3IgLnNsZWVwVGltZUxpbWl0IHNlY29uZHMsIGl0IHdpbGwgZmFsbCBhc2xlZXAgKEJvZHkuU0xFRVBZKS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFN0YXRlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBCb2R5LkFXQUtFXG4gICAgICovXG4gICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzcGVlZCAodGhlIG5vcm0gb2YgdGhlIHZlbG9jaXR5KSBpcyBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGJvZHkgaXMgY29uc2lkZXJlZCBzbGVlcHkuXG4gICAgICogQHByb3BlcnR5IHNsZWVwU3BlZWRMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4yXG4gICAgICovXG4gICAgdGhpcy5zbGVlcFNwZWVkTGltaXQgPSAwLjI7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYm9keSBoYXMgYmVlbiBzbGVlcHkgZm9yIHRoaXMgc2xlZXBUaW1lTGltaXQgc2Vjb25kcywgaXQgaXMgY29uc2lkZXJlZCBzbGVlcGluZy5cbiAgICAgKiBAcHJvcGVydHkgc2xlZXBUaW1lTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICB0aGlzLnNsZWVwVGltZUxpbWl0ID0gMTtcblxuICAgIC8qKlxuICAgICAqIEdyYXZpdHkgc2NhbGluZyBmYWN0b3IuIElmIHlvdSB3YW50IHRoZSBib2R5IHRvIGlnbm9yZSBncmF2aXR5LCBzZXQgdGhpcyB0byB6ZXJvLiBJZiB5b3Ugd2FudCB0byByZXZlcnNlIGdyYXZpdHksIHNldCBpdCB0byAtMS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZ3Jhdml0eVNjYWxlXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuZ3Jhdml0eVNjYWxlID0gMTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC4gVGhhdCBtZWFucyB0aGF0IHRoaXMgYm9keSB3aWxsIG1vdmUgdGhyb3VnaCBvdGhlciBib2RpZXMsIGJ1dCBpdCB3aWxsIHN0aWxsIHRyaWdnZXIgY29udGFjdCBldmVudHMsIGV0Yy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBIb3cgbG9uZyB0aGUgYm9keSBoYXMgYmVlbiBzbGVlcGluZy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gaWRsZVRpbWVcbiAgICAgKi9cbiAgICB0aGlzLmlkbGVUaW1lID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IHRpbWUgd2hlbiB0aGUgYm9keSB3ZW50IHRvIFNMRUVQWSBzdGF0ZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gdGltZUxhc3RTbGVlcHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudGltZUxhc3RTbGVlcHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGJvZHkgc3BlZWQgZXhjZWVkcyB0aGlzIHRocmVzaG9sZCwgQ0NEIChjb250aW51b3VzIGNvbGxpc2lvbiBkZXRlY3Rpb24pIHdpbGwgYmUgZW5hYmxlZC4gU2V0IGl0IHRvIGEgbmVnYXRpdmUgbnVtYmVyIHRvIGRpc2FibGUgQ0NEIGNvbXBsZXRlbHkgZm9yIHRoaXMgYm9keS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY2NkU3BlZWRUaHJlc2hvbGRcbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqL1xuICAgIHRoaXMuY2NkU3BlZWRUaHJlc2hvbGQgPSBvcHRpb25zLmNjZFNwZWVkVGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNjZFNwZWVkVGhyZXNob2xkIDogLTE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIHNlYXJjaGluZyBmb3IgdGhlIHRpbWUgb2YgaW1wYWN0IGR1cmluZyBDQ0QuIEEgbGFyZ2VyIG51bWJlciB3aWxsIGFzc3VyZSB0aGF0IHRoZXJlJ3MgYSBzbWFsbCBwZW5ldHJhdGlvbiBvbiBDQ0QgY29sbGlzaW9uLCBidXQgYSBzbWFsbCBudW1iZXIgd2lsbCBnaXZlIG1vcmUgcGVyZm9ybWFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNjZEl0ZXJhdGlvbnNcbiAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAqL1xuICAgIHRoaXMuY2NkSXRlcmF0aW9ucyA9IG9wdGlvbnMuY2NkSXRlcmF0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jY2RJdGVyYXRpb25zIDogMTA7XG5cbiAgICB0aGlzLmNvbmNhdmVQYXRoID0gbnVsbDtcblxuICAgIHRoaXMuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcblxuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbn1cbkJvZHkucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuQm9keS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb2R5O1xuXG5Cb2R5Ll9pZENvdW50ZXIgPSAwO1xuXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gdGhpcy5pbnZNYXNzO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZSA9IHRoaXMuaW52SW5lcnRpYTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdG90YWwgZGVuc2l0eSBvZiB0aGUgYm9keVxuICogQG1ldGhvZCBzZXREZW5zaXR5XG4gKi9cbkJvZHkucHJvdG90eXBlLnNldERlbnNpdHkgPSBmdW5jdGlvbihkZW5zaXR5KSB7XG4gICAgdmFyIHRvdGFsQXJlYSA9IHRoaXMuZ2V0QXJlYSgpO1xuICAgIHRoaXMubWFzcyA9IHRvdGFsQXJlYSAqIGRlbnNpdHk7XG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRvdGFsIGFyZWEgb2YgYWxsIHNoYXBlcyBpbiB0aGUgYm9keVxuICogQG1ldGhvZCBnZXRBcmVhXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkJvZHkucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG90YWxBcmVhID0gMDtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnNoYXBlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRvdGFsQXJlYSArPSB0aGlzLnNoYXBlc1tpXS5hcmVhO1xuICAgIH1cbiAgICByZXR1cm4gdG90YWxBcmVhO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIEFBQkIgZnJvbSB0aGUgYm9keS4gVGhlIEFBQkIgaXMgdXBkYXRlZCBpZiBuZWNlc3NhcnkuXG4gKiBAbWV0aG9kIGdldEFBQkJcbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0QUFCQiA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWFiYjtcbn07XG5cbnZhciBzaGFwZUFBQkIgPSBuZXcgQUFCQigpLFxuICAgIHRtcCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgQUFCQiBvZiB0aGUgQm9keVxuICogQG1ldGhvZCB1cGRhdGVBQUJCXG4gKi9cbkJvZHkucHJvdG90eXBlLnVwZGF0ZUFBQkIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2hhcGVzID0gdGhpcy5zaGFwZXMsXG4gICAgICAgIHNoYXBlT2Zmc2V0cyA9IHRoaXMuc2hhcGVPZmZzZXRzLFxuICAgICAgICBzaGFwZUFuZ2xlcyA9IHRoaXMuc2hhcGVBbmdsZXMsXG4gICAgICAgIE4gPSBzaGFwZXMubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSB0bXAsXG4gICAgICAgIGJvZHlBbmdsZSA9IHRoaXMuYW5nbGU7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXSxcbiAgICAgICAgICAgIGFuZ2xlID0gc2hhcGVBbmdsZXNbaV0gKyBib2R5QW5nbGU7XG5cbiAgICAgICAgLy8gR2V0IHNoYXBlIHdvcmxkIG9mZnNldFxuICAgICAgICB2ZWMyLnJvdGF0ZShvZmZzZXQsIHNoYXBlT2Zmc2V0c1tpXSwgYm9keUFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQob2Zmc2V0LCBvZmZzZXQsIHRoaXMucG9zaXRpb24pO1xuXG4gICAgICAgIC8vIEdldCBzaGFwZSBBQUJCXG4gICAgICAgIHNoYXBlLmNvbXB1dGVBQUJCKHNoYXBlQUFCQiwgb2Zmc2V0LCBhbmdsZSk7XG5cbiAgICAgICAgaWYoaT09PTApe1xuICAgICAgICAgICAgdGhpcy5hYWJiLmNvcHkoc2hhcGVBQUJCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWFiYi5leHRlbmQoc2hhcGVBQUJCKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgcmFkaXVzIG9mIHRoZSBib2R5LiBTaG91bGQgYmUgZG9uZSBpZiBhbnkgb2YgdGhlIHNoYXBlc1xuICogYXJlIGNoYW5nZWQuXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKi9cbkJvZHkucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgc2hhcGVzID0gdGhpcy5zaGFwZXMsXG4gICAgICAgIHNoYXBlT2Zmc2V0cyA9IHRoaXMuc2hhcGVPZmZzZXRzLFxuICAgICAgICBOID0gc2hhcGVzLmxlbmd0aCxcbiAgICAgICAgcmFkaXVzID0gMDtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2ldLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdmVjMi5sZW5ndGgoc2hhcGVPZmZzZXRzW2ldKSxcbiAgICAgICAgICAgIHIgPSBzaGFwZS5ib3VuZGluZ1JhZGl1cztcbiAgICAgICAgaWYob2Zmc2V0ICsgciA+IHJhZGl1cyl7XG4gICAgICAgICAgICByYWRpdXMgPSBvZmZzZXQgKyByO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHJhZGl1cztcbn07XG5cbi8qKlxuICogQWRkIGEgc2hhcGUgdG8gdGhlIGJvZHkuIFlvdSBjYW4gcGFzcyBhIGxvY2FsIHRyYW5zZm9ybSB3aGVuIGFkZGluZyBhIHNoYXBlLFxuICogc28gdGhhdCB0aGUgc2hhcGUgZ2V0cyBhbiBvZmZzZXQgYW5kIGFuZ2xlIHJlbGF0aXZlIHRvIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzLlxuICogV2lsbCBhdXRvbWF0aWNhbGx5IHVwZGF0ZSB0aGUgbWFzcyBwcm9wZXJ0aWVzIGFuZCBib3VuZGluZyByYWRpdXMuXG4gKlxuICogQG1ldGhvZCBhZGRTaGFwZVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgICAgICAgICBzaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IFtvZmZzZXRdIExvY2FsIGJvZHkgb2Zmc2V0IG9mIHRoZSBzaGFwZS5cbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICAgICAgW2FuZ2xlXSAgTG9jYWwgYm9keSBhbmdsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoKSxcbiAqICAgICAgICAgc2hhcGUgPSBuZXcgQ2lyY2xlKCk7XG4gKlxuICogICAgIC8vIEFkZCB0aGUgc2hhcGUgdG8gdGhlIGJvZHksIHBvc2l0aW9uZWQgaW4gdGhlIGNlbnRlclxuICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUpO1xuICpcbiAqICAgICAvLyBBZGQgYW5vdGhlciBzaGFwZSB0byB0aGUgYm9keSwgcG9zaXRpb25lZCAxIHVuaXQgbGVuZ3RoIGZyb20gdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MgYWxvbmcgdGhlIGxvY2FsIHgtYXhpcy5cbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlLFsxLDBdKTtcbiAqXG4gKiAgICAgLy8gQWRkIGFub3RoZXIgc2hhcGUgdG8gdGhlIGJvZHksIHBvc2l0aW9uZWQgMSB1bml0IGxlbmd0aCBmcm9tIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzIGFsb25nIHRoZSBsb2NhbCB5LWF4aXMsIGFuZCByb3RhdGVkIDkwIGRlZ3JlZXMgQ0NXLlxuICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUsWzAsMV0sTWF0aC5QSS8yKTtcbiAqL1xuQm9keS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbihzaGFwZSxvZmZzZXQsYW5nbGUpe1xuICAgIGFuZ2xlID0gYW5nbGUgfHwgMC4wO1xuXG4gICAgLy8gQ29weSB0aGUgb2Zmc2V0IHZlY3RvclxuICAgIGlmKG9mZnNldCl7XG4gICAgICAgIG9mZnNldCA9IHZlYzIuZnJvbVZhbHVlcyhvZmZzZXRbMF0sb2Zmc2V0WzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICB9XG5cbiAgICB0aGlzLnNoYXBlcyAgICAgIC5wdXNoKHNoYXBlKTtcbiAgICB0aGlzLnNoYXBlT2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgdGhpcy5zaGFwZUFuZ2xlcyAucHVzaChhbmdsZSk7XG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcblxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgc2hhcGVcbiAqIEBtZXRob2QgcmVtb3ZlU2hhcGVcbiAqIEBwYXJhbSAge1NoYXBlfSAgc2hhcGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgIFRydWUgaWYgdGhlIHNoYXBlIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZCwgZWxzZSBmYWxzZS5cbiAqL1xuQm9keS5wcm90b3R5cGUucmVtb3ZlU2hhcGUgPSBmdW5jdGlvbihzaGFwZSl7XG4gICAgdmFyIGlkeCA9IHRoaXMuc2hhcGVzLmluZGV4T2Yoc2hhcGUpO1xuXG4gICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgIHRoaXMuc2hhcGVzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIHRoaXMuc2hhcGVPZmZzZXRzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIHRoaXMuc2hhcGVBbmdsZXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIC5pbmVydGlhLCAuaW52TWFzcywgLmludkluZXJ0aWEgZm9yIHRoaXMgQm9keS4gU2hvdWxkIGJlIGNhbGxlZCB3aGVuXG4gKiBjaGFuZ2luZyB0aGUgc3RydWN0dXJlIG9yIG1hc3Mgb2YgdGhlIEJvZHkuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVNYXNzUHJvcGVydGllc1xuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgYm9keS5tYXNzICs9IDE7XG4gKiAgICAgYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVNYXNzUHJvcGVydGllcyA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy50eXBlID09PSBCb2R5LlNUQVRJQyB8fCB0aGlzLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKXtcblxuICAgICAgICB0aGlzLm1hc3MgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB0aGlzLmludk1hc3MgPSAwO1xuICAgICAgICB0aGlzLmluZXJ0aWEgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB0aGlzLmludkluZXJ0aWEgPSAwO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICB2YXIgc2hhcGVzID0gdGhpcy5zaGFwZXMsXG4gICAgICAgICAgICBOID0gc2hhcGVzLmxlbmd0aCxcbiAgICAgICAgICAgIG0gPSB0aGlzLm1hc3MgLyBOLFxuICAgICAgICAgICAgSSA9IDA7XG5cbiAgICAgICAgaWYoIXRoaXMuZml4ZWRSb3RhdGlvbil7XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxOOyBpKyspe1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgcjIgPSB2ZWMyLnNxdWFyZWRMZW5ndGgodGhpcy5zaGFwZU9mZnNldHNbaV0pLFxuICAgICAgICAgICAgICAgICAgICBJY20gPSBzaGFwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhKG0pO1xuICAgICAgICAgICAgICAgIEkgKz0gSWNtICsgbSpyMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYSA9IEk7XG4gICAgICAgICAgICB0aGlzLmludkluZXJ0aWEgPSBJPjAgPyAxL0kgOiAwO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluZXJ0aWEgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludmVyc2UgbWFzcyBwcm9wZXJ0aWVzIGFyZSBlYXN5XG4gICAgICAgIHRoaXMuaW52TWFzcyA9IDEvdGhpcy5tYXNzOy8vID4gMCA/IDEvdGhpcy5tYXNzIDogMDtcbiAgICB9XG59O1xuXG52YXIgQm9keV9hcHBseUZvcmNlX3IgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEFwcGx5IGZvcmNlIHRvIGEgd29ybGQgcG9pbnQuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgYSBwb2ludCBvbiB0aGUgUmlnaWRCb2R5IHN1cmZhY2UuIEFwcGx5aW5nIGZvcmNlIHRoaXMgd2F5IHdpbGwgYWRkIHRvIEJvZHkuZm9yY2UgYW5kIEJvZHkuYW5ndWxhckZvcmNlLlxuICogQG1ldGhvZCBhcHBseUZvcmNlXG4gKiBAcGFyYW0ge0FycmF5fSBmb3JjZSBUaGUgZm9yY2UgdG8gYWRkLlxuICogQHBhcmFtIHtBcnJheX0gd29ybGRQb2ludCBBIHdvcmxkIHBvaW50IHRvIGFwcGx5IHRoZSBmb3JjZSBvbi5cbiAqL1xuQm9keS5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKGZvcmNlLHdvcmxkUG9pbnQpe1xuICAgIC8vIENvbXB1dGUgcG9pbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJvZHkgY2VudGVyXG4gICAgdmFyIHIgPSBCb2R5X2FwcGx5Rm9yY2VfcjtcbiAgICB2ZWMyLnN1YihyLHdvcmxkUG9pbnQsdGhpcy5wb3NpdGlvbik7XG5cbiAgICAvLyBBZGQgbGluZWFyIGZvcmNlXG4gICAgdmVjMi5hZGQodGhpcy5mb3JjZSx0aGlzLmZvcmNlLGZvcmNlKTtcblxuICAgIC8vIENvbXB1dGUgcHJvZHVjZWQgcm90YXRpb25hbCBmb3JjZVxuICAgIHZhciByb3RGb3JjZSA9IHZlYzIuY3Jvc3NMZW5ndGgocixmb3JjZSk7XG5cbiAgICAvLyBBZGQgcm90YXRpb25hbCBmb3JjZVxuICAgIHRoaXMuYW5ndWxhckZvcmNlICs9IHJvdEZvcmNlO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSB3b3JsZCBwb2ludCB0byBsb2NhbCBib2R5IGZyYW1lLlxuICogQG1ldGhvZCB0b0xvY2FsRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRQb2ludCAgIFRoZSBpbnB1dCB3b3JsZCB2ZWN0b3JcbiAqL1xuQm9keS5wcm90b3R5cGUudG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ob3V0LCB3b3JsZFBvaW50KXtcbiAgICB2ZWMyLnRvTG9jYWxGcmFtZShvdXQsIHdvcmxkUG9pbnQsIHRoaXMucG9zaXRpb24sIHRoaXMuYW5nbGUpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBsb2NhbCBwb2ludCB0byB3b3JsZCBmcmFtZS5cbiAqIEBtZXRob2QgdG9Xb3JsZEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0ICAgICAgICAgIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpblxuICogQHBhcmFtICB7QXJyYXl9IGxvY2FsUG9pbnQgICBUaGUgaW5wdXQgbG9jYWwgdmVjdG9yXG4gKi9cbkJvZHkucHJvdG90eXBlLnRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uKG91dCwgbG9jYWxQb2ludCl7XG4gICAgdmVjMi50b0dsb2JhbEZyYW1lKG91dCwgbG9jYWxQb2ludCwgdGhpcy5wb3NpdGlvbiwgdGhpcy5hbmdsZSk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgcG9seWdvbiBzaGFwZSBwYXRoLCBhbmQgYXNzZW1ibGVzIGNvbnZleCBzaGFwZXMgZnJvbSB0aGF0IGFuZCBwdXRzIHRoZW0gYXQgcHJvcGVyIG9mZnNldCBwb2ludHMuXG4gKiBAbWV0aG9kIGZyb21Qb2x5Z29uXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIEFuIGFycmF5IG9mIDJkIHZlY3RvcnMsIGUuZy4gW1swLDBdLFswLDFdLC4uLl0gdGhhdCByZXNlbWJsZXMgYSBjb25jYXZlIG9yIGNvbnZleCBwb2x5Z29uLiBUaGUgc2hhcGUgbXVzdCBiZSBzaW1wbGUgYW5kIHdpdGhvdXQgaG9sZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9wdGltYWxEZWNvbXA9ZmFsc2VdICAgU2V0IHRvIHRydWUgaWYgeW91IG5lZWQgb3B0aW1hbCBkZWNvbXBvc2l0aW9uLiBXYXJuaW5nOiB2ZXJ5IHNsb3cgZm9yIHBvbHlnb25zIHdpdGggbW9yZSB0aGFuIDEwIHZlcnRpY2VzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwU2ltcGxlQ2hlY2s9ZmFsc2VdIFNldCB0byB0cnVlIGlmIHlvdSBhbHJlYWR5IGtub3cgdGhhdCB0aGUgcGF0aCBpcyBub3QgaW50ZXJzZWN0aW5nIGl0c2VsZi5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxOdW1iZXJ9IFtvcHRpb25zLnJlbW92ZUNvbGxpbmVhclBvaW50cz1mYWxzZV0gU2V0IHRvIGEgbnVtYmVyIChhbmdsZSB0aHJlc2hvbGQgdmFsdWUpIHRvIHJlbW92ZSBjb2xsaW5lYXIgcG9pbnRzLCBvciBmYWxzZSB0byBrZWVwIGFsbCBwb2ludHMuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MsIGVsc2UgZmFsc2UuXG4gKi9cbkJvZHkucHJvdG90eXBlLmZyb21Qb2x5Z29uID0gZnVuY3Rpb24ocGF0aCxvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIFJlbW92ZSBhbGwgc2hhcGVzXG4gICAgZm9yKHZhciBpPXRoaXMuc2hhcGVzLmxlbmd0aDsgaT49MDsgLS1pKXtcbiAgICAgICAgdGhpcy5yZW1vdmVTaGFwZSh0aGlzLnNoYXBlc1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgZGVjb21wLlBvbHlnb24oKTtcbiAgICBwLnZlcnRpY2VzID0gcGF0aDtcblxuICAgIC8vIE1ha2UgaXQgY291bnRlci1jbG9ja3dpc2VcbiAgICBwLm1ha2VDQ1coKTtcblxuICAgIGlmKHR5cGVvZihvcHRpb25zLnJlbW92ZUNvbGxpbmVhclBvaW50cykgPT09IFwibnVtYmVyXCIpe1xuICAgICAgICBwLnJlbW92ZUNvbGxpbmVhclBvaW50cyhvcHRpb25zLnJlbW92ZUNvbGxpbmVhclBvaW50cyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYW55IGxpbmUgc2VnbWVudCBpbnRlcnNlY3RzIHRoZSBwYXRoIGl0c2VsZlxuICAgIGlmKHR5cGVvZihvcHRpb25zLnNraXBTaW1wbGVDaGVjaykgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICBpZighcC5pc1NpbXBsZSgpKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNhdmUgdGhpcyBwYXRoIGZvciBsYXRlclxuICAgIHRoaXMuY29uY2F2ZVBhdGggPSBwLnZlcnRpY2VzLnNsaWNlKDApO1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuY29uY2F2ZVBhdGgubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IFswLDBdO1xuICAgICAgICB2ZWMyLmNvcHkodix0aGlzLmNvbmNhdmVQYXRoW2ldKTtcbiAgICAgICAgdGhpcy5jb25jYXZlUGF0aFtpXSA9IHY7XG4gICAgfVxuXG4gICAgLy8gU2xvdyBvciBmYXN0IGRlY29tcD9cbiAgICB2YXIgY29udmV4ZXM7XG4gICAgaWYob3B0aW9ucy5vcHRpbWFsRGVjb21wKXtcbiAgICAgICAgY29udmV4ZXMgPSBwLmRlY29tcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnZleGVzID0gcC5xdWlja0RlY29tcCgpO1xuICAgIH1cblxuICAgIHZhciBjbSA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvLyBBZGQgY29udmV4ZXNcbiAgICBmb3IodmFyIGk9MDsgaSE9PWNvbnZleGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgLy8gQ3JlYXRlIGNvbnZleFxuICAgICAgICB2YXIgYyA9IG5ldyBDb252ZXgoY29udmV4ZXNbaV0udmVydGljZXMpO1xuXG4gICAgICAgIC8vIE1vdmUgYWxsIHZlcnRpY2VzIHNvIGl0cyBjZW50ZXIgb2YgbWFzcyBpcyBpbiB0aGUgbG9jYWwgY2VudGVyIG9mIHRoZSBjb252ZXhcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT1jLnZlcnRpY2VzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciB2ID0gYy52ZXJ0aWNlc1tqXTtcbiAgICAgICAgICAgIHZlYzIuc3ViKHYsdixjLmNlbnRlck9mTWFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2ZWMyLnNjYWxlKGNtLGMuY2VudGVyT2ZNYXNzLDEpO1xuICAgICAgICBjLnVwZGF0ZVRyaWFuZ2xlcygpO1xuICAgICAgICBjLnVwZGF0ZUNlbnRlck9mTWFzcygpO1xuICAgICAgICBjLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBzaGFwZVxuICAgICAgICB0aGlzLmFkZFNoYXBlKGMsY20pO1xuICAgIH1cblxuICAgIHRoaXMuYWRqdXN0Q2VudGVyT2ZNYXNzKCk7XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIGFkanVzdENlbnRlck9mTWFzc190bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wNCA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIE1vdmVzIHRoZSBzaGFwZSBvZmZzZXRzIHNvIHRoZWlyIGNlbnRlciBvZiBtYXNzIGJlY29tZXMgdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MuXG4gKiBAbWV0aG9kIGFkanVzdENlbnRlck9mTWFzc1xuICovXG5Cb2R5LnByb3RvdHlwZS5hZGp1c3RDZW50ZXJPZk1hc3MgPSBmdW5jdGlvbigpe1xuICAgIHZhciBvZmZzZXRfdGltZXNfYXJlYSA9IGFkanVzdENlbnRlck9mTWFzc190bXAyLFxuICAgICAgICBzdW0gPSAgICAgICAgICAgICAgIGFkanVzdENlbnRlck9mTWFzc190bXAzLFxuICAgICAgICBjbSA9ICAgICAgICAgICAgICAgIGFkanVzdENlbnRlck9mTWFzc190bXA0LFxuICAgICAgICB0b3RhbEFyZWEgPSAgICAgICAgIDA7XG4gICAgdmVjMi5zZXQoc3VtLDAsMCk7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PXRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNoYXBlc1tpXSxcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2hhcGVPZmZzZXRzW2ldO1xuICAgICAgICB2ZWMyLnNjYWxlKG9mZnNldF90aW1lc19hcmVhLG9mZnNldCxzLmFyZWEpO1xuICAgICAgICB2ZWMyLmFkZChzdW0sc3VtLG9mZnNldF90aW1lc19hcmVhKTtcbiAgICAgICAgdG90YWxBcmVhICs9IHMuYXJlYTtcbiAgICB9XG5cbiAgICB2ZWMyLnNjYWxlKGNtLHN1bSwxL3RvdGFsQXJlYSk7XG5cbiAgICAvLyBOb3cgbW92ZSBhbGwgc2hhcGVzXG4gICAgZm9yKHZhciBpPTA7IGkhPT10aGlzLnNoYXBlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzID0gdGhpcy5zaGFwZXNbaV0sXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNoYXBlT2Zmc2V0c1tpXTtcblxuICAgICAgICAvLyBPZmZzZXQgbWF5IGJlIHVuZGVmaW5lZC4gRml4IHRoYXQuXG4gICAgICAgIGlmKCFvZmZzZXQpe1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5zaGFwZU9mZnNldHNbaV0gPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVjMi5zdWIob2Zmc2V0LG9mZnNldCxjbSk7XG4gICAgfVxuXG4gICAgLy8gTW92ZSB0aGUgYm9keSBwb3NpdGlvbiB0b29cbiAgICB2ZWMyLmFkZCh0aGlzLnBvc2l0aW9uLHRoaXMucG9zaXRpb24sY20pO1xuXG4gICAgLy8gQW5kIGNvbmNhdmUgcGF0aFxuICAgIGZvcih2YXIgaT0wOyB0aGlzLmNvbmNhdmVQYXRoICYmIGk8dGhpcy5jb25jYXZlUGF0aC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZlYzIuc3ViKHRoaXMuY29uY2F2ZVBhdGhbaV0sIHRoaXMuY29uY2F2ZVBhdGhbaV0sIGNtKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBmb3JjZSBvbiB0aGUgYm9keSB0byB6ZXJvLlxuICogQG1ldGhvZCBzZXRaZXJvRm9yY2VcbiAqL1xuQm9keS5wcm90b3R5cGUuc2V0WmVyb0ZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICB2ZWMyLnNldCh0aGlzLmZvcmNlLDAuMCwwLjApO1xuICAgIHRoaXMuYW5ndWxhckZvcmNlID0gMC4wO1xufTtcblxuQm9keS5wcm90b3R5cGUucmVzZXRDb25zdHJhaW50VmVsb2NpdHkgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgdmxhbWJkYSA9IGIudmxhbWJkYTtcbiAgICB2ZWMyLnNldCh2bGFtYmRhLDAsMCk7XG4gICAgYi53bGFtYmRhID0gMDtcbn07XG5cbkJvZHkucHJvdG90eXBlLmFkZENvbnN0cmFpbnRWZWxvY2l0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICB2ID0gYi52ZWxvY2l0eTtcbiAgICB2ZWMyLmFkZCggdiwgdiwgYi52bGFtYmRhKTtcbiAgICBiLmFuZ3VsYXJWZWxvY2l0eSArPSBiLndsYW1iZGE7XG59O1xuXG4vKipcbiAqIEFwcGx5IGRhbXBpbmcsIHNlZSA8YSBocmVmPVwiaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2J1bGxldC9pc3N1ZXMvZGV0YWlsP2lkPTc0XCI+dGhpczwvYT4gZm9yIGRldGFpbHMuXG4gKiBAbWV0aG9kIGFwcGx5RGFtcGluZ1xuICogQHBhcmFtICB7bnVtYmVyfSBkdCBDdXJyZW50IHRpbWUgc3RlcFxuICovXG5Cb2R5LnByb3RvdHlwZS5hcHBseURhbXBpbmcgPSBmdW5jdGlvbihkdCl7XG4gICAgaWYodGhpcy50eXBlID09PSBCb2R5LkRZTkFNSUMpeyAvLyBPbmx5IGZvciBkeW5hbWljIGJvZGllc1xuICAgICAgICB2YXIgdiA9IHRoaXMudmVsb2NpdHk7XG4gICAgICAgIHZlYzIuc2NhbGUodiwgdiwgTWF0aC5wb3coMS4wIC0gdGhpcy5kYW1waW5nLGR0KSk7XG4gICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ICo9IE1hdGgucG93KDEuMCAtIHRoaXMuYW5ndWxhckRhbXBpbmcsZHQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogV2FrZSB0aGUgYm9keSB1cC4gTm9ybWFsbHkgeW91IHNob3VsZCBub3QgbmVlZCB0aGlzLCBhcyB0aGUgYm9keSBpcyBhdXRvbWF0aWNhbGx5IGF3b2tlbiBhdCBldmVudHMgc3VjaCBhcyBjb2xsaXNpb25zLlxuICogU2V0cyB0aGUgc2xlZXBTdGF0ZSB0byB7eyNjcm9zc0xpbmsgXCJCb2R5L0FXQUtFOnByb3BlcnR5XCJ9fUJvZHkuQVdBS0V7ey9jcm9zc0xpbmt9fSBhbmQgZW1pdHMgdGhlIHdha2VVcCBldmVudCBpZiB0aGUgYm9keSB3YXNuJ3QgYXdha2UgYmVmb3JlLlxuICogQG1ldGhvZCB3YWtlVXBcbiAqL1xuQm9keS5wcm90b3R5cGUud2FrZVVwID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcyA9IHRoaXMuc2xlZXBTdGF0ZTtcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LkFXQUtFO1xuICAgIHRoaXMuaWRsZVRpbWUgPSAwO1xuICAgIGlmKHMgIT09IEJvZHkuQVdBS0Upe1xuICAgICAgICB0aGlzLmVtaXQoQm9keS53YWtlVXBFdmVudCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBGb3JjZSBib2R5IHNsZWVwXG4gKiBAbWV0aG9kIHNsZWVwXG4gKi9cbkJvZHkucHJvdG90eXBlLnNsZWVwID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQSU5HO1xuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gMDtcbiAgICB0aGlzLmFuZ3VsYXJGb3JjZSA9IDA7XG4gICAgdmVjMi5zZXQodGhpcy52ZWxvY2l0eSwwLDApO1xuICAgIHZlYzIuc2V0KHRoaXMuZm9yY2UsMCwwKTtcbiAgICB0aGlzLmVtaXQoQm9keS5zbGVlcEV2ZW50KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGV2ZXJ5IHRpbWVzdGVwIHRvIHVwZGF0ZSBpbnRlcm5hbCBzbGVlcCB0aW1lciBhbmQgY2hhbmdlIHNsZWVwIHN0YXRlIGlmIG5lZWRlZC5cbiAqIEBtZXRob2Qgc2xlZXBUaWNrXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgd29ybGQgdGltZSBpbiBzZWNvbmRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRvbnRTbGVlcFxuICogQHBhcmFtIHtudW1iZXJ9IGR0XG4gKi9cbkJvZHkucHJvdG90eXBlLnNsZWVwVGljayA9IGZ1bmN0aW9uKHRpbWUsIGRvbnRTbGVlcCwgZHQpe1xuICAgIGlmKCF0aGlzLmFsbG93U2xlZXAgfHwgdGhpcy50eXBlID09PSBCb2R5LlNMRUVQSU5HKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2FudHNUb1NsZWVwID0gZmFsc2U7XG5cbiAgICB2YXIgc2xlZXBTdGF0ZSA9IHRoaXMuc2xlZXBTdGF0ZSxcbiAgICAgICAgc3BlZWRTcXVhcmVkID0gdmVjMi5zcXVhcmVkTGVuZ3RoKHRoaXMudmVsb2NpdHkpICsgTWF0aC5wb3codGhpcy5hbmd1bGFyVmVsb2NpdHksMiksXG4gICAgICAgIHNwZWVkTGltaXRTcXVhcmVkID0gTWF0aC5wb3codGhpcy5zbGVlcFNwZWVkTGltaXQsMik7XG5cbiAgICAvLyBBZGQgdG8gaWRsZSB0aW1lXG4gICAgaWYoc3BlZWRTcXVhcmVkID49IHNwZWVkTGltaXRTcXVhcmVkKXtcbiAgICAgICAgdGhpcy5pZGxlVGltZSA9IDA7XG4gICAgICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuQVdBS0U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pZGxlVGltZSArPSBkdDtcbiAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUFk7XG4gICAgfVxuICAgIGlmKHRoaXMuaWRsZVRpbWUgPiB0aGlzLnNsZWVwVGltZUxpbWl0KXtcbiAgICAgICAgaWYoIWRvbnRTbGVlcCl7XG4gICAgICAgICAgICB0aGlzLnNsZWVwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndhbnRzVG9TbGVlcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgIGlmKHNsZWVwU3RhdGU9PT1Cb2R5LkFXQUtFICYmIHNwZWVkU3F1YXJlZCA8IHNwZWVkTGltaXRTcXVhcmVkKXtcbiAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUFk7IC8vIFNsZWVweVxuICAgICAgICB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gdGltZTtcbiAgICAgICAgdGhpcy5lbWl0KEJvZHkuc2xlZXB5RXZlbnQpO1xuICAgIH0gZWxzZSBpZihzbGVlcFN0YXRlPT09Qm9keS5TTEVFUFkgJiYgc3BlZWRTcXVhcmVkID49IHNwZWVkTGltaXRTcXVhcmVkKXtcbiAgICAgICAgdGhpcy53YWtlVXAoKTsgLy8gV2FrZSB1cFxuICAgIH0gZWxzZSBpZihzbGVlcFN0YXRlPT09Qm9keS5TTEVFUFkgJiYgKHRpbWUgLSB0aGlzLnRpbWVMYXN0U2xlZXB5ICkgPiB0aGlzLnNsZWVwVGltZUxpbWl0KXtcbiAgICAgICAgdGhpcy53YW50c1RvU2xlZXAgPSB0cnVlO1xuICAgICAgICBpZighZG9udFNsZWVwKXtcbiAgICAgICAgICAgIHRoaXMuc2xlZXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqL1xufTtcblxuQm9keS5wcm90b3R5cGUuZ2V0VmVsb2NpdHlGcm9tUG9zaXRpb24gPSBmdW5jdGlvbihzdG9yZSwgdGltZVN0ZXApe1xuICAgIHN0b3JlID0gc3RvcmUgfHwgdmVjMi5jcmVhdGUoKTtcbiAgICB2ZWMyLnN1YihzdG9yZSwgdGhpcy5wb3NpdGlvbiwgdGhpcy5wcmV2aW91c1Bvc2l0aW9uKTtcbiAgICB2ZWMyLnNjYWxlKHN0b3JlLCBzdG9yZSwgMS90aW1lU3RlcCk7XG4gICAgcmV0dXJuIHN0b3JlO1xufTtcblxuQm9keS5wcm90b3R5cGUuZ2V0QW5ndWxhclZlbG9jaXR5RnJvbVBvc2l0aW9uID0gZnVuY3Rpb24odGltZVN0ZXApe1xuICAgIHJldHVybiAodGhpcy5hbmdsZSAtIHRoaXMucHJldmlvdXNBbmdsZSkgLyB0aW1lU3RlcDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvZHkgaXMgb3ZlcmxhcHBpbmcgYW5vdGhlciBib2R5LiBOb3RlIHRoYXQgdGhpcyBtZXRob2Qgb25seSB3b3JrcyBpZiB0aGUgYm9keSB3YXMgYWRkZWQgdG8gYSBXb3JsZCBhbmQgaWYgYXQgbGVhc3Qgb25lIHN0ZXAgd2FzIHRha2VuLlxuICogQG1ldGhvZCBvdmVybGFwc1xuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuQm9keS5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbihib2R5KXtcbiAgICByZXR1cm4gdGhpcy53b3JsZC5vdmVybGFwS2VlcGVyLmJvZGllc0FyZU92ZXJsYXBwaW5nKHRoaXMsIGJvZHkpO1xufTtcblxudmFyIGludGVncmF0ZV9maE1pbnYgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVncmF0ZV92ZWxvZHQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIE1vdmUgdGhlIGJvZHkgZm9yd2FyZCBpbiB0aW1lIGdpdmVuIGl0cyBjdXJyZW50IHZlbG9jaXR5LlxuICogQG1ldGhvZCBpbnRlZ3JhdGVcbiAqIEBwYXJhbSAge051bWJlcn0gZHRcbiAqL1xuQm9keS5wcm90b3R5cGUuaW50ZWdyYXRlID0gZnVuY3Rpb24oZHQpe1xuICAgIHZhciBtaW52ID0gdGhpcy5pbnZNYXNzLFxuICAgICAgICBmID0gdGhpcy5mb3JjZSxcbiAgICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbixcbiAgICAgICAgdmVsbyA9IHRoaXMudmVsb2NpdHk7XG5cbiAgICAvLyBTYXZlIG9sZCBwb3NpdGlvblxuICAgIHZlYzIuY29weSh0aGlzLnByZXZpb3VzUG9zaXRpb24sIHRoaXMucG9zaXRpb24pO1xuICAgIHRoaXMucHJldmlvdXNBbmdsZSA9IHRoaXMuYW5nbGU7XG5cbiAgICAvLyBWZWxvY2l0eSB1cGRhdGVcbiAgICBpZighdGhpcy5maXhlZFJvdGF0aW9uKXtcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKz0gdGhpcy5hbmd1bGFyRm9yY2UgKiB0aGlzLmludkluZXJ0aWEgKiBkdDtcbiAgICB9XG4gICAgdmVjMi5zY2FsZShpbnRlZ3JhdGVfZmhNaW52LCBmLCBkdCAqIG1pbnYpO1xuICAgIHZlYzIuYWRkKHZlbG8sIGludGVncmF0ZV9maE1pbnYsIHZlbG8pO1xuXG4gICAgLy8gQ0NEXG4gICAgaWYoIXRoaXMuaW50ZWdyYXRlVG9UaW1lT2ZJbXBhY3QoZHQpKXtcblxuICAgICAgICAvLyBSZWd1bGFyIHBvc2l0aW9uIHVwZGF0ZVxuICAgICAgICB2ZWMyLnNjYWxlKGludGVncmF0ZV92ZWxvZHQsIHZlbG8sIGR0KTtcbiAgICAgICAgdmVjMi5hZGQocG9zLCBwb3MsIGludGVncmF0ZV92ZWxvZHQpO1xuICAgICAgICBpZighdGhpcy5maXhlZFJvdGF0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuYW5nbGUgKz0gdGhpcy5hbmd1bGFyVmVsb2NpdHkgKiBkdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcbn07XG5cbnZhciBkaXJlY3Rpb24gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGVuZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgc3RhcnRUb0VuZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgcmVtZW1iZXJQb3NpdGlvbiA9IHZlYzIuY3JlYXRlKCk7XG5Cb2R5LnByb3RvdHlwZS5pbnRlZ3JhdGVUb1RpbWVPZkltcGFjdCA9IGZ1bmN0aW9uKGR0KXtcblxuICAgIGlmKHRoaXMuY2NkU3BlZWRUaHJlc2hvbGQgPCAwIHx8IHZlYzIuc3F1YXJlZExlbmd0aCh0aGlzLnZlbG9jaXR5KSA8IE1hdGgucG93KHRoaXMuY2NkU3BlZWRUaHJlc2hvbGQsIDIpKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZlYzIubm9ybWFsaXplKGRpcmVjdGlvbiwgdGhpcy52ZWxvY2l0eSk7XG5cbiAgICB2ZWMyLnNjYWxlKGVuZCwgdGhpcy52ZWxvY2l0eSwgZHQpO1xuICAgIHZlYzIuYWRkKGVuZCwgZW5kLCB0aGlzLnBvc2l0aW9uKTtcblxuICAgIHZlYzIuc3ViKHN0YXJ0VG9FbmQsIGVuZCwgdGhpcy5wb3NpdGlvbik7XG4gICAgdmFyIHN0YXJ0VG9FbmRBbmdsZSA9IHRoaXMuYW5ndWxhclZlbG9jaXR5ICogZHQ7XG4gICAgdmFyIGxlbiA9IHZlYzIubGVuZ3RoKHN0YXJ0VG9FbmQpO1xuXG4gICAgdmFyIHRpbWVPZkltcGFjdCA9IDE7XG5cbiAgICB2YXIgaGl0O1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLndvcmxkLnJheWNhc3RBbGwodGhpcy5wb3NpdGlvbiwgZW5kLCB7fSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZihyZXN1bHQuYm9keSA9PT0gdGhhdCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGl0ID0gcmVzdWx0LmJvZHk7XG4gICAgICAgIHZlYzIuY29weShlbmQsIHJlc3VsdC5oaXRQb2ludFdvcmxkKTtcbiAgICAgICAgdmVjMi5zdWIoc3RhcnRUb0VuZCwgcmVzdWx0LmhpdFBvaW50V29ybGQsIHRoYXQucG9zaXRpb24pO1xuICAgICAgICB0aW1lT2ZJbXBhY3QgPSB2ZWMyLmxlbmd0aChzdGFydFRvRW5kKSAvIGxlbjtcbiAgICAgICAgcmVzdWx0LmFib3J0KCk7XG4gICAgfSk7XG5cbiAgICBpZighaGl0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciByZW1lbWJlckFuZ2xlID0gdGhpcy5hbmdsZTtcbiAgICB2ZWMyLmNvcHkocmVtZW1iZXJQb3NpdGlvbiwgdGhpcy5wb3NpdGlvbik7XG5cbiAgICAvLyBHb3QgYSBzdGFydCBhbmQgZW5kIHBvaW50LiBBcHByb3hpbWF0ZSB0aW1lIG9mIGltcGFjdCB1c2luZyBiaW5hcnkgc2VhcmNoXG4gICAgdmFyIGl0ZXIgPSAwO1xuICAgIHZhciB0bWluID0gMDtcbiAgICB2YXIgdG1pZCA9IDA7XG4gICAgdmFyIHRtYXggPSB0aW1lT2ZJbXBhY3Q7XG4gICAgd2hpbGUgKHRtYXggPj0gdG1pbiAmJiBpdGVyIDwgdGhpcy5jY2RJdGVyYXRpb25zKSB7XG4gICAgICAgIGl0ZXIrKztcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG1pZHBvaW50XG4gICAgICAgIHRtaWQgPSAodG1heCAtIHRtaW4pIC8gMjtcblxuICAgICAgICAvLyBNb3ZlIHRoZSBib2R5IHRvIHRoYXQgcG9pbnRcbiAgICAgICAgdmVjMi5zY2FsZShpbnRlZ3JhdGVfdmVsb2R0LCBzdGFydFRvRW5kLCB0aW1lT2ZJbXBhY3QpO1xuICAgICAgICB2ZWMyLmFkZCh0aGlzLnBvc2l0aW9uLCByZW1lbWJlclBvc2l0aW9uLCBpbnRlZ3JhdGVfdmVsb2R0KTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IHJlbWVtYmVyQW5nbGUgKyBzdGFydFRvRW5kQW5nbGUgKiB0aW1lT2ZJbXBhY3Q7XG4gICAgICAgIHRoaXMudXBkYXRlQUFCQigpO1xuXG4gICAgICAgIC8vIGNoZWNrIG92ZXJsYXBcbiAgICAgICAgdmFyIG92ZXJsYXBzID0gdGhpcy5hYWJiLm92ZXJsYXBzKGhpdC5hYWJiKSAmJiB0aGlzLndvcmxkLm5hcnJvd3BoYXNlLmJvZGllc092ZXJsYXAodGhpcywgaGl0KTtcblxuICAgICAgICBpZiAob3ZlcmxhcHMpIHtcbiAgICAgICAgICAgIC8vIGNoYW5nZSBtaW4gdG8gc2VhcmNoIHVwcGVyIGludGVydmFsXG4gICAgICAgICAgICB0bWluID0gdG1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNoYW5nZSBtYXggdG8gc2VhcmNoIGxvd2VyIGludGVydmFsXG4gICAgICAgICAgICB0bWF4ID0gdG1pZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVPZkltcGFjdCA9IHRtaWQ7XG5cbiAgICB2ZWMyLmNvcHkodGhpcy5wb3NpdGlvbiwgcmVtZW1iZXJQb3NpdGlvbik7XG4gICAgdGhpcy5hbmdsZSA9IHJlbWVtYmVyQW5nbGU7XG5cbiAgICAvLyBtb3ZlIHRvIFRPSVxuICAgIHZlYzIuc2NhbGUoaW50ZWdyYXRlX3ZlbG9kdCwgc3RhcnRUb0VuZCwgdGltZU9mSW1wYWN0KTtcbiAgICB2ZWMyLmFkZCh0aGlzLnBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uLCBpbnRlZ3JhdGVfdmVsb2R0KTtcbiAgICBpZighdGhpcy5maXhlZFJvdGF0aW9uKXtcbiAgICAgICAgdGhpcy5hbmdsZSArPSBzdGFydFRvRW5kQW5nbGUgKiB0aW1lT2ZJbXBhY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBldmVudCBzbGVlcHlcbiAqL1xuQm9keS5zbGVlcHlFdmVudCA9IHtcbiAgICB0eXBlOiBcInNsZWVweVwiXG59O1xuXG4vKipcbiAqIEBldmVudCBzbGVlcFxuICovXG5Cb2R5LnNsZWVwRXZlbnQgPSB7XG4gICAgdHlwZTogXCJzbGVlcFwiXG59O1xuXG4vKipcbiAqIEBldmVudCB3YWtldXBcbiAqL1xuQm9keS53YWtlVXBFdmVudCA9IHtcbiAgICB0eXBlOiBcIndha2V1cFwiXG59O1xuXG4vKipcbiAqIER5bmFtaWMgYm9keS5cbiAqIEBwcm9wZXJ0eSBEWU5BTUlDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LkRZTkFNSUMgPSAxO1xuXG4vKipcbiAqIFN0YXRpYyBib2R5LlxuICogQHByb3BlcnR5IFNUQVRJQ1xuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuQm9keS5TVEFUSUMgPSAyO1xuXG4vKipcbiAqIEtpbmVtYXRpYyBib2R5LlxuICogQHByb3BlcnR5IEtJTkVNQVRJQ1xuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuQm9keS5LSU5FTUFUSUMgPSA0O1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBBV0FLRVxuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuQm9keS5BV0FLRSA9IDA7XG5cbi8qKlxuICogQHByb3BlcnR5IFNMRUVQWVxuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuQm9keS5TTEVFUFkgPSAxO1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBTTEVFUElOR1xuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuQm9keS5TTEVFUElORyA9IDI7XG5cblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjcsXCIuLi9ldmVudHMvRXZlbnRFbWl0dGVyXCI6MjcsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3NoYXBlcy9Db252ZXhcIjozOSxcInBvbHktZGVjb21wXCI6NX1dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgU3ByaW5nID0gX2RlcmVxXygnLi9TcHJpbmcnKTtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZWFyU3ByaW5nO1xuXG4vKipcbiAqIEEgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMuXG4gKlxuICogVGhlIFNwcmluZyBleHBsaWNpdGx5IGFkZHMgZm9yY2UgYW5kIGFuZ3VsYXJGb3JjZSB0byB0aGUgYm9kaWVzLlxuICpcbiAqIEBjbGFzcyBMaW5lYXJTcHJpbmdcbiAqIEBleHRlbmRzIFNwcmluZ1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzdExlbmd0aF0gICBBIG51bWJlciA+IDAuIERlZmF1bHQgaXMgdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGlmZm5lc3M9MTAwXSAgU3ByaW5nIGNvbnN0YW50IChzZWUgSG9va2VzIExhdykuIEEgbnVtYmVyID49IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZz0xXSAgICAgIEEgbnVtYmVyID49IDAuIERlZmF1bHQ6IDFcbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdICAgV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuIE92ZXJyaWRlcyB0aGUgb3B0aW9uIFwibG9jYWxBbmNob3JBXCIgaWYgZ2l2ZW4uXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JCXVxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiBsb2NhbCBib2R5IGNvb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB0aGUgYm9keSBjZW50ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxuICovXG5mdW5jdGlvbiBMaW5lYXJTcHJpbmcoYm9keUEsYm9keUIsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBTcHJpbmcuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QSBpbiBsb2NhbCBib2R5QSBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JBID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBBbmNob3IgZm9yIGJvZHlCIGluIGxvY2FsIGJvZHlCIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JBKXsgdmVjMi5jb3B5KHRoaXMubG9jYWxBbmNob3JBLCBvcHRpb25zLmxvY2FsQW5jaG9yQSk7IH1cbiAgICBpZihvcHRpb25zLmxvY2FsQW5jaG9yQil7IHZlYzIuY29weSh0aGlzLmxvY2FsQW5jaG9yQiwgb3B0aW9ucy5sb2NhbEFuY2hvckIpOyB9XG4gICAgaWYob3B0aW9ucy53b3JsZEFuY2hvckEpeyB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7IH1cbiAgICBpZihvcHRpb25zLndvcmxkQW5jaG9yQil7IHRoaXMuc2V0V29ybGRBbmNob3JCKG9wdGlvbnMud29ybGRBbmNob3JCKTsgfVxuXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdmFyIHdvcmxkQW5jaG9yQiA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xuICAgIHZhciB3b3JsZERpc3RhbmNlID0gdmVjMi5kaXN0YW5jZSh3b3JsZEFuY2hvckEsIHdvcmxkQW5jaG9yQik7XG5cbiAgICAvKipcbiAgICAgKiBSZXN0IGxlbmd0aCBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0TGVuZ3RoXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RMZW5ndGggPSB0eXBlb2Yob3B0aW9ucy5yZXN0TGVuZ3RoKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmVzdExlbmd0aCA6IHdvcmxkRGlzdGFuY2U7XG59XG5MaW5lYXJTcHJpbmcucHJvdG90eXBlID0gbmV3IFNwcmluZygpO1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVhclNwcmluZztcblxuLyoqXG4gKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBzZXRXb3JsZEFuY2hvckFcbiAqIEBwYXJhbSB7QXJyYXl9IHdvcmxkQW5jaG9yQVxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLnNldFdvcmxkQW5jaG9yQSA9IGZ1bmN0aW9uKHdvcmxkQW5jaG9yQSl7XG4gICAgdGhpcy5ib2R5QS50b0xvY2FsRnJhbWUodGhpcy5sb2NhbEFuY2hvckEsIHdvcmxkQW5jaG9yQSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtBcnJheX0gd29ybGRBbmNob3JCXG4gKi9cbkxpbmVhclNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JCID0gZnVuY3Rpb24od29ybGRBbmNob3JCKXtcbiAgICB0aGlzLmJvZHlCLnRvTG9jYWxGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQiwgd29ybGRBbmNob3JCKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JBXG4gKiBAcGFyYW0ge0FycmF5fSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQSA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdGhpcy5ib2R5QS50b1dvcmxkRnJhbWUocmVzdWx0LCB0aGlzLmxvY2FsQW5jaG9yQSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIGdldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtBcnJheX0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5nZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMuYm9keUIudG9Xb3JsZEZyYW1lKHJlc3VsdCwgdGhpcy5sb2NhbEFuY2hvckIpO1xufTtcblxudmFyIGFwcGx5Rm9yY2VfciA9ICAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2Vfcl91bml0ID0gICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfdSA9ICAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfZiA9ICAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBID0gICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCID0gICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfcmkgPSAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfcmogPSAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfdG1wID0gICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5kYW1waW5nLFxuICAgICAgICBsID0gdGhpcy5yZXN0TGVuZ3RoLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgciA9IGFwcGx5Rm9yY2VfcixcbiAgICAgICAgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQsXG4gICAgICAgIHUgPSBhcHBseUZvcmNlX3UsXG4gICAgICAgIGYgPSBhcHBseUZvcmNlX2YsXG4gICAgICAgIHRtcCA9IGFwcGx5Rm9yY2VfdG1wO1xuXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBLFxuICAgICAgICB3b3JsZEFuY2hvckIgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQixcbiAgICAgICAgcmkgPSBhcHBseUZvcmNlX3JpLFxuICAgICAgICByaiA9IGFwcGx5Rm9yY2Vfcmo7XG5cbiAgICAvLyBHZXQgd29ybGQgYW5jaG9yc1xuICAgIHRoaXMuZ2V0V29ybGRBbmNob3JBKHdvcmxkQW5jaG9yQSk7XG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKTtcblxuICAgIC8vIEdldCBvZmZzZXQgcG9pbnRzXG4gICAgdmVjMi5zdWIocmksIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgIHZlYzIuc3ViKHJqLCB3b3JsZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcblxuICAgIC8vIENvbXB1dGUgZGlzdGFuY2UgdmVjdG9yIGJldHdlZW4gd29ybGQgYW5jaG9yIHBvaW50c1xuICAgIHZlYzIuc3ViKHIsIHdvcmxkQW5jaG9yQiwgd29ybGRBbmNob3JBKTtcbiAgICB2YXIgcmxlbiA9IHZlYzIubGVuKHIpO1xuICAgIHZlYzIubm9ybWFsaXplKHJfdW5pdCxyKTtcblxuICAgIC8vY29uc29sZS5sb2cocmxlbilcbiAgICAvL2NvbnNvbGUubG9nKFwiQVwiLHZlYzIuc3RyKHdvcmxkQW5jaG9yQSksXCJCXCIsdmVjMi5zdHIod29ybGRBbmNob3JCKSlcblxuICAgIC8vIENvbXB1dGUgcmVsYXRpdmUgdmVsb2NpdHkgb2YgdGhlIGFuY2hvciBwb2ludHMsIHVcbiAgICB2ZWMyLnN1Yih1LCBib2R5Qi52ZWxvY2l0eSwgYm9keUEudmVsb2NpdHkpO1xuICAgIHZlYzIuY3Jvc3NaVih0bXAsIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSwgcmopO1xuICAgIHZlYzIuYWRkKHUsIHUsIHRtcCk7XG4gICAgdmVjMi5jcm9zc1pWKHRtcCwgYm9keUEuYW5ndWxhclZlbG9jaXR5LCByaSk7XG4gICAgdmVjMi5zdWIodSwgdSwgdG1wKTtcblxuICAgIC8vIEYgPSAtIGsgKiAoIHggLSBMICkgLSBEICogKCB1IClcbiAgICB2ZWMyLnNjYWxlKGYsIHJfdW5pdCwgLWsqKHJsZW4tbCkgLSBkKnZlYzIuZG90KHUscl91bml0KSk7XG5cbiAgICAvLyBBZGQgZm9yY2VzIHRvIGJvZGllc1xuICAgIHZlYzIuc3ViKCBib2R5QS5mb3JjZSwgYm9keUEuZm9yY2UsIGYpO1xuICAgIHZlYzIuYWRkKCBib2R5Qi5mb3JjZSwgYm9keUIuZm9yY2UsIGYpO1xuXG4gICAgLy8gQW5ndWxhciBmb3JjZVxuICAgIHZhciByaV94X2YgPSB2ZWMyLmNyb3NzTGVuZ3RoKHJpLCBmKTtcbiAgICB2YXIgcmpfeF9mID0gdmVjMi5jcm9zc0xlbmd0aChyaiwgZik7XG4gICAgYm9keUEuYW5ndWxhckZvcmNlIC09IHJpX3hfZjtcbiAgICBib2R5Qi5hbmd1bGFyRm9yY2UgKz0gcmpfeF9mO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3V0aWxzL1V0aWxzXCI6NTAsXCIuL1NwcmluZ1wiOjM1fV0sMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBTcHJpbmcgPSBfZGVyZXFfKCcuL1NwcmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxTcHJpbmc7XG5cbi8qKlxuICogQSByb3RhdGlvbmFsIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzIHJvdGF0aW9uLiBUaGlzIHNwcmluZyBleHBsaWNpdGx5IGFkZHMgYW5ndWxhckZvcmNlICh0b3JxdWUpIHRvIHRoZSBib2RpZXMuXG4gKlxuICogVGhlIHNwcmluZyBjYW4gYmUgY29tYmluZWQgd2l0aCBhIHt7I2Nyb3NzTGluayBcIlJldm9sdXRlQ29uc3RyYWludFwifX17ey9jcm9zc0xpbmt9fSB0byBtYWtlLCBmb3IgZXhhbXBsZSwgYSBtb3VzZSB0cmFwLlxuICpcbiAqIEBjbGFzcyBSb3RhdGlvbmFsU3ByaW5nXG4gKiBAZXh0ZW5kcyBTcHJpbmdcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc3RBbmdsZV0gVGhlIHJlbGF0aXZlIGFuZ2xlIG9mIGJvZGllcyBhdCB3aGljaCB0aGUgc3ByaW5nIGlzIGF0IHJlc3QuIElmIG5vdCBnaXZlbiwgaXQncyBzZXQgdG8gdGhlIGN1cnJlbnQgcmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gQSBudW1iZXIgPj0gMC5cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbFNwcmluZyhib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgU3ByaW5nLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFJlc3QgYW5nbGUgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgcmVzdEFuZ2xlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RBbmdsZSA9IHR5cGVvZihvcHRpb25zLnJlc3RBbmdsZSkgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLnJlc3RBbmdsZSA6IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XG59XG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZSA9IG5ldyBTcHJpbmcoKTtcblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbFNwcmluZztcblxuLyoqXG4gKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxuICogQG1ldGhvZCBhcHBseUZvcmNlXG4gKi9cblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MsXG4gICAgICAgIGQgPSB0aGlzLmRhbXBpbmcsXG4gICAgICAgIGwgPSB0aGlzLnJlc3RBbmdsZSxcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHggPSBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlLFxuICAgICAgICB1ID0gYm9keUIuYW5ndWxhclZlbG9jaXR5IC0gYm9keUEuYW5ndWxhclZlbG9jaXR5O1xuXG4gICAgdmFyIHRvcnF1ZSA9IC0gayAqICh4IC0gbCkgLSBkICogdSAqIDA7XG5cbiAgICBib2R5QS5hbmd1bGFyRm9yY2UgLT0gdG9ycXVlO1xuICAgIGJvZHlCLmFuZ3VsYXJGb3JjZSArPSB0b3JxdWU7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9TcHJpbmdcIjozNX1dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcmluZztcblxuLyoqXG4gKiBBIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzLiBUaGUgU3ByaW5nIGV4cGxpY2l0bHkgYWRkcyBmb3JjZSBhbmQgYW5ndWxhckZvcmNlIHRvIHRoZSBib2RpZXMgYW5kIGRvZXMgdGhlcmVmb3JlIG5vdCBwdXQgbG9hZCBvbiB0aGUgY29uc3RyYWludCBzb2x2ZXIuXG4gKlxuICogQGNsYXNzIFNwcmluZ1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzPTEwMF0gIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gICAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuIERlZmF1bHRzIHRvIHRoZSBib2R5IGNlbnRlci5cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBPdmVycmlkZXMgdGhlIG9wdGlvbiBcImxvY2FsQW5jaG9yQVwiIGlmIGdpdmVuLlxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQl1cbiAqL1xuZnVuY3Rpb24gU3ByaW5nKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICBzdGlmZm5lc3M6IDEwMCxcbiAgICAgICAgZGFtcGluZzogMSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gb3B0aW9ucy5zdGlmZm5lc3M7XG5cbiAgICAvKipcbiAgICAgKiBEYW1waW5nIG9mIHRoZSBzcHJpbmcuXG4gICAgICogQHByb3BlcnR5IGRhbXBpbmdcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGFtcGluZyA9IG9wdGlvbnMuZGFtcGluZztcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IGNvbm5lY3RlZCBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QVxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcblxuICAgIC8qKlxuICAgICAqIFNlY29uZCBjb25uZWN0ZWQgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYm9keUJcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIHNwcmluZyBmb3JjZSB0byB0aGUgY29ubmVjdGVkIGJvZGllcy5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICovXG5TcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIC8vIFRvIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXNcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjUwfV0sMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gRXhwb3J0IHAyIGNsYXNzZXNcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEFBQkIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vQUFCQicpLFxuICAgIEFuZ2xlTG9ja0VxdWF0aW9uIDogICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvQW5nbGVMb2NrRXF1YXRpb24nKSxcbiAgICBCb2R5IDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9Cb2R5JyksXG4gICAgQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJyksXG4gICAgQ2Fwc3VsZSA6ICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9DYXBzdWxlJyksXG4gICAgQ2lyY2xlIDogICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9DaXJjbGUnKSxcbiAgICBDb25zdHJhaW50IDogICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvQ29uc3RyYWludCcpLFxuICAgIENvbnRhY3RFcXVhdGlvbiA6ICAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyksXG4gICAgQ29udGFjdE1hdGVyaWFsIDogICAgICAgICAgICAgICBfZGVyZXFfKCcuL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbCcpLFxuICAgIENvbnZleCA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ29udmV4JyksXG4gICAgRGlzdGFuY2VDb25zdHJhaW50IDogICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludCcpLFxuICAgIEVxdWF0aW9uIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvRXF1YXRpb24nKSxcbiAgICBFdmVudEVtaXR0ZXIgOiAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXZlbnRzL0V2ZW50RW1pdHRlcicpLFxuICAgIEZyaWN0aW9uRXF1YXRpb24gOiAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpLFxuICAgIEdlYXJDb25zdHJhaW50IDogICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludCcpLFxuICAgIEdyaWRCcm9hZHBoYXNlIDogICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vR3JpZEJyb2FkcGhhc2UnKSxcbiAgICBHU1NvbHZlciA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc29sdmVyL0dTU29sdmVyJyksXG4gICAgSGVpZ2h0ZmllbGQgOiAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9IZWlnaHRmaWVsZCcpLFxuICAgIExpbmUgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvTGluZScpLFxuICAgIExvY2tDb25zdHJhaW50IDogICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9Mb2NrQ29uc3RyYWludCcpLFxuICAgIE1hdGVyaWFsIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRlcmlhbC9NYXRlcmlhbCcpLFxuICAgIE5hcnJvd3BoYXNlIDogICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vTmFycm93cGhhc2UnKSxcbiAgICBOYWl2ZUJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL05haXZlQnJvYWRwaGFzZScpLFxuICAgIFBhcnRpY2xlIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvUGFydGljbGUnKSxcbiAgICBQbGFuZSA6ICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL1BsYW5lJyksXG4gICAgUmV2b2x1dGVDb25zdHJhaW50IDogICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL1Jldm9sdXRlQ29uc3RyYWludCcpLFxuICAgIFByaXNtYXRpY0NvbnN0cmFpbnQgOiAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9QcmlzbWF0aWNDb25zdHJhaW50JyksXG4gICAgUmF5IDogICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9SYXknKSxcbiAgICBSYXljYXN0UmVzdWx0IDogICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKSxcbiAgICBSZWN0YW5nbGUgOiAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL1JlY3RhbmdsZScpLFxuICAgIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uIDogICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24nKSxcbiAgICBTQVBCcm9hZHBoYXNlIDogICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL1NBUEJyb2FkcGhhc2UnKSxcbiAgICBTaGFwZSA6ICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL1NoYXBlJyksXG4gICAgU29sdmVyIDogICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NvbHZlci9Tb2x2ZXInKSxcbiAgICBTcHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9TcHJpbmcnKSxcbiAgICBMaW5lYXJTcHJpbmcgOiAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9MaW5lYXJTcHJpbmcnKSxcbiAgICBSb3RhdGlvbmFsU3ByaW5nIDogICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9Sb3RhdGlvbmFsU3ByaW5nJyksXG4gICAgVXRpbHMgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3V0aWxzL1V0aWxzJyksXG4gICAgV29ybGQgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3dvcmxkL1dvcmxkJyksXG4gICAgdmVjMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL21hdGgvdmVjMicpLFxuICAgIHZlcnNpb24gOiAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcbn07XG5cbn0se1wiLi4vcGFja2FnZS5qc29uXCI6NixcIi4vY29sbGlzaW9uL0FBQkJcIjo3LFwiLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjgsXCIuL2NvbGxpc2lvbi9HcmlkQnJvYWRwaGFzZVwiOjksXCIuL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2VcIjoxMCxcIi4vY29sbGlzaW9uL05hcnJvd3BoYXNlXCI6MTEsXCIuL2NvbGxpc2lvbi9SYXlcIjoxMixcIi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHRcIjoxMyxcIi4vY29sbGlzaW9uL1NBUEJyb2FkcGhhc2VcIjoxNCxcIi4vY29uc3RyYWludHMvQ29uc3RyYWludFwiOjE1LFwiLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnRcIjoxNixcIi4vY29uc3RyYWludHMvR2VhckNvbnN0cmFpbnRcIjoxNyxcIi4vY29uc3RyYWludHMvTG9ja0NvbnN0cmFpbnRcIjoxOCxcIi4vY29uc3RyYWludHMvUHJpc21hdGljQ29uc3RyYWludFwiOjE5LFwiLi9jb25zdHJhaW50cy9SZXZvbHV0ZUNvbnN0cmFpbnRcIjoyMCxcIi4vZXF1YXRpb25zL0FuZ2xlTG9ja0VxdWF0aW9uXCI6MjEsXCIuL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoyMixcIi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjMsXCIuL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uXCI6MjQsXCIuL2VxdWF0aW9ucy9Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvblwiOjI2LFwiLi9ldmVudHMvRXZlbnRFbWl0dGVyXCI6MjcsXCIuL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbFwiOjI4LFwiLi9tYXRlcmlhbC9NYXRlcmlhbFwiOjI5LFwiLi9tYXRoL3ZlYzJcIjozMSxcIi4vb2JqZWN0cy9Cb2R5XCI6MzIsXCIuL29iamVjdHMvTGluZWFyU3ByaW5nXCI6MzMsXCIuL29iamVjdHMvUm90YXRpb25hbFNwcmluZ1wiOjM0LFwiLi9vYmplY3RzL1NwcmluZ1wiOjM1LFwiLi9zaGFwZXMvQ2Fwc3VsZVwiOjM3LFwiLi9zaGFwZXMvQ2lyY2xlXCI6MzgsXCIuL3NoYXBlcy9Db252ZXhcIjozOSxcIi4vc2hhcGVzL0hlaWdodGZpZWxkXCI6NDAsXCIuL3NoYXBlcy9MaW5lXCI6NDEsXCIuL3NoYXBlcy9QYXJ0aWNsZVwiOjQyLFwiLi9zaGFwZXMvUGxhbmVcIjo0MyxcIi4vc2hhcGVzL1JlY3RhbmdsZVwiOjQ0LFwiLi9zaGFwZXMvU2hhcGVcIjo0NSxcIi4vc29sdmVyL0dTU29sdmVyXCI6NDYsXCIuL3NvbHZlci9Tb2x2ZXJcIjo0NyxcIi4vdXRpbHMvVXRpbHNcIjo1MCxcIi4vd29ybGQvV29ybGRcIjo1NH1dLDM3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYXBzdWxlO1xuXG4vKipcbiAqIENhcHN1bGUgc2hhcGUgY2xhc3MuXG4gKiBAY2xhc3MgQ2Fwc3VsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtsZW5ndGg9MV0gVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGVuZCBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzPTFdIFJhZGl1cyBvZiB0aGUgY2Fwc3VsZVxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgcmFkaXVzID0gMTtcbiAqICAgICB2YXIgbGVuZ3RoID0gMjtcbiAqICAgICB2YXIgY2Fwc3VsZVNoYXBlID0gbmV3IENhcHN1bGUobGVuZ3RoLCByYWRpdXMpO1xuICogICAgIGJvZHkuYWRkU2hhcGUoY2Fwc3VsZVNoYXBlKTtcbiAqL1xuZnVuY3Rpb24gQ2Fwc3VsZShsZW5ndGgsIHJhZGl1cyl7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZW5kIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbGVuZ3RoXG4gICAgICovXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGggfHwgMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIGNhcHN1bGUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzIHx8IDE7XG5cbiAgICBTaGFwZS5jYWxsKHRoaXMsU2hhcGUuQ0FQU1VMRSk7XG59XG5DYXBzdWxlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuQ2Fwc3VsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYXBzdWxlO1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIG1hc3MgbW9tZW50IG9mIGluZXJ0aWEgb2YgdGhlIENhcHN1bGUuXG4gKiBAbWV0aG9kIGNvbnB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICogQHRvZG9cbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIC8vIEFwcHJveGltYXRlIHdpdGggcmVjdGFuZ2xlXG4gICAgdmFyIHIgPSB0aGlzLnJhZGl1cyxcbiAgICAgICAgdyA9IHRoaXMubGVuZ3RoICsgciwgLy8gMipyIGlzIHRvbyBtdWNoLCAwIGlzIHRvbyBsaXR0bGVcbiAgICAgICAgaCA9IHIqMjtcbiAgICByZXR1cm4gbWFzcyAqIChoKmggKyB3KncpIC8gMTI7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSB0aGlzLnJhZGl1cyArIHRoaXMubGVuZ3RoLzI7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlQXJlYVxuICovXG5DYXBzdWxlLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmFyZWEgPSBNYXRoLlBJICogdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyArIHRoaXMucmFkaXVzICogMiAqIHRoaXMubGVuZ3RoO1xufTtcblxudmFyIHIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5DYXBzdWxlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2YXIgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG5cbiAgICAvLyBDb21wdXRlIGNlbnRlciBwb3NpdGlvbiBvZiBvbmUgb2YgdGhlIHRoZSBjaXJjbGVzLCB3b3JsZCBvcmllbnRlZCwgYnV0IHdpdGggbG9jYWwgb2Zmc2V0XG4gICAgdmVjMi5zZXQocix0aGlzLmxlbmd0aCAvIDIsMCk7XG4gICAgaWYoYW5nbGUgIT09IDApe1xuICAgICAgICB2ZWMyLnJvdGF0ZShyLHIsYW5nbGUpO1xuICAgIH1cblxuICAgIC8vIEdldCBib3VuZHNcbiAgICB2ZWMyLnNldChvdXQudXBwZXJCb3VuZCwgIE1hdGgubWF4KHJbMF0rcmFkaXVzLCAtclswXStyYWRpdXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoclsxXStyYWRpdXMsIC1yWzFdK3JhZGl1cykpO1xuICAgIHZlYzIuc2V0KG91dC5sb3dlckJvdW5kLCAgTWF0aC5taW4oclswXS1yYWRpdXMsIC1yWzBdLXJhZGl1cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihyWzFdLXJhZGl1cywgLXJbMV0tcmFkaXVzKSk7XG5cbiAgICAvLyBBZGQgb2Zmc2V0XG4gICAgdmVjMi5hZGQob3V0Lmxvd2VyQm91bmQsIG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgdmVjMi5hZGQob3V0LnVwcGVyQm91bmQsIG91dC51cHBlckJvdW5kLCBwb3NpdGlvbik7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9TaGFwZVwiOjQ1fV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGU7XG5cbi8qKlxuICogQ2lyY2xlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIENpcmNsZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXM9MV0gVGhlIHJhZGl1cyBvZiB0aGlzIGNpcmNsZVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHJhZGl1cyA9IDE7XG4gKiAgICAgdmFyIGNpcmNsZVNoYXBlID0gbmV3IENpcmNsZShyYWRpdXMpO1xuICogICAgIGJvZHkuYWRkU2hhcGUoY2lyY2xlU2hhcGUpO1xuICovXG5mdW5jdGlvbiBDaXJjbGUocmFkaXVzKXtcblxuICAgIC8qKlxuICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cbiAgICAgKiBAcHJvcGVydHkgcmFkaXVzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzLFNoYXBlLkNJUkNMRSk7XG59XG5DaXJjbGUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5DaXJjbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlO1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkNpcmNsZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHZhciByID0gdGhpcy5yYWRpdXM7XG4gICAgcmV0dXJuIG1hc3MgKiByICogciAvIDI7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHRoaXMucmFkaXVzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZUFyZWFcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmFyZWEgPSBNYXRoLlBJICogdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cztcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkNpcmNsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIHIgPSB0aGlzLnJhZGl1cztcbiAgICB2ZWMyLnNldChvdXQudXBwZXJCb3VuZCwgIHIsICByKTtcbiAgICB2ZWMyLnNldChvdXQubG93ZXJCb3VuZCwgLXIsIC1yKTtcbiAgICBpZihwb3NpdGlvbil7XG4gICAgICAgIHZlYzIuYWRkKG91dC5sb3dlckJvdW5kLCBvdXQubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgICAgICB2ZWMyLmFkZChvdXQudXBwZXJCb3VuZCwgb3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcbiAgICB9XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9TaGFwZVwiOjQ1fV0sMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgcG9seWsgPSBfZGVyZXFfKCcuLi9tYXRoL3BvbHlrJylcbiwgICBkZWNvbXAgPSBfZGVyZXFfKCdwb2x5LWRlY29tcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnZleDtcblxuLyoqXG4gKiBDb252ZXggc2hhcGUgY2xhc3MuXG4gKiBAY2xhc3MgQ29udmV4XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAcGFyYW0ge0FycmF5fSB2ZXJ0aWNlcyBBbiBhcnJheSBvZiB2ZXJ0aWNlcyB0aGF0IHNwYW4gdGhpcyBzaGFwZS4gVmVydGljZXMgYXJlIGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIChDQ1cpIGRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IFtheGVzXSBBbiBhcnJheSBvZiB1bml0IGxlbmd0aCB2ZWN0b3JzLCByZXByZXNlbnRpbmcgdGhlIHN5bW1ldHJ5IGF4ZXMgaW4gdGhlIGNvbnZleC5cbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gQ3JlYXRlIGEgYm94XG4gKiAgICAgdmFyIHZlcnRpY2VzID0gW1stMSwtMV0sIFsxLC0xXSwgWzEsMV0sIFstMSwxXV07XG4gKiAgICAgdmFyIGNvbnZleFNoYXBlID0gbmV3IENvbnZleCh2ZXJ0aWNlcyk7XG4gKiAgICAgYm9keS5hZGRTaGFwZShjb252ZXhTaGFwZSk7XG4gKi9cbmZ1bmN0aW9uIENvbnZleCh2ZXJ0aWNlcywgYXhlcyl7XG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNlcyBkZWZpbmVkIGluIHRoZSBsb2NhbCBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQXhlcyBkZWZpbmVkIGluIHRoZSBsb2NhbCBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkgYXhlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmF4ZXMgPSBbXTtcblxuICAgIC8vIENvcHkgdGhlIHZlcnRzXG4gICAgZm9yKHZhciBpPTA7IGk8dmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHZlYzIuY3JlYXRlKCk7XG4gICAgICAgIHZlYzIuY29weSh2LHZlcnRpY2VzW2ldKTtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKHYpO1xuICAgIH1cblxuICAgIGlmKGF4ZXMpe1xuICAgICAgICAvLyBDb3B5IHRoZSBheGVzXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIDwgYXhlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IHZlYzIuY3JlYXRlKCk7XG4gICAgICAgICAgICB2ZWMyLmNvcHkoYXhpcywgYXhlc1tpXSk7XG4gICAgICAgICAgICB0aGlzLmF4ZXMucHVzaChheGlzKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnN0cnVjdCBheGVzIGZyb20gdGhlIHZlcnRleCBkYXRhXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHdvcmxkIGVkZ2VcbiAgICAgICAgICAgIHZhciB3b3JsZFBvaW50MCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgdmFyIHdvcmxkUG9pbnQxID0gdmVydGljZXNbKGkrMSkgJSB2ZXJ0aWNlcy5sZW5ndGhdO1xuXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gdmVjMi5jcmVhdGUoKTtcbiAgICAgICAgICAgIHZlYzIuc3ViKG5vcm1hbCwgd29ybGRQb2ludDEsIHdvcmxkUG9pbnQwKTtcblxuICAgICAgICAgICAgLy8gR2V0IG5vcm1hbCAtIGp1c3Qgcm90YXRlIDkwIGRlZ3JlZXMgc2luY2UgdmVydGljZXMgYXJlIGdpdmVuIGluIENDV1xuICAgICAgICAgICAgdmVjMi5yb3RhdGU5MGN3KG5vcm1hbCwgbm9ybWFsKTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcblxuICAgICAgICAgICAgdGhpcy5heGVzLnB1c2gobm9ybWFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjZW50ZXIgb2YgbWFzcyBvZiB0aGUgQ29udmV4XG4gICAgICogQHByb3BlcnR5IGNlbnRlck9mTWFzc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNlbnRlck9mTWFzcyA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogVHJpYW5ndWxhdGVkIHZlcnNpb24gb2YgdGhpcyBjb252ZXguIFRoZSBzdHJ1Y3R1cmUgaXMgQXJyYXkgb2YgMy1BcnJheXMsIGFuZCBlYWNoIHN1YmFycmF5IGNvbnRhaW5zIDMgaW50ZWdlcnMsIHJlZmVyZW5jaW5nIHRoZSB2ZXJ0aWNlcy5cbiAgICAgKiBAcHJvcGVydHkgdHJpYW5nbGVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudHJpYW5nbGVzID0gW107XG5cbiAgICBpZih0aGlzLnZlcnRpY2VzLmxlbmd0aCl7XG4gICAgICAgIHRoaXMudXBkYXRlVHJpYW5nbGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ2VudGVyT2ZNYXNzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgY29udmV4XG4gICAgICogQHByb3BlcnR5IGJvdW5kaW5nUmFkaXVzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gMDtcblxuICAgIFNoYXBlLmNhbGwodGhpcywgU2hhcGUuQ09OVkVYKTtcblxuICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZUFyZWEoKTtcbiAgICBpZih0aGlzLmFyZWEgPCAwKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4IHZlcnRpY2VzIG11c3QgYmUgZ2l2ZW4gaW4gY29udGVyLWNsb2Nrd2lzZSB3aW5kaW5nLlwiKTtcbiAgICB9XG59XG5Db252ZXgucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5Db252ZXgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udmV4O1xuXG52YXIgdG1wVmVjMSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgdG1wVmVjMiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogUHJvamVjdCBhIENvbnZleCBvbnRvIGEgd29ybGQtb3JpZW50ZWQgYXhpc1xuICogQG1ldGhvZCBwcm9qZWN0T250b0F4aXNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRcbiAqIEBwYXJhbSAge0FycmF5fSBsb2NhbEF4aXNcbiAqIEBwYXJhbSAge0FycmF5fSByZXN1bHRcbiAqL1xuQ29udmV4LnByb3RvdHlwZS5wcm9qZWN0T250b0xvY2FsQXhpcyA9IGZ1bmN0aW9uKGxvY2FsQXhpcywgcmVzdWx0KXtcbiAgICB2YXIgbWF4PW51bGwsXG4gICAgICAgIG1pbj1udWxsLFxuICAgICAgICB2LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbG9jYWxBeGlzID0gdG1wVmVjMTtcblxuICAgIC8vIEdldCBwcm9qZWN0ZWQgcG9zaXRpb24gb2YgYWxsIHZlcnRpY2VzXG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzW2ldO1xuICAgICAgICB2YWx1ZSA9IHZlYzIuZG90KHYsIGxvY2FsQXhpcyk7XG4gICAgICAgIGlmKG1heCA9PT0gbnVsbCB8fCB2YWx1ZSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZihtaW4gPT09IG51bGwgfHwgdmFsdWUgPCBtaW4pe1xuICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihtaW4gPiBtYXgpe1xuICAgICAgICB2YXIgdCA9IG1pbjtcbiAgICAgICAgbWluID0gbWF4O1xuICAgICAgICBtYXggPSB0O1xuICAgIH1cblxuICAgIHZlYzIuc2V0KHJlc3VsdCwgbWluLCBtYXgpO1xufTtcblxuQ29udmV4LnByb3RvdHlwZS5wcm9qZWN0T250b1dvcmxkQXhpcyA9IGZ1bmN0aW9uKGxvY2FsQXhpcywgc2hhcGVPZmZzZXQsIHNoYXBlQW5nbGUsIHJlc3VsdCl7XG4gICAgdmFyIHdvcmxkQXhpcyA9IHRtcFZlYzI7XG5cbiAgICB0aGlzLnByb2plY3RPbnRvTG9jYWxBeGlzKGxvY2FsQXhpcywgcmVzdWx0KTtcblxuICAgIC8vIFByb2plY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5IG9udG8gdGhlIGF4aXMgLSBuZWVkIHRvIGFkZCB0aGlzIHRvIHRoZSByZXN1bHRcbiAgICBpZihzaGFwZUFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRBeGlzLCBsb2NhbEF4aXMsIHNoYXBlQW5nbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmxkQXhpcyA9IGxvY2FsQXhpcztcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IHZlYzIuZG90KHNoYXBlT2Zmc2V0LCB3b3JsZEF4aXMpO1xuXG4gICAgdmVjMi5zZXQocmVzdWx0LCByZXN1bHRbMF0gKyBvZmZzZXQsIHJlc3VsdFsxXSArIG9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSAudHJpYW5nbGVzIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZVRyaWFuZ2xlc1xuICovXG5Db252ZXgucHJvdG90eXBlLnVwZGF0ZVRyaWFuZ2xlcyA9IGZ1bmN0aW9uKCl7XG5cbiAgICB0aGlzLnRyaWFuZ2xlcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmV3cml0ZSBvbiBwb2x5ayBub3RhdGlvbiwgYXJyYXkgb2YgbnVtYmVyc1xuICAgIHZhciBwb2x5a1ZlcnRzID0gW107XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tpXTtcbiAgICAgICAgcG9seWtWZXJ0cy5wdXNoKHZbMF0sdlsxXSk7XG4gICAgfVxuXG4gICAgLy8gVHJpYW5ndWxhdGVcbiAgICB2YXIgdHJpYW5nbGVzID0gcG9seWsuVHJpYW5ndWxhdGUocG9seWtWZXJ0cyk7XG5cbiAgICAvLyBMb29wIG92ZXIgYWxsIHRyaWFuZ2xlcywgYWRkIHRoZWlyIGluZXJ0aWEgY29udHJpYnV0aW9ucyB0byBJXG4gICAgZm9yKHZhciBpPTA7IGk8dHJpYW5nbGVzLmxlbmd0aDsgaSs9Myl7XG4gICAgICAgIHZhciBpZDEgPSB0cmlhbmdsZXNbaV0sXG4gICAgICAgICAgICBpZDIgPSB0cmlhbmdsZXNbaSsxXSxcbiAgICAgICAgICAgIGlkMyA9IHRyaWFuZ2xlc1tpKzJdO1xuXG4gICAgICAgIC8vIEFkZCB0byB0cmlhbmdsZXNcbiAgICAgICAgdGhpcy50cmlhbmdsZXMucHVzaChbaWQxLGlkMixpZDNdKTtcbiAgICB9XG59O1xuXG52YXIgdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWRfdGltZXNfbWFzcyA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2EgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19iID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfYyA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2FjID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfY2EgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19jYiA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX24gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLmNlbnRlck9mTWFzcyBwcm9wZXJ0eS5cbiAqIEBtZXRob2QgdXBkYXRlQ2VudGVyT2ZNYXNzXG4gKi9cbkNvbnZleC5wcm90b3R5cGUudXBkYXRlQ2VudGVyT2ZNYXNzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdHJpYW5nbGVzID0gdGhpcy50cmlhbmdsZXMsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgY20gPSB0aGlzLmNlbnRlck9mTWFzcyxcbiAgICAgICAgY2VudHJvaWQgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWQsXG4gICAgICAgIG4gPSB1cGRhdGVDZW50ZXJPZk1hc3NfbixcbiAgICAgICAgYSA9IHVwZGF0ZUNlbnRlck9mTWFzc19hLFxuICAgICAgICBiID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2IsXG4gICAgICAgIGMgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYyxcbiAgICAgICAgYWMgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYWMsXG4gICAgICAgIGNhID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2NhLFxuICAgICAgICBjYiA9IHVwZGF0ZUNlbnRlck9mTWFzc19jYixcbiAgICAgICAgY2VudHJvaWRfdGltZXNfbWFzcyA9IHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZF90aW1lc19tYXNzO1xuXG4gICAgdmVjMi5zZXQoY20sMCwwKTtcbiAgICB2YXIgdG90YWxBcmVhID0gMDtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09dHJpYW5nbGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHQgPSB0cmlhbmdsZXNbaV0sXG4gICAgICAgICAgICBhID0gdmVydHNbdFswXV0sXG4gICAgICAgICAgICBiID0gdmVydHNbdFsxXV0sXG4gICAgICAgICAgICBjID0gdmVydHNbdFsyXV07XG5cbiAgICAgICAgdmVjMi5jZW50cm9pZChjZW50cm9pZCxhLGIsYyk7XG5cbiAgICAgICAgLy8gR2V0IG1hc3MgZm9yIHRoZSB0cmlhbmdsZSAoZGVuc2l0eT0xIGluIHRoaXMgY2FzZSlcbiAgICAgICAgLy8gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzgwMTk4L2FyZWEtb2YtdHJpYW5nbGUtdmlhLXZlY3RvcnNcbiAgICAgICAgdmFyIG0gPSBDb252ZXgudHJpYW5nbGVBcmVhKGEsYixjKTtcbiAgICAgICAgdG90YWxBcmVhICs9IG07XG5cbiAgICAgICAgLy8gQWRkIHRvIGNlbnRlciBvZiBtYXNzXG4gICAgICAgIHZlYzIuc2NhbGUoY2VudHJvaWRfdGltZXNfbWFzcywgY2VudHJvaWQsIG0pO1xuICAgICAgICB2ZWMyLmFkZChjbSwgY20sIGNlbnRyb2lkX3RpbWVzX21hc3MpO1xuICAgIH1cblxuICAgIHZlYzIuc2NhbGUoY20sY20sMS90b3RhbEFyZWEpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtYXNzIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBDb252ZXguXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICogQHNlZSBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzM0MjgyMi1tb21lbnQtb2YtaW5lcnRpYS1vZi1hLXBvbHlnb24tMmQvXG4gKi9cbkNvbnZleC5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHZhciBkZW5vbSA9IDAuMCxcbiAgICAgICAgbnVtZXIgPSAwLjAsXG4gICAgICAgIE4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICBmb3IodmFyIGogPSBOLTEsIGkgPSAwOyBpIDwgTjsgaiA9IGksIGkgKyspe1xuICAgICAgICB2YXIgcDAgPSB0aGlzLnZlcnRpY2VzW2pdO1xuICAgICAgICB2YXIgcDEgPSB0aGlzLnZlcnRpY2VzW2ldO1xuICAgICAgICB2YXIgYSA9IE1hdGguYWJzKHZlYzIuY3Jvc3NMZW5ndGgocDAscDEpKTtcbiAgICAgICAgdmFyIGIgPSB2ZWMyLmRvdChwMSxwMSkgKyB2ZWMyLmRvdChwMSxwMCkgKyB2ZWMyLmRvdChwMCxwMCk7XG4gICAgICAgIGRlbm9tICs9IGEgKiBiO1xuICAgICAgICBudW1lciArPSBhO1xuICAgIH1cbiAgICByZXR1cm4gKG1hc3MgLyA2LjApICogKGRlbm9tIC8gbnVtZXIpO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSAuYm91bmRpbmdSYWRpdXMgcHJvcGVydHlcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuQ29udmV4LnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgcjIgPSAwO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBsMiA9IHZlYzIuc3F1YXJlZExlbmd0aCh2ZXJ0c1tpXSk7XG4gICAgICAgIGlmKGwyID4gcjIpe1xuICAgICAgICAgICAgcjIgPSBsMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBNYXRoLnNxcnQocjIpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFyZWEgb2YgdGhlIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIHBvaW50cyBhLCBiLCBjLiBUaGUgYXJlYSBpcyBwb3NpdGl2ZSBpZiB0aGUgcG9pbnRzIGFyZSBnaXZlbiBpbiBjb3VudGVyLWNsb2Nrd2lzZSBvcmRlciwgb3RoZXJ3aXNlIG5lZ2F0aXZlLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCB0cmlhbmdsZUFyZWFcbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7QXJyYXl9IGJcbiAqIEBwYXJhbSB7QXJyYXl9IGNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQ29udmV4LnRyaWFuZ2xlQXJlYSA9IGZ1bmN0aW9uKGEsYixjKXtcbiAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pKihjWzFdIC0gYVsxXSkpLSgoY1swXSAtIGFbMF0pKihiWzFdIC0gYVsxXSkpKSAqIDAuNTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSAuYXJlYVxuICogQG1ldGhvZCB1cGRhdGVBcmVhXG4gKi9cbkNvbnZleC5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy51cGRhdGVUcmlhbmdsZXMoKTtcbiAgICB0aGlzLmFyZWEgPSAwO1xuXG4gICAgdmFyIHRyaWFuZ2xlcyA9IHRoaXMudHJpYW5nbGVzLFxuICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgZm9yKHZhciBpPTA7IGkhPT10cmlhbmdsZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdCA9IHRyaWFuZ2xlc1tpXSxcbiAgICAgICAgICAgIGEgPSB2ZXJ0c1t0WzBdXSxcbiAgICAgICAgICAgIGIgPSB2ZXJ0c1t0WzFdXSxcbiAgICAgICAgICAgIGMgPSB2ZXJ0c1t0WzJdXTtcblxuICAgICAgICAvLyBHZXQgbWFzcyBmb3IgdGhlIHRyaWFuZ2xlIChkZW5zaXR5PTEgaW4gdGhpcyBjYXNlKVxuICAgICAgICB2YXIgbSA9IENvbnZleC50cmlhbmdsZUFyZWEoYSxiLGMpO1xuICAgICAgICB0aGlzLmFyZWEgKz0gbTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkNvbnZleC5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgb3V0LnNldEZyb21Qb2ludHModGhpcy52ZXJ0aWNlcywgcG9zaXRpb24sIGFuZ2xlLCAwKTtcbn07XG5cbn0se1wiLi4vbWF0aC9wb2x5a1wiOjMwLFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL1NoYXBlXCI6NDUsXCJwb2x5LWRlY29tcFwiOjV9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWlnaHRmaWVsZDtcblxuLyoqXG4gKiBIZWlnaHRmaWVsZCBzaGFwZSBjbGFzcy4gSGVpZ2h0IGRhdGEgaXMgZ2l2ZW4gYXMgYW4gYXJyYXkuIFRoZXNlIGRhdGEgcG9pbnRzIGFyZSBzcHJlYWQgb3V0IGV2ZW5seSB3aXRoIGEgZGlzdGFuY2UgXCJlbGVtZW50V2lkdGhcIi5cbiAqIEBjbGFzcyBIZWlnaHRmaWVsZFxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBbiBhcnJheSBvZiBZIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHRlcnJhaW4uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblZhbHVlXSBNaW5pbXVtIHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cyBpbiB0aGUgZGF0YSBhcnJheS4gV2lsbCBiZSBjb21wdXRlZCBhdXRvbWF0aWNhbGx5IGlmIG5vdCBnaXZlbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhWYWx1ZV0gTWF4aW11bSB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lbGVtZW50V2lkdGg9MC4xXSBXb3JsZCBzcGFjaW5nIGJldHdlZW4gdGhlIGRhdGEgcG9pbnRzIGluIFggZGlyZWN0aW9uLlxuICogQHRvZG8gU2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVzZSBhbG9uZyBhbGwgYXhlcywgbm90IGp1c3QgeVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gR2VuZXJhdGUgc29tZSBoZWlnaHQgZGF0YSAoeS12YWx1ZXMpLlxuICogICAgIHZhciBkYXRhID0gW107XG4gKiAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEwMDA7IGkrKyl7XG4gKiAgICAgICAgIHZhciB5ID0gMC41ICogTWF0aC5jb3MoMC4yICogaSk7XG4gKiAgICAgICAgIGRhdGEucHVzaCh5KTtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIENyZWF0ZSB0aGUgaGVpZ2h0ZmllbGQgc2hhcGVcbiAqICAgICB2YXIgaGVpZ2h0ZmllbGRTaGFwZSA9IG5ldyBIZWlnaHRmaWVsZChkYXRhLCB7XG4gKiAgICAgICAgIGVsZW1lbnRXaWR0aDogMSAvLyBEaXN0YW5jZSBiZXR3ZWVuIHRoZSBkYXRhIHBvaW50cyBpbiBYIGRpcmVjdGlvblxuICogICAgIH0pO1xuICogICAgIHZhciBoZWlnaHRmaWVsZEJvZHkgPSBuZXcgQm9keSgpO1xuICogICAgIGhlaWdodGZpZWxkQm9keS5hZGRTaGFwZShoZWlnaHRmaWVsZFNoYXBlKTtcbiAqICAgICB3b3JsZC5hZGRCb2R5KGhlaWdodGZpZWxkQm9keSk7XG4gKi9cbmZ1bmN0aW9uIEhlaWdodGZpZWxkKGRhdGEsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIG1heFZhbHVlIDogbnVsbCxcbiAgICAgICAgbWluVmFsdWUgOiBudWxsLFxuICAgICAgICBlbGVtZW50V2lkdGggOiAwLjFcbiAgICB9KTtcblxuICAgIGlmKG9wdGlvbnMubWluVmFsdWUgPT09IG51bGwgfHwgb3B0aW9ucy5tYXhWYWx1ZSA9PT0gbnVsbCl7XG4gICAgICAgIG9wdGlvbnMubWF4VmFsdWUgPSBkYXRhWzBdO1xuICAgICAgICBvcHRpb25zLm1pblZhbHVlID0gZGF0YVswXTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkgIT09IGRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHYgPSBkYXRhW2ldO1xuICAgICAgICAgICAgaWYodiA+IG9wdGlvbnMubWF4VmFsdWUpe1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubWF4VmFsdWUgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodiA8IG9wdGlvbnMubWluVmFsdWUpe1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubWluVmFsdWUgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgaGVpZ2h0IHZhbHVlcywgdGhhdCBhcmUgc3ByZWFkIG91dCBhbG9uZyB0aGUgeCBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGRhdGFcbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgLyoqXG4gICAgICogTWF4IHZhbHVlIG9mIHRoZSBkYXRhXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFZhbHVlXG4gICAgICovXG4gICAgdGhpcy5tYXhWYWx1ZSA9IG9wdGlvbnMubWF4VmFsdWU7XG5cbiAgICAvKipcbiAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGRhdGFcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluVmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLm1pblZhbHVlID0gb3B0aW9ucy5taW5WYWx1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZWxlbWVudFdpZHRoXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50V2lkdGggPSBvcHRpb25zLmVsZW1lbnRXaWR0aDtcblxuICAgIFNoYXBlLmNhbGwodGhpcyxTaGFwZS5IRUlHSFRGSUVMRCk7XG59XG5IZWlnaHRmaWVsZC5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhlaWdodGZpZWxkO1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICBhcmVhID0gMDtcbiAgICBmb3IodmFyIGk9MDsgaTxkYXRhLmxlbmd0aC0xOyBpKyspe1xuICAgICAgICBhcmVhICs9IChkYXRhW2ldK2RhdGFbaSsxXSkgLyAyICogdGhpcy5lbGVtZW50V2lkdGg7XG4gICAgfVxuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgLy8gVXNlIHRoZSBtYXggZGF0YSByZWN0YW5nbGVcbiAgICBvdXQudXBwZXJCb3VuZFswXSA9IHRoaXMuZWxlbWVudFdpZHRoICogdGhpcy5kYXRhLmxlbmd0aCArIHBvc2l0aW9uWzBdO1xuICAgIG91dC51cHBlckJvdW5kWzFdID0gdGhpcy5tYXhWYWx1ZSArIHBvc2l0aW9uWzFdO1xuICAgIG91dC5sb3dlckJvdW5kWzBdID0gcG9zaXRpb25bMF07XG4gICAgb3V0Lmxvd2VyQm91bmRbMV0gPSAtTnVtYmVyLk1BWF9WQUxVRTsgLy8gSW5maW5pdHlcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjUwLFwiLi9TaGFwZVwiOjQ1fV0sNDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cbi8qKlxuICogTGluZSBzaGFwZSBjbGFzcy4gVGhlIGxpbmUgc2hhcGUgaXMgYWxvbmcgdGhlIHggZGlyZWN0aW9uLCBhbmQgc3RyZXRjaGVzIGZyb20gWy1sZW5ndGgvMiwgMF0gdG8gW2xlbmd0aC8yLDBdLlxuICogQGNsYXNzIExpbmVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGVuZ3RoPTFdIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGxpbmVcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTGluZShsZW5ndGgpe1xuXG4gICAgLyoqXG4gICAgICogTGVuZ3RoIG9mIHRoaXMgbGluZVxuICAgICAqIEBwcm9wZXJ0eSBsZW5ndGhcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoIHx8IDE7XG5cbiAgICBTaGFwZS5jYWxsKHRoaXMsU2hhcGUuTElORSk7XG59XG5MaW5lLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuTGluZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lO1xuXG5MaW5lLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgcmV0dXJuIG1hc3MgKiBNYXRoLnBvdyh0aGlzLmxlbmd0aCwyKSAvIDEyO1xufTtcblxuTGluZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSB0aGlzLmxlbmd0aC8yO1xufTtcblxudmFyIHBvaW50cyA9IFt2ZWMyLmNyZWF0ZSgpLHZlYzIuY3JlYXRlKCldO1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5MaW5lLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2YXIgbDIgPSB0aGlzLmxlbmd0aCAvIDI7XG4gICAgdmVjMi5zZXQocG9pbnRzWzBdLCAtbDIsICAwKTtcbiAgICB2ZWMyLnNldChwb2ludHNbMV0sICBsMiwgIDApO1xuICAgIG91dC5zZXRGcm9tUG9pbnRzKHBvaW50cyxwb3NpdGlvbixhbmdsZSwwKTtcbn07XG5cblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vU2hhcGVcIjo0NX1dLDQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJ0aWNsZTtcblxuLyoqXG4gKiBQYXJ0aWNsZSBzaGFwZSBjbGFzcy5cbiAqIEBjbGFzcyBQYXJ0aWNsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICovXG5mdW5jdGlvbiBQYXJ0aWNsZSgpe1xuICAgIFNoYXBlLmNhbGwodGhpcyxTaGFwZS5QQVJUSUNMRSk7XG59XG5QYXJ0aWNsZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblBhcnRpY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnRpY2xlO1xuXG5QYXJ0aWNsZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiAwOyAvLyBDYW4ndCByb3RhdGUgYSBwYXJ0aWNsZVxufTtcblxuUGFydGljbGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gMDtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZlYzIuY29weShvdXQubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgIHZlYzIuY29weShvdXQudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vU2hhcGVcIjo0NX1dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTaGFwZSA9ICBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICAgdmVjMiA9ICBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGxhbmU7XG5cbi8qKlxuICogUGxhbmUgc2hhcGUgY2xhc3MuIFRoZSBwbGFuZSBpcyBmYWNpbmcgaW4gdGhlIFkgZGlyZWN0aW9uLlxuICogQGNsYXNzIFBsYW5lXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBsYW5lKCl7XG4gICAgU2hhcGUuY2FsbCh0aGlzLFNoYXBlLlBMQU5FKTtcbn1cblBsYW5lLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuUGxhbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxhbmU7XG5cbi8qKlxuICogQ29tcHV0ZSBtb21lbnQgb2YgaW5lcnRpYVxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKi9cblBsYW5lLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgcmV0dXJuIDA7IC8vIFBsYW5lIGlzIGluZmluaXRlLiBUaGUgaW5lcnRpYSBzaG91bGQgdGhlcmVmb3JlIGJlIGluZmludHkgYnV0IGJ5IGNvbnZlbnRpb24gd2Ugc2V0IDAgaGVyZVxufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1c1xuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5QbGFuZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dFxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5QbGFuZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIGEgPSAwLFxuICAgICAgICBzZXQgPSB2ZWMyLnNldDtcbiAgICBpZih0eXBlb2YoYW5nbGUpID09PSBcIm51bWJlclwiKXtcbiAgICAgICAgYSA9IGFuZ2xlICUgKDIqTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgaWYoYSA9PT0gMCl7XG4gICAgICAgIC8vIHkgZ29lcyBmcm9tIC1pbmYgdG8gMFxuICAgICAgICBzZXQob3V0Lmxvd2VyQm91bmQsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHNldChvdXQudXBwZXJCb3VuZCwgIE51bWJlci5NQVhfVkFMVUUsICAwKTtcbiAgICB9IGVsc2UgaWYoYSA9PT0gTWF0aC5QSSAvIDIpe1xuICAgICAgICAvLyB4IGdvZXMgZnJvbSAwIHRvIGluZlxuICAgICAgICBzZXQob3V0Lmxvd2VyQm91bmQsIDAsIC1OdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgc2V0KG91dC51cHBlckJvdW5kLCAgICAgIE51bWJlci5NQVhfVkFMVUUsICBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB9IGVsc2UgaWYoYSA9PT0gTWF0aC5QSSl7XG4gICAgICAgIC8vIHkgZ29lcyBmcm9tIDAgdG8gaW5mXG4gICAgICAgIHNldChvdXQubG93ZXJCb3VuZCwgLU51bWJlci5NQVhfVkFMVUUsIDApO1xuICAgICAgICBzZXQob3V0LnVwcGVyQm91bmQsICBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB9IGVsc2UgaWYoYSA9PT0gMypNYXRoLlBJLzIpe1xuICAgICAgICAvLyB4IGdvZXMgZnJvbSAtaW5mIHRvIDBcbiAgICAgICAgc2V0KG91dC5sb3dlckJvdW5kLCAtTnVtYmVyLk1BWF9WQUxVRSwgICAgIC1OdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgc2V0KG91dC51cHBlckJvdW5kLCAgMCwgIE51bWJlci5NQVhfVkFMVUUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNldCBtYXggYm91bmRzXG4gICAgICAgIHNldChvdXQubG93ZXJCb3VuZCwgLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgc2V0KG91dC51cHBlckJvdW5kLCAgTnVtYmVyLk1BWF9WQUxVRSwgIE51bWJlci5NQVhfVkFMVUUpO1xuICAgIH1cblxuICAgIHZlYzIuYWRkKG91dC5sb3dlckJvdW5kLCBvdXQubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgIHZlYzIuYWRkKG91dC51cHBlckJvdW5kLCBvdXQudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xufTtcblxuUGxhbmUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjUwLFwiLi9TaGFwZVwiOjQ1fV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgQ29udmV4ID0gX2RlcmVxXygnLi9Db252ZXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGU7XG5cbi8qKlxuICogUmVjdGFuZ2xlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIFJlY3RhbmdsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTFdIFdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0xXSBIZWlnaHRcbiAqIEBleHRlbmRzIENvbnZleFxuICovXG5mdW5jdGlvbiBSZWN0YW5nbGUod2lkdGgsIGhlaWdodCl7XG5cbiAgICAvKipcbiAgICAgKiBUb3RhbCB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHByb3BlcnR5IHdpZHRoXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMTtcblxuICAgIC8qKlxuICAgICAqIFRvdGFsIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMTtcblxuICAgIHZhciB2ZXJ0cyA9IFsgICB2ZWMyLmZyb21WYWx1ZXMoLXdpZHRoLzIsIC1oZWlnaHQvMiksXG4gICAgICAgICAgICAgICAgICAgIHZlYzIuZnJvbVZhbHVlcyggd2lkdGgvMiwgLWhlaWdodC8yKSxcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5mcm9tVmFsdWVzKCB3aWR0aC8yLCAgaGVpZ2h0LzIpLFxuICAgICAgICAgICAgICAgICAgICB2ZWMyLmZyb21WYWx1ZXMoLXdpZHRoLzIsICBoZWlnaHQvMildO1xuICAgIHZhciBheGVzID0gW3ZlYzIuZnJvbVZhbHVlcygxLCAwKSwgdmVjMi5mcm9tVmFsdWVzKDAsIDEpXTtcblxuICAgIENvbnZleC5jYWxsKHRoaXMsIHZlcnRzLCBheGVzKTtcblxuICAgIHRoaXMudHlwZSA9IFNoYXBlLlJFQ1RBTkdMRTtcbn1cblJlY3RhbmdsZS5wcm90b3R5cGUgPSBuZXcgQ29udmV4KFtdKTtcblJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWN0YW5nbGU7XG5cbi8qKlxuICogQ29tcHV0ZSBtb21lbnQgb2YgaW5lcnRpYVxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuUmVjdGFuZ2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoLFxuICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgcmV0dXJuIG1hc3MgKiAoaCpoICsgdyp3KSAvIDEyO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1c1xuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5SZWN0YW5nbGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgIGggPSB0aGlzLmhlaWdodDtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTWF0aC5zcXJ0KHcqdyArIGgqaCkgLyAyO1xufTtcblxudmFyIGNvcm5lcjEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvcm5lcjIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvcm5lcjMgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvcm5lcjQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5SZWN0YW5nbGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIG91dC5zZXRGcm9tUG9pbnRzKHRoaXMudmVydGljZXMscG9zaXRpb24sYW5nbGUsMCk7XG59O1xuXG5SZWN0YW5nbGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbn07XG5cblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vQ29udmV4XCI6MzksXCIuL1NoYXBlXCI6NDV9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFNoYXBlO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHNoYXBlcy5cbiAqIEBjbGFzcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZVxuICovXG5mdW5jdGlvbiBTaGFwZSh0eXBlKXtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBzaGFwZS4gT25lIG9mOlxuICAgICAqXG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9DSVJDTEU6cHJvcGVydHlcIn19U2hhcGUuQ0lSQ0xFe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL1BBUlRJQ0xFOnByb3BlcnR5XCJ9fVNoYXBlLlBBUlRJQ0xFe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL1BMQU5FOnByb3BlcnR5XCJ9fVNoYXBlLlBMQU5Fe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0NPTlZFWDpwcm9wZXJ0eVwifX1TaGFwZS5DT05WRVh7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvTElORTpwcm9wZXJ0eVwifX1TaGFwZS5MSU5Fe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL1JFQ1RBTkdMRTpwcm9wZXJ0eVwifX1TaGFwZS5SRUNUQU5HTEV7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvQ0FQU1VMRTpwcm9wZXJ0eVwifX1TaGFwZS5DQVBTVUxFe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0hFSUdIVEZJRUxEOnByb3BlcnR5XCJ9fVNoYXBlLkhFSUdIVEZJRUxEe3svY3Jvc3NMaW5rfX1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0eXBlXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFNoYXBlIG9iamVjdCBpZGVudGlmaWVyLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICovXG4gICAgdGhpcy5pZCA9IFNoYXBlLmlkQ291bnRlcisrO1xuXG4gICAgLyoqXG4gICAgICogQm91bmRpbmcgY2lyY2xlIHJhZGl1cyBvZiB0aGlzIHNoYXBlXG4gICAgICogQHByb3BlcnR5IGJvdW5kaW5nUmFkaXVzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gMDtcblxuICAgIC8qKlxuICAgICAqIENvbGxpc2lvbiBncm91cCB0aGF0IHRoaXMgc2hhcGUgYmVsb25ncyB0byAoYml0IG1hc2spLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cuYXVyZWxpZW5yaWJvbi5jb20vYmxvZy8yMDExLzA3L2JveDJkLXR1dG9yaWFsLWNvbGxpc2lvbi1maWx0ZXJpbmcvXCI+dGhpcyB0dXRvcmlhbDwvYT4uXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkdyb3VwXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBTZXR1cCBiaXRzIGZvciBlYWNoIGF2YWlsYWJsZSBncm91cFxuICAgICAqICAgICB2YXIgUExBWUVSID0gTWF0aC5wb3coMiwwKSxcbiAgICAgKiAgICAgICAgIEVORU1ZID0gIE1hdGgucG93KDIsMSksXG4gICAgICogICAgICAgICBHUk9VTkQgPSBNYXRoLnBvdygyLDIpXG4gICAgICpcbiAgICAgKiAgICAgLy8gUHV0IHNoYXBlcyBpbnRvIHRoZWlyIGdyb3Vwc1xuICAgICAqICAgICBwbGF5ZXIxU2hhcGUuY29sbGlzaW9uR3JvdXAgPSBQTEFZRVI7XG4gICAgICogICAgIHBsYXllcjJTaGFwZS5jb2xsaXNpb25Hcm91cCA9IFBMQVlFUjtcbiAgICAgKiAgICAgZW5lbXlTaGFwZSAgLmNvbGxpc2lvbkdyb3VwID0gRU5FTVk7XG4gICAgICogICAgIGdyb3VuZFNoYXBlIC5jb2xsaXNpb25Hcm91cCA9IEdST1VORDtcbiAgICAgKlxuICAgICAqICAgICAvLyBBc3NpZ24gZ3JvdXBzIHRoYXQgZWFjaCBzaGFwZSBjb2xsaWRlIHdpdGguXG4gICAgICogICAgIC8vIE5vdGUgdGhhdCB0aGUgcGxheWVycyBjYW4gY29sbGlkZSB3aXRoIGdyb3VuZCBhbmQgZW5lbWllcywgYnV0IG5vdCB3aXRoIG90aGVyIHBsYXllcnMuXG4gICAgICogICAgIHBsYXllcjFTaGFwZS5jb2xsaXNpb25NYXNrID0gRU5FTVkgfCBHUk9VTkQ7XG4gICAgICogICAgIHBsYXllcjJTaGFwZS5jb2xsaXNpb25NYXNrID0gRU5FTVkgfCBHUk9VTkQ7XG4gICAgICogICAgIGVuZW15U2hhcGUgIC5jb2xsaXNpb25NYXNrID0gUExBWUVSIHwgR1JPVU5EO1xuICAgICAqICAgICBncm91bmRTaGFwZSAuY29sbGlzaW9uTWFzayA9IFBMQVlFUiB8IEVORU1ZO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gSG93IGNvbGxpc2lvbiBjaGVjayBpcyBkb25lXG4gICAgICogICAgIGlmKHNoYXBlQS5jb2xsaXNpb25Hcm91cCAmIHNoYXBlQi5jb2xsaXNpb25NYXNrKSE9MCAmJiAoc2hhcGVCLmNvbGxpc2lvbkdyb3VwICYgc2hhcGVBLmNvbGxpc2lvbk1hc2spIT0wKXtcbiAgICAgKiAgICAgICAgIC8vIFRoZSBzaGFwZXMgd2lsbCBjb2xsaWRlXG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvbkdyb3VwID0gMTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC4gVGhhdCBtZWFucyB0aGF0IHRoaXMgc2hhcGUgd2lsbCBtb3ZlIHRocm91Z2ggb3RoZXIgYm9keSBzaGFwZXMsIGJ1dCBpdCB3aWxsIHN0aWxsIHRyaWdnZXIgY29udGFjdCBldmVudHMsIGV0Yy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBDb2xsaXNpb24gbWFzayBvZiB0aGlzIHNoYXBlLiBTZWUgLmNvbGxpc2lvbkdyb3VwLlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25NYXNrXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvbk1hc2sgPSAgMTtcbiAgICBpZih0eXBlKXtcbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hdGVyaWFsIHRvIHVzZSBpbiBjb2xsaXNpb25zIGZvciB0aGlzIFNoYXBlLiBJZiB0aGlzIGlzIHNldCB0byBudWxsLCB0aGUgd29ybGQgd2lsbCB1c2UgZGVmYXVsdCBtYXRlcmlhbCBwcm9wZXJ0aWVzIGluc3RlYWQuXG4gICAgICogQHByb3BlcnR5IG1hdGVyaWFsXG4gICAgICogQHR5cGUge01hdGVyaWFsfVxuICAgICAqL1xuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXJlYSBvZiB0aGlzIHNoYXBlLlxuICAgICAqIEBwcm9wZXJ0eSBhcmVhXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFyZWEgPSAwO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdGhpcyBzaGFwZSB0byBiZSBhIHNlbnNvci4gQSBzZW5zb3IgZG9lcyBub3QgZ2VuZXJhdGUgY29udGFjdHMsIGJ1dCBpdCBzdGlsbCByZXBvcnRzIGNvbnRhY3QgZXZlbnRzLiBUaGlzIGlzIGdvb2QgaWYgeW91IHdhbnQgdG8ga25vdyBpZiBhIHNoYXBlIGlzIG92ZXJsYXBwaW5nIGFub3RoZXIgc2hhcGUsIHdpdGhvdXQgdGhlbSBnZW5lcmF0aW5nIGNvbnRhY3RzLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2Vuc29yXG4gICAgICovXG4gICAgdGhpcy5zZW5zb3IgPSBmYWxzZTtcblxuICAgIHRoaXMudXBkYXRlQXJlYSgpO1xufVxuXG5TaGFwZS5pZENvdW50ZXIgPSAwO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBDSVJDTEVcbiAqL1xuU2hhcGUuQ0lSQ0xFID0gICAgICAxO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBQQVJUSUNMRVxuICovXG5TaGFwZS5QQVJUSUNMRSA9ICAgIDI7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IFBMQU5FXG4gKi9cblNoYXBlLlBMQU5FID0gICAgICAgNDtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQ09OVkVYXG4gKi9cblNoYXBlLkNPTlZFWCA9ICAgICAgODtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gTElORVxuICovXG5TaGFwZS5MSU5FID0gICAgICAgIDE2O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBSRUNUQU5HTEVcbiAqL1xuU2hhcGUuUkVDVEFOR0xFID0gICAzMjtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQ0FQU1VMRVxuICovXG5TaGFwZS5DQVBTVUxFID0gICAgIDY0O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBIRUlHSFRGSUVMRFxuICovXG5TaGFwZS5IRUlHSFRGSUVMRCA9IDEyODtcblxuLyoqXG4gKiBTaG91bGQgcmV0dXJuIHRoZSBtb21lbnQgb2YgaW5lcnRpYSBhcm91bmQgdGhlIFogYXhpcyBvZiB0aGUgYm9keSBnaXZlbiB0aGUgdG90YWwgbWFzcy4gU2VlIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfbW9tZW50c19vZl9pbmVydGlhXCI+V2lraXBlZGlhJ3MgbGlzdCBvZiBtb21lbnRzIG9mIGluZXJ0aWE8L2E+LlxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn0gSWYgdGhlIGluZXJ0aWEgaXMgaW5maW5pdHkgb3IgaWYgdGhlIG9iamVjdCBzaW1wbHkgaXNuJ3QgcG9zc2libGUgdG8gcm90YXRlLCByZXR1cm4gMC5cbiAqL1xuU2hhcGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIFNoYXBlLi4uXCIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBib3VuZGluZyBjaXJjbGUgcmFkaXVzIG9mIHRoaXMgc2hhcGUuXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblNoYXBlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUudXBkYXRlQm91bmRpbmdSYWRpdXMgaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgU2hhcGUuLi5cIik7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLmFyZWEgcHJvcGVydHkgb2YgdGhlIHNoYXBlLlxuICogQG1ldGhvZCB1cGRhdGVBcmVhXG4gKi9cblNoYXBlLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZCBpbiBhbGwgc3ViY2xhc3Nlc1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSB3b3JsZCBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IChBQUJCKSBvZiB0aGlzIHNoYXBlLlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cblNoYXBlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZCBpbiBlYWNoIHN1YmNsYXNzXG59O1xuXG59LHt9XSw0NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgU29sdmVyID0gX2RlcmVxXygnLi9Tb2x2ZXInKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIEZyaWN0aW9uRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdTU29sdmVyO1xuXG4vKipcbiAqIEl0ZXJhdGl2ZSBHYXVzcy1TZWlkZWwgY29uc3RyYWludCBlcXVhdGlvbiBzb2x2ZXIuXG4gKlxuICogQGNsYXNzIEdTU29sdmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFNvbHZlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLml0ZXJhdGlvbnM9MTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9sZXJhbmNlPTBdXG4gKi9cbmZ1bmN0aW9uIEdTU29sdmVyKG9wdGlvbnMpe1xuICAgIFNvbHZlci5jYWxsKHRoaXMsb3B0aW9ucyxTb2x2ZXIuR1MpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIGRvIHdoZW4gc29sdmluZy4gTW9yZSBnaXZlcyBiZXR0ZXIgcmVzdWx0cywgYnV0IGlzIG1vcmUgZXhwZW5zaXZlLlxuICAgICAqIEBwcm9wZXJ0eSBpdGVyYXRpb25zXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLml0ZXJhdGlvbnMgPSBvcHRpb25zLml0ZXJhdGlvbnMgfHwgMTA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXJyb3IgdG9sZXJhbmNlLCBwZXIgY29uc3RyYWludC4gSWYgdGhlIHRvdGFsIGVycm9yIGlzIGJlbG93IHRoaXMgbGltaXQsIHRoZSBzb2x2ZXIgd2lsbCBzdG9wIGl0ZXJhdGluZy4gU2V0IHRvIHplcm8gZm9yIGFzIGdvb2Qgc29sdXRpb24gYXMgcG9zc2libGUsIGJ1dCB0byBzb21ldGhpbmcgbGFyZ2VyIHRoYW4gemVybyB0byBtYWtlIGNvbXB1dGF0aW9ucyBmYXN0ZXIuXG4gICAgICogQHByb3BlcnR5IHRvbGVyYW5jZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50b2xlcmFuY2UgPSBvcHRpb25zLnRvbGVyYW5jZSB8fCAxZS0xMDtcblxuICAgIHRoaXMuYXJyYXlTdGVwID0gMzA7XG4gICAgdGhpcy5sYW1iZGEgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSh0aGlzLmFycmF5U3RlcCk7XG4gICAgdGhpcy5CcyA9ICAgICBuZXcgVXRpbHMuQVJSQVlfVFlQRSh0aGlzLmFycmF5U3RlcCk7XG4gICAgdGhpcy5pbnZDcyA9ICBuZXcgVXRpbHMuQVJSQVlfVFlQRSh0aGlzLmFycmF5U3RlcCk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBzZXQgYWxsIHJpZ2h0IGhhbmQgc2lkZSB0ZXJtcyB0byB6ZXJvIHdoZW4gc29sdmluZy4gQ2FuIGJlIGhhbmR5IGZvciBhIGZldyBhcHBsaWNhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHVzZVplcm9SSFNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZVplcm9SSFMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBzb2x2ZXIgaXRlcmF0aW9ucyB0aGF0IGFyZSBkb25lIHRvIGFwcHJveGltYXRlIG5vcm1hbCBmb3JjZXMuIFdoZW4gdGhlc2UgaXRlcmF0aW9ucyBhcmUgZG9uZSwgZnJpY3Rpb24gZm9yY2Ugd2lsbCBiZSBjb21wdXRlZCBmcm9tIHRoZSBjb250YWN0IG5vcm1hbCBmb3JjZXMuIFRoZXNlIGZyaWN0aW9uIGZvcmNlcyB3aWxsIG92ZXJyaWRlIGFueSBvdGhlciBmcmljdGlvbiBmb3JjZXMgc2V0IGZyb20gdGhlIFdvcmxkIGZvciBleGFtcGxlLlxuICAgICAqIFRoZSBzb2x2ZXIgd2lsbCB1c2UgbGVzcyBpdGVyYXRpb25zIGlmIHRoZSBzb2x1dGlvbiBpcyBiZWxvdyB0aGUgLnRvbGVyYW5jZS5cbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25JdGVyYXRpb25zXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uSXRlcmF0aW9ucyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdGhhdCB3ZXJlIG1hZGUgZHVyaW5nIHRoZSBsYXN0IHNvbHZlLiBJZiAudG9sZXJhbmNlIGlzIHplcm8sIHRoaXMgdmFsdWUgd2lsbCBhbHdheXMgYmUgZXF1YWwgdG8gLml0ZXJhdGlvbnMsIGJ1dCBpZiAudG9sZXJhbmNlIGlzIGxhcmdlciB0aGFuIHplcm8sIGFuZCB0aGUgc29sdmVyIGNhbiBxdWl0IGVhcmx5LCB0aGVuIHRoaXMgbnVtYmVyIHdpbGwgYmUgc29tZXdoZXJlIGJldHdlZW4gMSBhbmQgLml0ZXJhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHVzZWRJdGVyYXRpb25zXG4gICAgICovXG4gICAgdGhpcy51c2VkSXRlcmF0aW9ucyA9IDA7XG59XG5HU1NvbHZlci5wcm90b3R5cGUgPSBuZXcgU29sdmVyKCk7XG5HU1NvbHZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHU1NvbHZlcjtcblxuZnVuY3Rpb24gc2V0QXJyYXlaZXJvKGFycmF5KXtcbiAgICB2YXIgbCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICBhcnJheVtsXSA9ICswLjA7XG4gICAgfVxufVxuXG4vKipcbiAqIFNvbHZlIHRoZSBzeXN0ZW0gb2YgZXF1YXRpb25zXG4gKiBAbWV0aG9kIHNvbHZlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBoICAgICAgIFRpbWUgc3RlcFxuICogQHBhcmFtICB7V29ybGR9ICAgd29ybGQgICAgV29ybGQgdG8gc29sdmVcbiAqL1xuR1NTb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oaCwgd29ybGQpe1xuXG4gICAgdGhpcy5zb3J0RXF1YXRpb25zKCk7XG5cbiAgICB2YXIgaXRlciA9IDAsXG4gICAgICAgIG1heEl0ZXIgPSB0aGlzLml0ZXJhdGlvbnMsXG4gICAgICAgIG1heEZyaWN0aW9uSXRlciA9IHRoaXMuZnJpY3Rpb25JdGVyYXRpb25zLFxuICAgICAgICBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgTmVxID0gZXF1YXRpb25zLmxlbmd0aCxcbiAgICAgICAgdG9sU3F1YXJlZCA9IE1hdGgucG93KHRoaXMudG9sZXJhbmNlKk5lcSwgMiksXG4gICAgICAgIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgTmJvZGllcyA9IHdvcmxkLmJvZGllcy5sZW5ndGgsXG4gICAgICAgIGFkZCA9IHZlYzIuYWRkLFxuICAgICAgICBzZXQgPSB2ZWMyLnNldCxcbiAgICAgICAgdXNlWmVyb1JIUyA9IHRoaXMudXNlWmVyb1JIUyxcbiAgICAgICAgbGFtYmRhID0gdGhpcy5sYW1iZGE7XG5cbiAgICB0aGlzLnVzZWRJdGVyYXRpb25zID0gMDtcblxuICAgIGlmKE5lcSl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgc29sdmUgbWFzc1xuICAgICAgICAgICAgYi51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGluZ3MgdGhhdCBkb2VzIG5vdCBjaGFuZ2UgZHVyaW5nIGl0ZXJhdGlvbiBjYW4gYmUgY29tcHV0ZWQgb25jZVxuICAgIGlmKGxhbWJkYS5sZW5ndGggPCBOZXEpe1xuICAgICAgICBsYW1iZGEgPSB0aGlzLmxhbWJkYSA9ICBuZXcgVXRpbHMuQVJSQVlfVFlQRShOZXEgKyB0aGlzLmFycmF5U3RlcCk7XG4gICAgICAgIHRoaXMuQnMgPSAgICAgICAgICAgICAgIG5ldyBVdGlscy5BUlJBWV9UWVBFKE5lcSArIHRoaXMuYXJyYXlTdGVwKTtcbiAgICAgICAgdGhpcy5pbnZDcyA9ICAgICAgICAgICAgbmV3IFV0aWxzLkFSUkFZX1RZUEUoTmVxICsgdGhpcy5hcnJheVN0ZXApO1xuICAgIH1cbiAgICBzZXRBcnJheVplcm8obGFtYmRhKTtcbiAgICB2YXIgaW52Q3MgPSB0aGlzLmludkNzLFxuICAgICAgICBCcyA9IHRoaXMuQnMsXG4gICAgICAgIGxhbWJkYSA9IHRoaXMubGFtYmRhO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1lcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGVxdWF0aW9uc1tpXTtcbiAgICAgICAgaWYoYy50aW1lU3RlcCAhPT0gaCB8fCBjLm5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGMudGltZVN0ZXAgPSBoO1xuICAgICAgICAgICAgYy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBCc1tpXSA9ICAgICBjLmNvbXB1dGVCKGMuYSxjLmIsaCk7XG4gICAgICAgIGludkNzW2ldID0gIGMuY29tcHV0ZUludkMoYy5lcHNpbG9uKTtcbiAgICB9XG5cbiAgICB2YXIgcSwgQiwgYywgZGVsdGFsYW1iZGFUb3QsaSxqO1xuXG4gICAgaWYoTmVxICE9PSAwKXtcblxuICAgICAgICBmb3IoaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAvLyBSZXNldCB2bGFtYmRhXG4gICAgICAgICAgICBiLnJlc2V0Q29uc3RyYWludFZlbG9jaXR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihtYXhGcmljdGlvbkl0ZXIpe1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGNvbnRhY3QgZXF1YXRpb25zIHRvIGdldCBub3JtYWwgZm9yY2VzXG4gICAgICAgICAgICBmb3IoaXRlcj0wOyBpdGVyIT09bWF4RnJpY3Rpb25JdGVyOyBpdGVyKyspe1xuXG4gICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgdG90YWwgZXJyb3IgZm9yIGVhY2ggaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ID0gMC4wO1xuXG4gICAgICAgICAgICAgICAgZm9yKGo9MDsgaiE9PU5lcTsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGVxdWF0aW9uc1tqXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFsYW1iZGEgPSBHU1NvbHZlci5pdGVyYXRlRXF1YXRpb24oaixjLGMuZXBzaWxvbixCcyxpbnZDcyxsYW1iZGEsdXNlWmVyb1JIUyxoLGl0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBNYXRoLmFicyhkZWx0YWxhbWJkYSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy51c2VkSXRlcmF0aW9ucysrO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxuICAgICAgICAgICAgICAgIGlmKGRlbHRhbGFtYmRhVG90KmRlbHRhbGFtYmRhVG90IDw9IHRvbFNxdWFyZWQpe1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEdTU29sdmVyLnVwZGF0ZU11bHRpcGxpZXJzKGVxdWF0aW9ucywgbGFtYmRhLCAxL2gpO1xuXG4gICAgICAgICAgICAvLyBTZXQgY29tcHV0ZWQgZnJpY3Rpb24gZm9yY2VcbiAgICAgICAgICAgIGZvcihqPTA7IGohPT1OZXE7IGorKyl7XG4gICAgICAgICAgICAgICAgdmFyIGVxID0gZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgICAgIGlmKGVxIGluc3RhbmNlb2YgRnJpY3Rpb25FcXVhdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgayE9PWVxLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgZiArPSBlcS5jb250YWN0RXF1YXRpb25zW2tdLm11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZiAqPSBlcS5mcmljdGlvbkNvZWZmaWNpZW50IC8gZXEuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGVxLm1heEZvcmNlID0gIGY7XG4gICAgICAgICAgICAgICAgICAgIGVxLm1pbkZvcmNlID0gLWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlcXVhdGlvbnNcbiAgICAgICAgZm9yKGl0ZXI9MDsgaXRlciE9PW1heEl0ZXI7IGl0ZXIrKyl7XG5cbiAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHRvdGFsIGVycm9yIGZvciBlYWNoIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ID0gMC4wO1xuXG4gICAgICAgICAgICBmb3Ioaj0wOyBqIT09TmVxOyBqKyspe1xuICAgICAgICAgICAgICAgIGMgPSBlcXVhdGlvbnNbal07XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFsYW1iZGEgPSBHU1NvbHZlci5pdGVyYXRlRXF1YXRpb24oaixjLGMuZXBzaWxvbixCcyxpbnZDcyxsYW1iZGEsdXNlWmVyb1JIUyxoLGl0ZXIpO1xuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ICs9IE1hdGguYWJzKGRlbHRhbGFtYmRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51c2VkSXRlcmF0aW9ucysrO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgZXJyb3IgaXMgc21hbGwgZW5vdWdoIC0gc3RvcCBpdGVyYXRlXG4gICAgICAgICAgICBpZihkZWx0YWxhbWJkYVRvdCpkZWx0YWxhbWJkYVRvdCA8PSB0b2xTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCByZXN1bHQgdG8gdmVsb2NpdHlcbiAgICAgICAgZm9yKGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICBib2RpZXNbaV0uYWRkQ29uc3RyYWludFZlbG9jaXR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBHU1NvbHZlci51cGRhdGVNdWx0aXBsaWVycyhlcXVhdGlvbnMsIGxhbWJkYSwgMS9oKTtcbiAgICB9XG59O1xuXG4vLyBTZXRzIHRoZSAubXVsdGlwbGllciBwcm9wZXJ0eSBvZiBlYWNoIGVxdWF0aW9uXG5HU1NvbHZlci51cGRhdGVNdWx0aXBsaWVycyA9IGZ1bmN0aW9uKGVxdWF0aW9ucywgbGFtYmRhLCBpbnZEdCl7XG4gICAgLy8gU2V0IHRoZSAubXVsdGlwbGllciBwcm9wZXJ0eSBvZiBlYWNoIGVxdWF0aW9uXG4gICAgdmFyIGwgPSBlcXVhdGlvbnMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIGVxdWF0aW9uc1tsXS5tdWx0aXBsaWVyID0gbGFtYmRhW2xdICogaW52RHQ7XG4gICAgfVxufTtcblxuR1NTb2x2ZXIuaXRlcmF0ZUVxdWF0aW9uID0gZnVuY3Rpb24oaixlcSxlcHMsQnMsaW52Q3MsbGFtYmRhLHVzZVplcm9SSFMsZHQsaXRlcil7XG4gICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cbiAgICB2YXIgQiA9IEJzW2pdLFxuICAgICAgICBpbnZDID0gaW52Q3Nbal0sXG4gICAgICAgIGxhbWJkYWogPSBsYW1iZGFbal0sXG4gICAgICAgIEdXbGFtYmRhID0gZXEuY29tcHV0ZUdXbGFtYmRhKCk7XG5cbiAgICB2YXIgbWF4Rm9yY2UgPSBlcS5tYXhGb3JjZSxcbiAgICAgICAgbWluRm9yY2UgPSBlcS5taW5Gb3JjZTtcblxuICAgIGlmKHVzZVplcm9SSFMpe1xuICAgICAgICBCID0gMDtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFsYW1iZGEgPSBpbnZDICogKCBCIC0gR1dsYW1iZGEgLSBlcHMgKiBsYW1iZGFqICk7XG5cbiAgICAvLyBDbGFtcCBpZiB3ZSBhcmUgbm90IHdpdGhpbiB0aGUgbWluL21heCBpbnRlcnZhbFxuICAgIHZhciBsYW1iZGFqX3BsdXNfZGVsdGFsYW1iZGEgPSBsYW1iZGFqICsgZGVsdGFsYW1iZGE7XG4gICAgaWYobGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhIDwgbWluRm9yY2UqZHQpe1xuICAgICAgICBkZWx0YWxhbWJkYSA9IG1pbkZvcmNlKmR0IC0gbGFtYmRhajtcbiAgICB9IGVsc2UgaWYobGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhID4gbWF4Rm9yY2UqZHQpe1xuICAgICAgICBkZWx0YWxhbWJkYSA9IG1heEZvcmNlKmR0IC0gbGFtYmRhajtcbiAgICB9XG4gICAgbGFtYmRhW2pdICs9IGRlbHRhbGFtYmRhO1xuICAgIGVxLmFkZFRvV2xhbWJkYShkZWx0YWxhbWJkYSk7XG5cbiAgICByZXR1cm4gZGVsdGFsYW1iZGE7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uXCI6MjQsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3V0aWxzL1V0aWxzXCI6NTAsXCIuL1NvbHZlclwiOjQ3fV0sNDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIEV2ZW50RW1pdHRlciA9IF9kZXJlcV8oJy4uL2V2ZW50cy9FdmVudEVtaXR0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2x2ZXI7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29uc3RyYWludCBzb2x2ZXJzLlxuICogQGNsYXNzIFNvbHZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuZnVuY3Rpb24gU29sdmVyKG9wdGlvbnMsdHlwZSl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGVxdWF0aW9ucyBpbiB0aGUgc29sdmVyLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHNvcnQgYWxsIGVxdWF0aW9ucyBiZWZvcmUgZWFjaCBzb2x2ZS5cbiAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25Tb3J0RnVuY3Rpb25cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb258Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9uU29ydEZ1bmN0aW9uID0gb3B0aW9ucy5lcXVhdGlvblNvcnRGdW5jdGlvbiB8fCBmYWxzZTtcbn1cblNvbHZlci5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5Tb2x2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29sdmVyO1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbXBsZW1lbnRlZCBpbiBlYWNoIHN1YmNsYXNzXG4gKiBAbWV0aG9kIHNvbHZlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGR0XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKGR0LHdvcmxkKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb2x2ZXIuc29sdmUgc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMhXCIpO1xufTtcblxudmFyIG1vY2tXb3JsZCA9IHtib2RpZXM6W119O1xuXG4vKipcbiAqIFNvbHZlcyBhbGwgY29uc3RyYWludHMgaW4gYW4gaXNsYW5kLlxuICogQG1ldGhvZCBzb2x2ZUlzbGFuZFxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICogQHBhcmFtICB7SXNsYW5kfSBpc2xhbmRcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5zb2x2ZUlzbGFuZCA9IGZ1bmN0aW9uKGR0LGlzbGFuZCl7XG5cbiAgICB0aGlzLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuXG4gICAgaWYoaXNsYW5kLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICAvLyBBZGQgZXF1YXRpb25zIHRvIHNvbHZlclxuICAgICAgICB0aGlzLmFkZEVxdWF0aW9ucyhpc2xhbmQuZXF1YXRpb25zKTtcbiAgICAgICAgbW9ja1dvcmxkLmJvZGllcy5sZW5ndGggPSAwO1xuICAgICAgICBpc2xhbmQuZ2V0Qm9kaWVzKG1vY2tXb3JsZC5ib2RpZXMpO1xuXG4gICAgICAgIC8vIFNvbHZlXG4gICAgICAgIGlmKG1vY2tXb3JsZC5ib2RpZXMubGVuZ3RoKXtcbiAgICAgICAgICAgIHRoaXMuc29sdmUoZHQsbW9ja1dvcmxkKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogU29ydCBhbGwgZXF1YXRpb25zIHVzaW5nIHRoZSAuZXF1YXRpb25Tb3J0RnVuY3Rpb24uIFNob3VsZCBiZSBjYWxsZWQgYnkgc3ViY2xhc3NlcyBiZWZvcmUgc29sdmluZy5cbiAqIEBtZXRob2Qgc29ydEVxdWF0aW9uc1xuICovXG5Tb2x2ZXIucHJvdG90eXBlLnNvcnRFcXVhdGlvbnMgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24pe1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5zb3J0KHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24pO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGFuIGVxdWF0aW9uIHRvIGJlIHNvbHZlZC5cbiAqXG4gKiBAbWV0aG9kIGFkZEVxdWF0aW9uXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICovXG5Tb2x2ZXIucHJvdG90eXBlLmFkZEVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xuICAgIGlmKGVxLmVuYWJsZWQpe1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBlcXVhdGlvbnMuIFNhbWUgYXMgLmFkZEVxdWF0aW9uLCBidXQgdGhpcyB0aW1lIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBvZiBFcXVhdGlvbnNcbiAqXG4gKiBAbWV0aG9kIGFkZEVxdWF0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gZXFzXG4gKi9cblNvbHZlci5wcm90b3R5cGUuYWRkRXF1YXRpb25zID0gZnVuY3Rpb24oZXFzKXtcbiAgICAvL1V0aWxzLmFwcGVuZEFycmF5KHRoaXMuZXF1YXRpb25zLGVxcyk7XG4gICAgZm9yKHZhciBpPTAsIE49ZXFzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tpXTtcbiAgICAgICAgaWYoZXEuZW5hYmxlZCl7XG4gICAgICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGVxdWF0aW9uLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlRXF1YXRpb25cbiAqIEBwYXJhbSB7RXF1YXRpb259IGVxXG4gKi9cblNvbHZlci5wcm90b3R5cGUucmVtb3ZlRXF1YXRpb24gPSBmdW5jdGlvbihlcSl7XG4gICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKGVxKTtcbiAgICBpZihpICE9PSAtMSl7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnNwbGljZShpLDEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBjdXJyZW50bHkgYWRkZWQgZXF1YXRpb25zLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQWxsRXF1YXRpb25zXG4gKi9cblNvbHZlci5wcm90b3R5cGUucmVtb3ZlQWxsRXF1YXRpb25zID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVxdWF0aW9ucy5sZW5ndGg9MDtcbn07XG5cblNvbHZlci5HUyA9IDE7XG5Tb2x2ZXIuSVNMQU5EID0gMjtcblxufSx7XCIuLi9ldmVudHMvRXZlbnRFbWl0dGVyXCI6MjcsXCIuLi91dGlscy9VdGlsc1wiOjUwfV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFR1cGxlRGljdGlvbmFyeSA9IF9kZXJlcV8oJy4vVHVwbGVEaWN0aW9uYXJ5Jyk7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT3ZlcmxhcEtlZXBlcjtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiBvdmVybGFwcyBpbiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgdGhlIGxhc3Qgc3RlcCBzdGF0ZS5cbiAqIEBjbGFzcyBPdmVybGFwS2VlcGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gT3ZlcmxhcEtlZXBlcigpIHtcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuICAgIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XG4gICAgdGhpcy5yZWNvcmRQb29sID0gW107XG4gICAgdGhpcy50bXBEaWN0ID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuICAgIHRoaXMudG1wQXJyYXkxID0gW107XG59XG5cbi8qKlxuICogVGlja3Mgb25lIHN0ZXAgZm9yd2FyZCBpbiB0aW1lLiBUaGlzIHdpbGwgbW92ZSB0aGUgY3VycmVudCBvdmVybGFwIHN0YXRlIHRvIHRoZSBcIm9sZFwiIG92ZXJsYXAgc3RhdGUsIGFuZCBjcmVhdGUgYSBuZXcgb25lIGFzIGN1cnJlbnQuXG4gKiBAbWV0aG9kIHRpY2tcbiAqL1xuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsYXN0ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZTtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGU7XG5cbiAgICAvLyBTYXZlIG9sZCBvYmplY3RzIGludG8gcG9vbFxuICAgIHZhciBsID0gbGFzdC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gbGFzdC5rZXlzW2xdO1xuICAgICAgICB2YXIgbGFzdE9iamVjdCA9IGxhc3QuZ2V0QnlLZXkoa2V5KTtcbiAgICAgICAgdmFyIGN1cnJlbnRPYmplY3QgPSBjdXJyZW50LmdldEJ5S2V5KGtleSk7XG4gICAgICAgIGlmKGxhc3RPYmplY3QgJiYgIWN1cnJlbnRPYmplY3Qpe1xuICAgICAgICAgICAgLy8gVGhlIHJlY29yZCBpcyBvbmx5IHVzZWQgaW4gdGhlIFwibGFzdFwiIGRpY3QsIGFuZCB3aWxsIGJlIHJlbW92ZWQuIFdlIG1pZ2h0IGFzIHdlbGwgcG9vbCBpdC5cbiAgICAgICAgICAgIHRoaXMucmVjb3JkUG9vbC5wdXNoKGxhc3RPYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgbGFzdCBvYmplY3RcbiAgICBsYXN0LnJlc2V0KCk7XG5cbiAgICAvLyBUcmFuc2ZlciBmcm9tIG5ldyBvYmplY3QgdG8gb2xkXG4gICAgbGFzdC5jb3B5KGN1cnJlbnQpO1xuXG4gICAgLy8gQ2xlYXIgY3VycmVudCBvYmplY3RcbiAgICBjdXJyZW50LnJlc2V0KCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0T3ZlcmxhcHBpbmdcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gc2hhcGVBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge0JvZHl9IHNoYXBlQlxuICovXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5zZXRPdmVybGFwcGluZyA9IGZ1bmN0aW9uKGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpIHtcbiAgICB2YXIgbGFzdCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuXG4gICAgLy8gU3RvcmUgY3VycmVudCBjb250YWN0IHN0YXRlXG4gICAgaWYoIWN1cnJlbnQuZ2V0KHNoYXBlQS5pZCwgc2hhcGVCLmlkKSl7XG5cbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmKHRoaXMucmVjb3JkUG9vbC5sZW5ndGgpe1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMucmVjb3JkUG9vbC5wb3AoKTtcbiAgICAgICAgICAgIGRhdGEuc2V0KGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBPdmVybGFwS2VlcGVyUmVjb3JkKGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudC5zZXQoc2hhcGVBLmlkLCBzaGFwZUIuaWQsIGRhdGEpO1xuICAgIH1cbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldE5ld092ZXJsYXBzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICByZXR1cm4gdGhpcy5nZXREaWZmKHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGUsIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUsIHJlc3VsdCk7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXRFbmRPdmVybGFwcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGlmZih0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlLCB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGJvZGllcyBhcmUgY3VycmVudGx5IG92ZXJsYXBwaW5nLlxuICogQG1ldGhvZCBib2RpZXNBcmVPdmVybGFwcGluZ1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5ib2RpZXNBcmVPdmVybGFwcGluZyA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuICAgIHZhciBsID0gY3VycmVudC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gY3VycmVudC5rZXlzW2xdO1xuICAgICAgICB2YXIgZGF0YSA9IGN1cnJlbnQuZGF0YVtrZXldO1xuICAgICAgICBpZigoZGF0YS5ib2R5QSA9PT0gYm9keUEgJiYgZGF0YS5ib2R5QiA9PT0gYm9keUIpIHx8IGRhdGEuYm9keUEgPT09IGJvZHlCICYmIGRhdGEuYm9keUIgPT09IGJvZHlBKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldERpZmYgPSBmdW5jdGlvbihkaWN0QSwgZGljdEIsIHJlc3VsdCl7XG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgICB2YXIgbGFzdCA9IGRpY3RBO1xuICAgIHZhciBjdXJyZW50ID0gZGljdEI7XG5cbiAgICByZXN1bHQubGVuZ3RoID0gMDtcblxuICAgIHZhciBsID0gY3VycmVudC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gY3VycmVudC5rZXlzW2xdO1xuICAgICAgICB2YXIgZGF0YSA9IGN1cnJlbnQuZGF0YVtrZXldO1xuXG4gICAgICAgIGlmKCFkYXRhKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5ICcra2V5KycgaGFkIG5vIGRhdGEhJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdERhdGEgPSBsYXN0LmRhdGFba2V5XTtcbiAgICAgICAgaWYoIWxhc3REYXRhKXtcbiAgICAgICAgICAgIC8vIE5vdCBvdmVybGFwcGluZyBpbiBsYXN0IHN0YXRlLCBidXQgaW4gY3VycmVudC5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmlzTmV3T3ZlcmxhcCA9IGZ1bmN0aW9uKHNoYXBlQSwgc2hhcGVCKXtcbiAgICB2YXIgaWRBID0gc2hhcGVBLmlkfDAsXG4gICAgICAgIGlkQiA9IHNoYXBlQi5pZHwwO1xuICAgIHZhciBsYXN0ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZTtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGU7XG4gICAgLy8gTm90IGluIGxhc3QgYnV0IGluIG5ld1xuICAgIHJldHVybiAhISFsYXN0LmdldChpZEEsIGlkQikgJiYgISFjdXJyZW50LmdldChpZEEsIGlkQik7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXROZXdCb2R5T3ZlcmxhcHMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMudG1wQXJyYXkxLmxlbmd0aCA9IDA7XG4gICAgdmFyIG92ZXJsYXBzID0gdGhpcy5nZXROZXdPdmVybGFwcyh0aGlzLnRtcEFycmF5MSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm9keURpZmYob3ZlcmxhcHMsIHJlc3VsdCk7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXRFbmRCb2R5T3ZlcmxhcHMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMudG1wQXJyYXkxLmxlbmd0aCA9IDA7XG4gICAgdmFyIG92ZXJsYXBzID0gdGhpcy5nZXRFbmRPdmVybGFwcyh0aGlzLnRtcEFycmF5MSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm9keURpZmYob3ZlcmxhcHMsIHJlc3VsdCk7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXRCb2R5RGlmZiA9IGZ1bmN0aW9uKG92ZXJsYXBzLCByZXN1bHQpe1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgICB2YXIgYWNjdW11bGF0b3IgPSB0aGlzLnRtcERpY3Q7XG5cbiAgICB2YXIgbCA9IG92ZXJsYXBzLmxlbmd0aDtcblxuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBkYXRhID0gb3ZlcmxhcHNbbF07XG5cbiAgICAgICAgLy8gU2luY2Ugd2UgdXNlIGJvZHkgaWQncyBmb3IgdGhlIGFjY3VtdWxhdG9yLCB0aGVzZSB3aWxsIGJlIGEgc3Vic2V0IG9mIHRoZSBvcmlnaW5hbCBvbmVcbiAgICAgICAgYWNjdW11bGF0b3Iuc2V0KGRhdGEuYm9keUEuaWR8MCwgZGF0YS5ib2R5Qi5pZHwwLCBkYXRhKTtcbiAgICB9XG5cbiAgICBsID0gYWNjdW11bGF0b3Iua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGRhdGEgPSBhY2N1bXVsYXRvci5nZXRCeUtleShhY2N1bXVsYXRvci5rZXlzW2xdKTtcbiAgICAgICAgaWYoZGF0YSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXRhLmJvZHlBLCBkYXRhLmJvZHlCKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFjY3VtdWxhdG9yLnJlc2V0KCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBPdmVybGFwIGRhdGEgY29udGFpbmVyIGZvciB0aGUgT3ZlcmxhcEtlZXBlclxuICogQGNsYXNzIE92ZXJsYXBLZWVwZXJSZWNvcmRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUJcbiAqL1xuZnVuY3Rpb24gT3ZlcmxhcEtlZXBlclJlY29yZChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKXtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1NoYXBlfSBzaGFwZUFcbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQSA9IHNoYXBlQTtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1NoYXBlfSBzaGFwZUJcbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQiA9IHNoYXBlQjtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlBXG4gICAgICovXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keUJcbiAgICAgKi9cbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG59XG5cbi8qKlxuICogU2V0IHRoZSBkYXRhIGZvciB0aGUgcmVjb3JkXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUJcbiAqL1xuT3ZlcmxhcEtlZXBlclJlY29yZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQil7XG4gICAgT3ZlcmxhcEtlZXBlclJlY29yZC5jYWxsKHRoaXMsIGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpO1xufTtcblxufSx7XCIuL1R1cGxlRGljdGlvbmFyeVwiOjQ5LFwiLi9VdGlsc1wiOjUwfV0sNDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFR1cGxlRGljdGlvbmFyeTtcblxuLyoqXG4gKiBAY2xhc3MgVHVwbGVEaWN0aW9uYXJ5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVHVwbGVEaWN0aW9uYXJ5KCkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgc3RvcmFnZVxuICAgICAqIEBwcm9wZXJ0eSBkYXRhXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEtleXMgdGhhdCBhcmUgY3VycmVudGx5IHVzZWQuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0ga2V5c1xuICAgICAqL1xuICAgIHRoaXMua2V5cyA9IFtdO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IGdpdmVuIHR3byBpbnRlZ2Vyc1xuICogQG1ldGhvZCBnZXRLZXlcbiAqIEBwYXJhbSAge251bWJlcn0gaVxuICogQHBhcmFtICB7bnVtYmVyfSBqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24oaWQxLCBpZDIpIHtcbiAgICBpZDEgPSBpZDF8MDtcbiAgICBpZDIgPSBpZDJ8MDtcblxuICAgIGlmICggKGlkMXwwKSA9PT0gKGlkMnwwKSApe1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8gdmFsaWQgZm9yIHZhbHVlcyA8IDJeMTZcbiAgICByZXR1cm4gKChpZDF8MCkgPiAoaWQyfDApID9cbiAgICAgICAgKGlkMSA8PCAxNikgfCAoaWQyICYgMHhGRkZGKSA6XG4gICAgICAgIChpZDIgPDwgMTYpIHwgKGlkMSAmIDB4RkZGRikpfDBcbiAgICAgICAgO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGdldEJ5S2V5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGtleVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldEJ5S2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAga2V5ID0ga2V5fDA7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtrZXldO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGdldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpLCBqKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmdldEtleShpLCBqKV07XG59O1xuXG4vKipcbiAqIFNldCBhIHZhbHVlLlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihpLCBqLCB2YWx1ZSkge1xuICAgIGlmKCF2YWx1ZSl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGRhdGEhXCIpO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShpLCBqKTtcblxuICAgIC8vIENoZWNrIGlmIGtleSBhbHJlYWR5IGV4aXN0c1xuICAgIGlmKCF0aGlzLmRhdGFba2V5XSl7XG4gICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcblxuICAgIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgZGF0YS5cbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICBrZXlzID0gdGhpcy5rZXlzO1xuXG4gICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pIHtcbiAgICAgICAgZGVsZXRlIGRhdGFba2V5c1tsXV07XG4gICAgfVxuXG4gICAga2V5cy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBDb3B5IGFub3RoZXIgVHVwbGVEaWN0aW9uYXJ5LiBOb3RlIHRoYXQgYWxsIGRhdGEgaW4gdGhpcyBkaWN0aW9uYXJ5IHdpbGwgYmUgcmVtb3ZlZC5cbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtIHtUdXBsZURpY3Rpb25hcnl9IGRpY3QgVGhlIFR1cGxlRGljdGlvbmFyeSB0byBjb3B5IGludG8gdGhpcyBvbmUuXG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGRpY3QpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgVXRpbHMuYXBwZW5kQXJyYXkodGhpcy5rZXlzLCBkaWN0LmtleXMpO1xuICAgIHZhciBsID0gZGljdC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gZGljdC5rZXlzW2xdO1xuICAgICAgICB0aGlzLmRhdGFba2V5XSA9IGRpY3QuZGF0YVtrZXldO1xuICAgIH1cbn07XG5cbn0se1wiLi9VdGlsc1wiOjUwfV0sNTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIFAyX0FSUkFZX1RZUEUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBVdGlscztcblxuLyoqXG4gKiBNaXNjIHV0aWxpdHkgZnVuY3Rpb25zXG4gKiBAY2xhc3MgVXRpbHNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGlscygpe31cblxuLyoqXG4gKiBBcHBlbmQgdGhlIHZhbHVlcyBpbiBhcnJheSBiIHRvIHRoZSBhcnJheSBhLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM3NDEyNi9ob3ctdG8tYXBwZW5kLWFuLWFycmF5LXRvLWFuLWV4aXN0aW5nLWphdmFzY3JpcHQtYXJyYXkvMTM3NDEzMSMxMzc0MTMxXCI+dGhpczwvYT4gZm9yIGFuIGV4cGxhbmF0aW9uLlxuICogQG1ldGhvZCBhcHBlbmRBcnJheVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge0FycmF5fSBiXG4gKi9cblV0aWxzLmFwcGVuZEFycmF5ID0gZnVuY3Rpb24oYSxiKXtcbiAgICBpZiAoYi5sZW5ndGggPCAxNTAwMDApIHtcbiAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBiLmxlbmd0aDsgaSAhPT0gbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGEucHVzaChiW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogR2FyYmFnZSBmcmVlIEFycmF5LnNwbGljZSgpLiBEb2VzIG5vdCBhbGxvY2F0ZSBhIG5ldyBhcnJheS5cbiAqIEBtZXRob2Qgc3BsaWNlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSAge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge051bWJlcn0gaG93bWFueVxuICovXG5VdGlscy5zcGxpY2UgPSBmdW5jdGlvbihhcnJheSxpbmRleCxob3dtYW55KXtcbiAgICBob3dtYW55ID0gaG93bWFueSB8fCAxO1xuICAgIGZvciAodmFyIGk9aW5kZXgsIGxlbj1hcnJheS5sZW5ndGgtaG93bWFueTsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgaG93bWFueV07XG4gICAgfVxuICAgIGFycmF5Lmxlbmd0aCA9IGxlbjtcbn07XG5cbi8qKlxuICogVGhlIGFycmF5IHR5cGUgdG8gdXNlIGZvciBpbnRlcm5hbCBudW1lcmljIGNvbXB1dGF0aW9ucyB0aHJvdWdob3V0IHRoZSBsaWJyYXJ5LiBGbG9hdDMyQXJyYXkgaXMgdXNlZCBpZiBpdCBpcyBhdmFpbGFibGUsIGJ1dCBmYWxscyBiYWNrIG9uIEFycmF5LiBJZiB5b3Ugd2FudCB0byBzZXQgYXJyYXkgdHlwZSBtYW51YWxseSwgaW5qZWN0IGl0IHZpYSB0aGUgZ2xvYmFsIHZhcmlhYmxlIFAyX0FSUkFZX1RZUEUuIFNlZSBleGFtcGxlIGJlbG93LlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gQVJSQVlfVFlQRVxuICogQGV4YW1wbGVcbiAqICAgICA8c2NyaXB0PlxuICogICAgICAgICA8IS0tIEluamVjdCB5b3VyIHByZWZlcnJlZCBhcnJheSB0eXBlIGJlZm9yZSBsb2FkaW5nIHAyLmpzIC0tPlxuICogICAgICAgICBQMl9BUlJBWV9UWVBFID0gQXJyYXk7XG4gKiAgICAgPC9zY3JpcHQ+XG4gKiAgICAgPHNjcmlwdCBzcmM9XCJwMi5qc1wiPjwvc2NyaXB0PlxuICovXG5pZih0eXBlb2YgUDJfQVJSQVlfVFlQRSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gUDJfQVJSQVlfVFlQRTtcbn0gZWxzZSBpZiAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgIFV0aWxzLkFSUkFZX1RZUEUgPSBGbG9hdDMyQXJyYXk7XG59IGVsc2Uge1xuICAgIFV0aWxzLkFSUkFZX1RZUEUgPSBBcnJheTtcbn1cblxuLyoqXG4gKiBFeHRlbmQgYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgb2YgYW5vdGhlclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBleHRlbmRcbiAqIEBwYXJhbSAge29iamVjdH0gYVxuICogQHBhcmFtICB7b2JqZWN0fSBiXG4gKi9cblV0aWxzLmV4dGVuZCA9IGZ1bmN0aW9uKGEsYil7XG4gICAgZm9yKHZhciBrZXkgaW4gYil7XG4gICAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEV4dGVuZCBhbiBvcHRpb25zIG9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBkZWZhdWx0c1xuICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIG9iamVjdC4gTWF5IGJlIGZhbHN5OiBpbiB0aGlzIGNhc2UsIGEgbmV3IG9iamVjdCBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqIEBwYXJhbSAge29iamVjdH0gZGVmYXVsdHMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGVmYXVsdCB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBtb2RpZmllZCBvcHRpb25zIG9iamVjdC5cbiAqL1xuVXRpbHMuZGVmYXVsdHMgPSBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgZm9yKHZhciBrZXkgaW4gZGVmYXVsdHMpe1xuICAgICAgICBpZighKGtleSBpbiBvcHRpb25zKSl7XG4gICAgICAgICAgICBvcHRpb25zW2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxufSx7fV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJc2xhbmQ7XG5cbi8qKlxuICogQW4gaXNsYW5kIG9mIGJvZGllcyBjb25uZWN0ZWQgd2l0aCBlcXVhdGlvbnMuXG4gKiBAY2xhc3MgSXNsYW5kXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSXNsYW5kKCl7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGVxdWF0aW9ucyBpbiB0aGlzIGlzbGFuZC5cbiAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGJvZGllcyBpbiB0aGlzIGlzbGFuZC5cbiAgICAgKiBAcHJvcGVydHkgYm9kaWVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYm9kaWVzID0gW107XG59XG5cbi8qKlxuICogQ2xlYW4gdGhpcyBpc2xhbmQgZnJvbSBib2RpZXMgYW5kIGVxdWF0aW9ucy5cbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuSXNsYW5kLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lcXVhdGlvbnMubGVuZ3RoID0gdGhpcy5ib2RpZXMubGVuZ3RoID0gMDtcbn07XG5cbnZhciBib2R5SWRzID0gW107XG5cbi8qKlxuICogR2V0IGFsbCB1bmlxdWUgYm9kaWVzIGluIHRoaXMgaXNsYW5kLlxuICogQG1ldGhvZCBnZXRCb2RpZXNcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBCb2R5XG4gKi9cbklzbGFuZC5wcm90b3R5cGUuZ2V0Qm9kaWVzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB2YXIgYm9kaWVzID0gcmVzdWx0IHx8IFtdLFxuICAgICAgICBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBib2R5SWRzLmxlbmd0aCA9IDA7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1lcXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBlcXNbaV07XG4gICAgICAgIGlmKGJvZHlJZHMuaW5kZXhPZihlcS5ib2R5QS5pZCk9PT0tMSl7XG4gICAgICAgICAgICBib2RpZXMucHVzaChlcS5ib2R5QSk7XG4gICAgICAgICAgICBib2R5SWRzLnB1c2goZXEuYm9keUEuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGJvZHlJZHMuaW5kZXhPZihlcS5ib2R5Qi5pZCk9PT0tMSl7XG4gICAgICAgICAgICBib2RpZXMucHVzaChlcS5ib2R5Qik7XG4gICAgICAgICAgICBib2R5SWRzLnB1c2goZXEuYm9keUIuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib2RpZXM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBlbnRpcmUgaXNsYW5kIHdhbnRzIHRvIHNsZWVwLlxuICogQG1ldGhvZCB3YW50c1RvU2xlZXBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbklzbGFuZC5wcm90b3R5cGUud2FudHNUb1NsZWVwID0gZnVuY3Rpb24oKXtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gdGhpcy5ib2RpZXNbaV07XG4gICAgICAgIGlmKGIudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmICFiLndhbnRzVG9TbGVlcCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIE1ha2UgYWxsIGJvZGllcyBpbiB0aGUgaXNsYW5kIHNsZWVwLlxuICogQG1ldGhvZCBzbGVlcFxuICovXG5Jc2xhbmQucHJvdG90eXBlLnNsZWVwID0gZnVuY3Rpb24oKXtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gdGhpcy5ib2RpZXNbaV07XG4gICAgICAgIGIuc2xlZXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG59LHtcIi4uL29iamVjdHMvQm9keVwiOjMyfV0sNTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIElzbGFuZCA9IF9kZXJlcV8oJy4vSXNsYW5kJylcbiwgICBJc2xhbmROb2RlID0gX2RlcmVxXygnLi9Jc2xhbmROb2RlJylcbiwgICBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSXNsYW5kTWFuYWdlcjtcblxuLyoqXG4gKiBTcGxpdHMgdGhlIHN5c3RlbSBvZiBib2RpZXMgYW5kIGVxdWF0aW9ucyBpbnRvIGluZGVwZW5kZW50IGlzbGFuZHNcbiAqXG4gKiBAY2xhc3MgSXNsYW5kTWFuYWdlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAZXh0ZW5kcyBTb2x2ZXJcbiAqL1xuZnVuY3Rpb24gSXNsYW5kTWFuYWdlcihvcHRpb25zKXtcblxuICAgIC8vIFBvb2xpbmcgb2Ygbm9kZSBvYmplY3RzIHNhdmVzIHNvbWUgR0MgbG9hZFxuICAgIHRoaXMuX25vZGVQb29sID0gW107XG4gICAgdGhpcy5faXNsYW5kUG9vbCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVxdWF0aW9ucyB0byBzcGxpdC4gTWFudWFsbHkgZmlsbCB0aGlzIGFycmF5IGJlZm9yZSBydW5uaW5nIC5zcGxpdCgpLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGVxdWF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0aW5nIHt7I2Nyb3NzTGluayBcIklzbGFuZFwifX17ey9jcm9zc0xpbmt9fXMuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gaXNsYW5kc1xuICAgICAqL1xuICAgIHRoaXMuaXNsYW5kcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyBncmFwaCBub2Rlcy5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBub2Rlc1xuICAgICAqL1xuICAgIHRoaXMubm9kZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBub2RlIHF1ZXVlLCB1c2VkIHdoZW4gdHJhdmVyc2luZyB0aGUgZ3JhcGggb2Ygbm9kZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBxdWV1ZVxuICAgICAqL1xuICAgIHRoaXMucXVldWUgPSBbXTtcbn1cblxuLyoqXG4gKiBHZXQgYW4gdW52aXNpdGVkIG5vZGUgZnJvbSBhIGxpc3Qgb2Ygbm9kZXMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdldFVudmlzaXRlZE5vZGVcbiAqIEBwYXJhbSAge0FycmF5fSBub2Rlc1xuICogQHJldHVybiB7SXNsYW5kTm9kZXxib29sZWFufSBUaGUgbm9kZSBpZiBmb3VuZCwgZWxzZSBmYWxzZS5cbiAqL1xuSXNsYW5kTWFuYWdlci5nZXRVbnZpc2l0ZWROb2RlID0gZnVuY3Rpb24obm9kZXMpe1xuICAgIHZhciBObm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1Obm9kZXM7IGkrKyl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmKCFub2RlLnZpc2l0ZWQgJiYgbm9kZS5ib2R5LnR5cGUgPT09IEJvZHkuRFlOQU1JQyl7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFZpc2l0IGEgbm9kZS5cbiAqIEBtZXRob2QgdmlzaXRcbiAqIEBwYXJhbSAge0lzbGFuZE5vZGV9IG5vZGVcbiAqIEBwYXJhbSAge0FycmF5fSBiZHNcbiAqIEBwYXJhbSAge0FycmF5fSBlcXNcbiAqL1xuSXNsYW5kTWFuYWdlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAobm9kZSxiZHMsZXFzKXtcbiAgICBiZHMucHVzaChub2RlLmJvZHkpO1xuICAgIHZhciBOZXFzID0gbm9kZS5lcXVhdGlvbnMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmVxczsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gbm9kZS5lcXVhdGlvbnNbaV07XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKGVxKSA9PT0gLTEpeyAvLyBBbHJlYWR5IGFkZGVkP1xuICAgICAgICAgICAgZXFzLnB1c2goZXEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBSdW5zIHRoZSBzZWFyY2ggYWxnb3JpdGhtLCBzdGFydGluZyBhdCBhIHJvb3Qgbm9kZS4gVGhlIHJlc3VsdGluZyBib2RpZXMgYW5kIGVxdWF0aW9ucyB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgcHJvdmlkZWQgYXJyYXlzLlxuICogQG1ldGhvZCBiZnNcbiAqIEBwYXJhbSAge0lzbGFuZE5vZGV9IHJvb3QgVGhlIG5vZGUgdG8gc3RhcnQgZnJvbVxuICogQHBhcmFtICB7QXJyYXl9IGJkcyAgQW4gYXJyYXkgdG8gYXBwZW5kIHJlc3VsdGluZyBCb2RpZXMgdG8uXG4gKiBAcGFyYW0gIHtBcnJheX0gZXFzICBBbiBhcnJheSB0byBhcHBlbmQgcmVzdWx0aW5nIEVxdWF0aW9ucyB0by5cbiAqL1xuSXNsYW5kTWFuYWdlci5wcm90b3R5cGUuYmZzID0gZnVuY3Rpb24ocm9vdCxiZHMsZXFzKXtcblxuICAgIC8vIFJlc2V0IHRoZSB2aXNpdCBxdWV1ZVxuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7XG4gICAgcXVldWUubGVuZ3RoID0gMDtcblxuICAgIC8vIEFkZCByb290IG5vZGUgdG8gcXVldWVcbiAgICBxdWV1ZS5wdXNoKHJvb3QpO1xuICAgIHJvb3QudmlzaXRlZCA9IHRydWU7XG4gICAgdGhpcy52aXNpdChyb290LGJkcyxlcXMpO1xuXG4gICAgLy8gUHJvY2VzcyBhbGwgcXVldWVkIG5vZGVzXG4gICAgd2hpbGUocXVldWUubGVuZ3RoKSB7XG5cbiAgICAgICAgLy8gR2V0IG5leHQgbm9kZSBpbiB0aGUgcXVldWVcbiAgICAgICAgdmFyIG5vZGUgPSBxdWV1ZS5wb3AoKTtcblxuICAgICAgICAvLyBWaXNpdCB1bnZpc2l0ZWQgbmVpZ2hib3Jpbmcgbm9kZXNcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICB3aGlsZSgoY2hpbGQgPSBJc2xhbmRNYW5hZ2VyLmdldFVudmlzaXRlZE5vZGUobm9kZS5uZWlnaGJvcnMpKSkge1xuICAgICAgICAgICAgY2hpbGQudmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KGNoaWxkLGJkcyxlcXMpO1xuXG4gICAgICAgICAgICAvLyBPbmx5IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUgaWYgaXQncyBkeW5hbWljXG4gICAgICAgICAgICBpZihjaGlsZC5ib2R5LnR5cGUgPT09IEJvZHkuRFlOQU1JQyl7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFNwbGl0IHRoZSB3b3JsZCBpbnRvIGluZGVwZW5kZW50IGlzbGFuZHMuIFRoZSByZXN1bHQgaXMgc3RvcmVkIGluIC5pc2xhbmRzLlxuICogQG1ldGhvZCBzcGxpdFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGdlbmVyYXRlZCBpc2xhbmRzXG4gKi9cbklzbGFuZE1hbmFnZXIucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24od29ybGQpe1xuICAgIHZhciBib2RpZXMgPSB3b3JsZC5ib2RpZXMsXG4gICAgICAgIG5vZGVzID0gdGhpcy5ub2RlcyxcbiAgICAgICAgZXF1YXRpb25zID0gdGhpcy5lcXVhdGlvbnM7XG5cbiAgICAvLyBNb3ZlIG9sZCBub2RlcyB0byB0aGUgbm9kZSBwb29sXG4gICAgd2hpbGUobm9kZXMubGVuZ3RoKXtcbiAgICAgICAgdGhpcy5fbm9kZVBvb2wucHVzaChub2Rlcy5wb3AoKSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGVcbiAgICBmb3IodmFyIGk9MDsgaSE9PWJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmKHRoaXMuX25vZGVQb29sLmxlbmd0aCl7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGVQb29sLnBvcCgpO1xuICAgICAgICAgICAgbm9kZS5yZXNldCgpO1xuICAgICAgICAgICAgbm9kZS5ib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IElzbGFuZE5vZGUoYm9kaWVzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgY29ubmVjdGl2aXR5IGRhdGEuIEVhY2ggZXF1YXRpb24gY29ubmVjdHMgMiBib2RpZXMuXG4gICAgZm9yKHZhciBrPTA7IGshPT1lcXVhdGlvbnMubGVuZ3RoOyBrKyspe1xuICAgICAgICB2YXIgZXE9ZXF1YXRpb25zW2tdLFxuICAgICAgICAgICAgaT1ib2RpZXMuaW5kZXhPZihlcS5ib2R5QSksXG4gICAgICAgICAgICBqPWJvZGllcy5pbmRleE9mKGVxLmJvZHlCKSxcbiAgICAgICAgICAgIG5pPW5vZGVzW2ldLFxuICAgICAgICAgICAgbmo9bm9kZXNbal07XG4gICAgICAgIG5pLm5laWdoYm9ycy5wdXNoKG5qKTtcbiAgICAgICAgbmoubmVpZ2hib3JzLnB1c2gobmkpO1xuICAgICAgICBuaS5lcXVhdGlvbnMucHVzaChlcSk7XG4gICAgICAgIG5qLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIG9sZCBpc2xhbmRzIHRvIHRoZSBpc2xhbmQgcG9vbFxuICAgIHZhciBpc2xhbmRzID0gdGhpcy5pc2xhbmRzO1xuICAgIHdoaWxlKGlzbGFuZHMubGVuZ3RoKXtcbiAgICAgICAgdmFyIGlzbGFuZCA9IGlzbGFuZHMucG9wKCk7XG4gICAgICAgIGlzbGFuZC5yZXNldCgpO1xuICAgICAgICB0aGlzLl9pc2xhbmRQb29sLnB1c2goaXNsYW5kKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgaXNsYW5kc1xuICAgIHZhciBjaGlsZDtcbiAgICB3aGlsZSgoY2hpbGQgPSBJc2xhbmRNYW5hZ2VyLmdldFVudmlzaXRlZE5vZGUobm9kZXMpKSl7XG5cbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpc2xhbmRcbiAgICAgICAgdmFyIGlzbGFuZCA9IHRoaXMuX2lzbGFuZFBvb2wubGVuZ3RoID8gdGhpcy5faXNsYW5kUG9vbC5wb3AoKSA6IG5ldyBJc2xhbmQoKTtcblxuICAgICAgICAvLyBHZXQgYWxsIGVxdWF0aW9ucyBhbmQgYm9kaWVzIGluIHRoaXMgaXNsYW5kXG4gICAgICAgIHRoaXMuYmZzKGNoaWxkLCBpc2xhbmQuYm9kaWVzLCBpc2xhbmQuZXF1YXRpb25zKTtcblxuICAgICAgICBpc2xhbmRzLnB1c2goaXNsYW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNsYW5kcztcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9vYmplY3RzL0JvZHlcIjozMixcIi4vSXNsYW5kXCI6NTEsXCIuL0lzbGFuZE5vZGVcIjo1M31dLDUzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gSXNsYW5kTm9kZTtcblxuLyoqXG4gKiBIb2xkcyBhIGJvZHkgYW5kIGtlZXBzIHRyYWNrIG9mIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG5lZWRlZCBmb3IgZ3JhcGggdHJhdmVyc2FsLlxuICogQGNsYXNzIElzbGFuZE5vZGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKi9cbmZ1bmN0aW9uIElzbGFuZE5vZGUoYm9keSl7XG5cblx0LyoqXG5cdCAqIFRoZSBib2R5IHRoYXQgaXMgY29udGFpbmVkIGluIHRoaXMgbm9kZS5cblx0ICogQHByb3BlcnR5IHtCb2R5fSBib2R5XG5cdCAqL1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICAvKipcbiAgICAgKiBOZWlnaGJvcmluZyBJc2xhbmROb2Rlc1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG5laWdoYm9yc1xuICAgICAqL1xuICAgIHRoaXMubmVpZ2hib3JzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBFcXVhdGlvbnMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBlcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBub2RlIHdhcyB2aXNpdGluZyBkdXJpbmcgdGhlIGdyYXBoIHRyYXZlcnNhbC5cbiAgICAgKiBAcHJvcGVydHkgdmlzaXRlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudmlzaXRlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIENsZWFuIHRoaXMgbm9kZSBmcm9tIGJvZGllcyBhbmQgZXF1YXRpb25zLlxuICogQG1ldGhvZCByZXNldFxuICovXG5Jc2xhbmROb2RlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lcXVhdGlvbnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLm5laWdoYm9ycy5sZW5ndGggPSAwO1xuICAgIHRoaXMudmlzaXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuYm9keSA9IG51bGw7XG59O1xuXG59LHt9XSw1NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKiBnbG9iYWwgcGVyZm9ybWFuY2UgKi9cbi8qanNoaW50IC1XMDIwICovXG5cbnZhciAgR1NTb2x2ZXIgPSBfZGVyZXFfKCcuLi9zb2x2ZXIvR1NTb2x2ZXInKVxuLCAgICBTb2x2ZXIgPSBfZGVyZXFfKCcuLi9zb2x2ZXIvU29sdmVyJylcbiwgICAgTmFpdmVCcm9hZHBoYXNlID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL05haXZlQnJvYWRwaGFzZScpXG4sICAgIFJheSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXknKVxuLCAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICAgQ2lyY2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL0NpcmNsZScpXG4sICAgIFJlY3RhbmdsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9SZWN0YW5nbGUnKVxuLCAgICBDb252ZXggPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ29udmV4JylcbiwgICAgTGluZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9MaW5lJylcbiwgICAgUGxhbmUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGxhbmUnKVxuLCAgICBDYXBzdWxlID0gX2RlcmVxXygnLi4vc2hhcGVzL0NhcHN1bGUnKVxuLCAgICBQYXJ0aWNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QYXJ0aWNsZScpXG4sICAgIEV2ZW50RW1pdHRlciA9IF9kZXJlcV8oJy4uL2V2ZW50cy9FdmVudEVtaXR0ZXInKVxuLCAgICBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5JylcbiwgICAgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKVxuLCAgICBMaW5lYXJTcHJpbmcgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0xpbmVhclNwcmluZycpXG4sICAgIE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvTWF0ZXJpYWwnKVxuLCAgICBDb250YWN0TWF0ZXJpYWwgPSBfZGVyZXFfKCcuLi9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWwnKVxuLCAgICBEaXN0YW5jZUNvbnN0cmFpbnQgPSBfZGVyZXFfKCcuLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnQnKVxuLCAgICBDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvQ29uc3RyYWludCcpXG4sICAgIExvY2tDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvTG9ja0NvbnN0cmFpbnQnKVxuLCAgICBSZXZvbHV0ZUNvbnN0cmFpbnQgPSBfZGVyZXFfKCcuLi9jb25zdHJhaW50cy9SZXZvbHV0ZUNvbnN0cmFpbnQnKVxuLCAgICBQcmlzbWF0aWNDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvUHJpc21hdGljQ29uc3RyYWludCcpXG4sICAgIEdlYXJDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvR2VhckNvbnN0cmFpbnQnKVxuLCAgICBwa2cgPSBfZGVyZXFfKCcuLi8uLi9wYWNrYWdlLmpzb24nKVxuLCAgICBCcm9hZHBoYXNlID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKVxuLCAgICBTQVBCcm9hZHBoYXNlID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1NBUEJyb2FkcGhhc2UnKVxuLCAgICBOYXJyb3dwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9OYXJyb3dwaGFzZScpXG4sICAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKVxuLCAgICBPdmVybGFwS2VlcGVyID0gX2RlcmVxXygnLi4vdXRpbHMvT3ZlcmxhcEtlZXBlcicpXG4sICAgIElzbGFuZE1hbmFnZXIgPSBfZGVyZXFfKCcuL0lzbGFuZE1hbmFnZXInKVxuLCAgICBSb3RhdGlvbmFsU3ByaW5nID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Sb3RhdGlvbmFsU3ByaW5nJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV29ybGQ7XG5cbmlmKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgIHBlcmZvcm1hbmNlID0ge307XG59XG5pZighcGVyZm9ybWFuY2Uubm93KXtcbiAgICB2YXIgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpe1xuICAgICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xuICAgIH1cbiAgICBwZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIG5vd09mZnNldDtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBkeW5hbWljcyB3b3JsZCwgd2hlcmUgYWxsIGJvZGllcyBhbmQgY29uc3RyYWludHMgbGl2ZXMuXG4gKlxuICogQGNsYXNzIFdvcmxkXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7U29sdmVyfSAgICAgICAgICBbb3B0aW9ucy5zb2x2ZXJdICAgICAgICAgICAgRGVmYXVsdHMgdG8gR1NTb2x2ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSAgICAgICAgICAgW29wdGlvbnMuZ3Jhdml0eV0gICAgICAgICAgIERlZmF1bHRzIHRvIFswLC05Ljc4XVxuICogQHBhcmFtIHtCcm9hZHBoYXNlfSAgICAgIFtvcHRpb25zLmJyb2FkcGhhc2VdICAgICAgICBEZWZhdWx0cyB0byBOYWl2ZUJyb2FkcGhhc2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5pc2xhbmRTcGxpdD1mYWxzZV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5kb1Byb2ZpbGluZz1mYWxzZV1cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKHtcbiAqICAgICAgICAgZ3Jhdml0eTogWzAsIC05LjgxXSxcbiAqICAgICAgICAgYnJvYWRwaGFzZTogbmV3IFNBUEJyb2FkcGhhc2UoKVxuICogICAgIH0pO1xuICovXG5mdW5jdGlvbiBXb3JsZChvcHRpb25zKXtcbiAgICBFdmVudEVtaXR0ZXIuYXBwbHkodGhpcyk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEFsbCBzcHJpbmdzIGluIHRoZSB3b3JsZC4gVG8gYWRkIGEgc3ByaW5nIHRvIHRoZSB3b3JsZCwgdXNlIHt7I2Nyb3NzTGluayBcIldvcmxkL2FkZFNwcmluZzptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc3ByaW5nc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnNwcmluZ3MgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEFsbCBib2RpZXMgaW4gdGhlIHdvcmxkLiBUbyBhZGQgYSBib2R5IHRvIHRoZSB3b3JsZCwgdXNlIHt7I2Nyb3NzTGluayBcIldvcmxkL2FkZEJvZHk6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGJvZGllc1xuICAgICAqL1xuICAgIHRoaXMuYm9kaWVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlZCBib2R5IGNvbGxpc2lvbiBwYWlycy4gU2VlIHt7I2Nyb3NzTGluayBcIldvcmxkL2Rpc2FibGVCb2R5Q29sbGlzaW9uOm1ldGhvZFwifX0uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBkaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlyc1xuICAgICAqL1xuICAgIHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzb2x2ZXIgdXNlZCB0byBzYXRpc2Z5IGNvbnN0cmFpbnRzIGFuZCBjb250YWN0cy4gRGVmYXVsdCBpcyB7eyNjcm9zc0xpbmsgXCJHU1NvbHZlclwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkge1NvbHZlcn0gc29sdmVyXG4gICAgICovXG4gICAgdGhpcy5zb2x2ZXIgPSBvcHRpb25zLnNvbHZlciB8fCBuZXcgR1NTb2x2ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYXJyb3dwaGFzZSB0byB1c2UgdG8gZ2VuZXJhdGUgY29udGFjdHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbmFycm93cGhhc2VcbiAgICAgKiBAdHlwZSB7TmFycm93cGhhc2V9XG4gICAgICovXG4gICAgdGhpcy5uYXJyb3dwaGFzZSA9IG5ldyBOYXJyb3dwaGFzZSh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpc2xhbmQgbWFuYWdlciBvZiB0aGlzIHdvcmxkLlxuICAgICAqIEBwcm9wZXJ0eSB7SXNsYW5kTWFuYWdlcn0gaXNsYW5kTWFuYWdlclxuICAgICAqL1xuICAgIHRoaXMuaXNsYW5kTWFuYWdlciA9IG5ldyBJc2xhbmRNYW5hZ2VyKCk7XG5cbiAgICAvKipcbiAgICAgKiBHcmF2aXR5IGluIHRoZSB3b3JsZC4gVGhpcyBpcyBhcHBsaWVkIG9uIGFsbCBib2RpZXMgaW4gdGhlIGJlZ2lubmluZyBvZiBlYWNoIHN0ZXAoKS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZ3Jhdml0eSA9IHZlYzIuZnJvbVZhbHVlcygwLCAtOS43OCk7XG4gICAgaWYob3B0aW9ucy5ncmF2aXR5KXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMuZ3Jhdml0eSwgb3B0aW9ucy5ncmF2aXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcmF2aXR5IHRvIHVzZSB3aGVuIGFwcHJveGltYXRpbmcgdGhlIGZyaWN0aW9uIG1heCBmb3JjZSAobXUqbWFzcypncmF2aXR5KS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJpY3Rpb25HcmF2aXR5XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkdyYXZpdHkgPSB2ZWMyLmxlbmd0aCh0aGlzLmdyYXZpdHkpIHx8IDEwO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgLmZyaWN0aW9uR3Jhdml0eSB0byBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGUgbGVuZ3RoIG9mIC5ncmF2aXR5LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHlcbiAgICAgKi9cbiAgICB0aGlzLnVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBsZW5ndGggb2YgLmdyYXZpdHkgaXMgemVybywgYW5kIC51c2VXb3JsZEdyYXZpdHlBc0ZyaWN0aW9uR3Jhdml0eT10cnVlLCB0aGVuIHN3aXRjaCB0byB1c2luZyAuZnJpY3Rpb25HcmF2aXR5IGZvciBmcmljdGlvbiBpbnN0ZWFkLiBUaGlzIGZhbGxiYWNrIGlzIHVzZWZ1bCBmb3IgZ3Jhdml0eWxlc3MgZ2FtZXMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5XG4gICAgICovXG4gICAgdGhpcy51c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZG8gdGltaW5nIG1lYXN1cmVtZW50cyBkdXJpbmcgdGhlIHN0ZXAoKSBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZG9Qb2ZpbGluZ1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZG9Qcm9maWxpbmcgPSBvcHRpb25zLmRvUHJvZmlsaW5nIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSG93IG1hbnkgbWlsbGlzZWNjb25kcyB0aGUgbGFzdCBzdGVwKCkgdG9vay4gVGhpcyBpcyB1cGRhdGVkIGVhY2ggc3RlcCBpZiAuZG9Qcm9maWxpbmcgaXMgc2V0IHRvIHRydWUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGFzdFN0ZXBUaW1lXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RTdGVwVGltZSA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBicm9hZHBoYXNlIGFsZ29yaXRobSB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYnJvYWRwaGFzZVxuICAgICAqIEB0eXBlIHtCcm9hZHBoYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYnJvYWRwaGFzZSA9IG9wdGlvbnMuYnJvYWRwaGFzZSB8fCBuZXcgU0FQQnJvYWRwaGFzZSgpO1xuICAgIHRoaXMuYnJvYWRwaGFzZS5zZXRXb3JsZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFVzZXItYWRkZWQgY29uc3RyYWludHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRHVtbXkgZGVmYXVsdCBtYXRlcmlhbCBpbiB0aGUgd29ybGQsIHVzZWQgaW4gLmRlZmF1bHRDb250YWN0TWF0ZXJpYWxcbiAgICAgKiBAcHJvcGVydHkge01hdGVyaWFsfSBkZWZhdWx0TWF0ZXJpYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY29udGFjdCBtYXRlcmlhbCB0byB1c2UsIGlmIG5vIGNvbnRhY3QgbWF0ZXJpYWwgd2FzIHNldCBmb3IgdGhlIGNvbGxpZGluZyBtYXRlcmlhbHMuXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0TWF0ZXJpYWx9IGRlZmF1bHRDb250YWN0TWF0ZXJpYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwgPSBuZXcgQ29udGFjdE1hdGVyaWFsKHRoaXMuZGVmYXVsdE1hdGVyaWFsLHRoaXMuZGVmYXVsdE1hdGVyaWFsKTtcblxuICAgIC8qKlxuICAgICAqIEZvciBrZWVwaW5nIHRyYWNrIG9mIHdoYXQgdGltZSBzdGVwIHNpemUgd2UgdXNlZCBsYXN0IHN0ZXBcbiAgICAgKiBAcHJvcGVydHkgbGFzdFRpbWVTdGVwXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RUaW1lU3RlcCA9IDEvNjA7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBzcHJpbmcgZm9yY2VzIGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgYXBwbHlTcHJpbmdGb3JjZXNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5U3ByaW5nRm9yY2VzID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0byBhdXRvbWF0aWNhbGx5IGFwcGx5IGJvZHkgZGFtcGluZyBlYWNoIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IGFwcGx5RGFtcGluZ1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXBwbHlEYW1waW5nID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0byBhdXRvbWF0aWNhbGx5IGFwcGx5IGdyYXZpdHkgZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBhcHBseUdyYXZpdHlcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5R3Jhdml0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUvZGlzYWJsZSBjb25zdHJhaW50IHNvbHZpbmcgaW4gZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBzb2x2ZUNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zb2x2ZUNvbnN0cmFpbnRzID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBDb250YWN0TWF0ZXJpYWxzIGFkZGVkIHRvIHRoZSBXb3JsZC5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdE1hdGVyaWFsc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RNYXRlcmlhbHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFdvcmxkIHRpbWUuXG4gICAgICogQHByb3BlcnR5IHRpbWVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGltZSA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIElzIHRydWUgZHVyaW5nIHRoZSBzdGVwKCkuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzdGVwcGluZ1xuICAgICAqL1xuICAgIHRoaXMuc3RlcHBpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEJvZGllcyB0aGF0IGFyZSBzY2hlZHVsZWQgdG8gYmUgcmVtb3ZlZCBhdCB0aGUgZW5kIG9mIHRoZSBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGJvZGllc1RvQmVSZW1vdmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJvZGllc1RvQmVSZW1vdmVkID0gW107XG5cbiAgICB0aGlzLmZpeGVkU3RlcFRpbWUgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBpc2xhbmQgc3BsaXR0aW5nLiBJc2xhbmQgc3BsaXR0aW5nIGNhbiBiZSBhbiBhZHZhbnRhZ2UgZm9yIG1hbnkgdGhpbmdzLCBpbmNsdWRpbmcgc29sdmVyIHBlcmZvcm1hbmNlLiBTZWUge3sjY3Jvc3NMaW5rIFwiSXNsYW5kTWFuYWdlclwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzbGFuZFNwbGl0XG4gICAgICovXG4gICAgdGhpcy5pc2xhbmRTcGxpdCA9IHR5cGVvZihvcHRpb25zLmlzbGFuZFNwbGl0KSE9PVwidW5kZWZpbmVkXCIgPyAhIW9wdGlvbnMuaXNsYW5kU3BsaXQgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHRoZSB3b3JsZCB0byBlbWl0IHRoZSBcImltcGFjdFwiIGV2ZW50LiBUdXJuaW5nIHRoaXMgb2ZmIGNvdWxkIGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgICogQHByb3BlcnR5IGVtaXRJbXBhY3RFdmVudFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZW1pdEltcGFjdEV2ZW50ID0gdHJ1ZTtcblxuICAgIC8vIElkIGNvdW50ZXJzXG4gICAgdGhpcy5fY29uc3RyYWludElkQ291bnRlciA9IDA7XG4gICAgdGhpcy5fYm9keUlkQ291bnRlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBhZnRlciB0aGUgc3RlcCgpLlxuICAgICAqIEBldmVudCBwb3N0U3RlcFxuICAgICAqL1xuICAgIHRoaXMucG9zdFN0ZXBFdmVudCA9IHtcbiAgICAgICAgdHlwZSA6IFwicG9zdFN0ZXBcIixcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBhIGJvZHkgaXMgYWRkZWQgdG8gdGhlIHdvcmxkLlxuICAgICAqIEBldmVudCBhZGRCb2R5XG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5XG4gICAgICovXG4gICAgdGhpcy5hZGRCb2R5RXZlbnQgPSB7XG4gICAgICAgIHR5cGUgOiBcImFkZEJvZHlcIixcbiAgICAgICAgYm9keSA6IG51bGxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBhIGJvZHkgaXMgcmVtb3ZlZCBmcm9tIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgcmVtb3ZlQm9keVxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICAgICAqL1xuICAgIHRoaXMucmVtb3ZlQm9keUV2ZW50ID0ge1xuICAgICAgICB0eXBlIDogXCJyZW1vdmVCb2R5XCIsXG4gICAgICAgIGJvZHkgOiBudWxsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBzcHJpbmcgaXMgYWRkZWQgdG8gdGhlIHdvcmxkLlxuICAgICAqIEBldmVudCBhZGRTcHJpbmdcbiAgICAgKiBAcGFyYW0ge1NwcmluZ30gc3ByaW5nXG4gICAgICovXG4gICAgdGhpcy5hZGRTcHJpbmdFdmVudCA9IHtcbiAgICAgICAgdHlwZSA6IFwiYWRkU3ByaW5nXCIsXG4gICAgICAgIHNwcmluZyA6IG51bGwsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBmaXJzdCBjb250YWN0IGlzIGNyZWF0ZWQgYmV0d2VlbiB0d28gYm9kaWVzLiBUaGlzIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBzdGVwIGhhcyBiZWVuIGRvbmUuXG4gICAgICogQGV2ZW50IGltcGFjdFxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gICAgICovXG4gICAgdGhpcy5pbXBhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJpbXBhY3RcIixcbiAgICAgICAgYm9keUEgOiBudWxsLFxuICAgICAgICBib2R5QiA6IG51bGwsXG4gICAgICAgIHNoYXBlQSA6IG51bGwsXG4gICAgICAgIHNoYXBlQiA6IG51bGwsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvbiA6IG51bGwsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGFmdGVyIHRoZSBCcm9hZHBoYXNlIGhhcyBjb2xsZWN0ZWQgY29sbGlzaW9uIHBhaXJzIGluIHRoZSB3b3JsZC5cbiAgICAgKiBJbnNpZGUgdGhlIGV2ZW50IGhhbmRsZXIsIHlvdSBjYW4gbW9kaWZ5IHRoZSBwYWlycyBhcnJheSBhcyB5b3UgbGlrZSwgdG9cbiAgICAgKiBwcmV2ZW50IGNvbGxpc2lvbnMgYmV0d2VlbiBvYmplY3RzIHRoYXQgeW91IGRvbid0IHdhbnQuXG4gICAgICogQGV2ZW50IHBvc3RCcm9hZHBoYXNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgQW4gYXJyYXkgb2YgY29sbGlzaW9uIHBhaXJzLiBJZiB0aGlzIGFycmF5IGlzIFtib2R5MSxib2R5Mixib2R5Myxib2R5NF0sIHRoZW4gdGhlIGJvZHkgcGFpcnMgMSwyIGFuZCAzLDQgd291bGQgYWR2YW5jZSB0byBuYXJyb3dwaGFzZS5cbiAgICAgKi9cbiAgICB0aGlzLnBvc3RCcm9hZHBoYXNlRXZlbnQgPSB7XG4gICAgICAgIHR5cGU6XCJwb3N0QnJvYWRwaGFzZVwiLFxuICAgICAgICBwYWlyczpudWxsLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIb3cgdG8gZGVhY3RpdmF0ZSBib2RpZXMgZHVyaW5nIHNpbXVsYXRpb24uIFBvc3NpYmxlIG1vZGVzIGFyZToge3sjY3Jvc3NMaW5rIFwiV29ybGQvTk9fU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuTk9fU0xFRVBJTkd7ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiV29ybGQvQk9EWV9TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5CT0RZX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIldvcmxkL0lTTEFORF9TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5JU0xBTkRfU0xFRVBJTkd7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBJZiBzbGVlcGluZyBpcyBlbmFibGVkLCB5b3UgbWlnaHQgbmVlZCB0byB7eyNjcm9zc0xpbmsgXCJCb2R5L3dha2VVcDptZXRob2RcIn19d2FrZSB1cHt7L2Nyb3NzTGlua319IHRoZSBib2RpZXMgaWYgdGhleSBmYWxsIGFzbGVlcCB3aGVuIHRoZXkgc2hvdWxkbid0LiBJZiB5b3Ugd2FudCB0byBlbmFibGUgc2xlZXBpbmcgaW4gdGhlIHdvcmxkLCBidXQgd2FudCB0byBkaXNhYmxlIGl0IGZvciBhIHBhcnRpY3VsYXIgYm9keSwgc2VlIHt7I2Nyb3NzTGluayBcIkJvZHkvYWxsb3dTbGVlcDpwcm9wZXJ0eVwifX1Cb2R5LmFsbG93U2xlZXB7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgc2xlZXBNb2RlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBXb3JsZC5OT19TTEVFUElOR1xuICAgICAqL1xuICAgIHRoaXMuc2xlZXBNb2RlID0gV29ybGQuTk9fU0xFRVBJTkc7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHR3byBzaGFwZXMgc3RhcnRzIHN0YXJ0IHRvIG92ZXJsYXAuIEZpcmVkIGluIHRoZSBuYXJyb3dwaGFzZSwgZHVyaW5nIHN0ZXAuXG4gICAgICogQGV2ZW50IGJlZ2luQ29udGFjdFxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQlxuICAgICAqIEBwYXJhbSB7Qm9keX0gIGJvZHlBXG4gICAgICogQHBhcmFtIHtCb2R5fSAgYm9keUJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb250YWN0RXF1YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5iZWdpbkNvbnRhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTpcImJlZ2luQ29udGFjdFwiLFxuICAgICAgICBzaGFwZUEgOiBudWxsLFxuICAgICAgICBzaGFwZUIgOiBudWxsLFxuICAgICAgICBib2R5QSA6IG51bGwsXG4gICAgICAgIGJvZHlCIDogbnVsbCxcbiAgICAgICAgY29udGFjdEVxdWF0aW9ucyA6IFtdLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHR3byBzaGFwZXMgc3RvcCBvdmVybGFwcGluZywgYWZ0ZXIgdGhlIG5hcnJvd3BoYXNlIChkdXJpbmcgc3RlcCkuXG4gICAgICogQGV2ZW50IGVuZENvbnRhY3RcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUFcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUJcbiAgICAgKiBAcGFyYW0ge0JvZHl9ICBib2R5QVxuICAgICAqIEBwYXJhbSB7Qm9keX0gIGJvZHlCXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29udGFjdEVxdWF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZW5kQ29udGFjdEV2ZW50ID0ge1xuICAgICAgICB0eXBlOlwiZW5kQ29udGFjdFwiLFxuICAgICAgICBzaGFwZUEgOiBudWxsLFxuICAgICAgICBzaGFwZUIgOiBudWxsLFxuICAgICAgICBib2R5QSA6IG51bGwsXG4gICAgICAgIGJvZHlCIDogbnVsbCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBiZWZvcmUgZXF1YXRpb25zIGFyZSBhZGRlZCB0byB0aGUgc29sdmVyIHRvIGJlIHNvbHZlZC4gQ2FuIGJlIHVzZWQgdG8gY29udHJvbCB3aGF0IGVxdWF0aW9ucyBnb2VzIGludG8gdGhlIHNvbHZlci5cbiAgICAgKiBAZXZlbnQgcHJlU29sdmVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb250YWN0RXF1YXRpb25zICBBbiBhcnJheSBvZiBjb250YWN0cyB0byBiZSBzb2x2ZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gZnJpY3Rpb25FcXVhdGlvbnMgQW4gYXJyYXkgb2YgZnJpY3Rpb24gZXF1YXRpb25zIHRvIGJlIHNvbHZlZC5cbiAgICAgKi9cbiAgICB0aGlzLnByZVNvbHZlRXZlbnQgPSB7XG4gICAgICAgIHR5cGU6XCJwcmVTb2x2ZVwiLFxuICAgICAgICBjb250YWN0RXF1YXRpb25zOm51bGwsXG4gICAgICAgIGZyaWN0aW9uRXF1YXRpb25zOm51bGwsXG4gICAgfTtcblxuICAgIC8vIEZvciBrZWVwaW5nIHRyYWNrIG9mIG92ZXJsYXBwaW5nIHNoYXBlc1xuICAgIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGUgPSB7IGtleXM6W10gfTtcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlID0geyBrZXlzOltdIH07XG5cbiAgICB0aGlzLm92ZXJsYXBLZWVwZXIgPSBuZXcgT3ZlcmxhcEtlZXBlcigpO1xufVxuV29ybGQucHJvdG90eXBlID0gbmV3IE9iamVjdChFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcbldvcmxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdvcmxkO1xuXG4vKipcbiAqIE5ldmVyIGRlYWN0aXZhdGUgYm9kaWVzLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IE5PX1NMRUVQSU5HXG4gKi9cbldvcmxkLk5PX1NMRUVQSU5HID0gMTtcblxuLyoqXG4gKiBEZWFjdGl2YXRlIGluZGl2aWR1YWwgYm9kaWVzIGlmIHRoZXkgYXJlIHNsZWVweS5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCT0RZX1NMRUVQSU5HXG4gKi9cbldvcmxkLkJPRFlfU0xFRVBJTkcgPSAyO1xuXG4vKipcbiAqIERlYWN0aXZhdGVzIGJvZGllcyB0aGF0IGFyZSBpbiBjb250YWN0LCBpZiBhbGwgb2YgdGhlbSBhcmUgc2xlZXB5LiBOb3RlIHRoYXQgeW91IG11c3QgZW5hYmxlIHt7I2Nyb3NzTGluayBcIldvcmxkL2lzbGFuZFNwbGl0OnByb3BlcnR5XCJ9fS5pc2xhbmRTcGxpdHt7L2Nyb3NzTGlua319IGZvciB0aGlzIHRvIHdvcmsuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gSVNMQU5EX1NMRUVQSU5HXG4gKi9cbldvcmxkLklTTEFORF9TTEVFUElORyA9IDQ7XG5cbi8qKlxuICogQWRkIGEgY29uc3RyYWludCB0byB0aGUgc2ltdWxhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGFkZENvbnN0cmFpbnRcbiAqIEBwYXJhbSB7Q29uc3RyYWludH0gY1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uKGMpe1xuICAgIHRoaXMuY29uc3RyYWludHMucHVzaChjKTtcbn07XG5cbi8qKlxuICogQWRkIGEgQ29udGFjdE1hdGVyaWFsIHRvIHRoZSBzaW11bGF0aW9uLlxuICogQG1ldGhvZCBhZGRDb250YWN0TWF0ZXJpYWxcbiAqIEBwYXJhbSB7Q29udGFjdE1hdGVyaWFsfSBjb250YWN0TWF0ZXJpYWxcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKGNvbnRhY3RNYXRlcmlhbCl7XG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxzLnB1c2goY29udGFjdE1hdGVyaWFsKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGNvbnRhY3QgbWF0ZXJpYWxcbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtDb250YWN0TWF0ZXJpYWx9IGNtXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVDb250YWN0TWF0ZXJpYWwgPSBmdW5jdGlvbihjbSl7XG4gICAgdmFyIGlkeCA9IHRoaXMuY29udGFjdE1hdGVyaWFscy5pbmRleE9mKGNtKTtcbiAgICBpZihpZHghPT0tMSl7XG4gICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLmNvbnRhY3RNYXRlcmlhbHMsaWR4LDEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGEgY29udGFjdCBtYXRlcmlhbCBnaXZlbiB0d28gbWF0ZXJpYWxzXG4gKiBAbWV0aG9kIGdldENvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxBXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEJcbiAqIEByZXR1cm4ge0NvbnRhY3RNYXRlcmlhbH0gVGhlIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgb3IgZmFsc2Ugb24gZmFpbC5cbiAqIEB0b2RvIFVzZSBmYXN0ZXIgaGFzaCBtYXAgdG8gbG9va3VwIGZyb20gbWF0ZXJpYWwgaWQnc1xuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Q29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24obWF0ZXJpYWxBLG1hdGVyaWFsQil7XG4gICAgdmFyIGNtYXRzID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xuICAgIGZvcih2YXIgaT0wLCBOPWNtYXRzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBjbSA9IGNtYXRzW2ldO1xuICAgICAgICBpZiggKGNtLm1hdGVyaWFsQS5pZCA9PT0gbWF0ZXJpYWxBLmlkKSAmJiAoY20ubWF0ZXJpYWxCLmlkID09PSBtYXRlcmlhbEIuaWQpIHx8XG4gICAgICAgICAgICAoY20ubWF0ZXJpYWxBLmlkID09PSBtYXRlcmlhbEIuaWQpICYmIChjbS5tYXRlcmlhbEIuaWQgPT09IG1hdGVyaWFsQS5pZCkgKXtcbiAgICAgICAgICAgIHJldHVybiBjbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjb25zdHJhaW50XG4gKlxuICogQG1ldGhvZCByZW1vdmVDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZUNvbnN0cmFpbnQgPSBmdW5jdGlvbihjKXtcbiAgICB2YXIgaWR4ID0gdGhpcy5jb25zdHJhaW50cy5pbmRleE9mKGMpO1xuICAgIGlmKGlkeCE9PS0xKXtcbiAgICAgICAgVXRpbHMuc3BsaWNlKHRoaXMuY29uc3RyYWludHMsaWR4LDEpO1xuICAgIH1cbn07XG5cbnZhciBzdGVwX3IgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfcnVuaXQgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfdSA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF9mID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX2ZoTWludiA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF92ZWxvZHQgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfbWcgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHhpdyA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIHhqdyA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIHplcm8gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBpbnRlcnB2ZWxvID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogU3RlcCB0aGUgcGh5c2ljcyB3b3JsZCBmb3J3YXJkIGluIHRpbWUuXG4gKlxuICogVGhlcmUgYXJlIHR3byBtb2Rlcy4gVGhlIHNpbXBsZSBtb2RlIGlzIGZpeGVkIHRpbWVzdGVwcGluZyB3aXRob3V0IGludGVycG9sYXRpb24uIEluIHRoaXMgY2FzZSB5b3Ugb25seSB1c2UgdGhlIGZpcnN0IGFyZ3VtZW50LiBUaGUgc2Vjb25kIGNhc2UgdXNlcyBpbnRlcnBvbGF0aW9uLiBJbiB0aGF0IHlvdSBhbHNvIHByb3ZpZGUgdGhlIHRpbWUgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IHVzZWQsIGFzIHdlbGwgYXMgdGhlIG1heGltdW0gZml4ZWQgdGltZXN0ZXBzIHRvIHRha2UuXG4gKlxuICogQG1ldGhvZCBzdGVwXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgICAgICAgICAgICAgICAgICAgICAgIFRoZSBmaXhlZCB0aW1lIHN0ZXAgc2l6ZSB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTaW5jZUxhc3RDYWxsZWQ9MF0gIFRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IGNhbGxlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4U3ViU3RlcHM9MTBdICAgICAgICAgTWF4aW11bSBudW1iZXIgb2YgZml4ZWQgc3RlcHMgdG8gdGFrZSBwZXIgZnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIGZpeGVkIHRpbWVzdGVwcGluZyB3aXRob3V0IGludGVycG9sYXRpb25cbiAqICAgICB2YXIgd29ybGQgPSBuZXcgV29ybGQoKTtcbiAqICAgICB3b3JsZC5zdGVwKDAuMDEpO1xuICpcbiAqIEBzZWUgaHR0cDovL2J1bGxldHBoeXNpY3Mub3JnL21lZGlhd2lraS0xLjUuOC9pbmRleC5waHAvU3RlcHBpbmdfVGhlX1dvcmxkXG4gKi9cbldvcmxkLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24oZHQsdGltZVNpbmNlTGFzdENhbGxlZCxtYXhTdWJTdGVwcyl7XG4gICAgbWF4U3ViU3RlcHMgPSBtYXhTdWJTdGVwcyB8fCAxMDtcbiAgICB0aW1lU2luY2VMYXN0Q2FsbGVkID0gdGltZVNpbmNlTGFzdENhbGxlZCB8fCAwO1xuXG4gICAgaWYodGltZVNpbmNlTGFzdENhbGxlZCA9PT0gMCl7IC8vIEZpeGVkLCBzaW1wbGUgc3RlcHBpbmdcblxuICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IHRpbWVcbiAgICAgICAgdGhpcy50aW1lICs9IGR0O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBudW1iZXIgb2YgZml4ZWQgc3RlcHMgd2Ugc2hvdWxkIGhhdmUgdGFrZW4gc2luY2UgdGhlIGxhc3Qgc3RlcFxuICAgICAgICB2YXIgaW50ZXJuYWxTdGVwcyA9IE1hdGguZmxvb3IoICh0aGlzLnRpbWUrdGltZVNpbmNlTGFzdENhbGxlZCkgLyBkdCkgLSBNYXRoLmZsb29yKHRoaXMudGltZSAvIGR0KTtcbiAgICAgICAgaW50ZXJuYWxTdGVwcyA9IE1hdGgubWluKGludGVybmFsU3RlcHMsbWF4U3ViU3RlcHMpO1xuXG4gICAgICAgIC8vIERvIHNvbWUgZml4ZWQgc3RlcHMgdG8gY2F0Y2ggdXBcbiAgICAgICAgdmFyIHQwID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09aW50ZXJuYWxTdGVwczsgaSsrKXtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTtcbiAgICAgICAgICAgIGlmKHBlcmZvcm1hbmNlLm5vdygpIC0gdDAgPiBkdCoxMDAwKXtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc2xvd2VyIHRoYW4gcmVhbC10aW1lLiBCZXR0ZXIgYmFpbCBvdXQuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmNyZW1lbnQgaW50ZXJuYWwgY2xvY2tcbiAgICAgICAgdGhpcy50aW1lICs9IHRpbWVTaW5jZUxhc3RDYWxsZWQ7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBcIkxlZnQgb3ZlclwiIHRpbWUgc3RlcFxuICAgICAgICB2YXIgaCA9IHRoaXMudGltZSAlIGR0O1xuICAgICAgICB2YXIgaF9kaXZfZHQgPSBoL2R0O1xuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09dGhpcy5ib2RpZXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmJvZGllc1tqXTtcbiAgICAgICAgICAgIGlmKGIudHlwZSAhPT0gQm9keS5TVEFUSUMgJiYgYi5zbGVlcFN0YXRlICE9PSBCb2R5LlNMRUVQSU5HKXtcbiAgICAgICAgICAgICAgICAvLyBJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgIHZlYzIuc3ViKGludGVycHZlbG8sIGIucG9zaXRpb24sIGIucHJldmlvdXNQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgdmVjMi5zY2FsZShpbnRlcnB2ZWxvLCBpbnRlcnB2ZWxvLCBoX2Rpdl9kdCk7XG4gICAgICAgICAgICAgICAgdmVjMi5hZGQoYi5pbnRlcnBvbGF0ZWRQb3NpdGlvbiwgYi5wb3NpdGlvbiwgaW50ZXJwdmVsbyk7XG5cbiAgICAgICAgICAgICAgICBiLmludGVycG9sYXRlZEFuZ2xlID0gYi5hbmdsZSArIChiLmFuZ2xlIC0gYi5wcmV2aW91c0FuZ2xlKSAqIGhfZGl2X2R0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igc3RhdGljIGJvZGllcywganVzdCBjb3B5LiBXaG8gZWxzZSB3aWxsIGRvIGl0P1xuICAgICAgICAgICAgICAgIHZlYzIuY29weShiLmludGVycG9sYXRlZFBvc2l0aW9uLCBiLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBiLmludGVycG9sYXRlZEFuZ2xlID0gYi5hbmdsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBlbmRPdmVybGFwcyA9IFtdO1xuXG4vKipcbiAqIE1ha2UgYSBmaXhlZCBzdGVwLlxuICogQG1ldGhvZCBpbnRlcm5hbFN0ZXBcbiAqIEBwYXJhbSAge251bWJlcn0gZHRcbiAqIEBwcml2YXRlXG4gKi9cbldvcmxkLnByb3RvdHlwZS5pbnRlcm5hbFN0ZXAgPSBmdW5jdGlvbihkdCl7XG4gICAgdGhpcy5zdGVwcGluZyA9IHRydWU7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIGRvUHJvZmlsaW5nID0gdGhpcy5kb1Byb2ZpbGluZyxcbiAgICAgICAgTnNwcmluZ3MgPSB0aGlzLnNwcmluZ3MubGVuZ3RoLFxuICAgICAgICBzcHJpbmdzID0gdGhpcy5zcHJpbmdzLFxuICAgICAgICBib2RpZXMgPSB0aGlzLmJvZGllcyxcbiAgICAgICAgZyA9IHRoaXMuZ3Jhdml0eSxcbiAgICAgICAgc29sdmVyID0gdGhpcy5zb2x2ZXIsXG4gICAgICAgIE5ib2RpZXMgPSB0aGlzLmJvZGllcy5sZW5ndGgsXG4gICAgICAgIGJyb2FkcGhhc2UgPSB0aGlzLmJyb2FkcGhhc2UsXG4gICAgICAgIG5wID0gdGhpcy5uYXJyb3dwaGFzZSxcbiAgICAgICAgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzLFxuICAgICAgICB0MCwgdDEsXG4gICAgICAgIGZoTWludiA9IHN0ZXBfZmhNaW52LFxuICAgICAgICB2ZWxvZHQgPSBzdGVwX3ZlbG9kdCxcbiAgICAgICAgbWcgPSBzdGVwX21nLFxuICAgICAgICBzY2FsZSA9IHZlYzIuc2NhbGUsXG4gICAgICAgIGFkZCA9IHZlYzIuYWRkLFxuICAgICAgICByb3RhdGUgPSB2ZWMyLnJvdGF0ZSxcbiAgICAgICAgaXNsYW5kTWFuYWdlciA9IHRoaXMuaXNsYW5kTWFuYWdlcjtcblxuICAgIHRoaXMub3ZlcmxhcEtlZXBlci50aWNrKCk7XG5cbiAgICB0aGlzLmxhc3RUaW1lU3RlcCA9IGR0O1xuXG4gICAgaWYoZG9Qcm9maWxpbmcpe1xuICAgICAgICB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBhcHByb3hpbWF0ZSBmcmljdGlvbiBncmF2aXR5LlxuICAgIGlmKHRoaXMudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHkpe1xuICAgICAgICB2YXIgZ3Jhdml0eUxlbiA9IHZlYzIubGVuZ3RoKHRoaXMuZ3Jhdml0eSk7XG4gICAgICAgIGlmKCEoZ3Jhdml0eUxlbiA9PT0gMCAmJiB0aGlzLnVzZUZyaWN0aW9uR3Jhdml0eU9uWmVyb0dyYXZpdHkpKXtcbiAgICAgICAgICAgIC8vIE5vbnplcm8gZ3Jhdml0eS4gVXNlIGl0LlxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkdyYXZpdHkgPSBncmF2aXR5TGVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGdyYXZpdHkgdG8gYm9kaWVzXG4gICAgaWYodGhpcy5hcHBseUdyYXZpdHkpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICBmaSA9IGIuZm9yY2U7XG4gICAgICAgICAgICBpZihiLnR5cGUgIT09IEJvZHkuRFlOQU1JQyB8fCBiLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmVjMi5zY2FsZShtZyxnLGIubWFzcypiLmdyYXZpdHlTY2FsZSk7IC8vIEY9bSpnXG4gICAgICAgICAgICBhZGQoZmksZmksbWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIHNwcmluZyBmb3JjZXNcbiAgICBpZih0aGlzLmFwcGx5U3ByaW5nRm9yY2VzKXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1Oc3ByaW5nczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzID0gc3ByaW5nc1tpXTtcbiAgICAgICAgICAgIHMuYXBwbHlGb3JjZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5hcHBseURhbXBpbmcpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgIGlmKGIudHlwZSA9PT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgICAgICAgICBiLmFwcGx5RGFtcGluZyhkdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCcm9hZHBoYXNlXG4gICAgdmFyIHJlc3VsdCA9IGJyb2FkcGhhc2UuZ2V0Q29sbGlzaW9uUGFpcnModGhpcyk7XG5cbiAgICAvLyBSZW1vdmUgaWdub3JlZCBjb2xsaXNpb24gcGFpcnNcbiAgICB2YXIgaWdub3JlZFBhaXJzID0gdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycztcbiAgICBmb3IodmFyIGk9aWdub3JlZFBhaXJzLmxlbmd0aC0yOyBpPj0wOyBpLT0yKXtcbiAgICAgICAgZm9yKHZhciBqPXJlc3VsdC5sZW5ndGgtMjsgaj49MDsgai09Mil7XG4gICAgICAgICAgICBpZiggKGlnbm9yZWRQYWlyc1tpXSAgID09PSByZXN1bHRbal0gJiYgaWdub3JlZFBhaXJzW2krMV0gPT09IHJlc3VsdFtqKzFdKSB8fFxuICAgICAgICAgICAgICAgIChpZ25vcmVkUGFpcnNbaSsxXSA9PT0gcmVzdWx0W2pdICYmIGlnbm9yZWRQYWlyc1tpXSAgID09PSByZXN1bHRbaisxXSkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaiwyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBjb25zdHJhaW5lZCBwYWlycyB3aXRoIGNvbGxpZGVDb25uZWN0ZWQgPT0gZmFsc2VcbiAgICB2YXIgTmNvbnN0cmFpbnRzID0gY29uc3RyYWludHMubGVuZ3RoO1xuICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgIHZhciBjID0gY29uc3RyYWludHNbaV07XG4gICAgICAgIGlmKCFjLmNvbGxpZGVDb25uZWN0ZWQpe1xuICAgICAgICAgICAgZm9yKHZhciBqPXJlc3VsdC5sZW5ndGgtMjsgaj49MDsgai09Mil7XG4gICAgICAgICAgICAgICAgaWYoIChjLmJvZHlBID09PSByZXN1bHRbal0gJiYgYy5ib2R5QiA9PT0gcmVzdWx0W2orMV0pIHx8XG4gICAgICAgICAgICAgICAgICAgIChjLmJvZHlCID09PSByZXN1bHRbal0gJiYgYy5ib2R5QSA9PT0gcmVzdWx0W2orMV0pKXtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNwbGljZShqLDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvc3RCcm9hZHBoYXNlIGV2ZW50XG4gICAgdGhpcy5wb3N0QnJvYWRwaGFzZUV2ZW50LnBhaXJzID0gcmVzdWx0O1xuICAgIHRoaXMuZW1pdCh0aGlzLnBvc3RCcm9hZHBoYXNlRXZlbnQpO1xuXG4gICAgLy8gTmFycm93cGhhc2VcbiAgICBucC5yZXNldCh0aGlzKTtcbiAgICBmb3IodmFyIGk9MCwgTnJlc3VsdHM9cmVzdWx0Lmxlbmd0aDsgaSE9PU5yZXN1bHRzOyBpKz0yKXtcbiAgICAgICAgdmFyIGJpID0gcmVzdWx0W2ldLFxuICAgICAgICAgICAgYmogPSByZXN1bHRbaSsxXTtcblxuICAgICAgICAvLyBMb29wIG92ZXIgYWxsIHNoYXBlcyBvZiBib2R5IGlcbiAgICAgICAgZm9yKHZhciBrPTAsIE5zaGFwZXNpPWJpLnNoYXBlcy5sZW5ndGg7IGshPT1Oc2hhcGVzaTsgaysrKXtcbiAgICAgICAgICAgIHZhciBzaSA9IGJpLnNoYXBlc1trXSxcbiAgICAgICAgICAgICAgICB4aSA9IGJpLnNoYXBlT2Zmc2V0c1trXSxcbiAgICAgICAgICAgICAgICBhaSA9IGJpLnNoYXBlQW5nbGVzW2tdO1xuXG4gICAgICAgICAgICAvLyBBbGwgc2hhcGVzIG9mIGJvZHkgalxuICAgICAgICAgICAgZm9yKHZhciBsPTAsIE5zaGFwZXNqPWJqLnNoYXBlcy5sZW5ndGg7IGwhPT1Oc2hhcGVzajsgbCsrKXtcbiAgICAgICAgICAgICAgICB2YXIgc2ogPSBiai5zaGFwZXNbbF0sXG4gICAgICAgICAgICAgICAgICAgIHhqID0gYmouc2hhcGVPZmZzZXRzW2xdLFxuICAgICAgICAgICAgICAgICAgICBhaiA9IGJqLnNoYXBlQW5nbGVzW2xdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNtID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xuICAgICAgICAgICAgICAgIGlmKHNpLm1hdGVyaWFsICYmIHNqLm1hdGVyaWFsKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuZ2V0Q29udGFjdE1hdGVyaWFsKHNpLm1hdGVyaWFsLHNqLm1hdGVyaWFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodG1wKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtID0gdG1wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5OYXJyb3dwaGFzZShucCxiaSxzaSx4aSxhaSxiaixzaix4aixhaixjbSx0aGlzLmZyaWN0aW9uR3Jhdml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXYWtlIHVwIGJvZGllc1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgIGlmKGJvZHkuX3dha2VVcEFmdGVyTmFycm93cGhhc2Upe1xuICAgICAgICAgICAgYm9keS53YWtlVXAoKTtcbiAgICAgICAgICAgIGJvZHkuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVtaXQgZW5kIG92ZXJsYXAgZXZlbnRzXG4gICAgaWYodGhpcy5oYXMoJ2VuZENvbnRhY3QnKSl7XG4gICAgICAgIHRoaXMub3ZlcmxhcEtlZXBlci5nZXRFbmRPdmVybGFwcyhlbmRPdmVybGFwcyk7XG4gICAgICAgIHZhciBlID0gdGhpcy5lbmRDb250YWN0RXZlbnQ7XG4gICAgICAgIHZhciBsID0gZW5kT3ZlcmxhcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZShsLS0pe1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBlbmRPdmVybGFwc1tsXTtcbiAgICAgICAgICAgIGUuc2hhcGVBID0gZGF0YS5zaGFwZUE7XG4gICAgICAgICAgICBlLnNoYXBlQiA9IGRhdGEuc2hhcGVCO1xuICAgICAgICAgICAgZS5ib2R5QSA9IGRhdGEuYm9keUE7XG4gICAgICAgICAgICBlLmJvZHlCID0gZGF0YS5ib2R5QjtcbiAgICAgICAgICAgIHRoaXMuZW1pdChlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmVTb2x2ZUV2ZW50ID0gdGhpcy5wcmVTb2x2ZUV2ZW50O1xuICAgIHByZVNvbHZlRXZlbnQuY29udGFjdEVxdWF0aW9ucyA9IG5wLmNvbnRhY3RFcXVhdGlvbnM7XG4gICAgcHJlU29sdmVFdmVudC5mcmljdGlvbkVxdWF0aW9ucyA9IG5wLmZyaWN0aW9uRXF1YXRpb25zO1xuICAgIHRoaXMuZW1pdChwcmVTb2x2ZUV2ZW50KTtcblxuICAgIC8vIHVwZGF0ZSBjb25zdHJhaW50IGVxdWF0aW9uc1xuICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5jb25zdHJhaW50czsgaSsrKXtcbiAgICAgICAgY29uc3RyYWludHNbaV0udXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaWYobnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggfHwgbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoIHx8IGNvbnN0cmFpbnRzLmxlbmd0aCl7XG4gICAgICAgIGlmKHRoaXMuaXNsYW5kU3BsaXQpe1xuICAgICAgICAgICAgLy8gU3BsaXQgaW50byBpc2xhbmRzXG4gICAgICAgICAgICBpc2xhbmRNYW5hZ2VyLmVxdWF0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkoaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMsIG5wLmNvbnRhY3RFcXVhdGlvbnMpO1xuICAgICAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkoaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMsIG5wLmZyaWN0aW9uRXF1YXRpb25zKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgICAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkoaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMsIGNvbnN0cmFpbnRzW2ldLmVxdWF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc2xhbmRNYW5hZ2VyLnNwbGl0KHRoaXMpO1xuXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWlzbGFuZE1hbmFnZXIuaXNsYW5kcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgdmFyIGlzbGFuZCA9IGlzbGFuZE1hbmFnZXIuaXNsYW5kc1tpXTtcbiAgICAgICAgICAgICAgICBpZihpc2xhbmQuZXF1YXRpb25zLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIHNvbHZlci5zb2x2ZUlzbGFuZChkdCxpc2xhbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBBZGQgY29udGFjdCBlcXVhdGlvbnMgdG8gc29sdmVyXG4gICAgICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb25zKG5wLmNvbnRhY3RFcXVhdGlvbnMpO1xuICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9ucyhucC5mcmljdGlvbkVxdWF0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB1c2VyLWRlZmluZWQgY29uc3RyYWludCBlcXVhdGlvbnNcbiAgICAgICAgICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9ucyhjb25zdHJhaW50c1tpXS5lcXVhdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aGlzLnNvbHZlQ29uc3RyYWludHMpe1xuICAgICAgICAgICAgICAgIHNvbHZlci5zb2x2ZShkdCx0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RlcCBmb3J3YXJkXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICBpZihib2R5LnNsZWVwU3RhdGUgIT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keS50eXBlICE9PSBCb2R5LlNUQVRJQyl7XG4gICAgICAgICAgICBib2R5LmludGVncmF0ZShkdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNldCBmb3JjZVxuICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgYm9kaWVzW2ldLnNldFplcm9Gb3JjZSgpO1xuICAgIH1cblxuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhhdC5sYXN0U3RlcFRpbWUgPSB0MS10MDtcbiAgICB9XG5cbiAgICAvLyBFbWl0IGltcGFjdCBldmVudFxuICAgIGlmKHRoaXMuZW1pdEltcGFjdEV2ZW50ICYmIHRoaXMuaGFzKCdpbXBhY3QnKSl7XG4gICAgICAgIHZhciBldiA9IHRoaXMuaW1wYWN0RXZlbnQ7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09bnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgZXEgPSBucC5jb250YWN0RXF1YXRpb25zW2ldO1xuICAgICAgICAgICAgaWYoZXEuZmlyc3RJbXBhY3Qpe1xuICAgICAgICAgICAgICAgIGV2LmJvZHlBID0gZXEuYm9keUE7XG4gICAgICAgICAgICAgICAgZXYuYm9keUIgPSBlcS5ib2R5QjtcbiAgICAgICAgICAgICAgICBldi5zaGFwZUEgPSBlcS5zaGFwZUE7XG4gICAgICAgICAgICAgICAgZXYuc2hhcGVCID0gZXEuc2hhcGVCO1xuICAgICAgICAgICAgICAgIGV2LmNvbnRhY3RFcXVhdGlvbiA9IGVxO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTbGVlcGluZyB1cGRhdGVcbiAgICBpZih0aGlzLnNsZWVwTW9kZSA9PT0gV29ybGQuQk9EWV9TTEVFUElORyl7XG4gICAgICAgIGZvcihpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUsIGZhbHNlLCBkdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYodGhpcy5zbGVlcE1vZGUgPT09IFdvcmxkLklTTEFORF9TTEVFUElORyAmJiB0aGlzLmlzbGFuZFNwbGl0KXtcblxuICAgICAgICAvLyBUZWxsIGFsbCBib2RpZXMgdG8gc2xlZXAgdGljayBidXQgZG9udCBzbGVlcCB5ZXRcbiAgICAgICAgZm9yKGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICBib2RpZXNbaV0uc2xlZXBUaWNrKHRoaXMudGltZSwgdHJ1ZSwgZHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2xlZXAgaXNsYW5kc1xuICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmlzbGFuZE1hbmFnZXIuaXNsYW5kcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgaXNsYW5kID0gdGhpcy5pc2xhbmRNYW5hZ2VyLmlzbGFuZHNbaV07XG4gICAgICAgICAgICBpZihpc2xhbmQud2FudHNUb1NsZWVwKCkpe1xuICAgICAgICAgICAgICAgIGlzbGFuZC5zbGVlcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGVwcGluZyA9IGZhbHNlO1xuXG4gICAgLy8gUmVtb3ZlIGJvZGllcyB0aGF0IGFyZSBzY2hlZHVsZWQgZm9yIHJlbW92YWxcbiAgICBpZih0aGlzLmJvZGllc1RvQmVSZW1vdmVkLmxlbmd0aCl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09dGhpcy5ib2RpZXNUb0JlUmVtb3ZlZC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJvZHkodGhpcy5ib2RpZXNUb0JlUmVtb3ZlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2RpZXNUb0JlUmVtb3ZlZC5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCh0aGlzLnBvc3RTdGVwRXZlbnQpO1xufTtcblxuLyoqXG4gKiBSdW5zIG5hcnJvd3BoYXNlIGZvciB0aGUgc2hhcGUgcGFpciBpIGFuZCBqLlxuICogQG1ldGhvZCBydW5OYXJyb3dwaGFzZVxuICogQHBhcmFtICB7TmFycm93cGhhc2V9IG5wXG4gKiBAcGFyYW0gIHtCb2R5fSBiaVxuICogQHBhcmFtICB7U2hhcGV9IHNpXG4gKiBAcGFyYW0gIHtBcnJheX0geGlcbiAqIEBwYXJhbSAge051bWJlcn0gYWlcbiAqIEBwYXJhbSAge0JvZHl9IGJqXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2pcbiAqIEBwYXJhbSAge0FycmF5fSB4alxuICogQHBhcmFtICB7TnVtYmVyfSBhalxuICogQHBhcmFtICB7TnVtYmVyfSBtdVxuICovXG5Xb3JsZC5wcm90b3R5cGUucnVuTmFycm93cGhhc2UgPSBmdW5jdGlvbihucCxiaSxzaSx4aSxhaSxiaixzaix4aixhaixjbSxnbGVuKXtcblxuICAgIC8vIENoZWNrIGNvbGxpc2lvbiBncm91cHMgYW5kIG1hc2tzXG4gICAgaWYoISgoc2kuY29sbGlzaW9uR3JvdXAgJiBzai5jb2xsaXNpb25NYXNrKSAhPT0gMCAmJiAoc2ouY29sbGlzaW9uR3JvdXAgJiBzaS5jb2xsaXNpb25NYXNrKSAhPT0gMCkpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IHdvcmxkIHBvc2l0aW9uIGFuZCBhbmdsZSBvZiBlYWNoIHNoYXBlXG4gICAgdmVjMi5yb3RhdGUoeGl3LCB4aSwgYmkuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHhqdywgeGosIGJqLmFuZ2xlKTtcbiAgICB2ZWMyLmFkZCh4aXcsIHhpdywgYmkucG9zaXRpb24pO1xuICAgIHZlYzIuYWRkKHhqdywgeGp3LCBiai5wb3NpdGlvbik7XG4gICAgdmFyIGFpdyA9IGFpICsgYmkuYW5nbGU7XG4gICAgdmFyIGFqdyA9IGFqICsgYmouYW5nbGU7XG5cbiAgICBucC5lbmFibGVGcmljdGlvbiA9IGNtLmZyaWN0aW9uID4gMDtcbiAgICBucC5mcmljdGlvbkNvZWZmaWNpZW50ID0gY20uZnJpY3Rpb247XG4gICAgdmFyIHJlZHVjZWRNYXNzO1xuICAgIGlmKGJpLnR5cGUgPT09IEJvZHkuU1RBVElDIHx8IGJpLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKXtcbiAgICAgICAgcmVkdWNlZE1hc3MgPSBiai5tYXNzO1xuICAgIH0gZWxzZSBpZihiai50eXBlID09PSBCb2R5LlNUQVRJQyB8fCBiai50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHJlZHVjZWRNYXNzID0gYmkubWFzcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZWR1Y2VkTWFzcyA9IChiaS5tYXNzKmJqLm1hc3MpLyhiaS5tYXNzK2JqLm1hc3MpO1xuICAgIH1cbiAgICBucC5zbGlwRm9yY2UgPSBjbS5mcmljdGlvbipnbGVuKnJlZHVjZWRNYXNzO1xuICAgIG5wLnJlc3RpdHV0aW9uID0gY20ucmVzdGl0dXRpb247XG4gICAgbnAuc3VyZmFjZVZlbG9jaXR5ID0gY20uc3VyZmFjZVZlbG9jaXR5O1xuICAgIG5wLmZyaWN0aW9uU3RpZmZuZXNzID0gY20uZnJpY3Rpb25TdGlmZm5lc3M7XG4gICAgbnAuZnJpY3Rpb25SZWxheGF0aW9uID0gY20uZnJpY3Rpb25SZWxheGF0aW9uO1xuICAgIG5wLnN0aWZmbmVzcyA9IGNtLnN0aWZmbmVzcztcbiAgICBucC5yZWxheGF0aW9uID0gY20ucmVsYXhhdGlvbjtcbiAgICBucC5jb250YWN0U2tpblNpemUgPSBjbS5jb250YWN0U2tpblNpemU7XG4gICAgbnAuZW5hYmxlZEVxdWF0aW9ucyA9IGJpLmNvbGxpc2lvblJlc3BvbnNlICYmIGJqLmNvbGxpc2lvblJlc3BvbnNlICYmIHNpLmNvbGxpc2lvblJlc3BvbnNlICYmIHNqLmNvbGxpc2lvblJlc3BvbnNlO1xuXG4gICAgdmFyIHJlc29sdmVyID0gbnBbc2kudHlwZSB8IHNqLnR5cGVdLFxuICAgICAgICBudW1Db250YWN0cyA9IDA7XG4gICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgIHZhciBzZW5zb3IgPSBzaS5zZW5zb3IgfHwgc2ouc2Vuc29yO1xuICAgICAgICB2YXIgbnVtRnJpY3Rpb25CZWZvcmUgPSBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7XG4gICAgICAgIGlmIChzaS50eXBlIDwgc2oudHlwZSkge1xuICAgICAgICAgICAgbnVtQ29udGFjdHMgPSByZXNvbHZlci5jYWxsKG5wLCBiaSxzaSx4aXcsYWl3LCBiaixzaix4ancsYWp3LCBzZW5zb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnVtQ29udGFjdHMgPSByZXNvbHZlci5jYWxsKG5wLCBiaixzaix4ancsYWp3LCBiaSxzaSx4aXcsYWl3LCBzZW5zb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1GcmljdGlvbkVxdWF0aW9ucyA9IG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCAtIG51bUZyaWN0aW9uQmVmb3JlO1xuXG4gICAgICAgIGlmKG51bUNvbnRhY3RzKXtcblxuICAgICAgICAgICAgaWYoIGJpLmFsbG93U2xlZXAgJiZcbiAgICAgICAgICAgICAgICBiaS50eXBlID09PSBCb2R5LkRZTkFNSUMgJiZcbiAgICAgICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5TTEVFUElORyAmJlxuICAgICAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgID09PSBCb2R5LkFXQUtFICYmXG4gICAgICAgICAgICAgICAgYmoudHlwZSAhPT0gQm9keS5TVEFUSUNcbiAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWVkU3F1YXJlZEIgPSB2ZWMyLnNxdWFyZWRMZW5ndGgoYmoudmVsb2NpdHkpICsgTWF0aC5wb3coYmouYW5ndWxhclZlbG9jaXR5LDIpO1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZExpbWl0U3F1YXJlZEIgPSBNYXRoLnBvdyhiai5zbGVlcFNwZWVkTGltaXQsMik7XG4gICAgICAgICAgICAgICAgaWYoc3BlZWRTcXVhcmVkQiA+PSBzcGVlZExpbWl0U3F1YXJlZEIqMil7XG4gICAgICAgICAgICAgICAgICAgIGJpLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBiai5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICAgICAgYmoudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmXG4gICAgICAgICAgICAgICAgYmouc2xlZXBTdGF0ZSAgPT09IEJvZHkuU0xFRVBJTkcgJiZcbiAgICAgICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgICAgIGJpLnR5cGUgIT09IEJvZHkuU1RBVElDXG4gICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRBID0gdmVjMi5zcXVhcmVkTGVuZ3RoKGJpLnZlbG9jaXR5KSArIE1hdGgucG93KGJpLmFuZ3VsYXJWZWxvY2l0eSwyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWRBID0gTWF0aC5wb3coYmkuc2xlZXBTcGVlZExpbWl0LDIpO1xuICAgICAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEEgPj0gc3BlZWRMaW1pdFNxdWFyZWRBKjIpe1xuICAgICAgICAgICAgICAgICAgICBiai5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm92ZXJsYXBLZWVwZXIuc2V0T3ZlcmxhcHBpbmcoYmksIHNpLCBiaiwgc2opO1xuICAgICAgICAgICAgaWYodGhpcy5oYXMoJ2JlZ2luQ29udGFjdCcpICYmIHRoaXMub3ZlcmxhcEtlZXBlci5pc05ld092ZXJsYXAoc2ksIHNqKSl7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXBvcnQgbmV3IHNoYXBlIG92ZXJsYXBcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuYmVnaW5Db250YWN0RXZlbnQ7XG4gICAgICAgICAgICAgICAgZS5zaGFwZUEgPSBzaTtcbiAgICAgICAgICAgICAgICBlLnNoYXBlQiA9IHNqO1xuICAgICAgICAgICAgICAgIGUuYm9keUEgPSBiaTtcbiAgICAgICAgICAgICAgICBlLmJvZHlCID0gYmo7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCBjb250YWN0IGVxdWF0aW9uc1xuICAgICAgICAgICAgICAgIGUuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mKG51bUNvbnRhY3RzKT09PVwibnVtYmVyXCIpe1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk9bnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGgtbnVtQ29udGFjdHM7IGk8bnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmNvbnRhY3RFcXVhdGlvbnMucHVzaChucC5jb250YWN0RXF1YXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGl2aWRlIHRoZSBtYXggZnJpY3Rpb24gZm9yY2UgYnkgdGhlIG51bWJlciBvZiBjb250YWN0c1xuICAgICAgICAgICAgaWYodHlwZW9mKG51bUNvbnRhY3RzKT09PVwibnVtYmVyXCIgJiYgbnVtRnJpY3Rpb25FcXVhdGlvbnMgPiAxKXsgLy8gV2h5IGRpdmlkZSBieSAxP1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaT1ucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGgtbnVtRnJpY3Rpb25FcXVhdGlvbnM7IGk8bnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IG5wLmZyaWN0aW9uRXF1YXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBmLnNldFNsaXBGb3JjZShmLmdldFNsaXBGb3JjZSgpIC8gbnVtRnJpY3Rpb25FcXVhdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLyoqXG4gKiBBZGQgYSBzcHJpbmcgdG8gdGhlIHNpbXVsYXRpb25cbiAqXG4gKiBAbWV0aG9kIGFkZFNwcmluZ1xuICogQHBhcmFtIHtTcHJpbmd9IHNcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZFNwcmluZyA9IGZ1bmN0aW9uKHMpe1xuICAgIHRoaXMuc3ByaW5ncy5wdXNoKHMpO1xuICAgIHRoaXMuYWRkU3ByaW5nRXZlbnQuc3ByaW5nID0gcztcbiAgICB0aGlzLmVtaXQodGhpcy5hZGRTcHJpbmdFdmVudCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHNwcmluZ1xuICpcbiAqIEBtZXRob2QgcmVtb3ZlU3ByaW5nXG4gKiBAcGFyYW0ge1NwcmluZ30gc1xuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlU3ByaW5nID0gZnVuY3Rpb24ocyl7XG4gICAgdmFyIGlkeCA9IHRoaXMuc3ByaW5ncy5pbmRleE9mKHMpO1xuICAgIGlmKGlkeCE9PS0xKXtcbiAgICAgICAgVXRpbHMuc3BsaWNlKHRoaXMuc3ByaW5ncyxpZHgsMSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgYSBib2R5IHRvIHRoZSBzaW11bGF0aW9uXG4gKlxuICogQG1ldGhvZCBhZGRCb2R5XG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCgpLFxuICogICAgICAgICBib2R5ID0gbmV3IEJvZHkoKTtcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHkpO1xuICogQHRvZG8gV2hhdCBpZiB0aGlzIGlzIGRvbmUgZHVyaW5nIHN0ZXA/XG4gKi9cbldvcmxkLnByb3RvdHlwZS5hZGRCb2R5ID0gZnVuY3Rpb24oYm9keSl7XG4gICAgaWYodGhpcy5ib2RpZXMuaW5kZXhPZihib2R5KSA9PT0gLTEpe1xuICAgICAgICB0aGlzLmJvZGllcy5wdXNoKGJvZHkpO1xuICAgICAgICBib2R5LndvcmxkID0gdGhpcztcbiAgICAgICAgdGhpcy5hZGRCb2R5RXZlbnQuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLmFkZEJvZHlFdmVudCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBib2R5IGZyb20gdGhlIHNpbXVsYXRpb24uIElmIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBkdXJpbmcgc3RlcCgpLCB0aGUgYm9keSByZW1vdmFsIGlzIHNjaGVkdWxlZCB0byBhZnRlciB0aGUgc3RlcC5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUJvZHlcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQm9keSA9IGZ1bmN0aW9uKGJvZHkpe1xuICAgIGlmKHRoaXMuc3RlcHBpbmcpe1xuICAgICAgICB0aGlzLmJvZGllc1RvQmVSZW1vdmVkLnB1c2goYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYm9keS53b3JsZCA9IG51bGw7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmJvZGllcy5pbmRleE9mKGJvZHkpO1xuICAgICAgICBpZihpZHghPT0tMSl7XG4gICAgICAgICAgICBVdGlscy5zcGxpY2UodGhpcy5ib2RpZXMsaWR4LDEpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVCb2R5RXZlbnQuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICBib2R5LnJlc2V0Q29uc3RyYWludFZlbG9jaXR5KCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5yZW1vdmVCb2R5RXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBib2R5IGJ5IGl0cyBpZC5cbiAqIEBtZXRob2QgZ2V0Qm9keUJ5SWRcbiAqIEByZXR1cm4ge0JvZHl8Qm9vbGVhbn0gVGhlIGJvZHksIG9yIGZhbHNlIGlmIGl0IHdhcyBub3QgZm91bmQuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5nZXRCb2R5QnlJZCA9IGZ1bmN0aW9uKGlkKXtcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gICAgZm9yKHZhciBpPTA7IGk8Ym9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBib2RpZXNbaV07XG4gICAgICAgIGlmKGIuaWQgPT09IGlkKXtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRGlzYWJsZSBjb2xsaXNpb24gYmV0d2VlbiB0d28gYm9kaWVzXG4gKiBAbWV0aG9kIGRpc2FibGVDb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqL1xuV29ybGQucHJvdG90eXBlLmRpc2FibGVCb2R5Q29sbGlzaW9uID0gZnVuY3Rpb24oYm9keUEsYm9keUIpe1xuICAgIHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnMucHVzaChib2R5QSxib2R5Qik7XG59O1xuXG4vKipcbiAqIEVuYWJsZSBjb2xsaXNpb25zIGJldHdlZW4gdGhlIGdpdmVuIHR3byBib2RpZXNcbiAqIEBtZXRob2QgZW5hYmxlQ29sbGlzaW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbldvcmxkLnByb3RvdHlwZS5lbmFibGVCb2R5Q29sbGlzaW9uID0gZnVuY3Rpb24oYm9keUEsYm9keUIpe1xuICAgIHZhciBwYWlycyA9IHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnM7XG4gICAgZm9yKHZhciBpPTA7IGk8cGFpcnMubGVuZ3RoOyBpKz0yKXtcbiAgICAgICAgaWYoKHBhaXJzW2ldID09PSBib2R5QSAmJiBwYWlyc1tpKzFdID09PSBib2R5QikgfHwgKHBhaXJzW2krMV0gPT09IGJvZHlBICYmIHBhaXJzW2ldID09PSBib2R5Qikpe1xuICAgICAgICAgICAgcGFpcnMuc3BsaWNlKGksMik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmZ1bmN0aW9uIHYyYSh2KXtcbiAgICBpZighdil7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZXR1cm4gW3ZbMF0sdlsxXV07XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLGIpe1xuICAgIGZvcih2YXIga2V5IGluIGIpe1xuICAgICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb250YWN0TWF0ZXJpYWxUb0pTT04oY20pe1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkIDogY20uaWQsXG4gICAgICAgIG1hdGVyaWFsQSA6ICAgICAgICAgICAgIGNtLm1hdGVyaWFsQS5pZCxcbiAgICAgICAgbWF0ZXJpYWxCIDogICAgICAgICAgICAgY20ubWF0ZXJpYWxCLmlkLFxuICAgICAgICBmcmljdGlvbiA6ICAgICAgICAgICAgICBjbS5mcmljdGlvbixcbiAgICAgICAgcmVzdGl0dXRpb24gOiAgICAgICAgICAgY20ucmVzdGl0dXRpb24sXG4gICAgICAgIHN0aWZmbmVzcyA6ICAgICAgICAgICAgIGNtLnN0aWZmbmVzcyxcbiAgICAgICAgcmVsYXhhdGlvbiA6ICAgICAgICAgICAgY20ucmVsYXhhdGlvbixcbiAgICAgICAgZnJpY3Rpb25TdGlmZm5lc3MgOiAgICAgY20uZnJpY3Rpb25TdGlmZm5lc3MsXG4gICAgICAgIGZyaWN0aW9uUmVsYXhhdGlvbiA6ICAgIGNtLmZyaWN0aW9uUmVsYXhhdGlvbixcbiAgICB9O1xufVxuXG4vKipcbiAqIFJlc2V0cyB0aGUgV29ybGQsIHJlbW92ZXMgYWxsIGJvZGllcywgY29uc3RyYWludHMgYW5kIHNwcmluZ3MuXG4gKlxuICogQG1ldGhvZCBjbGVhclxuICovXG5Xb3JsZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuXG4gICAgdGhpcy50aW1lID0gMDtcbiAgICB0aGlzLmZpeGVkU3RlcFRpbWUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGFsbCBzb2x2ZXIgZXF1YXRpb25zXG4gICAgaWYodGhpcy5zb2x2ZXIgJiYgdGhpcy5zb2x2ZXIuZXF1YXRpb25zLmxlbmd0aCl7XG4gICAgICAgIHRoaXMuc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgY29uc3RyYWludHNcbiAgICB2YXIgY3MgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgIGZvcih2YXIgaT1jcy5sZW5ndGgtMTsgaT49MDsgaS0tKXtcbiAgICAgICAgdGhpcy5yZW1vdmVDb25zdHJhaW50KGNzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGJvZGllc1xuICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcbiAgICBmb3IodmFyIGk9Ym9kaWVzLmxlbmd0aC0xOyBpPj0wOyBpLS0pe1xuICAgICAgICB0aGlzLnJlbW92ZUJvZHkoYm9kaWVzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIHNwcmluZ3NcbiAgICB2YXIgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncztcbiAgICBmb3IodmFyIGk9c3ByaW5ncy5sZW5ndGgtMTsgaT49MDsgaS0tKXtcbiAgICAgICAgdGhpcy5yZW1vdmVTcHJpbmcoc3ByaW5nc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBjb250YWN0IG1hdGVyaWFsc1xuICAgIHZhciBjbXMgPSB0aGlzLmNvbnRhY3RNYXRlcmlhbHM7XG4gICAgZm9yKHZhciBpPWNtcy5sZW5ndGgtMTsgaT49MDsgaS0tKXtcbiAgICAgICAgdGhpcy5yZW1vdmVDb250YWN0TWF0ZXJpYWwoY21zW2ldKTtcbiAgICB9XG5cbiAgICBXb3JsZC5hcHBseSh0aGlzKTtcbn07XG5cbi8qKlxuICogR2V0IGEgY29weSBvZiB0aGlzIFdvcmxkIGluc3RhbmNlXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcmV0dXJuIHtXb3JsZH1cbiAqL1xuV29ybGQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgd29ybGQgPSBuZXcgV29ybGQoKTtcbiAgICB3b3JsZC5mcm9tSlNPTih0aGlzLnRvSlNPTigpKTtcbiAgICByZXR1cm4gd29ybGQ7XG59O1xuXG52YXIgaGl0VGVzdF90bXAxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBoaXRUZXN0X3plcm8gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBoaXRUZXN0X3RtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBUZXN0IGlmIGEgd29ybGQgcG9pbnQgb3ZlcmxhcHMgYm9kaWVzXG4gKiBAbWV0aG9kIGhpdFRlc3RcbiAqIEBwYXJhbSAge0FycmF5fSAgd29ybGRQb2ludCAgUG9pbnQgdG8gdXNlIGZvciBpbnRlcnNlY3Rpb24gdGVzdHNcbiAqIEBwYXJhbSAge0FycmF5fSAgYm9kaWVzICAgICAgQSBsaXN0IG9mIG9iamVjdHMgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBVc2VkIGZvciBtYXRjaGluZyBhZ2FpbnN0IHBhcnRpY2xlcyBhbmQgbGluZXMuIEFkZHMgc29tZSBtYXJnaW4gdG8gdGhlc2UgaW5maW5pdGVzaW1hbCBvYmplY3RzLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBBcnJheSBvZiBib2RpZXMgdGhhdCBvdmVybGFwIHRoZSBwb2ludFxuICovXG5Xb3JsZC5wcm90b3R5cGUuaGl0VGVzdCA9IGZ1bmN0aW9uKHdvcmxkUG9pbnQsYm9kaWVzLHByZWNpc2lvbil7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG5cbiAgICAvLyBDcmVhdGUgYSBkdW1teSBwYXJ0aWNsZSBib2R5IHdpdGggYSBwYXJ0aWNsZSBzaGFwZSB0byB0ZXN0IGFnYWluc3QgdGhlIGJvZGllc1xuICAgIHZhciBwYiA9IG5ldyBCb2R5KHsgcG9zaXRpb246d29ybGRQb2ludCB9KSxcbiAgICAgICAgcHMgPSBuZXcgUGFydGljbGUoKSxcbiAgICAgICAgcHggPSB3b3JsZFBvaW50LFxuICAgICAgICBwYSA9IDAsXG4gICAgICAgIHggPSBoaXRUZXN0X3RtcDEsXG4gICAgICAgIHplcm8gPSBoaXRUZXN0X3plcm8sXG4gICAgICAgIHRtcCA9IGhpdFRlc3RfdG1wMjtcbiAgICBwYi5hZGRTaGFwZShwcyk7XG5cbiAgICB2YXIgbiA9IHRoaXMubmFycm93cGhhc2UsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgLy8gQ2hlY2sgYm9kaWVzXG4gICAgZm9yKHZhciBpPTAsIE49Ym9kaWVzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuICAgICAgICBmb3IodmFyIGo9MCwgTlM9Yi5zaGFwZXMubGVuZ3RoOyBqIT09TlM7IGorKyl7XG4gICAgICAgICAgICB2YXIgcyA9IGIuc2hhcGVzW2pdLFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGIuc2hhcGVPZmZzZXRzW2pdIHx8IHplcm8sXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBiLnNoYXBlQW5nbGVzW2pdIHx8IDAuMDtcblxuICAgICAgICAgICAgLy8gR2V0IHNoYXBlIHdvcmxkIHBvc2l0aW9uICsgYW5nbGVcbiAgICAgICAgICAgIHZlYzIucm90YXRlKHgsIG9mZnNldCwgYi5hbmdsZSk7XG4gICAgICAgICAgICB2ZWMyLmFkZCh4LCB4LCBiLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciBhID0gYW5nbGUgKyBiLmFuZ2xlO1xuXG4gICAgICAgICAgICBpZiggKHMgaW5zdGFuY2VvZiBDaXJjbGUgICAgJiYgbi5jaXJjbGVQYXJ0aWNsZSAgKGIscyx4LGEsICAgICBwYixwcyxweCxwYSwgdHJ1ZSkpIHx8XG4gICAgICAgICAgICAgICAgKHMgaW5zdGFuY2VvZiBDb252ZXggICAgJiYgbi5wYXJ0aWNsZUNvbnZleCAgKHBiLHBzLHB4LHBhLCBiLHMseCxhLCAgICAgdHJ1ZSkpIHx8XG4gICAgICAgICAgICAgICAgKHMgaW5zdGFuY2VvZiBQbGFuZSAgICAgJiYgbi5wYXJ0aWNsZVBsYW5lICAgKHBiLHBzLHB4LHBhLCBiLHMseCxhLCAgICAgdHJ1ZSkpIHx8XG4gICAgICAgICAgICAgICAgKHMgaW5zdGFuY2VvZiBDYXBzdWxlICAgJiYgbi5wYXJ0aWNsZUNhcHN1bGUgKHBiLHBzLHB4LHBhLCBiLHMseCxhLCAgICAgdHJ1ZSkpIHx8XG4gICAgICAgICAgICAgICAgKHMgaW5zdGFuY2VvZiBQYXJ0aWNsZSAgJiYgdmVjMi5zcXVhcmVkTGVuZ3RoKHZlYzIuc3ViKHRtcCx4LHdvcmxkUG9pbnQpKSA8IHByZWNpc2lvbipwcmVjaXNpb24pXG4gICAgICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIEVxdWF0aW9uIHBhcmFtZXRlcnMgZm9yIGFsbCBjb25zdHJhaW50cyBhbmQgY29udGFjdCBtYXRlcmlhbHMuXG4gKiBAbWV0aG9kIHNldEdsb2JhbEVxdWF0aW9uUGFyYW1ldGVyc1xuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbWV0ZXJzXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnJlbGF4YXRpb25dXG4gKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMuc3RpZmZuZXNzXVxuICovXG5Xb3JsZC5wcm90b3R5cGUuc2V0R2xvYmFsRXF1YXRpb25QYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1ldGVycyl7XG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgICAvLyBTZXQgZm9yIGFsbCBjb25zdHJhaW50c1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSB0aGlzLmNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNvbnN0cmFpbnRzW2ldO1xuICAgICAgICBmb3IodmFyIGo9MDsgaiAhPT0gYy5lcXVhdGlvbnMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgdmFyIGVxID0gYy5lcXVhdGlvbnNbal07XG4gICAgICAgICAgICBpZih0eXBlb2YocGFyYW1ldGVycy5zdGlmZm5lc3MpICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgICAgICBlcS5zdGlmZm5lc3MgPSBwYXJhbWV0ZXJzLnN0aWZmbmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHR5cGVvZihwYXJhbWV0ZXJzLnJlbGF4YXRpb24pICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgICAgICBlcS5yZWxheGF0aW9uID0gcGFyYW1ldGVycy5yZWxheGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGZvciBhbGwgY29udGFjdCBtYXRlcmlhbHNcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gdGhpcy5jb250YWN0TWF0ZXJpYWxzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNvbnRhY3RNYXRlcmlhbHNbaV07XG4gICAgICAgIGlmKHR5cGVvZihwYXJhbWV0ZXJzLnN0aWZmbmVzcykgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgYy5zdGlmZm5lc3MgPSBwYXJhbWV0ZXJzLnN0aWZmbmVzcztcbiAgICAgICAgICAgIGMuZnJpY3Rpb25TdGlmZm5lc3MgPSBwYXJhbWV0ZXJzLnN0aWZmbmVzcztcbiAgICAgICAgfVxuICAgICAgICBpZih0eXBlb2YocGFyYW1ldGVycy5yZWxheGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICBjLnJlbGF4YXRpb24gPSBwYXJhbWV0ZXJzLnJlbGF4YXRpb247XG4gICAgICAgICAgICBjLmZyaWN0aW9uUmVsYXhhdGlvbiA9IHBhcmFtZXRlcnMucmVsYXhhdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBmb3IgZGVmYXVsdCBjb250YWN0IG1hdGVyaWFsXG4gICAgdmFyIGMgPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgaWYodHlwZW9mKHBhcmFtZXRlcnMuc3RpZmZuZXNzKSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIGMuc3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgICAgIGMuZnJpY3Rpb25TdGlmZm5lc3MgPSBwYXJhbWV0ZXJzLnN0aWZmbmVzcztcbiAgICB9XG4gICAgaWYodHlwZW9mKHBhcmFtZXRlcnMucmVsYXhhdGlvbikgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICBjLnJlbGF4YXRpb24gPSBwYXJhbWV0ZXJzLnJlbGF4YXRpb247XG4gICAgICAgIGMuZnJpY3Rpb25SZWxheGF0aW9uID0gcGFyYW1ldGVycy5yZWxheGF0aW9uO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IHRoZSBzdGlmZm5lc3MgZm9yIGFsbCBlcXVhdGlvbnMgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzLlxuICogQG1ldGhvZCBzZXRHbG9iYWxTdGlmZm5lc3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGlmZm5lc3NcbiAqL1xuV29ybGQucHJvdG90eXBlLnNldEdsb2JhbFN0aWZmbmVzcyA9IGZ1bmN0aW9uKHN0aWZmbmVzcyl7XG4gICAgdGhpcy5zZXRHbG9iYWxFcXVhdGlvblBhcmFtZXRlcnMoe1xuICAgICAgICBzdGlmZm5lc3M6IHN0aWZmbmVzc1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHJlbGF4YXRpb24gZm9yIGFsbCBlcXVhdGlvbnMgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzLlxuICogQG1ldGhvZCBzZXRHbG9iYWxSZWxheGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmVsYXhhdGlvblxuICovXG5Xb3JsZC5wcm90b3R5cGUuc2V0R2xvYmFsUmVsYXhhdGlvbiA9IGZ1bmN0aW9uKHJlbGF4YXRpb24pe1xuICAgIHRoaXMuc2V0R2xvYmFsRXF1YXRpb25QYXJhbWV0ZXJzKHtcbiAgICAgICAgcmVsYXhhdGlvbjogcmVsYXhhdGlvblxuICAgIH0pO1xufTtcblxudmFyIHRtcFJheSA9IG5ldyBSYXkoKTtcblxuLyoqXG4gKiBSYXkgY2FzdCBhZ2FpbnN0IGFsbCBib2RpZXMuIFRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGhpdCB3aXRoIGEgUmF5Y2FzdFJlc3VsdCBhcyBzaW5nbGUgYXJndW1lbnQuXG4gKiBAbWV0aG9kIHJheWNhc3RBbGxcbiAqIEBwYXJhbSAge1ZlYzN9IGZyb21cbiAqIEBwYXJhbSAge1ZlYzN9IHRvXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uTWFzaz0tMV1cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uR3JvdXA9LTFdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yYXljYXN0QWxsID0gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMsIGNhbGxiYWNrKXtcbiAgICBvcHRpb25zLm1vZGUgPSBSYXkuQUxMO1xuICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XG4gICAgb3B0aW9ucy50byA9IHRvO1xuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSYXkgY2FzdCwgYW5kIHN0b3AgYXQgdGhlIGZpcnN0IHJlc3VsdC4gTm90ZSB0aGF0IHRoZSBvcmRlciBpcyByYW5kb20gLSBidXQgdGhlIG1ldGhvZCBpcyBmYXN0LlxuICogQG1ldGhvZCByYXljYXN0QW55XG4gKiBAcGFyYW0gIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbk1hc2s9LTFdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkdyb3VwPS0xXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cbiAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdEFueSA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zLCByZXN1bHQpe1xuICAgIG9wdGlvbnMubW9kZSA9IFJheS5BTlk7XG4gICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICBvcHRpb25zLnRvID0gdG87XG4gICAgb3B0aW9ucy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmF5IGNhc3QsIGFuZCByZXR1cm4gaW5mb3JtYXRpb24gb2YgdGhlIGNsb3Nlc3QgaGl0LlxuICogQG1ldGhvZCByYXljYXN0Q2xvc2VzdFxuICogQHBhcmFtICB7VmVjM30gZnJvbVxuICogQHBhcmFtICB7VmVjM30gdG9cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25NYXNrPS0xXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25Hcm91cD0tMV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnJheWNhc3RDbG9zZXN0ID0gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMsIHJlc3VsdCl7XG4gICAgb3B0aW9ucy5tb2RlID0gUmF5LkNMT1NFU1Q7XG4gICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICBvcHRpb25zLnRvID0gdG87XG4gICAgb3B0aW9ucy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbn07XG59LHtcIi4uLy4uL3BhY2thZ2UuanNvblwiOjYsXCIuLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjgsXCIuLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlXCI6MTAsXCIuLi9jb2xsaXNpb24vTmFycm93cGhhc2VcIjoxMSxcIi4uL2NvbGxpc2lvbi9SYXlcIjoxMixcIi4uL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlXCI6MTQsXCIuLi9jb25zdHJhaW50cy9Db25zdHJhaW50XCI6MTUsXCIuLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnRcIjoxNixcIi4uL2NvbnN0cmFpbnRzL0dlYXJDb25zdHJhaW50XCI6MTcsXCIuLi9jb25zdHJhaW50cy9Mb2NrQ29uc3RyYWludFwiOjE4LFwiLi4vY29uc3RyYWludHMvUHJpc21hdGljQ29uc3RyYWludFwiOjE5LFwiLi4vY29uc3RyYWludHMvUmV2b2x1dGVDb25zdHJhaW50XCI6MjAsXCIuLi9ldmVudHMvRXZlbnRFbWl0dGVyXCI6MjcsXCIuLi9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWxcIjoyOCxcIi4uL21hdGVyaWFsL01hdGVyaWFsXCI6MjksXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL29iamVjdHMvQm9keVwiOjMyLFwiLi4vb2JqZWN0cy9MaW5lYXJTcHJpbmdcIjozMyxcIi4uL29iamVjdHMvUm90YXRpb25hbFNwcmluZ1wiOjM0LFwiLi4vc2hhcGVzL0NhcHN1bGVcIjozNyxcIi4uL3NoYXBlcy9DaXJjbGVcIjozOCxcIi4uL3NoYXBlcy9Db252ZXhcIjozOSxcIi4uL3NoYXBlcy9MaW5lXCI6NDEsXCIuLi9zaGFwZXMvUGFydGljbGVcIjo0MixcIi4uL3NoYXBlcy9QbGFuZVwiOjQzLFwiLi4vc2hhcGVzL1JlY3RhbmdsZVwiOjQ0LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDUsXCIuLi9zb2x2ZXIvR1NTb2x2ZXJcIjo0NixcIi4uL3NvbHZlci9Tb2x2ZXJcIjo0NyxcIi4uL3V0aWxzL092ZXJsYXBLZWVwZXJcIjo0OCxcIi4uL3V0aWxzL1V0aWxzXCI6NTAsXCIuL0lzbGFuZE1hbmFnZXJcIjo1Mn1dfSx7fSxbMzZdKVxuKDM2KVxufSk7OyIsIiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLnBvbHkydHJpPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9e1widmVyc2lvblwiOiBcIjEuMy41XCJ9XG59LHt9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBQb2x5MlRyaSBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXG4gKiBcbiAqIHBvbHkydHJpLmpzIChKYXZhU2NyaXB0IHBvcnQpIChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3IzbWkvcG9seTJ0cmkuanNcbiAqIFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIDMtY2xhdXNlIEJTRCBMaWNlbnNlLCBzZWUgTElDRU5TRS50eHRcbiAqL1xuXG4vKiBqc2hpbnQgbWF4Y29tcGxleGl0eToxMSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKlxuICogTm90ZVxuICogPT09PVxuICogdGhlIHN0cnVjdHVyZSBvZiB0aGlzIEphdmFTY3JpcHQgdmVyc2lvbiBvZiBwb2x5MnRyaSBpbnRlbnRpb25hbGx5IGZvbGxvd3NcbiAqIGFzIGNsb3NlbHkgYXMgcG9zc2libGUgdGhlIHN0cnVjdHVyZSBvZiB0aGUgcmVmZXJlbmNlIEMrKyB2ZXJzaW9uLCB0byBtYWtlIGl0IFxuICogZWFzaWVyIHRvIGtlZXAgdGhlIDIgdmVyc2lvbnMgaW4gc3luYy5cbiAqL1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1Ob2RlXG5cbi8qKlxuICogQWR2YW5jaW5nIGZyb250IG5vZGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqIEBzdHJ1Y3RcbiAqIEBwYXJhbSB7IVhZfSBwIC0gUG9pbnRcbiAqIEBwYXJhbSB7VHJpYW5nbGU9fSB0IHRyaWFuZ2xlIChvcHRpb25hbClcbiAqL1xudmFyIE5vZGUgPSBmdW5jdGlvbihwLCB0KSB7XG4gICAgLyoqIEB0eXBlIHtYWX0gKi9cbiAgICB0aGlzLnBvaW50ID0gcDtcblxuICAgIC8qKiBAdHlwZSB7VHJpYW5nbGV8bnVsbH0gKi9cbiAgICB0aGlzLnRyaWFuZ2xlID0gdCB8fCBudWxsO1xuXG4gICAgLyoqIEB0eXBlIHtOb2RlfG51bGx9ICovXG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAvKiogQHR5cGUge05vZGV8bnVsbH0gKi9cbiAgICB0aGlzLnByZXYgPSBudWxsO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy52YWx1ZSA9IHAueDtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLUFkdmFuY2luZ0Zyb250XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqIEBzdHJ1Y3RcbiAqIEBwYXJhbSB7Tm9kZX0gaGVhZFxuICogQHBhcmFtIHtOb2RlfSB0YWlsXG4gKi9cbnZhciBBZHZhbmNpbmdGcm9udCA9IGZ1bmN0aW9uKGhlYWQsIHRhaWwpIHtcbiAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgdGhpcy5oZWFkXyA9IGhlYWQ7XG4gICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgIHRoaXMudGFpbF8gPSB0YWlsO1xuICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICB0aGlzLnNlYXJjaF9ub2RlXyA9IGhlYWQ7XG59O1xuXG4vKiogQHJldHVybiB7Tm9kZX0gKi9cbkFkdmFuY2luZ0Zyb250LnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZF87XG59O1xuXG4vKiogQHBhcmFtIHtOb2RlfSBub2RlICovXG5BZHZhbmNpbmdGcm9udC5wcm90b3R5cGUuc2V0SGVhZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLmhlYWRfID0gbm9kZTtcbn07XG5cbi8qKiBAcmV0dXJuIHtOb2RlfSAqL1xuQWR2YW5jaW5nRnJvbnQucHJvdG90eXBlLnRhaWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWlsXztcbn07XG5cbi8qKiBAcGFyYW0ge05vZGV9IG5vZGUgKi9cbkFkdmFuY2luZ0Zyb250LnByb3RvdHlwZS5zZXRUYWlsID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMudGFpbF8gPSBub2RlO1xufTtcblxuLyoqIEByZXR1cm4ge05vZGV9ICovXG5BZHZhbmNpbmdGcm9udC5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoX25vZGVfO1xufTtcblxuLyoqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuQWR2YW5jaW5nRnJvbnQucHJvdG90eXBlLnNldFNlYXJjaCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLnNlYXJjaF9ub2RlXyA9IG5vZGU7XG59O1xuXG4vKiogQHJldHVybiB7Tm9kZX0gKi9cbkFkdmFuY2luZ0Zyb250LnByb3RvdHlwZS5maW5kU2VhcmNoTm9kZSA9IGZ1bmN0aW9uKC8qeCovKSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IEJTVCBpbmRleFxuICAgIHJldHVybiB0aGlzLnNlYXJjaF9ub2RlXztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHggdmFsdWVcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbkFkdmFuY2luZ0Zyb250LnByb3RvdHlwZS5sb2NhdGVOb2RlID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zZWFyY2hfbm9kZV87XG5cbiAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgaWYgKHggPCBub2RlLnZhbHVlKSB7XG4gICAgICAgIHdoaWxlIChub2RlID0gbm9kZS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoeCA+PSBub2RlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hfbm9kZV8gPSBub2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpIHtcbiAgICAgICAgICAgIGlmICh4IDwgbm9kZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoX25vZGVfID0gbm9kZS5wcmV2O1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IVhZfSBwb2ludCAtIFBvaW50XG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5BZHZhbmNpbmdGcm9udC5wcm90b3R5cGUubG9jYXRlUG9pbnQgPSBmdW5jdGlvbihwb2ludCkge1xuICAgIHZhciBweCA9IHBvaW50Lng7XG4gICAgdmFyIG5vZGUgPSB0aGlzLmZpbmRTZWFyY2hOb2RlKHB4KTtcbiAgICB2YXIgbnggPSBub2RlLnBvaW50Lng7XG5cbiAgICBpZiAocHggPT09IG54KSB7XG4gICAgICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgICAgIGlmIChwb2ludCAhPT0gbm9kZS5wb2ludCkge1xuICAgICAgICAgICAgLy8gV2UgbWlnaHQgaGF2ZSB0d28gbm9kZXMgd2l0aCBzYW1lIHggdmFsdWUgZm9yIGEgc2hvcnQgdGltZVxuICAgICAgICAgICAgaWYgKHBvaW50ID09PSBub2RlLnByZXYucG9pbnQpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wcmV2O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludCA9PT0gbm9kZS5uZXh0LnBvaW50KSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5MnRyaSBJbnZhbGlkIEFkdmFuY2luZ0Zyb250LmxvY2F0ZVBvaW50KCkgY2FsbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChweCA8IG54KSB7XG4gICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICAgICAgd2hpbGUgKG5vZGUgPSBub2RlLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChwb2ludCA9PT0gbm9kZS5wb2ludCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpIHtcbiAgICAgICAgICAgIGlmIChwb2ludCA9PT0gbm9kZS5wb2ludCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hfbm9kZV8gPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLUV4cG9ydHNcblxubW9kdWxlLmV4cG9ydHMgPSBBZHZhbmNpbmdGcm9udDtcbm1vZHVsZS5leHBvcnRzLk5vZGUgPSBOb2RlO1xuXG5cbn0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIFBvbHkyVHJpIENvcHlyaWdodCAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cbiAqXG4gKiBwb2x5MnRyaS5qcyAoSmF2YVNjcmlwdCBwb3J0KSAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yM21pL3BvbHkydHJpLmpzXG4gKlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgMy1jbGF1c2UgQlNEIExpY2Vuc2UsIHNlZSBMSUNFTlNFLnR4dFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKlxuICogRnVuY3Rpb24gYWRkZWQgaW4gdGhlIEphdmFTY3JpcHQgdmVyc2lvbiAod2FzIG5vdCBwcmVzZW50IGluIHRoZSBjKysgdmVyc2lvbilcbiAqL1xuXG4vKipcbiAqIGFzc2VydCBhbmQgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmRpdGlvbiAgIHRoZSBjb25kaXRpb24gd2hpY2ggaXMgYXNzZXJ0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlICAgICAgdGhlIG1lc3NhZ2Ugd2hpY2ggaXMgZGlzcGxheSBpcyBjb25kaXRpb24gaXMgZmFsc3lcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwiQXNzZXJ0IEZhaWxlZFwiKTtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGFzc2VydDtcblxuXG5cbn0se31dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIFBvbHkyVHJpIENvcHlyaWdodCAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cbiAqIFxuICogcG9seTJ0cmkuanMgKEphdmFTY3JpcHQgcG9ydCkgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcjNtaS9wb2x5MnRyaS5qc1xuICogXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgMy1jbGF1c2UgQlNEIExpY2Vuc2UsIHNlZSBMSUNFTlNFLnR4dFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qXG4gKiBOb3RlXG4gKiA9PT09XG4gKiB0aGUgc3RydWN0dXJlIG9mIHRoaXMgSmF2YVNjcmlwdCB2ZXJzaW9uIG9mIHBvbHkydHJpIGludGVudGlvbmFsbHkgZm9sbG93c1xuICogYXMgY2xvc2VseSBhcyBwb3NzaWJsZSB0aGUgc3RydWN0dXJlIG9mIHRoZSByZWZlcmVuY2UgQysrIHZlcnNpb24sIHRvIG1ha2UgaXQgXG4gKiBlYXNpZXIgdG8ga2VlcCB0aGUgMiB2ZXJzaW9ucyBpbiBzeW5jLlxuICovXG5cbnZhciB4eSA9IF9kZXJlcV8oJy4veHknKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tUG9pbnRcbi8qKlxuICogQ29uc3RydWN0IGEgcG9pbnRcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBwb2ludCA9IG5ldyBwb2x5MnRyaS5Qb2ludCgxNTAsIDE1MCk7XG4gKiBAcHVibGljXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqIEBwYXJhbSB7bnVtYmVyPX0geCAgICBjb29yZGluYXRlICgwIGlmIHVuZGVmaW5lZClcbiAqIEBwYXJhbSB7bnVtYmVyPX0geSAgICBjb29yZGluYXRlICgwIGlmIHVuZGVmaW5lZClcbiAqL1xudmFyIFBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIHRoaXMueCA9ICt4IHx8IDA7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgdGhpcy55ID0gK3kgfHwgMDtcblxuICAgIC8vIEFsbCBleHRyYSBmaWVsZHMgYWRkZWQgdG8gUG9pbnQgYXJlIHByZWZpeGVkIHdpdGggX3AydF9cbiAgICAvLyB0byBhdm9pZCBjb2xsaXNpb25zIGlmIGN1c3RvbSBQb2ludCBjbGFzcyBpcyB1c2VkLlxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkZ2VzIHRoaXMgcG9pbnQgY29uc3RpdHV0ZXMgYW4gdXBwZXIgZW5kaW5nIHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPEVkZ2U+fVxuICAgICAqL1xuICAgIHRoaXMuX3AydF9lZGdlX2xpc3QgPSBudWxsO1xufTtcblxuLyoqXG4gKiBGb3IgcHJldHR5IHByaW50aW5nXG4gKiBAZXhhbXBsZVxuICogICAgICBcInA9XCIgKyBuZXcgcG9seTJ0cmkuUG9pbnQoNSw0MilcbiAqICAgICAgLy8g4oaSIFwicD0oNTs0MilcIlxuICogQHJldHVybnMge3N0cmluZ30gPGNvZGU+XCIoeDt5KVwiPC9jb2RlPlxuICovXG5Qb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geHkudG9TdHJpbmdCYXNlKHRoaXMpO1xufTtcblxuLyoqXG4gKiBKU09OIG91dHB1dCwgb25seSBjb29yZGluYXRlc1xuICogQGV4YW1wbGVcbiAqICAgICAgSlNPTi5zdHJpbmdpZnkobmV3IHBvbHkydHJpLlBvaW50KDEsMikpXG4gKiAgICAgIC8vIOKGkiAne1wieFwiOjEsXCJ5XCI6Mn0nXG4gKi9cblBvaW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geyB4OiB0aGlzLngsIHk6IHRoaXMueSB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIFBvaW50IG9iamVjdC5cbiAqIEByZXR1cm4ge1BvaW50fSBuZXcgY2xvbmVkIHBvaW50XG4gKi9cblBvaW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhpcyBQb2ludCBpbnN0YW5jZSB0byB0aGUgb3JpZ28uIDxjb2RlPigwOyAwKTwvY29kZT5cbiAqIEByZXR1cm4ge1BvaW50fSB0aGlzIChmb3IgY2hhaW5pbmcpXG4gKi9cblBvaW50LnByb3RvdHlwZS5zZXRfemVybyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMueCA9IDAuMDtcbiAgICB0aGlzLnkgPSAwLjA7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoaXMgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0geCAgIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgY29vcmRpbmF0ZVxuICogQHJldHVybiB7UG9pbnR9IHRoaXMgKGZvciBjaGFpbmluZylcbiAqL1xuUG9pbnQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLnggPSAreCB8fCAwO1xuICAgIHRoaXMueSA9ICt5IHx8IDA7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBOZWdhdGUgdGhpcyBQb2ludCBpbnN0YW5jZS4gKGNvbXBvbmVudC13aXNlKVxuICogQHJldHVybiB7UG9pbnR9IHRoaXMgKGZvciBjaGFpbmluZylcbiAqL1xuUG9pbnQucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgdGhpcy55ID0gLXRoaXMueTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG4vKipcbiAqIEFkZCBhbm90aGVyIFBvaW50IG9iamVjdCB0byB0aGlzIGluc3RhbmNlLiAoY29tcG9uZW50LXdpc2UpXG4gKiBAcGFyYW0geyFQb2ludH0gbiAtIFBvaW50IG9iamVjdC5cbiAqIEByZXR1cm4ge1BvaW50fSB0aGlzIChmb3IgY2hhaW5pbmcpXG4gKi9cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihuKSB7XG4gICAgdGhpcy54ICs9IG4ueDtcbiAgICB0aGlzLnkgKz0gbi55O1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cbi8qKlxuICogU3VidHJhY3QgdGhpcyBQb2ludCBpbnN0YW5jZSB3aXRoIGFub3RoZXIgcG9pbnQgZ2l2ZW4uIChjb21wb25lbnQtd2lzZSlcbiAqIEBwYXJhbSB7IVBvaW50fSBuIC0gUG9pbnQgb2JqZWN0LlxuICogQHJldHVybiB7UG9pbnR9IHRoaXMgKGZvciBjaGFpbmluZylcbiAqL1xuUG9pbnQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLnggLT0gbi54O1xuICAgIHRoaXMueSAtPSBuLnk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSB0aGlzIFBvaW50IGluc3RhbmNlIGJ5IGEgc2NhbGFyLiAoY29tcG9uZW50LXdpc2UpXG4gKiBAcGFyYW0ge251bWJlcn0gcyAgIHNjYWxhci5cbiAqIEByZXR1cm4ge1BvaW50fSB0aGlzIChmb3IgY2hhaW5pbmcpXG4gKi9cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihzKSB7XG4gICAgdGhpcy54ICo9IHM7XG4gICAgdGhpcy55ICo9IHM7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRpc3RhbmNlIG9mIHRoaXMgUG9pbnQgaW5zdGFuY2UgZnJvbSB0aGUgb3JpZ28uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGRpc3RhbmNlXG4gKi9cblBvaW50LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGlzIFBvaW50IGluc3RhbmNlIChhcyBhIHZlY3RvcikuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBvcmlnaW5hbCBkaXN0YW5jZSBvZiB0aGlzIGluc3RhbmNlIGZyb20gdGhlIG9yaWdvLlxuICovXG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdGhpcy54IC89IGxlbjtcbiAgICB0aGlzLnkgLz0gbGVuO1xuICAgIHJldHVybiBsZW47XG59O1xuXG4vKipcbiAqIFRlc3QgdGhpcyBQb2ludCBvYmplY3Qgd2l0aCBhbm90aGVyIGZvciBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7IVhZfSBwIC0gYW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBzYW1lIHggYW5kIHkgY29vcmRpbmF0ZXMsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cblBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9PT0gcC54ICYmIHRoaXMueSA9PT0gcC55O1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVBvaW50IChcInN0YXRpY1wiIG1ldGhvZHMpXG5cbi8qKlxuICogTmVnYXRlIGEgcG9pbnQgY29tcG9uZW50LXdpc2UgYW5kIHJldHVybiB0aGUgcmVzdWx0IGFzIGEgbmV3IFBvaW50IG9iamVjdC5cbiAqIEBwYXJhbSB7IVhZfSBwIC0gYW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtQb2ludH0gdGhlIHJlc3VsdGluZyBQb2ludCBvYmplY3QuXG4gKi9cblBvaW50Lm5lZ2F0ZSA9IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KC1wLngsIC1wLnkpO1xufTtcblxuLyoqXG4gKiBBZGQgdHdvIHBvaW50cyBjb21wb25lbnQtd2lzZSBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgUG9pbnQgb2JqZWN0LlxuICogQHBhcmFtIHshWFl9IGEgLSBhbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBiIC0gYW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtQb2ludH0gdGhlIHJlc3VsdGluZyBQb2ludCBvYmplY3QuXG4gKi9cblBvaW50LmFkZCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KGEueCArIGIueCwgYS55ICsgYi55KTtcbn07XG5cbi8qKlxuICogU3VidHJhY3QgdHdvIHBvaW50cyBjb21wb25lbnQtd2lzZSBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgUG9pbnQgb2JqZWN0LlxuICogQHBhcmFtIHshWFl9IGEgLSBhbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBiIC0gYW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtQb2ludH0gdGhlIHJlc3VsdGluZyBQb2ludCBvYmplY3QuXG4gKi9cblBvaW50LnN1YiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KGEueCAtIGIueCwgYS55IC0gYi55KTtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgYSBwb2ludCBieSBhIHNjYWxhciBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgUG9pbnQgb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHMgLSB0aGUgc2NhbGFyXG4gKiBAcGFyYW0geyFYWX0gcCAtIGFueSBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7UG9pbnR9IHRoZSByZXN1bHRpbmcgUG9pbnQgb2JqZWN0LlxuICovXG5Qb2ludC5tdWwgPSBmdW5jdGlvbihzLCBwKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludChzICogcC54LCBzICogcC55KTtcbn07XG5cbi8qKlxuICogUGVyZm9ybSB0aGUgY3Jvc3MgcHJvZHVjdCBvbiBlaXRoZXIgdHdvIHBvaW50cyAodGhpcyBwcm9kdWNlcyBhIHNjYWxhcilcbiAqIG9yIGEgcG9pbnQgYW5kIGEgc2NhbGFyICh0aGlzIHByb2R1Y2VzIGEgcG9pbnQpLlxuICogVGhpcyBmdW5jdGlvbiByZXF1aXJlcyB0d28gcGFyYW1ldGVycywgZWl0aGVyIG1heSBiZSBhIFBvaW50IG9iamVjdCBvciBhXG4gKiBudW1iZXIuXG4gKiBAcGFyYW0gIHtYWXxudW1iZXJ9IGEgLSBQb2ludCBvYmplY3Qgb3Igc2NhbGFyLlxuICogQHBhcmFtICB7WFl8bnVtYmVyfSBiIC0gUG9pbnQgb2JqZWN0IG9yIHNjYWxhci5cbiAqIEByZXR1cm4ge1BvaW50fG51bWJlcn0gYSBQb2ludCBvYmplY3Qgb3IgYSBudW1iZXIsIGRlcGVuZGluZyBvbiB0aGUgcGFyYW1ldGVycy5cbiAqL1xuUG9pbnQuY3Jvc3MgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKHR5cGVvZihhKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKHR5cGVvZihiKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBhICogYjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoLWEgKiBiLnksIGEgKiBiLngpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZihiKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoYiAqIGEueSwgLWIgKiBhLngpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGEueCAqIGIueSAtIGEueSAqIGIueDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIlBvaW50LUxpa2VcIlxuLypcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG9wZXJhdGUgb24gXCJQb2ludFwiIG9yIGFueSBcIlBvaW50IGxpa2VcIiBvYmplY3QgXG4gKiB3aXRoIHt4LHl9IChkdWNrIHR5cGluZykuXG4gKi9cblxuUG9pbnQudG9TdHJpbmcgPSB4eS50b1N0cmluZztcblBvaW50LmNvbXBhcmUgPSB4eS5jb21wYXJlO1xuUG9pbnQuY21wID0geHkuY29tcGFyZTsgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuUG9pbnQuZXF1YWxzID0geHkuZXF1YWxzO1xuXG4vKipcbiAqIFBlZm9ybSB0aGUgZG90IHByb2R1Y3Qgb24gdHdvIHZlY3RvcnMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyFYWX0gYSAtIGFueSBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IGIgLSBhbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGRvdCBwcm9kdWN0XG4gKi9cblBvaW50LmRvdCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYS54ICogYi54ICsgYS55ICogYi55O1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1FeHBvcnRzIChwdWJsaWMgQVBJKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG59LHtcIi4veHlcIjoxMX1dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIFBvbHkyVHJpIENvcHlyaWdodCAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cbiAqIFxuICogcG9seTJ0cmkuanMgKEphdmFTY3JpcHQgcG9ydCkgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcjNtaS9wb2x5MnRyaS5qc1xuICogXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgMy1jbGF1c2UgQlNEIExpY2Vuc2UsIHNlZSBMSUNFTlNFLnR4dFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKlxuICogQ2xhc3MgYWRkZWQgaW4gdGhlIEphdmFTY3JpcHQgdmVyc2lvbiAod2FzIG5vdCBwcmVzZW50IGluIHRoZSBjKysgdmVyc2lvbilcbiAqL1xuXG52YXIgeHkgPSBfZGVyZXFfKCcuL3h5Jyk7XG5cbi8qKlxuICogQ3VzdG9tIGV4Y2VwdGlvbiBjbGFzcyB0byBpbmRpY2F0ZSBpbnZhbGlkIFBvaW50IHZhbHVlc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKiBAZXh0ZW5kcyBFcnJvclxuICogQHN0cnVjdFxuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIC0gZXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtBcnJheS48WFk+PX0gcG9pbnRzIC0gaW52YWxpZCBwb2ludHNcbiAqL1xudmFyIFBvaW50RXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlLCBwb2ludHMpIHtcbiAgICB0aGlzLm5hbWUgPSBcIlBvaW50RXJyb3JcIjtcbiAgICAvKipcbiAgICAgKiBJbnZhbGlkIHBvaW50c1xuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdHlwZSB7QXJyYXkuPFhZPn1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cyA9IHBvaW50cyB8fCBbXTtcbiAgICAvKipcbiAgICAgKiBFcnJvciBtZXNzYWdlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIkludmFsaWQgUG9pbnRzIVwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSArPSBcIiBcIiArIHh5LnRvU3RyaW5nKHBvaW50c1tpXSk7XG4gICAgfVxufTtcblBvaW50RXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5Qb2ludEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50RXJyb3I7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludEVycm9yO1xuXG59LHtcIi4veHlcIjoxMX1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLypcbiAqIFBvbHkyVHJpIENvcHlyaWdodCAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cbiAqIFxuICogcG9seTJ0cmkuanMgKEphdmFTY3JpcHQgcG9ydCkgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcjNtaS9wb2x5MnRyaS5qc1xuICpcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFB1YmxpYyBBUEkgZm9yIHBvbHkydHJpLmpzXG4gKiBAbW9kdWxlIHBvbHkydHJpXG4gKi9cblxuXG4vKipcbiAqIElmIHlvdSBhcmUgbm90IHVzaW5nIGEgbW9kdWxlIHN5c3RlbSAoZS5nLiBDb21tb25KUywgUmVxdWlyZUpTKSwgeW91IGNhbiBhY2Nlc3MgdGhpcyBsaWJyYXJ5XG4gKiBhcyBhIGdsb2JhbCB2YXJpYWJsZSA8Y29kZT5wb2x5MnRyaTwvY29kZT4gaS5lLiA8Y29kZT53aW5kb3cucG9seTJ0cmk8L2NvZGU+IGluIGEgYnJvd3Nlci5cbiAqIEBuYW1lIHBvbHkydHJpXG4gKiBAZ2xvYmFsXG4gKiBAcHVibGljXG4gKiBAdHlwZSB7bW9kdWxlOnBvbHkydHJpfVxuICovXG52YXIgcHJldmlvdXNQb2x5MnRyaSA9IGdsb2JhbC5wb2x5MnRyaTtcbi8qKlxuICogRm9yIEJyb3dzZXIgKyAmbHQ7c2NyaXB0Jmd0OyA6XG4gKiByZXZlcnRzIHRoZSB7QGxpbmtjb2RlIHBvbHkydHJpfSBnbG9iYWwgb2JqZWN0IHRvIGl0cyBwcmV2aW91cyB2YWx1ZSxcbiAqIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBjYWxsZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAgICAgICAgICB2YXIgcCA9IHBvbHkydHJpLm5vQ29uZmxpY3QoKTtcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm4ge21vZHVsZTpwb2x5MnRyaX0gaW5zdGFuY2UgY2FsbGVkXG4gKi9cbi8vICh0aGlzIGZlYXR1cmUgaXMgbm90IGF1dG9tYXRpY2FsbHkgcHJvdmlkZWQgYnkgYnJvd3NlcmlmeSkuXG5leHBvcnRzLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICBnbG9iYWwucG9seTJ0cmkgPSBwcmV2aW91c1BvbHkydHJpO1xuICAgIHJldHVybiBleHBvcnRzO1xufTtcblxuLyoqXG4gKiBwb2x5MnRyaSBsaWJyYXJ5IHZlcnNpb25cbiAqIEBwdWJsaWNcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5leHBvcnRzLlZFUlNJT04gPSBfZGVyZXFfKCcuLi9kaXN0L3ZlcnNpb24uanNvbicpLnZlcnNpb247XG5cbi8qKlxuICogRXhwb3J0cyB0aGUge0BsaW5rY29kZSBQb2ludEVycm9yfSBjbGFzcy5cbiAqIEBwdWJsaWNcbiAqIEB0eXBlZGVmIHtQb2ludEVycm9yfSBtb2R1bGU6cG9seTJ0cmkuUG9pbnRFcnJvclxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMuUG9pbnRFcnJvciA9IF9kZXJlcV8oJy4vcG9pbnRlcnJvcicpO1xuLyoqXG4gKiBFeHBvcnRzIHRoZSB7QGxpbmtjb2RlIFBvaW50fSBjbGFzcy5cbiAqIEBwdWJsaWNcbiAqIEB0eXBlZGVmIHtQb2ludH0gbW9kdWxlOnBvbHkydHJpLlBvaW50XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0cy5Qb2ludCA9IF9kZXJlcV8oJy4vcG9pbnQnKTtcbi8qKlxuICogRXhwb3J0cyB0aGUge0BsaW5rY29kZSBUcmlhbmdsZX0gY2xhc3MuXG4gKiBAcHVibGljXG4gKiBAdHlwZWRlZiB7VHJpYW5nbGV9IG1vZHVsZTpwb2x5MnRyaS5UcmlhbmdsZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMuVHJpYW5nbGUgPSBfZGVyZXFfKCcuL3RyaWFuZ2xlJyk7XG4vKipcbiAqIEV4cG9ydHMgdGhlIHtAbGlua2NvZGUgU3dlZXBDb250ZXh0fSBjbGFzcy5cbiAqIEBwdWJsaWNcbiAqIEB0eXBlZGVmIHtTd2VlcENvbnRleHR9IG1vZHVsZTpwb2x5MnRyaS5Td2VlcENvbnRleHRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnRzLlN3ZWVwQ29udGV4dCA9IF9kZXJlcV8oJy4vc3dlZXBjb250ZXh0Jyk7XG5cblxuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eVxudmFyIHN3ZWVwID0gX2RlcmVxXygnLi9zd2VlcCcpO1xuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmtjb2RlIFN3ZWVwQ29udGV4dCN0cmlhbmd1bGF0ZX0gaW5zdGVhZFxuICovXG5leHBvcnRzLnRyaWFuZ3VsYXRlID0gc3dlZXAudHJpYW5ndWxhdGU7XG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmtjb2RlIFN3ZWVwQ29udGV4dCN0cmlhbmd1bGF0ZX0gaW5zdGVhZFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gVHJpYW5ndWxhdGUgLSB1c2Uge0BsaW5rY29kZSBTd2VlcENvbnRleHQjdHJpYW5ndWxhdGV9IGluc3RlYWRcbiAqL1xuZXhwb3J0cy5zd2VlcCA9IHtUcmlhbmd1bGF0ZTogc3dlZXAudHJpYW5ndWxhdGV9O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuLi9kaXN0L3ZlcnNpb24uanNvblwiOjEsXCIuL3BvaW50XCI6NCxcIi4vcG9pbnRlcnJvclwiOjUsXCIuL3N3ZWVwXCI6NyxcIi4vc3dlZXBjb250ZXh0XCI6OCxcIi4vdHJpYW5nbGVcIjo5fV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogUG9seTJUcmkgQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xuICogXG4gKiBwb2x5MnRyaS5qcyAoSmF2YVNjcmlwdCBwb3J0KSAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yM21pL3BvbHkydHJpLmpzXG4gKiBcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSAzLWNsYXVzZSBCU0QgTGljZW5zZSwgc2VlIExJQ0VOU0UudHh0XG4gKi9cblxuLyoganNoaW50IGxhdGVkZWY6bm9mdW5jLCBtYXhjb21wbGV4aXR5OjkgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVGhpcyAnU3dlZXAnIG1vZHVsZSBpcyBwcmVzZW50IGluIG9yZGVyIHRvIGtlZXAgdGhpcyBKYXZhU2NyaXB0IHZlcnNpb25cbiAqIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIHRoZSByZWZlcmVuY2UgQysrIHZlcnNpb24sIGV2ZW4gdGhvdWdoIGFsbW9zdCBhbGxcbiAqIGZ1bmN0aW9ucyBjb3VsZCBiZSBkZWNsYXJlZCBhcyBtZXRob2RzIG9uIHRoZSB7QGxpbmtjb2RlIG1vZHVsZTpzd2VlcGNvbnRleHR+U3dlZXBDb250ZXh0fSBvYmplY3QuXG4gKiBAbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qXG4gKiBOb3RlXG4gKiA9PT09XG4gKiB0aGUgc3RydWN0dXJlIG9mIHRoaXMgSmF2YVNjcmlwdCB2ZXJzaW9uIG9mIHBvbHkydHJpIGludGVudGlvbmFsbHkgZm9sbG93c1xuICogYXMgY2xvc2VseSBhcyBwb3NzaWJsZSB0aGUgc3RydWN0dXJlIG9mIHRoZSByZWZlcmVuY2UgQysrIHZlcnNpb24sIHRvIG1ha2UgaXQgXG4gKiBlYXNpZXIgdG8ga2VlcCB0aGUgMiB2ZXJzaW9ucyBpbiBzeW5jLlxuICovXG5cbnZhciBhc3NlcnQgPSBfZGVyZXFfKCcuL2Fzc2VydCcpO1xudmFyIFBvaW50RXJyb3IgPSBfZGVyZXFfKCcuL3BvaW50ZXJyb3InKTtcbnZhciBUcmlhbmdsZSA9IF9kZXJlcV8oJy4vdHJpYW5nbGUnKTtcbnZhciBOb2RlID0gX2RlcmVxXygnLi9hZHZhbmNpbmdmcm9udCcpLk5vZGU7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tdXRpbHNcblxudmFyIHV0aWxzID0gX2RlcmVxXygnLi91dGlscycpO1xuXG4vKiogQGNvbnN0ICovXG52YXIgRVBTSUxPTiA9IHV0aWxzLkVQU0lMT047XG5cbi8qKiBAY29uc3QgKi9cbnZhciBPcmllbnRhdGlvbiA9IHV0aWxzLk9yaWVudGF0aW9uO1xuLyoqIEBjb25zdCAqL1xudmFyIG9yaWVudDJkID0gdXRpbHMub3JpZW50MmQ7XG4vKiogQGNvbnN0ICovXG52YXIgaW5TY2FuQXJlYSA9IHV0aWxzLmluU2NhbkFyZWE7XG4vKiogQGNvbnN0ICovXG52YXIgaXNBbmdsZU9idHVzZSA9IHV0aWxzLmlzQW5nbGVPYnR1c2U7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tU3dlZXBcblxuLyoqXG4gKiBUcmlhbmd1bGF0ZSB0aGUgcG9seWdvbiB3aXRoIGhvbGVzIGFuZCBTdGVpbmVyIHBvaW50cy5cbiAqIERvIHRoaXMgQUZURVIgeW91J3ZlIGFkZGVkIHRoZSBwb2x5bGluZSwgaG9sZXMsIGFuZCBTdGVpbmVyIHBvaW50c1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7IVN3ZWVwQ29udGV4dH0gdGN4IC0gU3dlZXBDb250ZXh0IG9iamVjdFxuICovXG5mdW5jdGlvbiB0cmlhbmd1bGF0ZSh0Y3gpIHtcbiAgICB0Y3guaW5pdFRyaWFuZ3VsYXRpb24oKTtcbiAgICB0Y3guY3JlYXRlQWR2YW5jaW5nRnJvbnQoKTtcbiAgICAvLyBTd2VlcCBwb2ludHM7IGJ1aWxkIG1lc2hcbiAgICBzd2VlcFBvaW50cyh0Y3gpO1xuICAgIC8vIENsZWFuIHVwXG4gICAgZmluYWxpemF0aW9uUG9seWdvbih0Y3gpO1xufVxuXG4vKipcbiAqIFN0YXJ0IHN3ZWVwaW5nIHRoZSBZLXNvcnRlZCBwb2ludCBzZXQgZnJvbSBib3R0b20gdG8gdG9wXG4gKiBAcGFyYW0geyFTd2VlcENvbnRleHR9IHRjeCAtIFN3ZWVwQ29udGV4dCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gc3dlZXBQb2ludHModGN4KSB7XG4gICAgdmFyIGksIGxlbiA9IHRjeC5wb2ludENvdW50KCk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHRjeC5nZXRQb2ludChpKTtcbiAgICAgICAgdmFyIG5vZGUgPSBwb2ludEV2ZW50KHRjeCwgcG9pbnQpO1xuICAgICAgICB2YXIgZWRnZXMgPSBwb2ludC5fcDJ0X2VkZ2VfbGlzdDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGVkZ2VzICYmIGogPCBlZGdlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgZWRnZUV2ZW50QnlFZGdlKHRjeCwgZWRnZXNbal0sIG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7IVN3ZWVwQ29udGV4dH0gdGN4IC0gU3dlZXBDb250ZXh0IG9iamVjdFxuICovXG5mdW5jdGlvbiBmaW5hbGl6YXRpb25Qb2x5Z29uKHRjeCkge1xuICAgIC8vIEdldCBhbiBJbnRlcm5hbCB0cmlhbmdsZSB0byBzdGFydCB3aXRoXG4gICAgdmFyIHQgPSB0Y3guZnJvbnQoKS5oZWFkKCkubmV4dC50cmlhbmdsZTtcbiAgICB2YXIgcCA9IHRjeC5mcm9udCgpLmhlYWQoKS5uZXh0LnBvaW50O1xuICAgIHdoaWxlICghdC5nZXRDb25zdHJhaW5lZEVkZ2VDVyhwKSkge1xuICAgICAgICB0ID0gdC5uZWlnaGJvckNDVyhwKTtcbiAgICB9XG5cbiAgICAvLyBDb2xsZWN0IGludGVyaW9yIHRyaWFuZ2xlcyBjb25zdHJhaW5lZCBieSBlZGdlc1xuICAgIHRjeC5tZXNoQ2xlYW4odCk7XG59XG5cbi8qKlxuICogRmluZCBjbG9zZXMgbm9kZSB0byB0aGUgbGVmdCBvZiB0aGUgbmV3IHBvaW50IGFuZFxuICogY3JlYXRlIGEgbmV3IHRyaWFuZ2xlLiBJZiBuZWVkZWQgbmV3IGhvbGVzIGFuZCBiYXNpbnNcbiAqIHdpbGwgYmUgZmlsbGVkIHRvLlxuICogQHBhcmFtIHshU3dlZXBDb250ZXh0fSB0Y3ggLSBTd2VlcENvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0geyFYWX0gcG9pbnQgICBQb2ludFxuICovXG5mdW5jdGlvbiBwb2ludEV2ZW50KHRjeCwgcG9pbnQpIHtcbiAgICB2YXIgbm9kZSA9IHRjeC5sb2NhdGVOb2RlKHBvaW50KTtcbiAgICB2YXIgbmV3X25vZGUgPSBuZXdGcm9udFRyaWFuZ2xlKHRjeCwgcG9pbnQsIG5vZGUpO1xuXG4gICAgLy8gT25seSBuZWVkIHRvIGNoZWNrICtlcHNpbG9uIHNpbmNlIHBvaW50IG5ldmVyIGhhdmUgc21hbGxlclxuICAgIC8vIHggdmFsdWUgdGhhbiBub2RlIGR1ZSB0byBob3cgd2UgZmV0Y2ggbm9kZXMgZnJvbSB0aGUgZnJvbnRcbiAgICBpZiAocG9pbnQueCA8PSBub2RlLnBvaW50LnggKyAoRVBTSUxPTikpIHtcbiAgICAgICAgZmlsbCh0Y3gsIG5vZGUpO1xuICAgIH1cblxuICAgIC8vdGN4LkFkZE5vZGUobmV3X25vZGUpO1xuXG4gICAgZmlsbEFkdmFuY2luZ0Zyb250KHRjeCwgbmV3X25vZGUpO1xuICAgIHJldHVybiBuZXdfbm9kZTtcbn1cblxuZnVuY3Rpb24gZWRnZUV2ZW50QnlFZGdlKHRjeCwgZWRnZSwgbm9kZSkge1xuICAgIHRjeC5lZGdlX2V2ZW50LmNvbnN0cmFpbmVkX2VkZ2UgPSBlZGdlO1xuICAgIHRjeC5lZGdlX2V2ZW50LnJpZ2h0ID0gKGVkZ2UucC54ID4gZWRnZS5xLngpO1xuXG4gICAgaWYgKGlzRWRnZVNpZGVPZlRyaWFuZ2xlKG5vZGUudHJpYW5nbGUsIGVkZ2UucCwgZWRnZS5xKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRm9yIG5vdyB3ZSB3aWxsIGRvIGFsbCBuZWVkZWQgZmlsbGluZ1xuICAgIC8vIFRPRE86IGludGVncmF0ZSB3aXRoIGZsaXAgcHJvY2VzcyBtaWdodCBnaXZlIHNvbWUgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgLy8gICAgICAgYnV0IGZvciBub3cgdGhpcyBhdm9pZCB0aGUgaXNzdWUgd2l0aCBjYXNlcyB0aGF0IG5lZWRzIGJvdGggZmxpcHMgYW5kIGZpbGxzXG4gICAgZmlsbEVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgIGVkZ2VFdmVudEJ5UG9pbnRzKHRjeCwgZWRnZS5wLCBlZGdlLnEsIG5vZGUudHJpYW5nbGUsIGVkZ2UucSk7XG59XG5cbmZ1bmN0aW9uIGVkZ2VFdmVudEJ5UG9pbnRzKHRjeCwgZXAsIGVxLCB0cmlhbmdsZSwgcG9pbnQpIHtcbiAgICBpZiAoaXNFZGdlU2lkZU9mVHJpYW5nbGUodHJpYW5nbGUsIGVwLCBlcSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwMSA9IHRyaWFuZ2xlLnBvaW50Q0NXKHBvaW50KTtcbiAgICB2YXIgbzEgPSBvcmllbnQyZChlcSwgcDEsIGVwKTtcbiAgICBpZiAobzEgPT09IE9yaWVudGF0aW9uLkNPTExJTkVBUikge1xuICAgICAgICAvLyBUT0RPIGludGVncmF0ZSBoZXJlIGNoYW5nZXMgZnJvbSBDKysgdmVyc2lvblxuICAgICAgICAvLyAoQysrIHJlcG8gcmV2aXNpb24gMDk4ODBhODY5MDk1IGRhdGVkIE1hcmNoIDgsIDIwMTEpXG4gICAgICAgIHRocm93IG5ldyBQb2ludEVycm9yKCdwb2x5MnRyaSBFZGdlRXZlbnQ6IENvbGxpbmVhciBub3Qgc3VwcG9ydGVkIScsIFtlcSwgcDEsIGVwXSk7XG4gICAgfVxuXG4gICAgdmFyIHAyID0gdHJpYW5nbGUucG9pbnRDVyhwb2ludCk7XG4gICAgdmFyIG8yID0gb3JpZW50MmQoZXEsIHAyLCBlcCk7XG4gICAgaWYgKG8yID09PSBPcmllbnRhdGlvbi5DT0xMSU5FQVIpIHtcbiAgICAgICAgLy8gVE9ETyBpbnRlZ3JhdGUgaGVyZSBjaGFuZ2VzIGZyb20gQysrIHZlcnNpb25cbiAgICAgICAgLy8gKEMrKyByZXBvIHJldmlzaW9uIDA5ODgwYTg2OTA5NSBkYXRlZCBNYXJjaCA4LCAyMDExKVxuICAgICAgICB0aHJvdyBuZXcgUG9pbnRFcnJvcigncG9seTJ0cmkgRWRnZUV2ZW50OiBDb2xsaW5lYXIgbm90IHN1cHBvcnRlZCEnLCBbZXEsIHAyLCBlcF0pO1xuICAgIH1cblxuICAgIGlmIChvMSA9PT0gbzIpIHtcbiAgICAgICAgLy8gTmVlZCB0byBkZWNpZGUgaWYgd2UgYXJlIHJvdGF0aW5nIENXIG9yIENDVyB0byBnZXQgdG8gYSB0cmlhbmdsZVxuICAgICAgICAvLyB0aGF0IHdpbGwgY3Jvc3MgZWRnZVxuICAgICAgICBpZiAobzEgPT09IE9yaWVudGF0aW9uLkNXKSB7XG4gICAgICAgICAgICB0cmlhbmdsZSA9IHRyaWFuZ2xlLm5laWdoYm9yQ0NXKHBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyaWFuZ2xlID0gdHJpYW5nbGUubmVpZ2hib3JDVyhwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWRnZUV2ZW50QnlQb2ludHModGN4LCBlcCwgZXEsIHRyaWFuZ2xlLCBwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyB0cmlhbmdsZSBjcm9zc2VzIGNvbnN0cmFpbnQgc28gbGV0cyBmbGlwcGluIHN0YXJ0IVxuICAgICAgICBmbGlwRWRnZUV2ZW50KHRjeCwgZXAsIGVxLCB0cmlhbmdsZSwgcG9pbnQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNFZGdlU2lkZU9mVHJpYW5nbGUodHJpYW5nbGUsIGVwLCBlcSkge1xuICAgIHZhciBpbmRleCA9IHRyaWFuZ2xlLmVkZ2VJbmRleChlcCwgZXEpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdHJpYW5nbGUubWFya0NvbnN0cmFpbmVkRWRnZUJ5SW5kZXgoaW5kZXgpO1xuICAgICAgICB2YXIgdCA9IHRyaWFuZ2xlLmdldE5laWdoYm9yKGluZGV4KTtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIHQubWFya0NvbnN0cmFpbmVkRWRnZUJ5UG9pbnRzKGVwLCBlcSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZyb250IHRyaWFuZ2xlIGFuZCBsZWdhbGl6ZSBpdFxuICogQHBhcmFtIHshU3dlZXBDb250ZXh0fSB0Y3ggLSBTd2VlcENvbnRleHQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG5ld0Zyb250VHJpYW5nbGUodGN4LCBwb2ludCwgbm9kZSkge1xuICAgIHZhciB0cmlhbmdsZSA9IG5ldyBUcmlhbmdsZShwb2ludCwgbm9kZS5wb2ludCwgbm9kZS5uZXh0LnBvaW50KTtcblxuICAgIHRyaWFuZ2xlLm1hcmtOZWlnaGJvcihub2RlLnRyaWFuZ2xlKTtcbiAgICB0Y3guYWRkVG9NYXAodHJpYW5nbGUpO1xuXG4gICAgdmFyIG5ld19ub2RlID0gbmV3IE5vZGUocG9pbnQpO1xuICAgIG5ld19ub2RlLm5leHQgPSBub2RlLm5leHQ7XG4gICAgbmV3X25vZGUucHJldiA9IG5vZGU7XG4gICAgbm9kZS5uZXh0LnByZXYgPSBuZXdfbm9kZTtcbiAgICBub2RlLm5leHQgPSBuZXdfbm9kZTtcblxuICAgIGlmICghbGVnYWxpemUodGN4LCB0cmlhbmdsZSkpIHtcbiAgICAgICAgdGN4Lm1hcFRyaWFuZ2xlVG9Ob2Rlcyh0cmlhbmdsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld19ub2RlO1xufVxuXG4vKipcbiAqIEFkZHMgYSB0cmlhbmdsZSB0byB0aGUgYWR2YW5jaW5nIGZyb250IHRvIGZpbGwgYSBob2xlLlxuICogQHBhcmFtIHshU3dlZXBDb250ZXh0fSB0Y3ggLSBTd2VlcENvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0gbm9kZSAtIG1pZGRsZSBub2RlLCB0aGF0IGlzIHRoZSBib3R0b20gb2YgdGhlIGhvbGVcbiAqL1xuZnVuY3Rpb24gZmlsbCh0Y3gsIG5vZGUpIHtcbiAgICB2YXIgdHJpYW5nbGUgPSBuZXcgVHJpYW5nbGUobm9kZS5wcmV2LnBvaW50LCBub2RlLnBvaW50LCBub2RlLm5leHQucG9pbnQpO1xuXG4gICAgLy8gVE9ETzogc2hvdWxkIGNvcHkgdGhlIGNvbnN0cmFpbmVkX2VkZ2UgdmFsdWUgZnJvbSBuZWlnaGJvciB0cmlhbmdsZXNcbiAgICAvLyAgICAgICBmb3Igbm93IGNvbnN0cmFpbmVkX2VkZ2UgdmFsdWVzIGFyZSBjb3BpZWQgZHVyaW5nIHRoZSBsZWdhbGl6ZVxuICAgIHRyaWFuZ2xlLm1hcmtOZWlnaGJvcihub2RlLnByZXYudHJpYW5nbGUpO1xuICAgIHRyaWFuZ2xlLm1hcmtOZWlnaGJvcihub2RlLnRyaWFuZ2xlKTtcblxuICAgIHRjeC5hZGRUb01hcCh0cmlhbmdsZSk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIGFkdmFuY2luZyBmcm9udFxuICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O1xuXG5cbiAgICAvLyBJZiBpdCB3YXMgbGVnYWxpemVkIHRoZSB0cmlhbmdsZSBoYXMgYWxyZWFkeSBiZWVuIG1hcHBlZFxuICAgIGlmICghbGVnYWxpemUodGN4LCB0cmlhbmdsZSkpIHtcbiAgICAgICAgdGN4Lm1hcFRyaWFuZ2xlVG9Ob2Rlcyh0cmlhbmdsZSk7XG4gICAgfVxuXG4gICAgLy90Y3gucmVtb3ZlTm9kZShub2RlKTtcbn1cblxuLyoqXG4gKiBGaWxscyBob2xlcyBpbiB0aGUgQWR2YW5jaW5nIEZyb250XG4gKiBAcGFyYW0geyFTd2VlcENvbnRleHR9IHRjeCAtIFN3ZWVwQ29udGV4dCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZmlsbEFkdmFuY2luZ0Zyb250KHRjeCwgbikge1xuICAgIC8vIEZpbGwgcmlnaHQgaG9sZXNcbiAgICB2YXIgbm9kZSA9IG4ubmV4dDtcbiAgICB3aGlsZSAobm9kZS5uZXh0KSB7XG4gICAgICAgIC8vIFRPRE8gaW50ZWdyYXRlIGhlcmUgY2hhbmdlcyBmcm9tIEMrKyB2ZXJzaW9uXG4gICAgICAgIC8vIChDKysgcmVwbyByZXZpc2lvbiBhY2Y4MWYxZjE3NjQgZGF0ZWQgQXByaWwgNywgMjAxMilcbiAgICAgICAgaWYgKGlzQW5nbGVPYnR1c2Uobm9kZS5wb2ludCwgbm9kZS5uZXh0LnBvaW50LCBub2RlLnByZXYucG9pbnQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmaWxsKHRjeCwgbm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuXG4gICAgLy8gRmlsbCBsZWZ0IGhvbGVzXG4gICAgbm9kZSA9IG4ucHJldjtcbiAgICB3aGlsZSAobm9kZS5wcmV2KSB7XG4gICAgICAgIC8vIFRPRE8gaW50ZWdyYXRlIGhlcmUgY2hhbmdlcyBmcm9tIEMrKyB2ZXJzaW9uXG4gICAgICAgIC8vIChDKysgcmVwbyByZXZpc2lvbiBhY2Y4MWYxZjE3NjQgZGF0ZWQgQXByaWwgNywgMjAxMilcbiAgICAgICAgaWYgKGlzQW5nbGVPYnR1c2Uobm9kZS5wb2ludCwgbm9kZS5uZXh0LnBvaW50LCBub2RlLnByZXYucG9pbnQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmaWxsKHRjeCwgbm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXY7XG4gICAgfVxuXG4gICAgLy8gRmlsbCByaWdodCBiYXNpbnNcbiAgICBpZiAobi5uZXh0ICYmIG4ubmV4dC5uZXh0KSB7XG4gICAgICAgIGlmIChpc0Jhc2luQW5nbGVSaWdodChuKSkge1xuICAgICAgICAgICAgZmlsbEJhc2luKHRjeCwgbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogVGhlIGJhc2luIGFuZ2xlIGlzIGRlY2lkZWQgYWdhaW5zdCB0aGUgaG9yaXpvbnRhbCBsaW5lIFsxLDBdLlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGFuZ2xlIDwgMyrPgC80XG4gKi9cbmZ1bmN0aW9uIGlzQmFzaW5BbmdsZVJpZ2h0KG5vZGUpIHtcbiAgICB2YXIgYXggPSBub2RlLnBvaW50LnggLSBub2RlLm5leHQubmV4dC5wb2ludC54O1xuICAgIHZhciBheSA9IG5vZGUucG9pbnQueSAtIG5vZGUubmV4dC5uZXh0LnBvaW50Lnk7XG4gICAgYXNzZXJ0KGF5ID49IDAsIFwidW5vcmRlcmVkIHlcIik7XG4gICAgcmV0dXJuIChheCA+PSAwIHx8IE1hdGguYWJzKGF4KSA8IGF5KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdHJpYW5nbGUgd2FzIGxlZ2FsaXplZFxuICogQHBhcmFtIHshU3dlZXBDb250ZXh0fSB0Y3ggLSBTd2VlcENvbnRleHQgb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBsZWdhbGl6ZSh0Y3gsIHQpIHtcbiAgICAvLyBUbyBsZWdhbGl6ZSBhIHRyaWFuZ2xlIHdlIHN0YXJ0IGJ5IGZpbmRpbmcgaWYgYW55IG9mIHRoZSB0aHJlZSBlZGdlc1xuICAgIC8vIHZpb2xhdGUgdGhlIERlbGF1bmF5IGNvbmRpdGlvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgIGlmICh0LmRlbGF1bmF5X2VkZ2VbaV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdCA9IHQuZ2V0TmVpZ2hib3IoaSk7XG4gICAgICAgIGlmIChvdCkge1xuICAgICAgICAgICAgdmFyIHAgPSB0LmdldFBvaW50KGkpO1xuICAgICAgICAgICAgdmFyIG9wID0gb3Qub3Bwb3NpdGVQb2ludCh0LCBwKTtcbiAgICAgICAgICAgIHZhciBvaSA9IG90LmluZGV4KG9wKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIENvbnN0cmFpbmVkIEVkZ2Ugb3IgYSBEZWxhdW5heSBFZGdlKG9ubHkgZHVyaW5nIHJlY3Vyc2l2ZSBsZWdhbGl6YXRpb24pXG4gICAgICAgICAgICAvLyB0aGVuIHdlIHNob3VsZCBub3QgdHJ5IHRvIGxlZ2FsaXplXG4gICAgICAgICAgICBpZiAob3QuY29uc3RyYWluZWRfZWRnZVtvaV0gfHwgb3QuZGVsYXVuYXlfZWRnZVtvaV0pIHtcbiAgICAgICAgICAgICAgICB0LmNvbnN0cmFpbmVkX2VkZ2VbaV0gPSBvdC5jb25zdHJhaW5lZF9lZGdlW29pXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluc2lkZSA9IGluQ2lyY2xlKHAsIHQucG9pbnRDQ1cocCksIHQucG9pbnRDVyhwKSwgb3ApO1xuICAgICAgICAgICAgaWYgKGluc2lkZSkge1xuICAgICAgICAgICAgICAgIC8vIExldHMgbWFyayB0aGlzIHNoYXJlZCBlZGdlIGFzIERlbGF1bmF5XG4gICAgICAgICAgICAgICAgdC5kZWxhdW5heV9lZGdlW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvdC5kZWxhdW5heV9lZGdlW29pXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBMZXRzIHJvdGF0ZSBzaGFyZWQgZWRnZSBvbmUgdmVydGV4IENXIHRvIGxlZ2FsaXplIGl0XG4gICAgICAgICAgICAgICAgcm90YXRlVHJpYW5nbGVQYWlyKHQsIHAsIG90LCBvcCk7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBub3cgZ290IG9uZSB2YWxpZCBEZWxhdW5heSBFZGdlIHNoYXJlZCBieSB0d28gdHJpYW5nbGVzXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBnaXZlcyB1cyA0IG5ldyBlZGdlcyB0byBjaGVjayBmb3IgRGVsYXVuYXlcblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRyaWFuZ2xlIHRvIG5vZGUgbWFwcGluZyBpcyBkb25lIG9ubHkgb25lIHRpbWUgZm9yIGEgc3BlY2lmaWMgdHJpYW5nbGVcbiAgICAgICAgICAgICAgICB2YXIgbm90X2xlZ2FsaXplZCA9ICFsZWdhbGl6ZSh0Y3gsIHQpO1xuICAgICAgICAgICAgICAgIGlmIChub3RfbGVnYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRjeC5tYXBUcmlhbmdsZVRvTm9kZXModCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm90X2xlZ2FsaXplZCA9ICFsZWdhbGl6ZSh0Y3gsIG90KTtcbiAgICAgICAgICAgICAgICBpZiAobm90X2xlZ2FsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICB0Y3gubWFwVHJpYW5nbGVUb05vZGVzKG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIERlbGF1bmF5IGVkZ2VzLCBzaW5jZSB0aGV5IG9ubHkgYXJlIHZhbGlkIERlbGF1bmF5IGVkZ2VzXG4gICAgICAgICAgICAgICAgLy8gdW50aWwgd2UgYWRkIGEgbmV3IHRyaWFuZ2xlIG9yIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIFhYWDogbmVlZCB0byB0aGluayBhYm91dCB0aGlzLiBDYW4gdGhlc2UgZWRnZXMgYmUgdHJpZWQgYWZ0ZXIgd2VcbiAgICAgICAgICAgICAgICAvLyAgICAgIHJldHVybiB0byBwcmV2aW91cyByZWN1cnNpdmUgbGV2ZWw/XG4gICAgICAgICAgICAgICAgdC5kZWxhdW5heV9lZGdlW2ldID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb3QuZGVsYXVuYXlfZWRnZVtvaV0gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRyaWFuZ2xlIGhhdmUgYmVlbiBsZWdhbGl6ZWQgbm8gbmVlZCB0byBjaGVjayB0aGUgb3RoZXIgZWRnZXMgc2luY2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVjdXJzaXZlIGxlZ2FsaXphdGlvbiB3aWxsIGhhbmRsZXMgdGhvc2Ugc28gd2UgY2FuIGVuZCBoZXJlLlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiA8Yj5SZXF1aXJlbWVudDwvYj46PGJyPlxuICogMS4gYSxiIGFuZCBjIGZvcm0gYSB0cmlhbmdsZS48YnI+XG4gKiAyLiBhIGFuZCBkIGlzIGtub3cgdG8gYmUgb24gb3Bwb3NpdGUgc2lkZSBvZiBiYzxicj5cbiAqIDxwcmU+XG4gKiAgICAgICAgICAgICAgICBhXG4gKiAgICAgICAgICAgICAgICArXG4gKiAgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgICAgICAgICAvICAgXFxcbiAqICAgICAgICAgICAgYi8gICAgIFxcY1xuICogICAgICAgICAgICArLS0tLS0tLStcbiAqICAgICAgICAgICAvICAgIGQgICAgXFxcbiAqICAgICAgICAgIC8gICAgICAgICAgIFxcXG4gKiA8L3ByZT5cbiAqIDxiPkZhY3Q8L2I+OiBkIGhhcyB0byBiZSBpbiBhcmVhIEIgdG8gaGF2ZSBhIGNoYW5jZSB0byBiZSBpbnNpZGUgdGhlIGNpcmNsZSBmb3JtZWQgYnlcbiAqICBhLGIgYW5kIGM8YnI+XG4gKiAgZCBpcyBvdXRzaWRlIEIgaWYgb3JpZW50MmQoYSxiLGQpIG9yIG9yaWVudDJkKGMsYSxkKSBpcyBDVzxicj5cbiAqICBUaGlzIHByZWtub3dsZWRnZSBnaXZlcyB1cyBhIHdheSB0byBvcHRpbWl6ZSB0aGUgaW5jaXJjbGUgdGVzdFxuICogQHBhcmFtIHBhIC0gdHJpYW5nbGUgcG9pbnQsIG9wcG9zaXRlIGRcbiAqIEBwYXJhbSBwYiAtIHRyaWFuZ2xlIHBvaW50XG4gKiBAcGFyYW0gcGMgLSB0cmlhbmdsZSBwb2ludFxuICogQHBhcmFtIHBkIC0gcG9pbnQgb3Bwb3NpdGUgYVxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBkIGlzIGluc2lkZSBjaXJjbGUsIGZhbHNlIGlmIG9uIGNpcmNsZSBlZGdlXG4gKi9cbmZ1bmN0aW9uIGluQ2lyY2xlKHBhLCBwYiwgcGMsIHBkKSB7XG4gICAgdmFyIGFkeCA9IHBhLnggLSBwZC54O1xuICAgIHZhciBhZHkgPSBwYS55IC0gcGQueTtcbiAgICB2YXIgYmR4ID0gcGIueCAtIHBkLng7XG4gICAgdmFyIGJkeSA9IHBiLnkgLSBwZC55O1xuXG4gICAgdmFyIGFkeGJkeSA9IGFkeCAqIGJkeTtcbiAgICB2YXIgYmR4YWR5ID0gYmR4ICogYWR5O1xuICAgIHZhciBvYWJkID0gYWR4YmR5IC0gYmR4YWR5O1xuICAgIGlmIChvYWJkIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjZHggPSBwYy54IC0gcGQueDtcbiAgICB2YXIgY2R5ID0gcGMueSAtIHBkLnk7XG5cbiAgICB2YXIgY2R4YWR5ID0gY2R4ICogYWR5O1xuICAgIHZhciBhZHhjZHkgPSBhZHggKiBjZHk7XG4gICAgdmFyIG9jYWQgPSBjZHhhZHkgLSBhZHhjZHk7XG4gICAgaWYgKG9jYWQgPD0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGJkeGNkeSA9IGJkeCAqIGNkeTtcbiAgICB2YXIgY2R4YmR5ID0gY2R4ICogYmR5O1xuXG4gICAgdmFyIGFsaWZ0ID0gYWR4ICogYWR4ICsgYWR5ICogYWR5O1xuICAgIHZhciBibGlmdCA9IGJkeCAqIGJkeCArIGJkeSAqIGJkeTtcbiAgICB2YXIgY2xpZnQgPSBjZHggKiBjZHggKyBjZHkgKiBjZHk7XG5cbiAgICB2YXIgZGV0ID0gYWxpZnQgKiAoYmR4Y2R5IC0gY2R4YmR5KSArIGJsaWZ0ICogb2NhZCArIGNsaWZ0ICogb2FiZDtcbiAgICByZXR1cm4gZGV0ID4gMDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgdHJpYW5nbGUgcGFpciBvbmUgdmVydGV4IENXXG4gKjxwcmU+XG4gKiAgICAgICBuMiAgICAgICAgICAgICAgICAgICAgbjJcbiAqICBQICstLS0tLSsgICAgICAgICAgICAgUCArLS0tLS0rXG4gKiAgICB8IHQgIC98ICAgICAgICAgICAgICAgfFxcICB0IHxcbiAqICAgIHwgICAvIHwgICAgICAgICAgICAgICB8IFxcICAgfFxuICogIG4xfCAgLyAgfG4zICAgICAgICAgICBuMXwgIFxcICB8bjNcbiAqICAgIHwgLyAgIHwgICAgYWZ0ZXIgQ1cgICB8ICAgXFwgfFxuICogICAgfC8gb1QgfCAgICAgICAgICAgICAgIHwgb1QgXFx8XG4gKiAgICArLS0tLS0rIG9QICAgICAgICAgICAgKy0tLS0tK1xuICogICAgICAgbjQgICAgICAgICAgICAgICAgICAgIG40XG4gKiA8L3ByZT5cbiAqL1xuZnVuY3Rpb24gcm90YXRlVHJpYW5nbGVQYWlyKHQsIHAsIG90LCBvcCkge1xuICAgIHZhciBuMSwgbjIsIG4zLCBuNDtcbiAgICBuMSA9IHQubmVpZ2hib3JDQ1cocCk7XG4gICAgbjIgPSB0Lm5laWdoYm9yQ1cocCk7XG4gICAgbjMgPSBvdC5uZWlnaGJvckNDVyhvcCk7XG4gICAgbjQgPSBvdC5uZWlnaGJvckNXKG9wKTtcblxuICAgIHZhciBjZTEsIGNlMiwgY2UzLCBjZTQ7XG4gICAgY2UxID0gdC5nZXRDb25zdHJhaW5lZEVkZ2VDQ1cocCk7XG4gICAgY2UyID0gdC5nZXRDb25zdHJhaW5lZEVkZ2VDVyhwKTtcbiAgICBjZTMgPSBvdC5nZXRDb25zdHJhaW5lZEVkZ2VDQ1cob3ApO1xuICAgIGNlNCA9IG90LmdldENvbnN0cmFpbmVkRWRnZUNXKG9wKTtcblxuICAgIHZhciBkZTEsIGRlMiwgZGUzLCBkZTQ7XG4gICAgZGUxID0gdC5nZXREZWxhdW5heUVkZ2VDQ1cocCk7XG4gICAgZGUyID0gdC5nZXREZWxhdW5heUVkZ2VDVyhwKTtcbiAgICBkZTMgPSBvdC5nZXREZWxhdW5heUVkZ2VDQ1cob3ApO1xuICAgIGRlNCA9IG90LmdldERlbGF1bmF5RWRnZUNXKG9wKTtcblxuICAgIHQubGVnYWxpemUocCwgb3ApO1xuICAgIG90LmxlZ2FsaXplKG9wLCBwKTtcblxuICAgIC8vIFJlbWFwIGRlbGF1bmF5X2VkZ2VcbiAgICBvdC5zZXREZWxhdW5heUVkZ2VDQ1cocCwgZGUxKTtcbiAgICB0LnNldERlbGF1bmF5RWRnZUNXKHAsIGRlMik7XG4gICAgdC5zZXREZWxhdW5heUVkZ2VDQ1cob3AsIGRlMyk7XG4gICAgb3Quc2V0RGVsYXVuYXlFZGdlQ1cob3AsIGRlNCk7XG5cbiAgICAvLyBSZW1hcCBjb25zdHJhaW5lZF9lZGdlXG4gICAgb3Quc2V0Q29uc3RyYWluZWRFZGdlQ0NXKHAsIGNlMSk7XG4gICAgdC5zZXRDb25zdHJhaW5lZEVkZ2VDVyhwLCBjZTIpO1xuICAgIHQuc2V0Q29uc3RyYWluZWRFZGdlQ0NXKG9wLCBjZTMpO1xuICAgIG90LnNldENvbnN0cmFpbmVkRWRnZUNXKG9wLCBjZTQpO1xuXG4gICAgLy8gUmVtYXAgbmVpZ2hib3JzXG4gICAgLy8gWFhYOiBtaWdodCBvcHRpbWl6ZSB0aGUgbWFya05laWdoYm9yIGJ5IGtlZXBpbmcgdHJhY2sgb2ZcbiAgICAvLyAgICAgIHdoYXQgc2lkZSBzaG91bGQgYmUgYXNzaWduZWQgdG8gd2hhdCBuZWlnaGJvciBhZnRlciB0aGVcbiAgICAvLyAgICAgIHJvdGF0aW9uLiBOb3cgbWFyayBuZWlnaGJvciBkb2VzIGxvdHMgb2YgdGVzdGluZyB0byBmaW5kXG4gICAgLy8gICAgICB0aGUgcmlnaHQgc2lkZS5cbiAgICB0LmNsZWFyTmVpZ2hib3JzKCk7XG4gICAgb3QuY2xlYXJOZWlnaGJvcnMoKTtcbiAgICBpZiAobjEpIHtcbiAgICAgICAgb3QubWFya05laWdoYm9yKG4xKTtcbiAgICB9XG4gICAgaWYgKG4yKSB7XG4gICAgICAgIHQubWFya05laWdoYm9yKG4yKTtcbiAgICB9XG4gICAgaWYgKG4zKSB7XG4gICAgICAgIHQubWFya05laWdoYm9yKG4zKTtcbiAgICB9XG4gICAgaWYgKG40KSB7XG4gICAgICAgIG90Lm1hcmtOZWlnaGJvcihuNCk7XG4gICAgfVxuICAgIHQubWFya05laWdoYm9yKG90KTtcbn1cblxuLyoqXG4gKiBGaWxscyBhIGJhc2luIHRoYXQgaGFzIGZvcm1lZCBvbiB0aGUgQWR2YW5jaW5nIEZyb250IHRvIHRoZSByaWdodFxuICogb2YgZ2l2ZW4gbm9kZS48YnI+XG4gKiBGaXJzdCB3ZSBkZWNpZGUgYSBsZWZ0LGJvdHRvbSBhbmQgcmlnaHQgbm9kZSB0aGF0IGZvcm1zIHRoZVxuICogYm91bmRhcmllcyBvZiB0aGUgYmFzaW4uIFRoZW4gd2UgZG8gYSByZXF1cnNpdmUgZmlsbC5cbiAqXG4gKiBAcGFyYW0geyFTd2VlcENvbnRleHR9IHRjeCAtIFN3ZWVwQ29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSBub2RlIC0gc3RhcnRpbmcgbm9kZSwgdGhpcyBvciBuZXh0IG5vZGUgd2lsbCBiZSBsZWZ0IG5vZGVcbiAqL1xuZnVuY3Rpb24gZmlsbEJhc2luKHRjeCwgbm9kZSkge1xuICAgIGlmIChvcmllbnQyZChub2RlLnBvaW50LCBub2RlLm5leHQucG9pbnQsIG5vZGUubmV4dC5uZXh0LnBvaW50KSA9PT0gT3JpZW50YXRpb24uQ0NXKSB7XG4gICAgICAgIHRjeC5iYXNpbi5sZWZ0X25vZGUgPSBub2RlLm5leHQubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0Y3guYmFzaW4ubGVmdF9ub2RlID0gbm9kZS5uZXh0O1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGJvdHRvbSBhbmQgcmlnaHQgbm9kZVxuICAgIHRjeC5iYXNpbi5ib3R0b21fbm9kZSA9IHRjeC5iYXNpbi5sZWZ0X25vZGU7XG4gICAgd2hpbGUgKHRjeC5iYXNpbi5ib3R0b21fbm9kZS5uZXh0ICYmIHRjeC5iYXNpbi5ib3R0b21fbm9kZS5wb2ludC55ID49IHRjeC5iYXNpbi5ib3R0b21fbm9kZS5uZXh0LnBvaW50LnkpIHtcbiAgICAgICAgdGN4LmJhc2luLmJvdHRvbV9ub2RlID0gdGN4LmJhc2luLmJvdHRvbV9ub2RlLm5leHQ7XG4gICAgfVxuICAgIGlmICh0Y3guYmFzaW4uYm90dG9tX25vZGUgPT09IHRjeC5iYXNpbi5sZWZ0X25vZGUpIHtcbiAgICAgICAgLy8gTm8gdmFsaWQgYmFzaW5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRjeC5iYXNpbi5yaWdodF9ub2RlID0gdGN4LmJhc2luLmJvdHRvbV9ub2RlO1xuICAgIHdoaWxlICh0Y3guYmFzaW4ucmlnaHRfbm9kZS5uZXh0ICYmIHRjeC5iYXNpbi5yaWdodF9ub2RlLnBvaW50LnkgPCB0Y3guYmFzaW4ucmlnaHRfbm9kZS5uZXh0LnBvaW50LnkpIHtcbiAgICAgICAgdGN4LmJhc2luLnJpZ2h0X25vZGUgPSB0Y3guYmFzaW4ucmlnaHRfbm9kZS5uZXh0O1xuICAgIH1cbiAgICBpZiAodGN4LmJhc2luLnJpZ2h0X25vZGUgPT09IHRjeC5iYXNpbi5ib3R0b21fbm9kZSkge1xuICAgICAgICAvLyBObyB2YWxpZCBiYXNpbnNcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRjeC5iYXNpbi53aWR0aCA9IHRjeC5iYXNpbi5yaWdodF9ub2RlLnBvaW50LnggLSB0Y3guYmFzaW4ubGVmdF9ub2RlLnBvaW50Lng7XG4gICAgdGN4LmJhc2luLmxlZnRfaGlnaGVzdCA9IHRjeC5iYXNpbi5sZWZ0X25vZGUucG9pbnQueSA+IHRjeC5iYXNpbi5yaWdodF9ub2RlLnBvaW50Lnk7XG5cbiAgICBmaWxsQmFzaW5SZXEodGN4LCB0Y3guYmFzaW4uYm90dG9tX25vZGUpO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZSBhbGdvcml0aG0gdG8gZmlsbCBhIEJhc2luIHdpdGggdHJpYW5nbGVzXG4gKlxuICogQHBhcmFtIHshU3dlZXBDb250ZXh0fSB0Y3ggLSBTd2VlcENvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0gbm9kZSAtIGJvdHRvbV9ub2RlXG4gKi9cbmZ1bmN0aW9uIGZpbGxCYXNpblJlcSh0Y3gsIG5vZGUpIHtcbiAgICAvLyBpZiBzaGFsbG93IHN0b3AgZmlsbGluZ1xuICAgIGlmIChpc1NoYWxsb3codGN4LCBub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmlsbCh0Y3gsIG5vZGUpO1xuXG4gICAgdmFyIG87XG4gICAgaWYgKG5vZGUucHJldiA9PT0gdGN4LmJhc2luLmxlZnRfbm9kZSAmJiBub2RlLm5leHQgPT09IHRjeC5iYXNpbi5yaWdodF9ub2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKG5vZGUucHJldiA9PT0gdGN4LmJhc2luLmxlZnRfbm9kZSkge1xuICAgICAgICBvID0gb3JpZW50MmQobm9kZS5wb2ludCwgbm9kZS5uZXh0LnBvaW50LCBub2RlLm5leHQubmV4dC5wb2ludCk7XG4gICAgICAgIGlmIChvID09PSBPcmllbnRhdGlvbi5DVykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSBlbHNlIGlmIChub2RlLm5leHQgPT09IHRjeC5iYXNpbi5yaWdodF9ub2RlKSB7XG4gICAgICAgIG8gPSBvcmllbnQyZChub2RlLnBvaW50LCBub2RlLnByZXYucG9pbnQsIG5vZGUucHJldi5wcmV2LnBvaW50KTtcbiAgICAgICAgaWYgKG8gPT09IE9yaWVudGF0aW9uLkNDVykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgbmVpZ2hib3Igbm9kZSB3aXRoIGxvd2VzdCBZIHZhbHVlXG4gICAgICAgIGlmIChub2RlLnByZXYucG9pbnQueSA8IG5vZGUubmV4dC5wb2ludC55KSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wcmV2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbGxCYXNpblJlcSh0Y3gsIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBpc1NoYWxsb3codGN4LCBub2RlKSB7XG4gICAgdmFyIGhlaWdodDtcbiAgICBpZiAodGN4LmJhc2luLmxlZnRfaGlnaGVzdCkge1xuICAgICAgICBoZWlnaHQgPSB0Y3guYmFzaW4ubGVmdF9ub2RlLnBvaW50LnkgLSBub2RlLnBvaW50Lnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gdGN4LmJhc2luLnJpZ2h0X25vZGUucG9pbnQueSAtIG5vZGUucG9pbnQueTtcbiAgICB9XG5cbiAgICAvLyBpZiBzaGFsbG93IHN0b3AgZmlsbGluZ1xuICAgIGlmICh0Y3guYmFzaW4ud2lkdGggPiBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmlsbEVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpIHtcbiAgICBpZiAodGN4LmVkZ2VfZXZlbnQucmlnaHQpIHtcbiAgICAgICAgZmlsbFJpZ2h0QWJvdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmaWxsTGVmdEFib3ZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWxsUmlnaHRBYm92ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5uZXh0LnBvaW50LnggPCBlZGdlLnAueCkge1xuICAgICAgICAvLyBDaGVjayBpZiBuZXh0IG5vZGUgaXMgYmVsb3cgdGhlIGVkZ2VcbiAgICAgICAgaWYgKG9yaWVudDJkKGVkZ2UucSwgbm9kZS5uZXh0LnBvaW50LCBlZGdlLnApID09PSBPcmllbnRhdGlvbi5DQ1cpIHtcbiAgICAgICAgICAgIGZpbGxSaWdodEJlbG93RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWxsUmlnaHRCZWxvd0VkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpIHtcbiAgICBpZiAobm9kZS5wb2ludC54IDwgZWRnZS5wLngpIHtcbiAgICAgICAgaWYgKG9yaWVudDJkKG5vZGUucG9pbnQsIG5vZGUubmV4dC5wb2ludCwgbm9kZS5uZXh0Lm5leHQucG9pbnQpID09PSBPcmllbnRhdGlvbi5DQ1cpIHtcbiAgICAgICAgICAgIC8vIENvbmNhdmVcbiAgICAgICAgICAgIGZpbGxSaWdodENvbmNhdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvbnZleFxuICAgICAgICAgICAgZmlsbFJpZ2h0Q29udmV4RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgICAgICAgICAvLyBSZXRyeSB0aGlzIG9uZVxuICAgICAgICAgICAgZmlsbFJpZ2h0QmVsb3dFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsbFJpZ2h0Q29uY2F2ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpIHtcbiAgICBmaWxsKHRjeCwgbm9kZS5uZXh0KTtcbiAgICBpZiAobm9kZS5uZXh0LnBvaW50ICE9PSBlZGdlLnApIHtcbiAgICAgICAgLy8gTmV4dCBhYm92ZSBvciBiZWxvdyBlZGdlP1xuICAgICAgICBpZiAob3JpZW50MmQoZWRnZS5xLCBub2RlLm5leHQucG9pbnQsIGVkZ2UucCkgPT09IE9yaWVudGF0aW9uLkNDVykge1xuICAgICAgICAgICAgLy8gQmVsb3dcbiAgICAgICAgICAgIGlmIChvcmllbnQyZChub2RlLnBvaW50LCBub2RlLm5leHQucG9pbnQsIG5vZGUubmV4dC5uZXh0LnBvaW50KSA9PT0gT3JpZW50YXRpb24uQ0NXKSB7XG4gICAgICAgICAgICAgICAgLy8gTmV4dCBpcyBjb25jYXZlXG4gICAgICAgICAgICAgICAgZmlsbFJpZ2h0Q29uY2F2ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGlzIGNvbnZleFxuICAgICAgICAgICAgICAgIC8qIGpzaGludCBub2VtcHR5OmZhbHNlICovXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbGxSaWdodENvbnZleEVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpIHtcbiAgICAvLyBOZXh0IGNvbmNhdmUgb3IgY29udmV4P1xuICAgIGlmIChvcmllbnQyZChub2RlLm5leHQucG9pbnQsIG5vZGUubmV4dC5uZXh0LnBvaW50LCBub2RlLm5leHQubmV4dC5uZXh0LnBvaW50KSA9PT0gT3JpZW50YXRpb24uQ0NXKSB7XG4gICAgICAgIC8vIENvbmNhdmVcbiAgICAgICAgZmlsbFJpZ2h0Q29uY2F2ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUubmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29udmV4XG4gICAgICAgIC8vIE5leHQgYWJvdmUgb3IgYmVsb3cgZWRnZT9cbiAgICAgICAgaWYgKG9yaWVudDJkKGVkZ2UucSwgbm9kZS5uZXh0Lm5leHQucG9pbnQsIGVkZ2UucCkgPT09IE9yaWVudGF0aW9uLkNDVykge1xuICAgICAgICAgICAgLy8gQmVsb3dcbiAgICAgICAgICAgIGZpbGxSaWdodENvbnZleEVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUubmV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBYm92ZVxuICAgICAgICAgICAgLyoganNoaW50IG5vZW1wdHk6ZmFsc2UgKi9cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsbExlZnRBYm92ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5wcmV2LnBvaW50LnggPiBlZGdlLnAueCkge1xuICAgICAgICAvLyBDaGVjayBpZiBuZXh0IG5vZGUgaXMgYmVsb3cgdGhlIGVkZ2VcbiAgICAgICAgaWYgKG9yaWVudDJkKGVkZ2UucSwgbm9kZS5wcmV2LnBvaW50LCBlZGdlLnApID09PSBPcmllbnRhdGlvbi5DVykge1xuICAgICAgICAgICAgZmlsbExlZnRCZWxvd0VkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucHJldjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsbExlZnRCZWxvd0VkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpIHtcbiAgICBpZiAobm9kZS5wb2ludC54ID4gZWRnZS5wLngpIHtcbiAgICAgICAgaWYgKG9yaWVudDJkKG5vZGUucG9pbnQsIG5vZGUucHJldi5wb2ludCwgbm9kZS5wcmV2LnByZXYucG9pbnQpID09PSBPcmllbnRhdGlvbi5DVykge1xuICAgICAgICAgICAgLy8gQ29uY2F2ZVxuICAgICAgICAgICAgZmlsbExlZnRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDb252ZXhcbiAgICAgICAgICAgIGZpbGxMZWZ0Q29udmV4RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgICAgICAgICAvLyBSZXRyeSB0aGlzIG9uZVxuICAgICAgICAgICAgZmlsbExlZnRCZWxvd0VkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWxsTGVmdENvbnZleEVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpIHtcbiAgICAvLyBOZXh0IGNvbmNhdmUgb3IgY29udmV4P1xuICAgIGlmIChvcmllbnQyZChub2RlLnByZXYucG9pbnQsIG5vZGUucHJldi5wcmV2LnBvaW50LCBub2RlLnByZXYucHJldi5wcmV2LnBvaW50KSA9PT0gT3JpZW50YXRpb24uQ1cpIHtcbiAgICAgICAgLy8gQ29uY2F2ZVxuICAgICAgICBmaWxsTGVmdENvbmNhdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlLnByZXYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnZleFxuICAgICAgICAvLyBOZXh0IGFib3ZlIG9yIGJlbG93IGVkZ2U/XG4gICAgICAgIGlmIChvcmllbnQyZChlZGdlLnEsIG5vZGUucHJldi5wcmV2LnBvaW50LCBlZGdlLnApID09PSBPcmllbnRhdGlvbi5DVykge1xuICAgICAgICAgICAgLy8gQmVsb3dcbiAgICAgICAgICAgIGZpbGxMZWZ0Q29udmV4RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZS5wcmV2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFib3ZlXG4gICAgICAgICAgICAvKiBqc2hpbnQgbm9lbXB0eTpmYWxzZSAqL1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWxsTGVmdENvbmNhdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKSB7XG4gICAgZmlsbCh0Y3gsIG5vZGUucHJldik7XG4gICAgaWYgKG5vZGUucHJldi5wb2ludCAhPT0gZWRnZS5wKSB7XG4gICAgICAgIC8vIE5leHQgYWJvdmUgb3IgYmVsb3cgZWRnZT9cbiAgICAgICAgaWYgKG9yaWVudDJkKGVkZ2UucSwgbm9kZS5wcmV2LnBvaW50LCBlZGdlLnApID09PSBPcmllbnRhdGlvbi5DVykge1xuICAgICAgICAgICAgLy8gQmVsb3dcbiAgICAgICAgICAgIGlmIChvcmllbnQyZChub2RlLnBvaW50LCBub2RlLnByZXYucG9pbnQsIG5vZGUucHJldi5wcmV2LnBvaW50KSA9PT0gT3JpZW50YXRpb24uQ1cpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGlzIGNvbmNhdmVcbiAgICAgICAgICAgICAgICBmaWxsTGVmdENvbmNhdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTmV4dCBpcyBjb252ZXhcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgbm9lbXB0eTpmYWxzZSAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmbGlwRWRnZUV2ZW50KHRjeCwgZXAsIGVxLCB0LCBwKSB7XG4gICAgdmFyIG90ID0gdC5uZWlnaGJvckFjcm9zcyhwKTtcbiAgICBhc3NlcnQob3QsIFwiRkxJUCBmYWlsZWQgZHVlIHRvIG1pc3NpbmcgdHJpYW5nbGUhXCIpO1xuXG4gICAgdmFyIG9wID0gb3Qub3Bwb3NpdGVQb2ludCh0LCBwKTtcblxuICAgIC8vIEFkZGl0aW9uYWwgY2hlY2sgZnJvbSBKYXZhIHZlcnNpb24gKHNlZSBpc3N1ZSAjODgpXG4gICAgaWYgKHQuZ2V0Q29uc3RyYWluZWRFZGdlQWNyb3NzKHApKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHQuaW5kZXgocCk7XG4gICAgICAgIHRocm93IG5ldyBQb2ludEVycm9yKFwicG9seTJ0cmkgSW50ZXJzZWN0aW5nIENvbnN0cmFpbnRzXCIsXG4gICAgICAgICAgICAgICAgW3AsIG9wLCB0LmdldFBvaW50KChpbmRleCArIDEpICUgMyksIHQuZ2V0UG9pbnQoKGluZGV4ICsgMikgJSAzKV0pO1xuICAgIH1cblxuICAgIGlmIChpblNjYW5BcmVhKHAsIHQucG9pbnRDQ1cocCksIHQucG9pbnRDVyhwKSwgb3ApKSB7XG4gICAgICAgIC8vIExldHMgcm90YXRlIHNoYXJlZCBlZGdlIG9uZSB2ZXJ0ZXggQ1dcbiAgICAgICAgcm90YXRlVHJpYW5nbGVQYWlyKHQsIHAsIG90LCBvcCk7XG4gICAgICAgIHRjeC5tYXBUcmlhbmdsZVRvTm9kZXModCk7XG4gICAgICAgIHRjeC5tYXBUcmlhbmdsZVRvTm9kZXMob3QpO1xuXG4gICAgICAgIC8vIFhYWDogaW4gdGhlIG9yaWdpbmFsIEMrKyBjb2RlIGZvciB0aGUgbmV4dCAyIGxpbmVzLCB3ZSBhcmVcbiAgICAgICAgLy8gY29tcGFyaW5nIHBvaW50IHZhbHVlcyAoYW5kIG5vdCBwb2ludGVycykuIEluIHRoaXMgSmF2YVNjcmlwdFxuICAgICAgICAvLyBjb2RlLCB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMgKHBvaW50ZXJzKS4gVGhpcyB3b3Jrc1xuICAgICAgICAvLyBiZWNhdXNlIHdlIGNhbid0IGhhdmUgMiBkaWZmZXJlbnQgcG9pbnRzIHdpdGggdGhlIHNhbWUgdmFsdWVzLlxuICAgICAgICAvLyBCdXQgdG8gYmUgcmVhbGx5IGVxdWl2YWxlbnQsIHdlIHNob3VsZCB1c2UgXCJQb2ludC5lcXVhbHNcIiBoZXJlLlxuICAgICAgICBpZiAocCA9PT0gZXEgJiYgb3AgPT09IGVwKSB7XG4gICAgICAgICAgICBpZiAoZXEgPT09IHRjeC5lZGdlX2V2ZW50LmNvbnN0cmFpbmVkX2VkZ2UucSAmJiBlcCA9PT0gdGN4LmVkZ2VfZXZlbnQuY29uc3RyYWluZWRfZWRnZS5wKSB7XG4gICAgICAgICAgICAgICAgdC5tYXJrQ29uc3RyYWluZWRFZGdlQnlQb2ludHMoZXAsIGVxKTtcbiAgICAgICAgICAgICAgICBvdC5tYXJrQ29uc3RyYWluZWRFZGdlQnlQb2ludHMoZXAsIGVxKTtcbiAgICAgICAgICAgICAgICBsZWdhbGl6ZSh0Y3gsIHQpO1xuICAgICAgICAgICAgICAgIGxlZ2FsaXplKHRjeCwgb3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBYWFg6IEkgdGhpbmsgb25lIG9mIHRoZSB0cmlhbmdsZXMgc2hvdWxkIGJlIGxlZ2FsaXplZCBoZXJlP1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCBub2VtcHR5OmZhbHNlICovXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbyA9IG9yaWVudDJkKGVxLCBvcCwgZXApO1xuICAgICAgICAgICAgdCA9IG5leHRGbGlwVHJpYW5nbGUodGN4LCBvLCB0LCBvdCwgcCwgb3ApO1xuICAgICAgICAgICAgZmxpcEVkZ2VFdmVudCh0Y3gsIGVwLCBlcSwgdCwgcCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3UCA9IG5leHRGbGlwUG9pbnQoZXAsIGVxLCBvdCwgb3ApO1xuICAgICAgICBmbGlwU2NhbkVkZ2VFdmVudCh0Y3gsIGVwLCBlcSwgdCwgb3QsIG5ld1ApO1xuICAgICAgICBlZGdlRXZlbnRCeVBvaW50cyh0Y3gsIGVwLCBlcSwgdCwgcCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFmdGVyIGEgZmxpcCB3ZSBoYXZlIHR3byB0cmlhbmdsZXMgYW5kIGtub3cgdGhhdCBvbmx5IG9uZSB3aWxsIHN0aWxsIGJlXG4gKiBpbnRlcnNlY3RpbmcgdGhlIGVkZ2UuIFNvIGRlY2lkZSB3aGljaCB0byBjb250aXVuZSB3aXRoIGFuZCBsZWdhbGl6ZSB0aGUgb3RoZXJcbiAqXG4gKiBAcGFyYW0geyFTd2VlcENvbnRleHR9IHRjeCAtIFN3ZWVwQ29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSBvIC0gc2hvdWxkIGJlIHRoZSByZXN1bHQgb2YgYW4gb3JpZW50MmQoIGVxLCBvcCwgZXAgKVxuICogQHBhcmFtIHQgLSB0cmlhbmdsZSAxXG4gKiBAcGFyYW0gb3QgLSB0cmlhbmdsZSAyXG4gKiBAcGFyYW0gcCAtIGEgcG9pbnQgc2hhcmVkIGJ5IGJvdGggdHJpYW5nbGVzXG4gKiBAcGFyYW0gb3AgLSBhbm90aGVyIHBvaW50IHNoYXJlZCBieSBib3RoIHRyaWFuZ2xlc1xuICogQHJldHVybiByZXR1cm5zIHRoZSB0cmlhbmdsZSBzdGlsbCBpbnRlcnNlY3RpbmcgdGhlIGVkZ2VcbiAqL1xuZnVuY3Rpb24gbmV4dEZsaXBUcmlhbmdsZSh0Y3gsIG8sIHQsIG90LCBwLCBvcCkge1xuICAgIHZhciBlZGdlX2luZGV4O1xuICAgIGlmIChvID09PSBPcmllbnRhdGlvbi5DQ1cpIHtcbiAgICAgICAgLy8gb3QgaXMgbm90IGNyb3NzaW5nIGVkZ2UgYWZ0ZXIgZmxpcFxuICAgICAgICBlZGdlX2luZGV4ID0gb3QuZWRnZUluZGV4KHAsIG9wKTtcbiAgICAgICAgb3QuZGVsYXVuYXlfZWRnZVtlZGdlX2luZGV4XSA9IHRydWU7XG4gICAgICAgIGxlZ2FsaXplKHRjeCwgb3QpO1xuICAgICAgICBvdC5jbGVhckRlbGF1bmF5RWRnZXMoKTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgLy8gdCBpcyBub3QgY3Jvc3NpbmcgZWRnZSBhZnRlciBmbGlwXG4gICAgZWRnZV9pbmRleCA9IHQuZWRnZUluZGV4KHAsIG9wKTtcblxuICAgIHQuZGVsYXVuYXlfZWRnZVtlZGdlX2luZGV4XSA9IHRydWU7XG4gICAgbGVnYWxpemUodGN4LCB0KTtcbiAgICB0LmNsZWFyRGVsYXVuYXlFZGdlcygpO1xuICAgIHJldHVybiBvdDtcbn1cblxuLyoqXG4gKiBXaGVuIHdlIG5lZWQgdG8gdHJhdmVyc2UgZnJvbSBvbmUgdHJpYW5nbGUgdG8gdGhlIG5leHQgd2UgbmVlZFxuICogdGhlIHBvaW50IGluIGN1cnJlbnQgdHJpYW5nbGUgdGhhdCBpcyB0aGUgb3Bwb3NpdGUgcG9pbnQgdG8gdGhlIG5leHRcbiAqIHRyaWFuZ2xlLlxuICovXG5mdW5jdGlvbiBuZXh0RmxpcFBvaW50KGVwLCBlcSwgb3QsIG9wKSB7XG4gICAgdmFyIG8yZCA9IG9yaWVudDJkKGVxLCBvcCwgZXApO1xuICAgIGlmIChvMmQgPT09IE9yaWVudGF0aW9uLkNXKSB7XG4gICAgICAgIC8vIFJpZ2h0XG4gICAgICAgIHJldHVybiBvdC5wb2ludENDVyhvcCk7XG4gICAgfSBlbHNlIGlmIChvMmQgPT09IE9yaWVudGF0aW9uLkNDVykge1xuICAgICAgICAvLyBMZWZ0XG4gICAgICAgIHJldHVybiBvdC5wb2ludENXKG9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUG9pbnRFcnJvcihcInBvbHkydHJpIFtVbnN1cHBvcnRlZF0gbmV4dEZsaXBQb2ludDogb3Bwb3NpbmcgcG9pbnQgb24gY29uc3RyYWluZWQgZWRnZSFcIiwgW2VxLCBvcCwgZXBdKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2NhbiBwYXJ0IG9mIHRoZSBGbGlwU2NhbiBhbGdvcml0aG08YnI+XG4gKiBXaGVuIGEgdHJpYW5nbGUgcGFpciBpc24ndCBmbGlwcGFibGUgd2Ugd2lsbCBzY2FuIGZvciB0aGUgbmV4dFxuICogcG9pbnQgdGhhdCBpcyBpbnNpZGUgdGhlIGZsaXAgdHJpYW5nbGUgc2NhbiBhcmVhLiBXaGVuIGZvdW5kXG4gKiB3ZSBnZW5lcmF0ZSBhIG5ldyBmbGlwRWRnZUV2ZW50XG4gKlxuICogQHBhcmFtIHshU3dlZXBDb250ZXh0fSB0Y3ggLSBTd2VlcENvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0gZXAgLSBsYXN0IHBvaW50IG9uIHRoZSBlZGdlIHdlIGFyZSB0cmF2ZXJzaW5nXG4gKiBAcGFyYW0gZXEgLSBmaXJzdCBwb2ludCBvbiB0aGUgZWRnZSB3ZSBhcmUgdHJhdmVyc2luZ1xuICogQHBhcmFtIHshVHJpYW5nbGV9IGZsaXBfdHJpYW5nbGUgLSB0aGUgY3VycmVudCB0cmlhbmdsZSBzaGFyaW5nIHRoZSBwb2ludCBlcSB3aXRoIGVkZ2VcbiAqIEBwYXJhbSB0XG4gKiBAcGFyYW0gcFxuICovXG5mdW5jdGlvbiBmbGlwU2NhbkVkZ2VFdmVudCh0Y3gsIGVwLCBlcSwgZmxpcF90cmlhbmdsZSwgdCwgcCkge1xuICAgIHZhciBvdCA9IHQubmVpZ2hib3JBY3Jvc3MocCk7XG4gICAgYXNzZXJ0KG90LCBcIkZMSVAgZmFpbGVkIGR1ZSB0byBtaXNzaW5nIHRyaWFuZ2xlXCIpO1xuXG4gICAgdmFyIG9wID0gb3Qub3Bwb3NpdGVQb2ludCh0LCBwKTtcblxuICAgIGlmIChpblNjYW5BcmVhKGVxLCBmbGlwX3RyaWFuZ2xlLnBvaW50Q0NXKGVxKSwgZmxpcF90cmlhbmdsZS5wb2ludENXKGVxKSwgb3ApKSB7XG4gICAgICAgIC8vIGZsaXAgd2l0aCBuZXcgZWRnZSBvcC5lcVxuICAgICAgICBmbGlwRWRnZUV2ZW50KHRjeCwgZXEsIG9wLCBvdCwgb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdQID0gbmV4dEZsaXBQb2ludChlcCwgZXEsIG90LCBvcCk7XG4gICAgICAgIGZsaXBTY2FuRWRnZUV2ZW50KHRjeCwgZXAsIGVxLCBmbGlwX3RyaWFuZ2xlLCBvdCwgbmV3UCk7XG4gICAgfVxufVxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1FeHBvcnRzXG5cbmV4cG9ydHMudHJpYW5ndWxhdGUgPSB0cmlhbmd1bGF0ZTtcblxufSx7XCIuL2FkdmFuY2luZ2Zyb250XCI6MixcIi4vYXNzZXJ0XCI6MyxcIi4vcG9pbnRlcnJvclwiOjUsXCIuL3RyaWFuZ2xlXCI6OSxcIi4vdXRpbHNcIjoxMH1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIFBvbHkyVHJpIENvcHlyaWdodCAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cbiAqIFxuICogcG9seTJ0cmkuanMgKEphdmFTY3JpcHQgcG9ydCkgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcjNtaS9wb2x5MnRyaS5qc1xuICogXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgMy1jbGF1c2UgQlNEIExpY2Vuc2UsIHNlZSBMSUNFTlNFLnR4dFxuICovXG5cbi8qIGpzaGludCBtYXhjb21wbGV4aXR5OjYgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLypcbiAqIE5vdGVcbiAqID09PT1cbiAqIHRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyBKYXZhU2NyaXB0IHZlcnNpb24gb2YgcG9seTJ0cmkgaW50ZW50aW9uYWxseSBmb2xsb3dzXG4gKiBhcyBjbG9zZWx5IGFzIHBvc3NpYmxlIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIHJlZmVyZW5jZSBDKysgdmVyc2lvbiwgdG8gbWFrZSBpdCBcbiAqIGVhc2llciB0byBrZWVwIHRoZSAyIHZlcnNpb25zIGluIHN5bmMuXG4gKi9cblxudmFyIFBvaW50RXJyb3IgPSBfZGVyZXFfKCcuL3BvaW50ZXJyb3InKTtcbnZhciBQb2ludCA9IF9kZXJlcV8oJy4vcG9pbnQnKTtcbnZhciBUcmlhbmdsZSA9IF9kZXJlcV8oJy4vdHJpYW5nbGUnKTtcbnZhciBzd2VlcCA9IF9kZXJlcV8oJy4vc3dlZXAnKTtcbnZhciBBZHZhbmNpbmdGcm9udCA9IF9kZXJlcV8oJy4vYWR2YW5jaW5nZnJvbnQnKTtcbnZhciBOb2RlID0gQWR2YW5jaW5nRnJvbnQuTm9kZTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS11dGlsc1xuXG4vKipcbiAqIEluaXRpYWwgdHJpYW5nbGUgZmFjdG9yLCBzZWVkIHRyaWFuZ2xlIHdpbGwgZXh0ZW5kIDMwJSBvZlxuICogUG9pbnRTZXQgd2lkdGggdG8gYm90aCBsZWZ0IGFuZCByaWdodC5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RcbiAqL1xudmFyIGtBbHBoYSA9IDAuMztcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tRWRnZVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2ltcGxlIHBvbHlnb24ncyBlZGdlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BvaW50fSBwMVxuICogQHBhcmFtIHtQb2ludH0gcDJcbiAqIEB0aHJvdyB7UG9pbnRFcnJvcn0gaWYgcDEgaXMgc2FtZSBhcyBwMlxuICovXG52YXIgRWRnZSA9IGZ1bmN0aW9uKHAxLCBwMikge1xuICAgIHRoaXMucCA9IHAxO1xuICAgIHRoaXMucSA9IHAyO1xuXG4gICAgaWYgKHAxLnkgPiBwMi55KSB7XG4gICAgICAgIHRoaXMucSA9IHAxO1xuICAgICAgICB0aGlzLnAgPSBwMjtcbiAgICB9IGVsc2UgaWYgKHAxLnkgPT09IHAyLnkpIHtcbiAgICAgICAgaWYgKHAxLnggPiBwMi54KSB7XG4gICAgICAgICAgICB0aGlzLnEgPSBwMTtcbiAgICAgICAgICAgIHRoaXMucCA9IHAyO1xuICAgICAgICB9IGVsc2UgaWYgKHAxLnggPT09IHAyLngpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQb2ludEVycm9yKCdwb2x5MnRyaSBJbnZhbGlkIEVkZ2UgY29uc3RydWN0b3I6IHJlcGVhdGVkIHBvaW50cyEnLCBbcDFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5xLl9wMnRfZWRnZV9saXN0KSB7XG4gICAgICAgIHRoaXMucS5fcDJ0X2VkZ2VfbGlzdCA9IFtdO1xuICAgIH1cbiAgICB0aGlzLnEuX3AydF9lZGdlX2xpc3QucHVzaCh0aGlzKTtcbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tQmFzaW5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgQmFzaW4gPSBmdW5jdGlvbigpIHtcbiAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgdGhpcy5sZWZ0X25vZGUgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICB0aGlzLmJvdHRvbV9ub2RlID0gbnVsbDtcbiAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgdGhpcy5yaWdodF9ub2RlID0gbnVsbDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLndpZHRoID0gMC4wO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmxlZnRfaGlnaGVzdCA9IGZhbHNlO1xufTtcblxuQmFzaW4ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sZWZ0X25vZGUgPSBudWxsO1xuICAgIHRoaXMuYm90dG9tX25vZGUgPSBudWxsO1xuICAgIHRoaXMucmlnaHRfbm9kZSA9IG51bGw7XG4gICAgdGhpcy53aWR0aCA9IDAuMDtcbiAgICB0aGlzLmxlZnRfaGlnaGVzdCA9IGZhbHNlO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1FZGdlRXZlbnRcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgRWRnZUV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgLyoqIEB0eXBlIHtFZGdlfSAqL1xuICAgIHRoaXMuY29uc3RyYWluZWRfZWRnZSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMucmlnaHQgPSBmYWxzZTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1Td2VlcENvbnRleHQgKHB1YmxpYyBBUEkpXG4vKipcbiAqIFN3ZWVwQ29udGV4dCBjb25zdHJ1Y3RvciBvcHRpb25cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN3ZWVwQ29udGV4dE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbj19IGNsb25lQXJyYXlzIC0gaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIGRvIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBBcnJheSBwYXJhbWV0ZXJzXG4gKiAgICAgICAgICAgICAgICAgIChjb250b3VyLCBob2xlcykuIFBvaW50cyBpbnNpZGUgYXJyYXlzIGFyZSBuZXZlciBjb3BpZWQuXG4gKiAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgPGNvZGU+ZmFsc2U8L2NvZGU+IDoga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgYXJyYXkgYXJndW1lbnRzLFxuICogICAgICAgICAgICAgICAgICB3aG8gd2lsbCBiZSBtb2RpZmllZCBpbiBwbGFjZS5cbiAqL1xuLyoqXG4gKiBDb25zdHJ1Y3RvciBmb3IgdGhlIHRyaWFuZ3VsYXRpb24gY29udGV4dC5cbiAqIEl0IGFjY2VwdHMgYSBzaW1wbGUgcG9seWxpbmUgKHdpdGggbm9uIHJlcGVhdGluZyBwb2ludHMpLCBcbiAqIHdoaWNoIGRlZmluZXMgdGhlIGNvbnN0cmFpbmVkIGVkZ2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgICAgICB2YXIgY29udG91ciA9IFtcbiAqICAgICAgICAgICAgICBuZXcgcG9seTJ0cmkuUG9pbnQoMTAwLCAxMDApLFxuICogICAgICAgICAgICAgIG5ldyBwb2x5MnRyaS5Qb2ludCgxMDAsIDMwMCksXG4gKiAgICAgICAgICAgICAgbmV3IHBvbHkydHJpLlBvaW50KDMwMCwgMzAwKSxcbiAqICAgICAgICAgICAgICBuZXcgcG9seTJ0cmkuUG9pbnQoMzAwLCAxMDApXG4gKiAgICAgICAgICBdO1xuICogICAgICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyLCB7Y2xvbmVBcnJheXM6IHRydWV9KTtcbiAqIEBleGFtcGxlXG4gKiAgICAgICAgICB2YXIgY29udG91ciA9IFt7eDoxMDAsIHk6MTAwfSwge3g6MTAwLCB5OjMwMH0sIHt4OjMwMCwgeTozMDB9LCB7eDozMDAsIHk6MTAwfV07XG4gKiAgICAgICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIsIHtjbG9uZUFycmF5czogdHJ1ZX0pO1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKiBAc3RydWN0XG4gKiBAcGFyYW0ge0FycmF5LjxYWT59IGNvbnRvdXIgLSBhcnJheSBvZiBwb2ludCBvYmplY3RzLiBUaGUgcG9pbnRzIGNhbiBiZSBlaXRoZXIge0BsaW5rY29kZSBQb2ludH0gaW5zdGFuY2VzLFxuICogICAgICAgICAgb3IgYW55IFwiUG9pbnQgbGlrZVwiIGN1c3RvbSBjbGFzcyB3aXRoIDxjb2RlPnt4LCB5fTwvY29kZT4gYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7U3dlZXBDb250ZXh0T3B0aW9ucz19IG9wdGlvbnMgLSBjb25zdHJ1Y3RvciBvcHRpb25zXG4gKi9cbnZhciBTd2VlcENvbnRleHQgPSBmdW5jdGlvbihjb250b3VyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy50cmlhbmdsZXNfID0gW107XG4gICAgdGhpcy5tYXBfID0gW107XG4gICAgdGhpcy5wb2ludHNfID0gKG9wdGlvbnMuY2xvbmVBcnJheXMgPyBjb250b3VyLnNsaWNlKDApIDogY29udG91cik7XG4gICAgdGhpcy5lZGdlX2xpc3QgPSBbXTtcblxuICAgIC8vIEJvdW5kaW5nIGJveCBvZiBhbGwgcG9pbnRzLiBDb21wdXRlZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHRyaWFuZ3VsYXRpb24sIFxuICAgIC8vIGl0IGlzIHN0b3JlZCBpbiBjYXNlIGl0IGlzIG5lZWRlZCBieSB0aGUgY2FsbGVyLlxuICAgIHRoaXMucG1pbl8gPSB0aGlzLnBtYXhfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2luZyBmcm9udFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FkdmFuY2luZ0Zyb250fVxuICAgICAqL1xuICAgIHRoaXMuZnJvbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIGhlYWQgcG9pbnQgdXNlZCB3aXRoIGFkdmFuY2luZyBmcm9udFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqL1xuICAgIHRoaXMuaGVhZF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogdGFpbCBwb2ludCB1c2VkIHdpdGggYWR2YW5jaW5nIGZyb250XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICovXG4gICAgdGhpcy50YWlsXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtOb2RlfVxuICAgICAqL1xuICAgIHRoaXMuYWZfaGVhZF8gPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge05vZGV9XG4gICAgICovXG4gICAgdGhpcy5hZl9taWRkbGVfID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtOb2RlfVxuICAgICAqL1xuICAgIHRoaXMuYWZfdGFpbF8gPSBudWxsO1xuXG4gICAgdGhpcy5iYXNpbiA9IG5ldyBCYXNpbigpO1xuICAgIHRoaXMuZWRnZV9ldmVudCA9IG5ldyBFZGdlRXZlbnQoKTtcblxuICAgIHRoaXMuaW5pdEVkZ2VzKHRoaXMucG9pbnRzXyk7XG59O1xuXG5cbi8qKlxuICogQWRkIGEgaG9sZSB0byB0aGUgY29uc3RyYWludHNcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKiAgICAgIHZhciBob2xlID0gW1xuICogICAgICAgICAgbmV3IHBvbHkydHJpLlBvaW50KDIwMCwgMjAwKSxcbiAqICAgICAgICAgIG5ldyBwb2x5MnRyaS5Qb2ludCgyMDAsIDI1MCksXG4gKiAgICAgICAgICBuZXcgcG9seTJ0cmkuUG9pbnQoMjUwLCAyNTApXG4gKiAgICAgIF07XG4gKiAgICAgIHN3Y3R4LmFkZEhvbGUoaG9sZSk7XG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICogICAgICBzd2N0eC5hZGRIb2xlKFt7eDoyMDAsIHk6MjAwfSwge3g6MjAwLCB5OjI1MH0sIHt4OjI1MCwgeToyNTB9XSk7XG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0FycmF5LjxYWT59IHBvbHlsaW5lIC0gYXJyYXkgb2YgXCJQb2ludCBsaWtlXCIgb2JqZWN0cyB3aXRoIHt4LHl9XG4gKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuYWRkSG9sZSA9IGZ1bmN0aW9uKHBvbHlsaW5lKSB7XG4gICAgdGhpcy5pbml0RWRnZXMocG9seWxpbmUpO1xuICAgIHZhciBpLCBsZW4gPSBwb2x5bGluZS5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMucG9pbnRzXy5wdXNoKHBvbHlsaW5lW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICogQGZ1bmN0aW9uXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rY29kZSBTd2VlcENvbnRleHQjYWRkSG9sZX0gaW5zdGVhZFxuICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLkFkZEhvbGUgPSBTd2VlcENvbnRleHQucHJvdG90eXBlLmFkZEhvbGU7XG5cblxuLyoqXG4gKiBBZGQgc2V2ZXJhbCBob2xlcyB0byB0aGUgY29uc3RyYWludHNcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKiAgICAgIHZhciBob2xlcyA9IFtcbiAqICAgICAgICAgIFsgbmV3IHBvbHkydHJpLlBvaW50KDIwMCwgMjAwKSwgbmV3IHBvbHkydHJpLlBvaW50KDIwMCwgMjUwKSwgbmV3IHBvbHkydHJpLlBvaW50KDI1MCwgMjUwKSBdLFxuICogICAgICAgICAgWyBuZXcgcG9seTJ0cmkuUG9pbnQoMzAwLCAzMDApLCBuZXcgcG9seTJ0cmkuUG9pbnQoMzAwLCAzNTApLCBuZXcgcG9seTJ0cmkuUG9pbnQoMzUwLCAzNTApIF1cbiAqICAgICAgXTtcbiAqICAgICAgc3djdHguYWRkSG9sZXMoaG9sZXMpO1xuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqICAgICAgdmFyIGhvbGVzID0gW1xuICogICAgICAgICAgW3t4OjIwMCwgeToyMDB9LCB7eDoyMDAsIHk6MjUwfSwge3g6MjUwLCB5OjI1MH1dLFxuICogICAgICAgICAgW3t4OjMwMCwgeTozMDB9LCB7eDozMDAsIHk6MzUwfSwge3g6MzUwLCB5OjM1MH1dXG4gKiAgICAgIF07XG4gKiAgICAgIHN3Y3R4LmFkZEhvbGVzKGhvbGVzKTtcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxYWT4+fSBob2xlcyAtIGFycmF5IG9mIGFycmF5IG9mIFwiUG9pbnQgbGlrZVwiIG9iamVjdHMgd2l0aCB7eCx5fVxuICovXG4vLyBNZXRob2QgYWRkZWQgaW4gdGhlIEphdmFTY3JpcHQgdmVyc2lvbiAod2FzIG5vdCBwcmVzZW50IGluIHRoZSBjKysgdmVyc2lvbilcblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuYWRkSG9sZXMgPSBmdW5jdGlvbihob2xlcykge1xuICAgIHZhciBpLCBsZW4gPSBob2xlcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuaW5pdEVkZ2VzKGhvbGVzW2ldKTtcbiAgICB9XG4gICAgdGhpcy5wb2ludHNfID0gdGhpcy5wb2ludHNfLmNvbmNhdC5hcHBseSh0aGlzLnBvaW50c18sIGhvbGVzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG5cbi8qKlxuICogQWRkIGEgU3RlaW5lciBwb2ludCB0byB0aGUgY29uc3RyYWludHNcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKiAgICAgIHZhciBwb2ludCA9IG5ldyBwb2x5MnRyaS5Qb2ludCgxNTAsIDE1MCk7XG4gKiAgICAgIHN3Y3R4LmFkZFBvaW50KHBvaW50KTtcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKiAgICAgIHN3Y3R4LmFkZFBvaW50KHt4OjE1MCwgeToxNTB9KTtcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7WFl9IHBvaW50IC0gYW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIHt4LHl9XG4gKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuYWRkUG9pbnQgPSBmdW5jdGlvbihwb2ludCkge1xuICAgIHRoaXMucG9pbnRzXy5wdXNoKHBvaW50KTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG4vKipcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gKiBAZnVuY3Rpb25cbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmtjb2RlIFN3ZWVwQ29udGV4dCNhZGRQb2ludH0gaW5zdGVhZFxuICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLkFkZFBvaW50ID0gU3dlZXBDb250ZXh0LnByb3RvdHlwZS5hZGRQb2ludDtcblxuXG4vKipcbiAqIEFkZCBzZXZlcmFsIFN0ZWluZXIgcG9pbnRzIHRvIHRoZSBjb25zdHJhaW50c1xuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqICAgICAgdmFyIHBvaW50cyA9IFtcbiAqICAgICAgICAgIG5ldyBwb2x5MnRyaS5Qb2ludCgxNTAsIDE1MCksXG4gKiAgICAgICAgICBuZXcgcG9seTJ0cmkuUG9pbnQoMjAwLCAyNTApLFxuICogICAgICAgICAgbmV3IHBvbHkydHJpLlBvaW50KDI1MCwgMjUwKVxuICogICAgICBdO1xuICogICAgICBzd2N0eC5hZGRQb2ludHMocG9pbnRzKTtcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKiAgICAgIHN3Y3R4LmFkZFBvaW50cyhbe3g6MTUwLCB5OjE1MH0sIHt4OjIwMCwgeToyNTB9LCB7eDoyNTAsIHk6MjUwfV0pO1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtBcnJheS48WFk+fSBwb2ludHMgLSBhcnJheSBvZiBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCB7eCx5fVxuICovXG4vLyBNZXRob2QgYWRkZWQgaW4gdGhlIEphdmFTY3JpcHQgdmVyc2lvbiAod2FzIG5vdCBwcmVzZW50IGluIHRoZSBjKysgdmVyc2lvbilcblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuYWRkUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgdGhpcy5wb2ludHNfID0gdGhpcy5wb2ludHNfLmNvbmNhdChwb2ludHMpO1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cblxuLyoqXG4gKiBUcmlhbmd1bGF0ZSB0aGUgcG9seWdvbiB3aXRoIGhvbGVzIGFuZCBTdGVpbmVyIHBvaW50cy5cbiAqIERvIHRoaXMgQUZURVIgeW91J3ZlIGFkZGVkIHRoZSBwb2x5bGluZSwgaG9sZXMsIGFuZCBTdGVpbmVyIHBvaW50c1xuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqICAgICAgc3djdHgudHJpYW5ndWxhdGUoKTtcbiAqICAgICAgdmFyIHRyaWFuZ2xlcyA9IHN3Y3R4LmdldFRyaWFuZ2xlcygpO1xuICogQHB1YmxpY1xuICovXG4vLyBTaG9ydGN1dCBtZXRob2QgZm9yIHN3ZWVwLnRyaWFuZ3VsYXRlKFN3ZWVwQ29udGV4dCkuXG4vLyBNZXRob2QgYWRkZWQgaW4gdGhlIEphdmFTY3JpcHQgdmVyc2lvbiAod2FzIG5vdCBwcmVzZW50IGluIHRoZSBjKysgdmVyc2lvbilcblN3ZWVwQ29udGV4dC5wcm90b3R5cGUudHJpYW5ndWxhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBzd2VlcC50cmlhbmd1bGF0ZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHByb3ZpZGVkIGNvbnN0cmFpbnRzIChjb250b3VyLCBob2xlcyBhbmQgXG4gKiBTdGVpbnRlciBwb2ludHMpLiBXYXJuaW5nIDogdGhlc2UgdmFsdWVzIGFyZSBub3QgYXZhaWxhYmxlIGlmIHRoZSB0cmlhbmd1bGF0aW9uIFxuICogaGFzIG5vdCBiZWVuIGRvbmUgeWV0LlxuICogQHB1YmxpY1xuICogQHJldHVybnMge3ttaW46UG9pbnQsbWF4OlBvaW50fX0gb2JqZWN0IHdpdGggJ21pbicgYW5kICdtYXgnIFBvaW50XG4gKi9cbi8vIE1ldGhvZCBhZGRlZCBpbiB0aGUgSmF2YVNjcmlwdCB2ZXJzaW9uICh3YXMgbm90IHByZXNlbnQgaW4gdGhlIGMrKyB2ZXJzaW9uKVxuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7bWluOiB0aGlzLnBtaW5fLCBtYXg6IHRoaXMucG1heF99O1xufTtcblxuLyoqXG4gKiBHZXQgcmVzdWx0IG9mIHRyaWFuZ3VsYXRpb24uXG4gKiBUaGUgb3V0cHV0IHRyaWFuZ2xlcyBoYXZlIHZlcnRpY2VzIHdoaWNoIGFyZSByZWZlcmVuY2VzXG4gKiB0byB0aGUgaW5pdGlhbCBpbnB1dCBwb2ludHMgKG5vdCBjb3BpZXMpOiBhbnkgY3VzdG9tIGZpZWxkcyBpbiB0aGVcbiAqIGluaXRpYWwgcG9pbnRzIGNhbiBiZSByZXRyaWV2ZWQgaW4gdGhlIG91dHB1dCB0cmlhbmdsZXMuXG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICogICAgICBzd2N0eC50cmlhbmd1bGF0ZSgpO1xuICogICAgICB2YXIgdHJpYW5nbGVzID0gc3djdHguZ2V0VHJpYW5nbGVzKCk7XG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgY29udG91ciA9IFt7eDoxMDAsIHk6MTAwLCBpZDoxfSwge3g6MTAwLCB5OjMwMCwgaWQ6Mn0sIHt4OjMwMCwgeTozMDAsIGlkOjN9XTtcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqICAgICAgc3djdHgudHJpYW5ndWxhdGUoKTtcbiAqICAgICAgdmFyIHRyaWFuZ2xlcyA9IHN3Y3R4LmdldFRyaWFuZ2xlcygpO1xuICogICAgICB0eXBlb2YgdHJpYW5nbGVzWzBdLmdldFBvaW50KDApLmlkXG4gKiAgICAgIC8vIOKGkiBcIm51bWJlclwiXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7YXJyYXk8VHJpYW5nbGU+fSAgIGFycmF5IG9mIHRyaWFuZ2xlc1xuICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmdldFRyaWFuZ2xlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyaWFuZ2xlc187XG59O1xuXG4vKipcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gKiBAZnVuY3Rpb25cbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmtjb2RlIFN3ZWVwQ29udGV4dCNnZXRUcmlhbmdsZXN9IGluc3RlYWRcbiAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5HZXRUcmlhbmdsZXMgPSBTd2VlcENvbnRleHQucHJvdG90eXBlLmdldFRyaWFuZ2xlcztcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1Td2VlcENvbnRleHQgKHByaXZhdGUgQVBJKVxuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuZnJvbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9udF87XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUucG9pbnRDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c18ubGVuZ3RoO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmhlYWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkXztcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5zZXRIZWFkID0gZnVuY3Rpb24ocDEpIHtcbiAgICB0aGlzLmhlYWRfID0gcDE7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUudGFpbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhaWxfO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLnNldFRhaWwgPSBmdW5jdGlvbihwMSkge1xuICAgIHRoaXMudGFpbF8gPSBwMTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5nZXRNYXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmluaXRUcmlhbmd1bGF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHhtYXggPSB0aGlzLnBvaW50c19bMF0ueDtcbiAgICB2YXIgeG1pbiA9IHRoaXMucG9pbnRzX1swXS54O1xuICAgIHZhciB5bWF4ID0gdGhpcy5wb2ludHNfWzBdLnk7XG4gICAgdmFyIHltaW4gPSB0aGlzLnBvaW50c19bMF0ueTtcblxuICAgIC8vIENhbGN1bGF0ZSBib3VuZHNcbiAgICB2YXIgaSwgbGVuID0gdGhpcy5wb2ludHNfLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50c19baV07XG4gICAgICAgIC8qIGpzaGludCBleHByOnRydWUgKi9cbiAgICAgICAgKHAueCA+IHhtYXgpICYmICh4bWF4ID0gcC54KTtcbiAgICAgICAgKHAueCA8IHhtaW4pICYmICh4bWluID0gcC54KTtcbiAgICAgICAgKHAueSA+IHltYXgpICYmICh5bWF4ID0gcC55KTtcbiAgICAgICAgKHAueSA8IHltaW4pICYmICh5bWluID0gcC55KTtcbiAgICB9XG4gICAgdGhpcy5wbWluXyA9IG5ldyBQb2ludCh4bWluLCB5bWluKTtcbiAgICB0aGlzLnBtYXhfID0gbmV3IFBvaW50KHhtYXgsIHltYXgpO1xuXG4gICAgdmFyIGR4ID0ga0FscGhhICogKHhtYXggLSB4bWluKTtcbiAgICB2YXIgZHkgPSBrQWxwaGEgKiAoeW1heCAtIHltaW4pO1xuICAgIHRoaXMuaGVhZF8gPSBuZXcgUG9pbnQoeG1heCArIGR4LCB5bWluIC0gZHkpO1xuICAgIHRoaXMudGFpbF8gPSBuZXcgUG9pbnQoeG1pbiAtIGR4LCB5bWluIC0gZHkpO1xuXG4gICAgLy8gU29ydCBwb2ludHMgYWxvbmcgeS1heGlzXG4gICAgdGhpcy5wb2ludHNfLnNvcnQoUG9pbnQuY29tcGFyZSk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuaW5pdEVkZ2VzID0gZnVuY3Rpb24ocG9seWxpbmUpIHtcbiAgICB2YXIgaSwgbGVuID0gcG9seWxpbmUubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0aGlzLmVkZ2VfbGlzdC5wdXNoKG5ldyBFZGdlKHBvbHlsaW5lW2ldLCBwb2x5bGluZVsoaSArIDEpICUgbGVuXSkpO1xuICAgIH1cbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzX1tpbmRleF07XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuYWRkVG9NYXAgPSBmdW5jdGlvbih0cmlhbmdsZSkge1xuICAgIHRoaXMubWFwXy5wdXNoKHRyaWFuZ2xlKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5sb2NhdGVOb2RlID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9udF8ubG9jYXRlTm9kZShwb2ludC54KTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVBZHZhbmNpbmdGcm9udCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoZWFkO1xuICAgIHZhciBtaWRkbGU7XG4gICAgdmFyIHRhaWw7XG4gICAgLy8gSW5pdGlhbCB0cmlhbmdsZVxuICAgIHZhciB0cmlhbmdsZSA9IG5ldyBUcmlhbmdsZSh0aGlzLnBvaW50c19bMF0sIHRoaXMudGFpbF8sIHRoaXMuaGVhZF8pO1xuXG4gICAgdGhpcy5tYXBfLnB1c2godHJpYW5nbGUpO1xuXG4gICAgaGVhZCA9IG5ldyBOb2RlKHRyaWFuZ2xlLmdldFBvaW50KDEpLCB0cmlhbmdsZSk7XG4gICAgbWlkZGxlID0gbmV3IE5vZGUodHJpYW5nbGUuZ2V0UG9pbnQoMCksIHRyaWFuZ2xlKTtcbiAgICB0YWlsID0gbmV3IE5vZGUodHJpYW5nbGUuZ2V0UG9pbnQoMikpO1xuXG4gICAgdGhpcy5mcm9udF8gPSBuZXcgQWR2YW5jaW5nRnJvbnQoaGVhZCwgdGFpbCk7XG5cbiAgICBoZWFkLm5leHQgPSBtaWRkbGU7XG4gICAgbWlkZGxlLm5leHQgPSB0YWlsO1xuICAgIG1pZGRsZS5wcmV2ID0gaGVhZDtcbiAgICB0YWlsLnByZXYgPSBtaWRkbGU7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gICAgLyoganNoaW50IHVudXNlZDpmYWxzZSAqL1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLm1hcFRyaWFuZ2xlVG9Ob2RlcyA9IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7ICsraSkge1xuICAgICAgICBpZiAoIXQuZ2V0TmVpZ2hib3IoaSkpIHtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5mcm9udF8ubG9jYXRlUG9pbnQodC5wb2ludENXKHQuZ2V0UG9pbnQoaSkpKTtcbiAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgbi50cmlhbmdsZSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUucmVtb3ZlRnJvbU1hcCA9IGZ1bmN0aW9uKHRyaWFuZ2xlKSB7XG4gICAgdmFyIGksIG1hcCA9IHRoaXMubWFwXywgbGVuID0gbWFwLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKG1hcFtpXSA9PT0gdHJpYW5nbGUpIHtcbiAgICAgICAgICAgIG1hcC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRG8gYSBkZXB0aCBmaXJzdCB0cmF2ZXJzYWwgdG8gY29sbGVjdCB0cmlhbmdsZXNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1RyaWFuZ2xlfSB0cmlhbmdsZSBzdGFydFxuICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLm1lc2hDbGVhbiA9IGZ1bmN0aW9uKHRyaWFuZ2xlKSB7XG4gICAgLy8gTmV3IGltcGxlbWVudGF0aW9uIGF2b2lkcyByZWN1cnNpdmUgY2FsbHMgYW5kIHVzZSBhIGxvb3AgaW5zdGVhZC5cbiAgICAvLyBDZi4gaXNzdWVzICMgNTcsIDY1IGFuZCA2OS5cbiAgICB2YXIgdHJpYW5nbGVzID0gW3RyaWFuZ2xlXSwgdCwgaTtcbiAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgd2hpbGUgKHQgPSB0cmlhbmdsZXMucG9wKCkpIHtcbiAgICAgICAgaWYgKCF0LmlzSW50ZXJpb3IoKSkge1xuICAgICAgICAgICAgdC5zZXRJbnRlcmlvcih0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGVzXy5wdXNoKHQpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdC5jb25zdHJhaW5lZF9lZGdlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHQuZ2V0TmVpZ2hib3IoaSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1FeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0gU3dlZXBDb250ZXh0O1xuXG59LHtcIi4vYWR2YW5jaW5nZnJvbnRcIjoyLFwiLi9wb2ludFwiOjQsXCIuL3BvaW50ZXJyb3JcIjo1LFwiLi9zd2VlcFwiOjcsXCIuL3RyaWFuZ2xlXCI6OX1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIFBvbHkyVHJpIENvcHlyaWdodCAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cbiAqIFxuICogcG9seTJ0cmkuanMgKEphdmFTY3JpcHQgcG9ydCkgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcjNtaS9wb2x5MnRyaS5qc1xuICpcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSAzLWNsYXVzZSBCU0QgTGljZW5zZSwgc2VlIExJQ0VOU0UudHh0XG4gKi9cblxuLyoganNoaW50IG1heGNvbXBsZXhpdHk6MTAgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLypcbiAqIE5vdGVcbiAqID09PT1cbiAqIHRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyBKYXZhU2NyaXB0IHZlcnNpb24gb2YgcG9seTJ0cmkgaW50ZW50aW9uYWxseSBmb2xsb3dzXG4gKiBhcyBjbG9zZWx5IGFzIHBvc3NpYmxlIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIHJlZmVyZW5jZSBDKysgdmVyc2lvbiwgdG8gbWFrZSBpdCBcbiAqIGVhc2llciB0byBrZWVwIHRoZSAyIHZlcnNpb25zIGluIHN5bmMuXG4gKi9cblxudmFyIHh5ID0gX2RlcmVxXyhcIi4veHlcIik7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tVHJpYW5nbGVcbi8qKlxuICogVHJpYW5nbGUgY2xhc3MuPGJyPlxuICogVHJpYW5nbGUtYmFzZWQgZGF0YSBzdHJ1Y3R1cmVzIGFyZSBrbm93biB0byBoYXZlIGJldHRlciBwZXJmb3JtYW5jZSB0aGFuXG4gKiBxdWFkLWVkZ2Ugc3RydWN0dXJlcy5cbiAqIFNlZTogSi4gU2hld2NodWssIFwiVHJpYW5nbGU6IEVuZ2luZWVyaW5nIGEgMkQgUXVhbGl0eSBNZXNoIEdlbmVyYXRvciBhbmRcbiAqIERlbGF1bmF5IFRyaWFuZ3VsYXRvclwiLCBcIlRyaWFuZ3VsYXRpb25zIGluIENHQUxcIlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0cnVjdFxuICogQHBhcmFtIHshWFl9IHBhICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IHBiICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IHBjICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICovXG52YXIgVHJpYW5nbGUgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgLyoqXG4gICAgICogVHJpYW5nbGUgcG9pbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPFhZPn1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50c18gPSBbYSwgYiwgY107XG5cbiAgICAvKipcbiAgICAgKiBOZWlnaGJvciBsaXN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPFRyaWFuZ2xlPn1cbiAgICAgKi9cbiAgICB0aGlzLm5laWdoYm9yc18gPSBbbnVsbCwgbnVsbCwgbnVsbF07XG5cbiAgICAvKipcbiAgICAgKiBIYXMgdGhpcyB0cmlhbmdsZSBiZWVuIG1hcmtlZCBhcyBhbiBpbnRlcmlvciB0cmlhbmdsZT9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJpb3JfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBGbGFncyB0byBkZXRlcm1pbmUgaWYgYW4gZWRnZSBpcyBhIENvbnN0cmFpbmVkIGVkZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48Ym9vbGVhbj59XG4gICAgICovXG4gICAgdGhpcy5jb25zdHJhaW5lZF9lZGdlID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuXG4gICAgLyoqXG4gICAgICogRmxhZ3MgdG8gZGV0ZXJtaW5lIGlmIGFuIGVkZ2UgaXMgYSBEZWxhdW5leSBlZGdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHRoaXMuZGVsYXVuYXlfZWRnZSA9IFtmYWxzZSwgZmFsc2UsIGZhbHNlXTtcbn07XG5cbnZhciBwMnMgPSB4eS50b1N0cmluZztcbi8qKlxuICogRm9yIHByZXR0eSBwcmludGluZyBleC4gPGNvZGU+XCJbKDU7NDIpKDEwOzIwKSgyMTszMCldXCI8L2NvZGU+LlxuICogQHB1YmxpY1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgcDJzKHRoaXMucG9pbnRzX1swXSkgKyBwMnModGhpcy5wb2ludHNfWzFdKSArIHAycyh0aGlzLnBvaW50c19bMl0pICsgXCJdXCIpO1xufTtcblxuLyoqXG4gKiBHZXQgb25lIHZlcnRpY2Ugb2YgdGhlIHRyaWFuZ2xlLlxuICogVGhlIG91dHB1dCB0cmlhbmdsZXMgb2YgYSB0cmlhbmd1bGF0aW9uIGhhdmUgdmVydGljZXMgd2hpY2ggYXJlIHJlZmVyZW5jZXNcbiAqIHRvIHRoZSBpbml0aWFsIGlucHV0IHBvaW50cyAobm90IGNvcGllcyk6IGFueSBjdXN0b20gZmllbGRzIGluIHRoZVxuICogaW5pdGlhbCBwb2ludHMgY2FuIGJlIHJldHJpZXZlZCBpbiB0aGUgb3V0cHV0IHRyaWFuZ2xlcy5cbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBjb250b3VyID0gW3t4OjEwMCwgeToxMDAsIGlkOjF9LCB7eDoxMDAsIHk6MzAwLCBpZDoyfSwge3g6MzAwLCB5OjMwMCwgaWQ6M31dO1xuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICogICAgICBzd2N0eC50cmlhbmd1bGF0ZSgpO1xuICogICAgICB2YXIgdHJpYW5nbGVzID0gc3djdHguZ2V0VHJpYW5nbGVzKCk7XG4gKiAgICAgIHR5cGVvZiB0cmlhbmdsZXNbMF0uZ2V0UG9pbnQoMCkuaWRcbiAqICAgICAgLy8g4oaSIFwibnVtYmVyXCJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHZlcnRpY2UgaW5kZXg6IDAsIDEgb3IgMlxuICogQHB1YmxpY1xuICogQHJldHVybnMge1hZfVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c19baW5kZXhdO1xufTtcblxuLyoqXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICogQGZ1bmN0aW9uXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rY29kZSBUcmlhbmdsZSNnZXRQb2ludH0gaW5zdGVhZFxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUuR2V0UG9pbnQgPSBUcmlhbmdsZS5wcm90b3R5cGUuZ2V0UG9pbnQ7XG5cbi8qKlxuICogR2V0IGFsbCAzIHZlcnRpY2VzIG9mIHRoZSB0cmlhbmdsZSBhcyBhbiBhcnJheVxuICogQHB1YmxpY1xuICogQHJldHVybiB7QXJyYXkuPFhZPn1cbiAqL1xuLy8gTWV0aG9kIGFkZGVkIGluIHRoZSBKYXZhU2NyaXB0IHZlcnNpb24gKHdhcyBub3QgcHJlc2VudCBpbiB0aGUgYysrIHZlcnNpb24pXG5UcmlhbmdsZS5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzXztcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybnMgez9UcmlhbmdsZX1cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLmdldE5laWdoYm9yID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5uZWlnaGJvcnNfW2luZGV4XTtcbn07XG5cbi8qKlxuICogVGVzdCBpZiB0aGlzIFRyaWFuZ2xlIGNvbnRhaW5zIHRoZSBQb2ludCBvYmplY3QgZ2l2ZW4gYXMgcGFyYW1ldGVyIGFzIG9uZSBvZiBpdHMgdmVydGljZXMuXG4gKiBPbmx5IHBvaW50IHJlZmVyZW5jZXMgYXJlIGNvbXBhcmVkLCBub3QgdmFsdWVzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtYWX0gcG9pbnQgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+VHJ1ZTwvY29kZT4gaWYgdGhlIFBvaW50IG9iamVjdCBpcyBvZiB0aGUgVHJpYW5nbGUncyB2ZXJ0aWNlcyxcbiAqICAgICAgICAgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbihwb2ludCkge1xuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICByZXR1cm4gKHBvaW50ID09PSBwb2ludHNbMF0gfHwgcG9pbnQgPT09IHBvaW50c1sxXSB8fCBwb2ludCA9PT0gcG9pbnRzWzJdKTtcbn07XG5cbi8qKlxuICogVGVzdCBpZiB0aGlzIFRyaWFuZ2xlIGNvbnRhaW5zIHRoZSBFZGdlIG9iamVjdCBnaXZlbiBhcyBwYXJhbWV0ZXIgYXMgaXRzXG4gKiBib3VuZGluZyBlZGdlcy4gT25seSBwb2ludCByZWZlcmVuY2VzIGFyZSBjb21wYXJlZCwgbm90IHZhbHVlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAqIEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPlRydWU8L2NvZGU+IGlmIHRoZSBFZGdlIG9iamVjdCBpcyBvZiB0aGUgVHJpYW5nbGUncyBib3VuZGluZ1xuICogICAgICAgICBlZGdlcywgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLmNvbnRhaW5zRWRnZSA9IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluc1BvaW50KGVkZ2UucCkgJiYgdGhpcy5jb250YWluc1BvaW50KGVkZ2UucSk7XG59O1xuXG4vKipcbiAqIFRlc3QgaWYgdGhpcyBUcmlhbmdsZSBjb250YWlucyB0aGUgdHdvIFBvaW50IG9iamVjdHMgZ2l2ZW4gYXMgcGFyYW1ldGVycyBhbW9uZyBpdHMgdmVydGljZXMuXG4gKiBPbmx5IHBvaW50IHJlZmVyZW5jZXMgYXJlIGNvbXBhcmVkLCBub3QgdmFsdWVzLlxuICogQHBhcmFtIHtYWX0gcDEgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHtYWX0gcDIgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLmNvbnRhaW5zUG9pbnRzID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbnNQb2ludChwMSkgJiYgdGhpcy5jb250YWluc1BvaW50KHAyKTtcbn07XG5cbi8qKlxuICogSGFzIHRoaXMgdHJpYW5nbGUgYmVlbiBtYXJrZWQgYXMgYW4gaW50ZXJpb3IgdHJpYW5nbGU/XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLmlzSW50ZXJpb3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcmlvcl87XG59O1xuXG4vKipcbiAqIE1hcmsgdGhpcyB0cmlhbmdsZSBhcyBhbiBpbnRlcmlvciB0cmlhbmdsZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW50ZXJpb3JcbiAqIEByZXR1cm5zIHtUcmlhbmdsZX0gdGhpc1xuICovXG5UcmlhbmdsZS5wcm90b3R5cGUuc2V0SW50ZXJpb3IgPSBmdW5jdGlvbihpbnRlcmlvcikge1xuICAgIHRoaXMuaW50ZXJpb3JfID0gaW50ZXJpb3I7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBuZWlnaGJvciBwb2ludGVycy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1hZfSBwMSAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0ge1hZfSBwMiAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0ge1RyaWFuZ2xlfSB0IFRyaWFuZ2xlIG9iamVjdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBjYW4ndCBmaW5kIG9iamVjdHNcbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLm1hcmtOZWlnaGJvclBvaW50ZXJzID0gZnVuY3Rpb24ocDEsIHAyLCB0KSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmICgocDEgPT09IHBvaW50c1syXSAmJiBwMiA9PT0gcG9pbnRzWzFdKSB8fCAocDEgPT09IHBvaW50c1sxXSAmJiBwMiA9PT0gcG9pbnRzWzJdKSkge1xuICAgICAgICB0aGlzLm5laWdoYm9yc19bMF0gPSB0O1xuICAgIH0gZWxzZSBpZiAoKHAxID09PSBwb2ludHNbMF0gJiYgcDIgPT09IHBvaW50c1syXSkgfHwgKHAxID09PSBwb2ludHNbMl0gJiYgcDIgPT09IHBvaW50c1swXSkpIHtcbiAgICAgICAgdGhpcy5uZWlnaGJvcnNfWzFdID0gdDtcbiAgICB9IGVsc2UgaWYgKChwMSA9PT0gcG9pbnRzWzBdICYmIHAyID09PSBwb2ludHNbMV0pIHx8IChwMSA9PT0gcG9pbnRzWzFdICYmIHAyID09PSBwb2ludHNbMF0pKSB7XG4gICAgICAgIHRoaXMubmVpZ2hib3JzX1syXSA9IHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5MnRyaSBJbnZhbGlkIFRyaWFuZ2xlLm1hcmtOZWlnaGJvclBvaW50ZXJzKCkgY2FsbCcpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRXhoYXVzdGl2ZSBzZWFyY2ggdG8gdXBkYXRlIG5laWdoYm9yIHBvaW50ZXJzXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHshVHJpYW5nbGV9IHRcbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLm1hcmtOZWlnaGJvciA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNfO1xuICAgIGlmICh0LmNvbnRhaW5zUG9pbnRzKHBvaW50c1sxXSwgcG9pbnRzWzJdKSkge1xuICAgICAgICB0aGlzLm5laWdoYm9yc19bMF0gPSB0O1xuICAgICAgICB0Lm1hcmtOZWlnaGJvclBvaW50ZXJzKHBvaW50c1sxXSwgcG9pbnRzWzJdLCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHQuY29udGFpbnNQb2ludHMocG9pbnRzWzBdLCBwb2ludHNbMl0pKSB7XG4gICAgICAgIHRoaXMubmVpZ2hib3JzX1sxXSA9IHQ7XG4gICAgICAgIHQubWFya05laWdoYm9yUG9pbnRlcnMocG9pbnRzWzBdLCBwb2ludHNbMl0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodC5jb250YWluc1BvaW50cyhwb2ludHNbMF0sIHBvaW50c1sxXSkpIHtcbiAgICAgICAgdGhpcy5uZWlnaGJvcnNfWzJdID0gdDtcbiAgICAgICAgdC5tYXJrTmVpZ2hib3JQb2ludGVycyhwb2ludHNbMF0sIHBvaW50c1sxXSwgdGhpcyk7XG4gICAgfVxufTtcblxuXG5UcmlhbmdsZS5wcm90b3R5cGUuY2xlYXJOZWlnaGJvcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm5laWdoYm9yc19bMF0gPSBudWxsO1xuICAgIHRoaXMubmVpZ2hib3JzX1sxXSA9IG51bGw7XG4gICAgdGhpcy5uZWlnaGJvcnNfWzJdID0gbnVsbDtcbn07XG5cblRyaWFuZ2xlLnByb3RvdHlwZS5jbGVhckRlbGF1bmF5RWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRlbGF1bmF5X2VkZ2VbMF0gPSBmYWxzZTtcbiAgICB0aGlzLmRlbGF1bmF5X2VkZ2VbMV0gPSBmYWxzZTtcbiAgICB0aGlzLmRlbGF1bmF5X2VkZ2VbMl0gPSBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9pbnQgY2xvY2t3aXNlIHRvIHRoZSBnaXZlbiBwb2ludC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1hZfSBwIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLnBvaW50Q1cgPSBmdW5jdGlvbihwKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSBwb2ludHNbMF0pIHtcbiAgICAgICAgcmV0dXJuIHBvaW50c1syXTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHBvaW50c1sxXSkge1xuICAgICAgICByZXR1cm4gcG9pbnRzWzBdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gcG9pbnRzWzJdKSB7XG4gICAgICAgIHJldHVybiBwb2ludHNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb2ludCBjb3VudGVyLWNsb2Nrd2lzZSB0byB0aGUgZ2l2ZW4gcG9pbnQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtYWX0gcCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5wb2ludENDVyA9IGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNfO1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHBvaW50c1swXSkge1xuICAgICAgICByZXR1cm4gcG9pbnRzWzFdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gcG9pbnRzWzFdKSB7XG4gICAgICAgIHJldHVybiBwb2ludHNbMl07XG4gICAgfSBlbHNlIGlmIChwID09PSBwb2ludHNbMl0pIHtcbiAgICAgICAgcmV0dXJuIHBvaW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5laWdoYm9yIGNsb2Nrd2lzZSB0byBnaXZlbiBwb2ludC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1hZfSBwIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLm5laWdoYm9yQ1cgPSBmdW5jdGlvbihwKSB7XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzBdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yc19bMV07XG4gICAgfSBlbHNlIGlmIChwID09PSB0aGlzLnBvaW50c19bMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3JzX1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcnNfWzBdO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmVpZ2hib3IgY291bnRlci1jbG9ja3dpc2UgdG8gZ2l2ZW4gcG9pbnQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtYWX0gcCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5uZWlnaGJvckNDVyA9IGZ1bmN0aW9uKHApIHtcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSB0aGlzLnBvaW50c19bMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3JzX1syXTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHRoaXMucG9pbnRzX1sxXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcnNfWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yc19bMV07XG4gICAgfVxufTtcblxuVHJpYW5nbGUucHJvdG90eXBlLmdldENvbnN0cmFpbmVkRWRnZUNXID0gZnVuY3Rpb24ocCkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHRoaXMucG9pbnRzX1swXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW5lZF9lZGdlWzFdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWluZWRfZWRnZVswXTtcbiAgICB9XG59O1xuXG5UcmlhbmdsZS5wcm90b3R5cGUuZ2V0Q29uc3RyYWluZWRFZGdlQ0NXID0gZnVuY3Rpb24ocCkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHRoaXMucG9pbnRzX1swXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW5lZF9lZGdlWzJdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWluZWRfZWRnZVsxXTtcbiAgICB9XG59O1xuXG4vLyBBZGRpdGlvbmFsIGNoZWNrIGZyb20gSmF2YSB2ZXJzaW9uIChzZWUgaXNzdWUgIzg4KVxuVHJpYW5nbGUucHJvdG90eXBlLmdldENvbnN0cmFpbmVkRWRnZUFjcm9zcyA9IGZ1bmN0aW9uKHApIHtcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSB0aGlzLnBvaW50c19bMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWluZWRfZWRnZVswXTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHRoaXMucG9pbnRzX1sxXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW5lZF9lZGdlWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMl07XG4gICAgfVxufTtcblxuVHJpYW5nbGUucHJvdG90eXBlLnNldENvbnN0cmFpbmVkRWRnZUNXID0gZnVuY3Rpb24ocCwgY2UpIHtcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSB0aGlzLnBvaW50c19bMF0pIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW5lZF9lZGdlWzFdID0gY2U7XG4gICAgfSBlbHNlIGlmIChwID09PSB0aGlzLnBvaW50c19bMV0pIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW5lZF9lZGdlWzJdID0gY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW5lZF9lZGdlWzBdID0gY2U7XG4gICAgfVxufTtcblxuVHJpYW5nbGUucHJvdG90eXBlLnNldENvbnN0cmFpbmVkRWRnZUNDVyA9IGZ1bmN0aW9uKHAsIGNlKSB7XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzBdKSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWluZWRfZWRnZVsyXSA9IGNlO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzFdKSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWluZWRfZWRnZVswXSA9IGNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWluZWRfZWRnZVsxXSA9IGNlO1xuICAgIH1cbn07XG5cblRyaWFuZ2xlLnByb3RvdHlwZS5nZXREZWxhdW5heUVkZ2VDVyA9IGZ1bmN0aW9uKHApIHtcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSB0aGlzLnBvaW50c19bMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsYXVuYXlfZWRnZVsxXTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHRoaXMucG9pbnRzX1sxXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxhdW5heV9lZGdlWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGF1bmF5X2VkZ2VbMF07XG4gICAgfVxufTtcblxuVHJpYW5nbGUucHJvdG90eXBlLmdldERlbGF1bmF5RWRnZUNDVyA9IGZ1bmN0aW9uKHApIHtcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSB0aGlzLnBvaW50c19bMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsYXVuYXlfZWRnZVsyXTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHRoaXMucG9pbnRzX1sxXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxhdW5heV9lZGdlWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGF1bmF5X2VkZ2VbMV07XG4gICAgfVxufTtcblxuVHJpYW5nbGUucHJvdG90eXBlLnNldERlbGF1bmF5RWRnZUNXID0gZnVuY3Rpb24ocCwgZSkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHRoaXMucG9pbnRzX1swXSkge1xuICAgICAgICB0aGlzLmRlbGF1bmF5X2VkZ2VbMV0gPSBlO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzFdKSB7XG4gICAgICAgIHRoaXMuZGVsYXVuYXlfZWRnZVsyXSA9IGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWxhdW5heV9lZGdlWzBdID0gZTtcbiAgICB9XG59O1xuXG5UcmlhbmdsZS5wcm90b3R5cGUuc2V0RGVsYXVuYXlFZGdlQ0NXID0gZnVuY3Rpb24ocCwgZSkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHRoaXMucG9pbnRzX1swXSkge1xuICAgICAgICB0aGlzLmRlbGF1bmF5X2VkZ2VbMl0gPSBlO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzFdKSB7XG4gICAgICAgIHRoaXMuZGVsYXVuYXlfZWRnZVswXSA9IGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWxhdW5heV9lZGdlWzFdID0gZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSBuZWlnaGJvciBhY3Jvc3MgdG8gZ2l2ZW4gcG9pbnQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtYWX0gcCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJucyB7VHJpYW5nbGV9XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5uZWlnaGJvckFjcm9zcyA9IGZ1bmN0aW9uKHApIHtcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSB0aGlzLnBvaW50c19bMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3JzX1swXTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHRoaXMucG9pbnRzX1sxXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcnNfWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yc19bMl07XG4gICAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHshVHJpYW5nbGV9IHQgVHJpYW5nbGUgb2JqZWN0LlxuICogQHBhcmFtIHtYWX0gcCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5vcHBvc2l0ZVBvaW50ID0gZnVuY3Rpb24odCwgcCkge1xuICAgIHZhciBjdyA9IHQucG9pbnRDVyhwKTtcbiAgICByZXR1cm4gdGhpcy5wb2ludENXKGN3KTtcbn07XG5cbi8qKlxuICogTGVnYWxpemUgdHJpYW5nbGUgYnkgcm90YXRpbmcgY2xvY2t3aXNlIGFyb3VuZCBvUG9pbnRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1hZfSBvcG9pbnQgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHtYWX0gbnBvaW50IC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBvUG9pbnQgY2FuIG5vdCBiZSBmb3VuZFxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUubGVnYWxpemUgPSBmdW5jdGlvbihvcG9pbnQsIG5wb2ludCkge1xuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAob3BvaW50ID09PSBwb2ludHNbMF0pIHtcbiAgICAgICAgcG9pbnRzWzFdID0gcG9pbnRzWzBdO1xuICAgICAgICBwb2ludHNbMF0gPSBwb2ludHNbMl07XG4gICAgICAgIHBvaW50c1syXSA9IG5wb2ludDtcbiAgICB9IGVsc2UgaWYgKG9wb2ludCA9PT0gcG9pbnRzWzFdKSB7XG4gICAgICAgIHBvaW50c1syXSA9IHBvaW50c1sxXTtcbiAgICAgICAgcG9pbnRzWzFdID0gcG9pbnRzWzBdO1xuICAgICAgICBwb2ludHNbMF0gPSBucG9pbnQ7XG4gICAgfSBlbHNlIGlmIChvcG9pbnQgPT09IHBvaW50c1syXSkge1xuICAgICAgICBwb2ludHNbMF0gPSBwb2ludHNbMl07XG4gICAgICAgIHBvaW50c1syXSA9IHBvaW50c1sxXTtcbiAgICAgICAgcG9pbnRzWzFdID0gbnBvaW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seTJ0cmkgSW52YWxpZCBUcmlhbmdsZS5sZWdhbGl6ZSgpIGNhbGwnKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IG9mIGEgcG9pbnQgaW4gdGhlIHRyaWFuZ2xlLiBcbiAqIFRoZSBwb2ludCAqbXVzdCogYmUgYSByZWZlcmVuY2UgdG8gb25lIG9mIHRoZSB0cmlhbmdsZSdzIHZlcnRpY2VzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WFl9IHAgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybnMge251bWJlcn0gaW5kZXggMCwgMSBvciAyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgcCBjYW4gbm90IGJlIGZvdW5kXG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNfO1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHBvaW50c1swXSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHBvaW50c1sxXSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHBvaW50c1syXSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHkydHJpIEludmFsaWQgVHJpYW5nbGUuaW5kZXgoKSBjYWxsJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtYWX0gcDEgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHtYWX0gcDIgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7bnVtYmVyfSBpbmRleCAwLCAxIG9yIDIsIG9yIC0xIGlmIGVycnJvclxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUuZWRnZUluZGV4ID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwMSA9PT0gcG9pbnRzWzBdKSB7XG4gICAgICAgIGlmIChwMiA9PT0gcG9pbnRzWzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwMiA9PT0gcG9pbnRzWzJdKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocDEgPT09IHBvaW50c1sxXSkge1xuICAgICAgICBpZiAocDIgPT09IHBvaW50c1syXSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAocDIgPT09IHBvaW50c1swXSkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHAxID09PSBwb2ludHNbMl0pIHtcbiAgICAgICAgaWYgKHAyID09PSBwb2ludHNbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKHAyID09PSBwb2ludHNbMV0pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG5cbi8qKlxuICogTWFyayBhbiBlZGdlIG9mIHRoaXMgdHJpYW5nbGUgYXMgY29uc3RyYWluZWQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gZWRnZSBpbmRleFxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUubWFya0NvbnN0cmFpbmVkRWRnZUJ5SW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHRoaXMuY29uc3RyYWluZWRfZWRnZVtpbmRleF0gPSB0cnVlO1xufTtcbi8qKlxuICogTWFyayBhbiBlZGdlIG9mIHRoaXMgdHJpYW5nbGUgYXMgY29uc3RyYWluZWQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFZGdlfSBlZGdlIGluc3RhbmNlXG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5tYXJrQ29uc3RyYWluZWRFZGdlQnlFZGdlID0gZnVuY3Rpb24oZWRnZSkge1xuICAgIHRoaXMubWFya0NvbnN0cmFpbmVkRWRnZUJ5UG9pbnRzKGVkZ2UucCwgZWRnZS5xKTtcbn07XG4vKipcbiAqIE1hcmsgYW4gZWRnZSBvZiB0aGlzIHRyaWFuZ2xlIGFzIGNvbnN0cmFpbmVkLlxuICogVGhpcyBtZXRob2QgdGFrZXMgdHdvIFBvaW50IGluc3RhbmNlcyBkZWZpbmluZyB0aGUgZWRnZSBvZiB0aGUgdHJpYW5nbGUuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtYWX0gcCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0ge1hZfSBxIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLm1hcmtDb25zdHJhaW5lZEVkZ2VCeVBvaW50cyA9IGZ1bmN0aW9uKHAsIHEpIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNfO1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzICAgICAgICBcbiAgICBpZiAoKHEgPT09IHBvaW50c1swXSAmJiBwID09PSBwb2ludHNbMV0pIHx8IChxID09PSBwb2ludHNbMV0gJiYgcCA9PT0gcG9pbnRzWzBdKSkge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMl0gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoKHEgPT09IHBvaW50c1swXSAmJiBwID09PSBwb2ludHNbMl0pIHx8IChxID09PSBwb2ludHNbMl0gJiYgcCA9PT0gcG9pbnRzWzBdKSkge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMV0gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoKHEgPT09IHBvaW50c1sxXSAmJiBwID09PSBwb2ludHNbMl0pIHx8IChxID09PSBwb2ludHNbMl0gJiYgcCA9PT0gcG9pbnRzWzFdKSkge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMF0gPSB0cnVlO1xuICAgIH1cbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tRXhwb3J0cyAocHVibGljIEFQSSlcblxubW9kdWxlLmV4cG9ydHMgPSBUcmlhbmdsZTtcblxufSx7XCIuL3h5XCI6MTF9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogUG9seTJUcmkgQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xuICogXG4gKiBwb2x5MnRyaS5qcyAoSmF2YVNjcmlwdCBwb3J0KSAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yM21pL3BvbHkydHJpLmpzXG4gKiBcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSAzLWNsYXVzZSBCU0QgTGljZW5zZSwgc2VlIExJQ0VOU0UudHh0XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUHJlY2lzaW9uIHRvIGRldGVjdCByZXBlYXRlZCBvciBjb2xsaW5lYXIgcG9pbnRzXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0IHtudW1iZXJ9XG4gKiBAZGVmYXVsdFxuICovXG52YXIgRVBTSUxPTiA9IDFlLTEyO1xuZXhwb3J0cy5FUFNJTE9OID0gRVBTSUxPTjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGVudW0ge251bWJlcn1cbiAqIEByZWFkb25seVxuICovXG52YXIgT3JpZW50YXRpb24gPSB7XG4gICAgXCJDV1wiOiAxLFxuICAgIFwiQ0NXXCI6IC0xLFxuICAgIFwiQ09MTElORUFSXCI6IDBcbn07XG5leHBvcnRzLk9yaWVudGF0aW9uID0gT3JpZW50YXRpb247XG5cblxuLyoqXG4gKiBGb3JtdWxhIHRvIGNhbGN1bGF0ZSBzaWduZWQgYXJlYTxicj5cbiAqIFBvc2l0aXZlIGlmIENDVzxicj5cbiAqIE5lZ2F0aXZlIGlmIENXPGJyPlxuICogMCBpZiBjb2xsaW5lYXI8YnI+XG4gKiA8cHJlPlxuICogQVtQMSxQMixQM10gID0gICh4MSp5MiAtIHkxKngyKSArICh4Mip5MyAtIHkyKngzKSArICh4Myp5MSAtIHkzKngxKVxuICogICAgICAgICAgICAgID0gICh4MS14MykqKHkyLXkzKSAtICh5MS15MykqKHgyLXgzKVxuICogPC9wcmU+XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7IVhZfSBwYSAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBwYiAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBwYyAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge09yaWVudGF0aW9ufVxuICovXG5mdW5jdGlvbiBvcmllbnQyZChwYSwgcGIsIHBjKSB7XG4gICAgdmFyIGRldGxlZnQgPSAocGEueCAtIHBjLngpICogKHBiLnkgLSBwYy55KTtcbiAgICB2YXIgZGV0cmlnaHQgPSAocGEueSAtIHBjLnkpICogKHBiLnggLSBwYy54KTtcbiAgICB2YXIgdmFsID0gZGV0bGVmdCAtIGRldHJpZ2h0O1xuICAgIGlmICh2YWwgPiAtKEVQU0lMT04pICYmIHZhbCA8IChFUFNJTE9OKSkge1xuICAgICAgICByZXR1cm4gT3JpZW50YXRpb24uQ09MTElORUFSO1xuICAgIH0gZWxzZSBpZiAodmFsID4gMCkge1xuICAgICAgICByZXR1cm4gT3JpZW50YXRpb24uQ0NXO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcmllbnRhdGlvbi5DVztcbiAgICB9XG59XG5leHBvcnRzLm9yaWVudDJkID0gb3JpZW50MmQ7XG5cblxuLyoqXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7IVhZfSBwYSAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBwYiAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBwYyAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBwZCAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGluU2NhbkFyZWEocGEsIHBiLCBwYywgcGQpIHtcbiAgICB2YXIgb2FkYiA9IChwYS54IC0gcGIueCkgKiAocGQueSAtIHBiLnkpIC0gKHBkLnggLSBwYi54KSAqIChwYS55IC0gcGIueSk7XG4gICAgaWYgKG9hZGIgPj0gLUVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvYWRjID0gKHBhLnggLSBwYy54KSAqIChwZC55IC0gcGMueSkgLSAocGQueCAtIHBjLngpICogKHBhLnkgLSBwYy55KTtcbiAgICBpZiAob2FkYyA8PSBFUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmluU2NhbkFyZWEgPSBpblNjYW5BcmVhO1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGFuZ2xlIGJldHdlZW4gKHBhLHBiKSBhbmQgKHBhLHBjKSBpcyBvYnR1c2UgaS5lLiAoYW5nbGUgPiDPgC8yIHx8IGFuZ2xlIDwgLc+ALzIpXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7IVhZfSBwYSAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBwYiAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBwYyAgcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYW5nbGUgaXMgb2J0dXNlXG4gKi9cbmZ1bmN0aW9uIGlzQW5nbGVPYnR1c2UocGEsIHBiLCBwYykge1xuICAgIHZhciBheCA9IHBiLnggLSBwYS54O1xuICAgIHZhciBheSA9IHBiLnkgLSBwYS55O1xuICAgIHZhciBieCA9IHBjLnggLSBwYS54O1xuICAgIHZhciBieSA9IHBjLnkgLSBwYS55O1xuICAgIHJldHVybiAoYXggKiBieCArIGF5ICogYnkpIDwgMDtcbn1cbmV4cG9ydHMuaXNBbmdsZU9idHVzZSA9IGlzQW5nbGVPYnR1c2U7XG5cblxufSx7fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIFBvbHkyVHJpIENvcHlyaWdodCAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cbiAqIFxuICogcG9seTJ0cmkuanMgKEphdmFTY3JpcHQgcG9ydCkgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcjNtaS9wb2x5MnRyaS5qc1xuICogXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgMy1jbGF1c2UgQlNEIExpY2Vuc2UsIHNlZSBMSUNFTlNFLnR4dFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG9wZXJhdGUgb24gXCJQb2ludFwiIG9yIGFueSBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCB7eCx5fSxcbiAqIGFzIGRlZmluZWQgYnkgdGhlIHtAbGluayBYWX0gdHlwZVxuICogKFtkdWNrIHR5cGluZ117QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EdWNrX3R5cGluZ30pLlxuICogQG1vZHVsZVxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIHBvbHkydHJpLmpzIHN1cHBvcnRzIHVzaW5nIGN1c3RvbSBwb2ludCBjbGFzcyBpbnN0ZWFkIG9mIHtAbGlua2NvZGUgUG9pbnR9LlxuICogQW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIDxjb2RlPnt4LCB5fTwvY29kZT4gYXR0cmlidXRlcyBpcyBzdXBwb3J0ZWRcbiAqIHRvIGluaXRpYWxpemUgdGhlIFN3ZWVwQ29udGV4dCBwb2x5bGluZXMgYW5kIHBvaW50c1xuICogKFtkdWNrIHR5cGluZ117QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EdWNrX3R5cGluZ30pLlxuICpcbiAqIHBvbHkydHJpLmpzIG1pZ2h0IGFkZCBleHRyYSBmaWVsZHMgdG8gdGhlIHBvaW50IG9iamVjdHMgd2hlbiBjb21wdXRpbmcgdGhlXG4gKiB0cmlhbmd1bGF0aW9uIDogdGhleSBhcmUgcHJlZml4ZWQgd2l0aCA8Y29kZT5fcDJ0XzwvY29kZT4gdG8gYXZvaWQgY29sbGlzaW9uc1xuICogd2l0aCBmaWVsZHMgaW4gdGhlIGN1c3RvbSBjbGFzcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgY29udG91ciA9IFt7eDoxMDAsIHk6MTAwfSwge3g6MTAwLCB5OjMwMH0sIHt4OjMwMCwgeTozMDB9LCB7eDozMDAsIHk6MTAwfV07XG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gWFlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0geCBjb29yZGluYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0geSAtIHkgY29vcmRpbmF0ZVxuICovXG5cblxuLyoqXG4gKiBQb2ludCBwcmV0dHkgcHJpbnRpbmcgOiBwcmludHMgeCBhbmQgeSBjb29yZGluYXRlcy5cbiAqIEBleGFtcGxlXG4gKiAgICAgIHh5LnRvU3RyaW5nQmFzZSh7eDo1LCB5OjQyfSlcbiAqICAgICAgLy8g4oaSIFwiKDU7NDIpXCJcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7IVhZfSBwIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IDxjb2RlPlwiKHg7eSlcIjwvY29kZT5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmdCYXNlKHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgcC54ICsgXCI7XCIgKyBwLnkgKyBcIilcIik7XG59XG5cbi8qKlxuICogUG9pbnQgcHJldHR5IHByaW50aW5nLiBEZWxlZ2F0ZXMgdG8gdGhlIHBvaW50J3MgY3VzdG9tIFwidG9TdHJpbmcoKVwiIG1ldGhvZCBpZiBleGlzdHMsXG4gKiBlbHNlIHNpbXBseSBwcmludHMgeCBhbmQgeSBjb29yZGluYXRlcy5cbiAqIEBleGFtcGxlXG4gKiAgICAgIHh5LnRvU3RyaW5nKHt4OjUsIHk6NDJ9KVxuICogICAgICAvLyDihpIgXCIoNTs0MilcIlxuICogQGV4YW1wbGVcbiAqICAgICAgeHkudG9TdHJpbmcoe3g6NSx5OjQyLHRvU3RyaW5nOmZ1bmN0aW9uKCkge3JldHVybiB0aGlzLngrXCI6XCIrdGhpcy55O319KVxuICogICAgICAvLyDihpIgXCI1OjQyXCJcbiAqIEBwYXJhbSB7IVhZfSBwIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IDxjb2RlPlwiKHg7eSlcIjwvY29kZT5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcocCkge1xuICAgIC8vIFRyeSBhIGN1c3RvbSB0b1N0cmluZyBmaXJzdCwgYW5kIGZhbGxiYWNrIHRvIG93biBpbXBsZW1lbnRhdGlvbiBpZiBub25lXG4gICAgdmFyIHMgPSBwLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIChzID09PSAnW29iamVjdCBPYmplY3RdJyA/IHRvU3RyaW5nQmFzZShwKSA6IHMpO1xufVxuXG5cbi8qKlxuICogQ29tcGFyZSB0d28gcG9pbnRzIGNvbXBvbmVudC13aXNlLiBPcmRlcmVkIGJ5IHkgYXhpcyBmaXJzdCwgdGhlbiB4IGF4aXMuXG4gKiBAcGFyYW0geyFYWX0gYSAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gYiAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtudW1iZXJ9IDxjb2RlPiZsdDsgMDwvY29kZT4gaWYgPGNvZGU+YSAmbHQ7IGI8L2NvZGU+LFxuICogICAgICAgICA8Y29kZT4mZ3Q7IDA8L2NvZGU+IGlmIDxjb2RlPmEgJmd0OyBiPC9jb2RlPiwgXG4gKiAgICAgICAgIDxjb2RlPjA8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgaWYgKGEueSA9PT0gYi55KSB7XG4gICAgICAgIHJldHVybiBhLnggLSBiLng7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEueSAtIGIueTtcbiAgICB9XG59XG5cbi8qKlxuICogVGVzdCB0d28gUG9pbnQgb2JqZWN0cyBmb3IgZXF1YWxpdHkuXG4gKiBAcGFyYW0geyFYWX0gYSAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gYiAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtib29sZWFufSA8Y29kZT5UcnVlPC9jb2RlPiBpZiA8Y29kZT5hID09IGI8L2NvZGU+LCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB0b1N0cmluZzogdG9TdHJpbmcsXG4gICAgdG9TdHJpbmdCYXNlOiB0b1N0cmluZ0Jhc2UsXG4gICAgY29tcGFyZTogY29tcGFyZSxcbiAgICBlcXVhbHM6IGVxdWFsc1xufTtcblxufSx7fV19LHt9LFs2XSlcbig2KVxufSk7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0ZGVmaW5pdGlvbjogMSxcblx0d29ybGRXaWR0aDogMjAsXG5cdHNpbVJlbmRlckZyZXE6IDUwLFxuXHRncmF2aXR5OiBbMCwgLTkuOF0sXG5cdGdyb3Vwczpcblx0e1xuXHRcdGRlZmF1bHQ6XG5cdFx0e1xuXHRcdFx0c3RydWN0dXJlOiAncHJlY2lzZUhleGFGaWxsJyxcblx0XHRcdGlubmVyU3RydWN0dXJlRGVmOiAwLjA0LFxuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0ZGlzdGFuY2VDb25zdHJhaW50OlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3RpZmZuZXNzOiA1MDAsXG5cdFx0XHRcdFx0cmVsYXhhdGlvbjogMC4xXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5vZGVSYWRpdXM6IDAuMSxcblx0XHRcdFx0bWFzczogMVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bGluZTpcblx0XHR7XG5cdFx0XHRzdHJ1Y3R1cmU6ICdsaW5lJyxcblx0XHRcdHBoeXNpY3M6XG5cdFx0XHR7XG5cdFx0XHRcdGRpc3RhbmNlQ29uc3RyYWludDpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHN0aWZmbmVzczogNTAwLFxuXHRcdFx0XHRcdHJlbGF4YXRpb246IDAuMVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRub2RlUmFkaXVzOiAwLjEsXG5cdFx0XHRcdG1hc3M6IDFcblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhcmQ6XG5cdFx0e1xuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0bWFzczogMSxcblx0XHRcdFx0Ym9keVR5cGU6ICdoYXJkJ1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bm9Db2xsaWRlOlxuXHRcdHtcblx0XHRcdHBoeXNpY3M6XG5cdFx0XHR7XG5cdFx0XHRcdG1hc3M6IDEsXG5cdFx0XHRcdGJvZHlUeXBlOiAnaGFyZCcsXG5cdFx0XHRcdG5vQ29sbGlkZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y2xvdWQ6XG5cdFx0e1xuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0bWFzczogMSxcblx0XHRcdFx0Z3Jhdml0eVNjYWxlOiAwLFxuXHRcdFx0XHRib2R5VHlwZTogJ2hhcmQnLFxuXHRcdFx0XHRub0NvbGxpZGU6IHRydWVcblx0XHRcdH1cblx0XHR9LFxuXHRcdG1ldGFsOlxuXHRcdHtcblxuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0bWFzczogMTAsXG5cdFx0XHRcdGJvZHlUeXBlOiAnaGFyZCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdGJhbGxvb246XG5cdFx0e1xuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0bWFzczogMSxcblx0XHRcdFx0Z3Jhdml0eVNjYWxlOiAtMSxcblx0XHRcdFx0Ym9keVR5cGU6ICdoYXJkJ1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3RhdGljOlxuXHRcdHtcblx0XHRcdGZpeGVkOiB0cnVlLFxuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0bWFzczogMCxcblx0XHRcdFx0Ym9keVR5cGU6ICdoYXJkJ1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Z2hvc3Q6XG5cdFx0e1xuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0Ym9keVR5cGU6ICdnaG9zdCdcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbiIsInZhciBHcmlkID1cbntcblx0aW5pdDogZnVuY3Rpb24gKCRncmFwaClcblx0e1xuXHRcdHRoaXMuX2dyYXBoID0gJGdyYXBoO1xuXHRcdHZhciBub2Rlc0FycmF5ID0gdGhpcy5fbm9kZXNBcnJheSA9IFtdO1xuXHRcdHRoaXMuX2dyYXBoLmZvckVhY2goZnVuY3Rpb24gKCRsaW5lKVxuXHRcdHtcblx0XHRcdGlmICgkbGluZSlcblx0XHRcdHtcblx0XHRcdFx0JGxpbmUuZm9yRWFjaChmdW5jdGlvbiAoJG5vZGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoJG5vZGUpIHsgbm9kZXNBcnJheS5wdXNoKCRub2RlKTsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjcmVhdGVGcm9tUG9seWdvbjogZnVuY3Rpb24gKCRwb2x5Z29uLCAkZGVmLCAkaGV4YSlcblx0e1xuXHRcdHZhciBib3VuZGluZ0JveCA9ICRwb2x5Z29uLmdldEJvdW5kaW5nQm94KCk7XG5cblx0XHR2YXIgZGVmID0gJGRlZjtcblx0XHQvL3ZhciBkZWYgPSB3aWR0aCAvICRkZWY7XG5cdFx0dmFyIHRvUmV0dXJuID0gW107XG5cdFx0dmFyIHlJbmMgPSAkaGV4YSA/IGRlZiAqIChNYXRoLnNxcnQoMykgLyAyKSA6IGRlZjtcblx0XHR2YXIgaGFsZkRlZiA9IGRlZiAqIDAuNTtcblx0XHRmb3IgKHZhciB5UG9zID0gYm91bmRpbmdCb3hbMF1bMV07IHlQb3MgPD0gYm91bmRpbmdCb3hbMV1bMV07IHlQb3MgKz0geUluYylcblx0XHR7XG5cdFx0XHR2YXIgbGluZSA9IFtdO1xuXHRcdFx0Ly92YXIgaW50ZXJzZWN0aW9ucyA9ICRwb2x5Z29uLmdldEludGVyc2VjdGlvbnNBdFkoeVBvcyk7XG5cdFx0XHR2YXIgeFBvcyA9IGJvdW5kaW5nQm94WzBdWzBdO1xuXHRcdFx0eFBvcyA9ICgkaGV4YSAmJiB0b1JldHVybi5sZW5ndGggJSAyICE9PSAwKSA/IHhQb3MgKyBoYWxmRGVmIDogeFBvcztcblx0XHRcdGZvciAoeFBvczsgeFBvcyA8PSBib3VuZGluZ0JveFsxXVswXSArIGhhbGZEZWY7IHhQb3MgKz0gZGVmKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoJHBvbHlnb24uaXNJbnNpZGUoW3hQb3MsIHlQb3NdKSkgeyBsaW5lLnB1c2goW3hQb3MsIHlQb3NdKTsgfVxuXHRcdFx0XHRlbHNlIHsgbGluZS5wdXNoKG51bGwpOyB9XG5cdFx0XHR9XG5cdFx0XHR0b1JldHVybi5wdXNoKGxpbmUpO1xuXHRcdH1cblx0XHRyZXR1cm4gT2JqZWN0LmNyZWF0ZShHcmlkKS5pbml0KHRvUmV0dXJuKTtcblx0fSxcblxuXHRnZXRHcmFwaDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZ3JhcGg7IH0sXG5cblx0Z2V0Tm9kZXNBcnJheTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbm9kZXNBcnJheTsgfSxcblxuXHRnZXRDbG9zZXN0OiBmdW5jdGlvbiAoJHgsICR5LCAkc2l6ZSlcblx0e1xuXHRcdHZhciBzaXplID0gJHNpemUgfHwgMTtcblx0XHR2YXIgY2xvc2VzdCA9IHRoaXMuX25vZGVzQXJyYXkuY29uY2F0KCk7XG5cdFx0Y2xvc2VzdC5zb3J0KGZ1bmN0aW9uICgkYSwgJGIpXG5cdFx0e1xuXHRcdFx0aWYgKCRhID09PSBudWxsIHx8ICRiID09PSBudWxsKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHR2YXIgc2lkZVgxID0gTWF0aC5hYnMoJGFbMF0gLSAkeCk7XG5cdFx0XHR2YXIgc2lkZVkxID0gTWF0aC5hYnMoJGFbMV0gLSAkeSk7XG5cdFx0XHR2YXIgZGlzdDEgPSBNYXRoLnNxcnQoc2lkZVgxICogc2lkZVgxICsgc2lkZVkxICogc2lkZVkxKTtcblxuXHRcdFx0dmFyIHNpZGVYMiA9IE1hdGguYWJzKCRiWzBdIC0gJHgpO1xuXHRcdFx0dmFyIHNpZGVZMiA9IE1hdGguYWJzKCRiWzFdIC0gJHkpO1xuXHRcdFx0dmFyIGRpc3QyID0gTWF0aC5zcXJ0KHNpZGVYMiAqIHNpZGVYMiArIHNpZGVZMiAqIHNpZGVZMik7XG5cblx0XHRcdHJldHVybiBkaXN0MSAtIGRpc3QyO1xuXHRcdH0pO1xuXHRcdHJldHVybiBjbG9zZXN0LnNsaWNlKDAsIHNpemUpO1xuXHR9LFxuXG5cdGdldE5laWdoYm91cnM6IGZ1bmN0aW9uICgkeCwgJHksICRyZXR1cm5FbXB0eSlcblx0e1xuXHRcdHZhciB0b1JldHVybiA9IFtdO1xuXHRcdHZhciBncmFwaCA9IHRoaXMuX2dyYXBoO1xuXHRcdHZhciBldmVuID0gJHkgJSAyID4gMDtcblx0XHR2YXIgbGVmdCA9IGV2ZW4gPyAkeCA6ICR4IC0gMTtcblx0XHR2YXIgcmlnaHQgPSBldmVuID8gJHggKyAxIDogJHg7XG5cblx0XHR2YXIgTkUgPSBncmFwaFskeSAtIDFdICYmIGdyYXBoWyR5IC0gMV1bcmlnaHRdID8gZ3JhcGhbJHkgLSAxXVtyaWdodF0gOiBudWxsO1xuXHRcdHZhciBFID0gZ3JhcGhbJHkgKyAwXSAmJiBncmFwaFskeSArIDBdWyR4ICsgMV0gPyBncmFwaFskeV1bJHggKyAxXSA6IG51bGw7XG5cdFx0dmFyIFNFID0gZ3JhcGhbJHkgKyAxXSAmJiBncmFwaFskeSArIDFdW3JpZ2h0XSA/IGdyYXBoWyR5ICsgMV1bcmlnaHRdIDogbnVsbDtcblx0XHR2YXIgU1cgPSBncmFwaFskeSArIDFdICYmIGdyYXBoWyR5ICsgMV1bbGVmdF0gPyBncmFwaFskeSArIDFdW2xlZnRdIDogbnVsbDtcblx0XHR2YXIgVyA9IGdyYXBoWyR5ICsgMF0gJiYgZ3JhcGhbJHkgKyAwXVskeCAtIDFdID8gZ3JhcGhbJHldWyR4IC0gMV0gOiBudWxsO1xuXHRcdHZhciBOVyA9IGdyYXBoWyR5IC0gMV0gJiYgZ3JhcGhbJHkgLSAxXVtsZWZ0XSA/IGdyYXBoWyR5IC0gMV1bbGVmdF0gOiBudWxsO1xuXG5cdFx0aWYgKE5FIHx8ICRyZXR1cm5FbXB0eSkgeyB0b1JldHVybi5wdXNoKE5FKTsgfVxuXHRcdGlmIChFIHx8ICRyZXR1cm5FbXB0eSkgeyB0b1JldHVybi5wdXNoKEUpOyB9XG5cdFx0aWYgKFNFIHx8ICRyZXR1cm5FbXB0eSkgeyB0b1JldHVybi5wdXNoKFNFKTsgfVxuXHRcdGlmIChTVyB8fCAkcmV0dXJuRW1wdHkpIHsgdG9SZXR1cm4ucHVzaChTVyk7IH1cblx0XHRpZiAoVyB8fCAkcmV0dXJuRW1wdHkpIHsgdG9SZXR1cm4ucHVzaChXKTsgfVxuXHRcdGlmIChOVyB8fCAkcmV0dXJuRW1wdHkpIHsgdG9SZXR1cm4ucHVzaChOVyk7IH1cblxuXHRcdHJldHVybiB0b1JldHVybjtcblx0fSxcblxuXHRnZXROZXR3b3JrOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIGdyYXBoID0gdGhpcy5fZ3JhcGg7XG5cdFx0dmFyIG5ldHdvcmsgPSBbXTtcblx0XHR2YXIgdmlzaXRlZCA9IFtdO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgcm93c0xlbmd0aCA9IGdyYXBoLmxlbmd0aDtcblx0XHRmb3IgKGk7IGkgPCByb3dzTGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGsgPSAwO1xuXHRcdFx0dmFyIHBvaW50c0xlbmd0aCA9IGdyYXBoW2ldLmxlbmd0aDtcblx0XHRcdGZvciAoazsgayA8IHBvaW50c0xlbmd0aDsgayArPSAxKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgY3VyclBvaW50ID0gZ3JhcGhbaV1ba107XG5cdFx0XHRcdGlmIChjdXJyUG9pbnQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgY3VyclBvaW50TmVpZ2hib3VycyA9IHRoaXMuZ2V0TmVpZ2hib3VycyhrLCBpKTtcblx0XHRcdFx0XHRmb3IgKHZhciBtID0gMCwgbmVpZ2hib3Vyc0xlbmd0aCA9IGN1cnJQb2ludE5laWdoYm91cnMubGVuZ3RoOyBtIDwgbmVpZ2hib3Vyc0xlbmd0aDsgbSArPSAxKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBjdXJyTmVpZ2ggPSBjdXJyUG9pbnROZWlnaGJvdXJzW21dO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJOZWlnaCAmJiB2aXNpdGVkLmluZGV4T2YoY3Vyck5laWdoKSA9PT0gLTEpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdG5ldHdvcmsucHVzaChbY3VyclBvaW50LCBjdXJyTmVpZ2hdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmlzaXRlZC5wdXNoKGN1cnJQb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5ldHdvcms7XG5cdH0sXG5cblx0Z2V0T3V0bGluZTogZnVuY3Rpb24gKClcblx0e1xuXHRcdGlmICghdGhpcy5vdXRsaW5lKVxuXHRcdHtcblx0XHRcdHZhciBncmFwaCA9IHRoaXMuX2dyYXBoO1xuXHRcdFx0dmFyIG91dGxpbmVHcmFwaCA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIHJvd3NMZW5ndGggPSBncmFwaC5sZW5ndGg7IGkgPCByb3dzTGVuZ3RoOyBpICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdG91dGxpbmVHcmFwaFtpXSA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBrID0gMCwgcG9pbnRzTGVuZ3RoID0gZ3JhcGhbaV0ubGVuZ3RoOyBrIDwgcG9pbnRzTGVuZ3RoOyBrICs9IDEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgcG9pbnQgPSBncmFwaFtpXVtrXTtcblx0XHRcdFx0XHRvdXRsaW5lR3JhcGhbaV1ba10gPSBudWxsO1xuXHRcdFx0XHRcdGlmIChwb2ludClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgaXNFZGdlID0gdGhpcy5nZXROZWlnaGJvdXJzKGssIGkpLmxlbmd0aCA8IDY7XG5cdFx0XHRcdFx0XHRpZiAoaXNFZGdlKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRvdXRsaW5lR3JhcGhbaV1ba10gPSBbaywgaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm91dGxpbmUgPSBPYmplY3QuY3JlYXRlKEdyaWQpLmluaXQob3V0bGluZUdyYXBoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5vdXRsaW5lO1xuXHR9LFxuXG5cdGdldFNoYXBlUGF0aDogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciBwYXRoID0gW107XG5cdFx0dmFyIGN1cnJlbnRPdXRsaW5lID0gdGhpcy5nZXRPdXRsaW5lcygpWzBdO1xuXHRcdHZhciBvdXRsaW5lR3JhcGggPSBjdXJyZW50T3V0bGluZS5nZXRHcmFwaCgpO1xuXHRcdHZhciBnZXRTdGFydGluZ0luZGV4ID0gZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb3V0bGluZUdyYXBoLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIW91dGxpbmVHcmFwaFtpXSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHRmb3IgKHZhciBrID0gMCwgcG9pbnRzTGVuZ3RoID0gb3V0bGluZUdyYXBoW2ldLmxlbmd0aDsgayA8IHBvaW50c0xlbmd0aDsgayArPSAxKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGN1cnJQb2ludCA9IG91dGxpbmVHcmFwaFtpXVtrXTtcblx0XHRcdFx0XHRpZiAoY3VyclBvaW50KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGN1cnJQb2ludCwgY3VycmVudE91dGxpbmUuZ2V0TmVpZ2hib3VycyhjdXJyUG9pbnRbMF0sIGN1cnJQb2ludFsxXSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY3VyclBvaW50ICYmIGN1cnJlbnRPdXRsaW5lLmdldE5laWdoYm91cnMoY3VyclBvaW50WzBdLCBjdXJyUG9pbnRbMV0pLmxlbmd0aCA9PT0gMilcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY3VyclBvaW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgdmlzaXRlZCA9IFtdO1xuXHRcdHZhciBzdGFydGluZ0luZGV4ID0gZ2V0U3RhcnRpbmdJbmRleC5jYWxsKHRoaXMpO1xuXHRcdGNvbnNvbGUubG9nKHN0YXJ0aW5nSW5kZXgpO1xuXHRcdGRlYnVnZ2VyO1xuXHRcdGlmICghc3RhcnRpbmdJbmRleCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBnZXRBbmdsZSA9IGZ1bmN0aW9uICgkaW5kZXgpXG5cdFx0e1xuXHRcdFx0dmFyIGFuZ2xlID0gKCRpbmRleCArIDEpICogNjA7XG5cdFx0XHRhbmdsZSA9IGFuZ2xlID09PSAwID8gMzYwIDogYW5nbGU7XG5cdFx0XHRyZXR1cm4gYW5nbGU7XG5cdFx0fTtcblx0XHR2YXIgZ2V0TmVpZ2hib3VySW5kZXggPSBmdW5jdGlvbiAoJHBvaW50LCAkbmVpZ2hib3VyKVxuXHRcdHtcblx0XHRcdHJldHVybiBjdXJyZW50T3V0bGluZS5nZXROZWlnaGJvdXJzKCRwb2ludFswXSwgJHBvaW50WzFdLCB0cnVlKS5pbmRleE9mKCRuZWlnaGJvdXIpO1xuXHRcdH07XG5cblx0XHR2YXIgbmV4dCA9IGN1cnJlbnRPdXRsaW5lLmdldE5laWdoYm91cnMoc3RhcnRpbmdJbmRleFswXSwgc3RhcnRpbmdJbmRleFsxXSlbMF07XG5cdFx0dmFyIGxhc3RBbmdsZSA9IGdldEFuZ2xlKGdldE5laWdoYm91ckluZGV4KHN0YXJ0aW5nSW5kZXgsIG5leHQpKTtcblx0XHR2YXIgY3VyckluZGV4ID0gbmV4dDtcblx0XHRwYXRoLnB1c2godGhpcy5fZ3JhcGhbc3RhcnRpbmdJbmRleFsxXV1bc3RhcnRpbmdJbmRleFswXV0pO1xuXHRcdHBhdGgucHVzaCh0aGlzLl9ncmFwaFtuZXh0WzFdXVtuZXh0WzBdXSk7XG5cdFx0dmlzaXRlZC5wdXNoKHN0YXJ0aW5nSW5kZXgpO1xuXG5cdFx0dmFyIGJlc3Q7XG5cdFx0dmFyIG5laWdoYm91cnM7XG5cdFx0dmFyIGJlc3RBbmdsZTtcblx0XHR2YXIgb3V0bGluZU5vZGVzQXJyYXkgPSBjdXJyZW50T3V0bGluZS5nZXROb2Rlc0FycmF5KCk7XG5cdFx0dmFyIG91dGxpbmVQb2ludHNMZW5ndGggPSBvdXRsaW5lTm9kZXNBcnJheS5sZW5ndGg7XG5cblx0XHR3aGlsZSAodmlzaXRlZC5sZW5ndGggPCBvdXRsaW5lUG9pbnRzTGVuZ3RoIC0gMSkvL2N1cnJJbmRleCAhPT0gc3RhcnRpbmdJbmRleClcblx0XHR7XG5cdFx0XHRuZWlnaGJvdXJzID0gY3VycmVudE91dGxpbmUuZ2V0TmVpZ2hib3VycyhjdXJySW5kZXhbMF0sIGN1cnJJbmRleFsxXSk7XG5cdFx0XHR2YXIgYmVzdFNjb3JlID0gMDtcblx0XHRcdGJlc3QgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBuZWlnaGJvdXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgY3Vyck5laWdoID0gbmVpZ2hib3Vyc1tpXTtcblx0XHRcdFx0dmFyIGN1cnJTY29yZSA9IDA7XG5cdFx0XHRcdHZhciBjdXJyQW5nbGUgPSBnZXRBbmdsZShnZXROZWlnaGJvdXJJbmRleChjdXJySW5kZXgsIGN1cnJOZWlnaCkpO1xuXHRcdFx0XHRjdXJyU2NvcmUgPSBjdXJyQW5nbGUgLSBsYXN0QW5nbGU7XG5cdFx0XHRcdGlmIChjdXJyU2NvcmUgPiAxODApIHsgY3VyclNjb3JlID0gY3VyclNjb3JlIC0gMzYwOyB9XG5cdFx0XHRcdGlmIChjdXJyU2NvcmUgPCAtMTgwKSB7IGN1cnJTY29yZSA9IGN1cnJTY29yZSArIDM2MDsgfVxuXHRcdFx0XHR2YXIgbmVpZ2hJbmRleCA9IHZpc2l0ZWQuaW5kZXhPZihjdXJyTmVpZ2gpO1xuXHRcdFx0XHRpZiAobmVpZ2hJbmRleCAhPT0gLTEpIHsgY3VyclNjb3JlID0gbmVpZ2hJbmRleCAvIHZpc2l0ZWQubGVuZ3RoICogMTAwMDAgKyAxMDAwMCArIGN1cnJTY29yZTsgfVxuXHRcdFx0XHRpZiAoIWJlc3QgfHwgY3VyclNjb3JlIDwgYmVzdFNjb3JlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YmVzdFNjb3JlID0gY3VyclNjb3JlO1xuXHRcdFx0XHRcdGJlc3QgPSBjdXJyTmVpZ2g7XG5cdFx0XHRcdFx0YmVzdEFuZ2xlID0gY3VyckFuZ2xlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsYXN0QW5nbGUgPSBiZXN0QW5nbGU7XG5cdFx0XHRpZiAodmlzaXRlZC5pbmRleE9mKGN1cnJJbmRleCkgIT09IC0xKSB7IHZpc2l0ZWQuc3BsaWNlKHZpc2l0ZWQuaW5kZXhPZihjdXJySW5kZXgpLCAxKTsgfVxuXHRcdFx0dmlzaXRlZC5wdXNoKGN1cnJJbmRleCk7XG5cdFx0XHRjdXJySW5kZXggPSBiZXN0O1xuXG5cdFx0XHRwYXRoLnB1c2godGhpcy5fZ3JhcGhbY3VyckluZGV4WzFdXVtjdXJySW5kZXhbMF1dKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhdGg7XG5cdH0sXG5cblx0Z2V0T3V0bGluZXM6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgdG9SZXR1cm4gPSBbXTtcblx0XHR2YXIgY3VycmVudEdyYXBoO1xuXHRcdHZhciBvdXRsaW5lID0gdGhpcy5nZXRPdXRsaW5lKCk7XG5cdFx0dmFyIHJlbWFpbmluZyA9IG91dGxpbmUuZ2V0Tm9kZXNBcnJheSgpLmNvbmNhdCgpO1xuXG5cdFx0dmFyIHJlY3VyID0gZnVuY3Rpb24gKCRwb2ludClcblx0XHR7XG5cdFx0XHRjdXJyZW50R3JhcGhbJHBvaW50WzFdXSA9IGN1cnJlbnRHcmFwaFskcG9pbnRbMV1dIHx8IFtdO1xuXHRcdFx0Y3VycmVudEdyYXBoWyRwb2ludFsxXV1bJHBvaW50WzBdXSA9ICRwb2ludDtcblx0XHRcdHZhciBuZWlnaGJvdXJzID0gb3V0bGluZS5nZXROZWlnaGJvdXJzKCRwb2ludFswXSwgJHBvaW50WzFdKTtcblx0XHRcdHJlbWFpbmluZy5zcGxpY2UocmVtYWluaW5nLmluZGV4T2YoJHBvaW50KSwgMSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbmVpZ2hib3Vycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIG5laWdoID0gbmVpZ2hib3Vyc1tpXTtcblx0XHRcdFx0aWYgKHJlbWFpbmluZy5pbmRleE9mKG5laWdoKSAhPT0gLTEpIHsgcmVjdXIobmVpZ2gpOyB9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHdoaWxlIChyZW1haW5pbmcubGVuZ3RoKVxuXHRcdHtcblx0XHRcdGN1cnJlbnRHcmFwaCA9IFtdO1xuXHRcdFx0dmFyIHN0YXJ0aW5nUG9pbnQgPSByZW1haW5pbmdbMF07XG5cdFx0XHRyZWN1cihzdGFydGluZ1BvaW50KTtcblx0XHRcdHRvUmV0dXJuLnB1c2goT2JqZWN0LmNyZWF0ZShHcmlkKS5pbml0KGN1cnJlbnRHcmFwaCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdG9SZXR1cm47XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZDtcblxuIiwidmFyIFBvbHlnb24gPVxue1xuXHRpbml0OiBmdW5jdGlvbiAoJHBvaW50cylcblx0e1xuXHRcdHZhciBwb2x5Z29uID0gT2JqZWN0LmNyZWF0ZShQb2x5Z29uKTtcblx0XHRwb2x5Z29uLnBvaW50cyA9ICRwb2ludHM7XG5cdFx0cG9seWdvbi5fYm91bmRpbmdCb3ggPSB1bmRlZmluZWQ7XG5cdFx0cmV0dXJuIHBvbHlnb247XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciBzdW1BID0gMDtcblx0XHR2YXIgc3VtQiA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyUG9pbnQgPSB0aGlzLnBvaW50c1tpXTtcblx0XHRcdHZhciBuZXh0ID0gaSA9PT0gbGVuZ3RoIC0gMSA/IHRoaXMucG9pbnRzWzBdIDogdGhpcy5wb2ludHNbaSArIDFdO1xuXHRcdFx0c3VtQSArPSBjdXJyUG9pbnRbMF0gKiBuZXh0WzFdO1xuXHRcdFx0c3VtQiArPSBjdXJyUG9pbnRbMV0gKiBuZXh0WzBdO1xuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLmFicygoc3VtQSAtIHN1bUIpICogMC41KTtcblx0fSxcblxuXHRnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKClcblx0e1xuXHRcdGlmICghdGhpcy5fYm91bmRpbmdCb3gpXG5cdFx0e1xuXHRcdFx0dmFyIG1pblggPSB0aGlzLnBvaW50c1swXVswXTtcblx0XHRcdHZhciBtYXhYID0gbWluWDtcblx0XHRcdHZhciBtaW5ZID0gdGhpcy5wb2ludHNbMF1bMV07XG5cdFx0XHR2YXIgbWF4WSA9IG1pblk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHBvaW50ID0gdGhpcy5wb2ludHNbaV07XG5cdFx0XHRcdG1pblggPSBNYXRoLm1pbihtaW5YLCBwb2ludFswXSk7XG5cdFx0XHRcdG1heFggPSBNYXRoLm1heChtYXhYLCBwb2ludFswXSk7XG5cdFx0XHRcdG1pblkgPSBNYXRoLm1pbihtaW5ZLCBwb2ludFsxXSk7XG5cdFx0XHRcdG1heFkgPSBNYXRoLm1heChtYXhZLCBwb2ludFsxXSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9ib3VuZGluZ0JveCA9IFtbbWluWCwgbWluWV0sIFttYXhYLCBtYXhZXV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9ib3VuZGluZ0JveDtcblx0fSxcblxuXHRnZXRTZWdtZW50czogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciBzZWdtZW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0c2VnbWVudHMucHVzaChbdGhpcy5wb2ludHNbaV0sIHRoaXMucG9pbnRzW2kgKyAxXV0pO1xuXHRcdH1cblx0XHRzZWdtZW50cy5wdXNoKFt0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGggLSAxXSwgdGhpcy5wb2ludHNbMF1dKTtcblx0XHRyZXR1cm4gc2VnbWVudHM7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uc0F0WTogZnVuY3Rpb24gKCR0ZXN0WSlcblx0e1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuZ2V0U2VnbWVudHMoKTtcblx0XHR2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3VyclNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHZhciB4MSA9IGN1cnJTZWdtZW50WzBdWzBdO1xuXHRcdFx0dmFyIHkxID0gY3VyclNlZ21lbnRbMF1bMV07XG5cdFx0XHR2YXIgeDIgPSBjdXJyU2VnbWVudFsxXVswXTtcblx0XHRcdHZhciB5MiA9IGN1cnJTZWdtZW50WzFdWzFdO1xuXHRcdFx0dmFyIHNtYWxsWSA9IE1hdGgubWluKHkxLCB5Mik7XG5cdFx0XHR2YXIgYmlnWSA9IE1hdGgubWF4KHkxLCB5Mik7XG5cblx0XHRcdGlmICgkdGVzdFkgPiBzbWFsbFkgJiYgJHRlc3RZIDwgYmlnWSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHBZID0geTIgLSAkdGVzdFk7XG5cdFx0XHRcdHZhciBzZWdZID0geTIgLSB5MTtcblx0XHRcdFx0dmFyIHNlZ1ggPSB4MiAtIHgxO1xuXHRcdFx0XHR2YXIgcFggPSBwWSAqIHNlZ1ggLyBzZWdZO1xuXHRcdFx0XHRpbnRlcnNlY3Rpb25zLnB1c2goeDIgLSBwWCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpbnRlcnNlY3Rpb25zO1xuXHR9LFxuXG5cdGlzSW5zaWRlOiBmdW5jdGlvbiAoJHBvaW50KVxuXHR7XG5cdFx0dmFyIGluZk51bWJlciA9IDA7XG5cdFx0dmFyIGludGVyc2VjdGlvbnMgPSB0aGlzLmdldEludGVyc2VjdGlvbnNBdFkoJHBvaW50WzFdKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaW50ZXJzZWN0aW9ucy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHRpZiAoJHBvaW50WzBdIDwgaW50ZXJzZWN0aW9uc1tpXSkgeyBpbmZOdW1iZXIgKz0gMTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gaW5mTnVtYmVyICUgMiA+IDA7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcblxuIiwiXG52YXIgU1ZHUGFyc2VyID0gZnVuY3Rpb24gKCkge307XG4vL3ZhciBpc1BvbHlnb24gPSAvcG9seWdvbnxyZWN0L2lnO1xudmFyIGlzTGluZSA9IC9wb2x5bGluZXxsaW5lfHBhdGgvaWc7XG52YXIgbGluZVRhZ3MgPSAncG9seWxpbmUsIGxpbmUsIHBhdGgnO1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCR3b3JsZCwgJFNWRylcbntcblx0dGhpcy5TVkcgPSAkU1ZHO1xuXHR0aGlzLnZpZXdCb3hXaWR0aCA9IE51bWJlcih0aGlzLlNWRy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5zcGxpdCgnICcpWzJdKTtcblx0dGhpcy52aWV3Qm94SGVpZ2h0ID0gTnVtYmVyKHRoaXMuU1ZHLmdldEF0dHJpYnV0ZSgndmlld0JveCcpLnNwbGl0KCcgJylbM10pO1xuXHR0aGlzLnJhdGlvID0gJHdvcmxkLmdldFdpZHRoKCkgLyB0aGlzLnZpZXdCb3hXaWR0aDtcblx0dGhpcy53b3JsZCA9ICR3b3JsZDtcblx0dGhpcy53b3JsZC5zZXRIZWlnaHQodGhpcy52aWV3Qm94SGVpZ2h0ICogdGhpcy5yYXRpbyk7XG5cblx0Ly90ZW1wXG5cdHZhciBlbGVtZW50c1F1ZXJ5ID0gJyo6bm90KGcpOm5vdChsaW5lYXJHcmFkaWVudCk6bm90KHJhZGlhbEdyYWRpZW50KTpub3Qoc3RvcCk6bm90KFtpZCo9XCJqb2ludFwiXSk6bm90KFtpZCo9XCJjb25zdHJhaW50XCJdKSc7XG5cdHZhciBlbGVtUmF3cyA9IHRoaXMuU1ZHLnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudHNRdWVyeSk7XG5cblx0dmFyIGkgPSAwO1xuXHR2YXIgcmF3R3JvdXBQYWlyaW5ncyA9IFtdO1xuXHR2YXIgZWxlbXNMZW5ndGggPSBlbGVtUmF3cy5sZW5ndGg7XG5cblx0Zm9yIChpID0gMDsgaSA8IGVsZW1zTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgcmF3RWxlbWVudCA9IGVsZW1SYXdzW2ldO1xuXHRcdC8vaWYgKHJhd0VsZW1lbnQubm9kZVR5cGUgPT09IDMpIHsgY29udGludWU7IH1cblx0XHR2YXIgZ3JvdXBJbmZvcyA9IHRoaXMuZ2V0R3JvdXBJbmZvcyhyYXdFbGVtZW50KTtcblx0XHR2YXIgY3Vyckdyb3VwID0gJHdvcmxkLmNyZWF0ZUdyb3VwKGdyb3VwSW5mb3MudHlwZSwgZ3JvdXBJbmZvcy5JRCk7XG5cblx0XHQvL3ZhciBlbGVtZW50cyA9IHJhd0VsZW1lbnQ7XG5cdFx0Ly90aGlzLnBhcnNlRWxlbWVudHMoZWxlbWVudHMsIGN1cnJHcm91cCk7XG5cblx0XHR2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VFbGVtZW50KHJhd0VsZW1lbnQpO1xuXHRcdHZhciBub2Rlc1RvRHJhdyA9IGN1cnJHcm91cC5zdHJ1Y3R1cmUuY3JlYXRlKGVsZW1lbnQpO1xuXHRcdHRoaXMuc2V0R3JhcGhpY0luc3RydWN0aW9ucyhjdXJyR3JvdXAsIHJhd0VsZW1lbnQsIG5vZGVzVG9EcmF3LCBlbGVtZW50KTtcblxuXHRcdC8vIHZhciBoYXNHcm91cDtcblx0XHQvLyBmb3IgKHZhciBrID0gMCwgbGVuZ3RoID0gcmF3R3JvdXBQYWlyaW5ncy5sZW5ndGg7IGsgPCBsZW5ndGg7IGsgKz0gMSlcblx0XHQvLyB7XG5cdFx0Ly8gXHR2YXIgY3VyciA9IHJhd0dyb3VwUGFpcmluZ3Nba107XG5cdFx0Ly8gXHRpZiAoY3Vyci5ncm91cCA9PT0gY3Vyckdyb3VwKVxuXHRcdC8vIFx0e1xuXHRcdC8vIFx0XHRoYXNHcm91cCA9IHRydWU7XG5cdFx0Ly8gXHRcdGJyZWFrO1xuXHRcdC8vIFx0fVxuXHRcdC8vIH1cblx0XHQvLyBpZiAoIWhhc0dyb3VwKSB7IHJhd0dyb3VwUGFpcmluZ3MucHVzaCh7IGdyb3VwOiBjdXJyR3JvdXAsIHJhdzogcmF3RWxlbWVudC5wYXJlbnROb2RlIH0pOyB9XG5cdFx0cmF3R3JvdXBQYWlyaW5ncy5wdXNoKHsgZ3JvdXA6IGN1cnJHcm91cCwgcmF3OiByYXdFbGVtZW50LnBhcmVudE5vZGUgfSk7XG5cdH1cblxuXHR2YXIgcGFpcmluZ3NMZW5ndGggPSByYXdHcm91cFBhaXJpbmdzLmxlbmd0aDtcblx0Zm9yIChpID0gMDsgaSA8IHBhaXJpbmdzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgcGFpcmluZyA9IHJhd0dyb3VwUGFpcmluZ3NbaV07XG5cdFx0Ly8gdGhpcy5wYXJzZUFuY2hvcnMocGFpcmluZy5yYXcsIHBhaXJpbmcuZ3JvdXApO1xuXHRcdHRoaXMucGFyc2VDb25zdHJhaW50cyhwYWlyaW5nLnJhdywgcGFpcmluZy5ncm91cCk7XG5cdFx0dGhpcy5wYXJzZUN1c3RvbUpvaW50cyhwYWlyaW5nLnJhdywgcGFpcmluZy5ncm91cCk7XG5cdH1cblxuXHR0aGlzLndvcmxkLmFkZEdyb3Vwc1RvV29ybGQoKTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuZ2V0R3JvdXBJbmZvcyA9IGZ1bmN0aW9uICgkcmF3R3JvdXApXG57XG5cdHZhciBncm91cEVsZW1lbnQgPSAhJHJhd0dyb3VwLmlkICYmICRyYXdHcm91cC5wYXJlbnROb2RlLnRhZ05hbWUgIT09ICdzdmcnID8gJHJhd0dyb3VwLnBhcmVudE5vZGUgOiAkcmF3R3JvdXA7XG5cdHZhciB0eXBlO1xuXHR2YXIgSUQ7XG5cdHZhciByZWdleCA9IC8oW2EtelxcZF0rKVxcdyovaWdtO1xuXHR2YXIgZmlyc3QgPSByZWdleC5leGVjKGdyb3VwRWxlbWVudC5pZCk7XG5cdHZhciBzZWNvbmQgPSByZWdleC5leGVjKGdyb3VwRWxlbWVudC5pZCk7XG5cdC8vaWYgKGZpcnN0KSB7IHR5cGUgPSBzZWNvbmQgPyBzZWNvbmRbMV0gOiBmaXJzdFsxXTsgfVxuXHQvL3ZhciBncm91cFR5cGUgPSBncm91cEVsZW1lbnQuaWQubWF0Y2goKTtcblx0Ly9pZiAoZ3JvdXBUeXBlKSB7IHJldHVybiBncm91cFR5cGVbMV0gfHwgZ3JvdXBUeXBlWzBdOyB9XG5cdC8vYXV0b21hdGljIGZvciBsaW5lc1xuXHRpZiAoIWZpcnN0ICYmIChncm91cEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChsaW5lVGFncykubGVuZ3RoID4gMCB8fCBncm91cEVsZW1lbnQudGFnTmFtZS5zZWFyY2goaXNMaW5lKSA+IC0xKSlcblx0e1xuXHRcdHR5cGUgPSAnbGluZSc7XG5cdH1cblx0dHlwZSA9IGZpcnN0ID8gZmlyc3RbMV0gOiB1bmRlZmluZWQ7XG5cdElEID0gc2Vjb25kID8gc2Vjb25kWzFdIDogbnVsbDtcblxuXHRyZXR1cm4geyBJRDogSUQsIHR5cGU6IHR5cGUgfTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2VDb25zdHJhaW50cyA9IGZ1bmN0aW9uICgkcmF3R3JvdXAsICRncm91cClcbntcblx0dmFyIGNoaWxkcmVuID0gJHJhd0dyb3VwLmNoaWxkTm9kZXM7Ly8kcmF3R3JvdXAucXVlcnlTZWxlY3RvckFsbCgnW2lkKj1cImNvbnN0cmFpbnRcIl0nKTtcblxuXHRmb3IgKHZhciBpID0gMCwgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0aWYgKGNoaWxkcmVuW2ldLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSB8fCBjaGlsZHJlbltpXS5pZC5zZWFyY2goL2NvbnN0cmFpbnQvaSkgPCAwKSB7IGNvbnRpbnVlOyB9XG5cdFx0dmFyIGN1cnJDb25zdHJhaW50ID0gY2hpbGRyZW5baV07XG5cdFx0dmFyIHJlc3VsdCA9IC9jb25zdHJhaW50LShbYS16XFxkXSopL2lnLmV4ZWMoY3VyckNvbnN0cmFpbnQuaWQpO1xuXG5cdFx0dmFyIHBhcmVudEdyb3VwSUQgPSByZXN1bHQgPyByZXN1bHRbMV0gOiB1bmRlZmluZWQ7XG5cdFx0dmFyIHBhcmVudEdyb3VwID0gcGFyZW50R3JvdXBJRCA/IHRoaXMud29ybGQuZ2V0R3JvdXBCeUlEKHBhcmVudEdyb3VwSUQpIDogdW5kZWZpbmVkO1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBhcnNlRWxlbWVudChjdXJyQ29uc3RyYWludCkucG9pbnRzO1xuXHRcdC8vIGNvbnNvbGUubG9nKCRncm91cC5JRCwgcGFyZW50R3JvdXAgPyBwYXJlbnRHcm91cC5JRCA6IHVuZGVmaW5lZCk7XG5cdFx0dGhpcy53b3JsZC5jb25zdHJhaW5Hcm91cHMoJGdyb3VwLCBwYXJlbnRHcm91cCwgcG9pbnRzKTtcblx0fVxufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5wYXJzZUVsZW1lbnRzID0gZnVuY3Rpb24gKCRlbGVtZW50cywgJGdyb3VwKVxue1xuXHRmb3IgKHZhciBpID0gMCwgZWxlbWVudHNMZW5ndGggPSAkZWxlbWVudHMubGVuZ3RoOyBpIDwgZWxlbWVudHNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciByYXdFbGVtZW50ID0gJGVsZW1lbnRzW2ldO1xuXG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlRWxlbWVudChyYXdFbGVtZW50KTtcblxuXHRcdHZhciBub2Rlc1RvRHJhdyA9ICRncm91cC5zdHJ1Y3R1cmUuY3JlYXRlKGVsZW1lbnQpO1xuXHRcdHRoaXMuc2V0R3JhcGhpY0luc3RydWN0aW9ucygkZ3JvdXAsIHJhd0VsZW1lbnQsIG5vZGVzVG9EcmF3LCBlbGVtZW50KTtcblx0fVxufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5wYXJzZUVsZW1lbnQgPSBmdW5jdGlvbiAoJHJhd0VsZW1lbnQpXG57XG5cdHZhciB0YWdOYW1lID0gJHJhd0VsZW1lbnQudGFnTmFtZTtcblxuXHRzd2l0Y2ggKHRhZ05hbWUpXG5cdHtcblx0XHRjYXNlICdsaW5lJzpcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlTGluZSgkcmF3RWxlbWVudCk7XG5cdFx0Y2FzZSAncmVjdCc6XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZVJlY3QoJHJhd0VsZW1lbnQpO1xuXG5cdFx0Y2FzZSAncG9seWdvbic6XG5cdFx0Y2FzZSAncG9seWxpbmUnOlxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VQb2x5KCRyYXdFbGVtZW50KTtcblxuXHRcdGNhc2UgJ3BhdGgnOlxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VQYXRoKCRyYXdFbGVtZW50KTtcblxuXHRcdGNhc2UgJ2NpcmNsZSc6XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNpcmNsZSgkcmF3RWxlbWVudCk7XG5cdH1cbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuc2V0R3JhcGhpY0luc3RydWN0aW9ucyA9IGZ1bmN0aW9uICgkZ3JvdXAsICRyYXdFbGVtZW50LCAkbm9kZXMpXG57XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSAkbm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3Vyck5vZGUgPSAkbm9kZXNbaV07XG5cdFx0Y3Vyck5vZGUuZHJhd2luZyA9IHt9O1xuXHRcdCRncm91cC5ub2Rlcy5zcGxpY2UoJGdyb3VwLm5vZGVzLmluZGV4T2YoY3Vyck5vZGUpLCAxKTtcblx0XHQkZ3JvdXAubm9kZXMuc3BsaWNlKGksIDAsIGN1cnJOb2RlKTtcblx0XHQvLyBjb25zb2xlLmxvZygkZ3JvdXAubm9kZXMuaW5kZXhPZihjdXJyTm9kZSkpO1xuXHRcdC8vIGRlYnVnZ2VyO1xuXHR9XG5cdHZhciBzdGFydE5vZGUgPSAkbm9kZXNbMF07XG5cdHZhciBlbmROb2RlID0gJG5vZGVzWyRub2Rlcy5sZW5ndGggLSAxXTtcblxuXHR2YXIgZmlsbCA9ICRyYXdFbGVtZW50LmdldEF0dHJpYnV0ZSgnZmlsbCcpIHx8ICcjMDAwMDAwJztcblx0dmFyIHN0cm9rZSA9ICRyYXdFbGVtZW50LmdldEF0dHJpYnV0ZSgnc3Ryb2tlJykgfHwgJ25vbmUnO1xuXHR2YXIgbGluZVdpZHRoID0gJHJhd0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnKTtcblx0dmFyIG9wYWNpdHkgPSAkcmF3RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29wYWNpdHknKTtcblx0c3RhcnROb2RlLmRyYXdpbmcuZmlsbCA9IGZpbGw7Ly9maWxsID09PSB1bmRlZmluZWQgPyAnbm9uZScgOiBmaWxsO1xuXHRzdGFydE5vZGUuZHJhd2luZy5zdHJva2UgPSBzdHJva2U7XG5cdHN0YXJ0Tm9kZS5kcmF3aW5nLnJhZGl1cyA9ICRncm91cC5zdHJ1Y3R1cmVQcm9wZXJ0aWVzLnJhZGl1cyAvIHRoaXMucmF0aW87XG5cdHN0YXJ0Tm9kZS5kcmF3aW5nLmxpbmVXaWR0aCA9IGxpbmVXaWR0aCAqIHRoaXMucmF0aW8gfHwgMSAqIHRoaXMucmF0aW87Ly9saW5lV2lkdGggPT09IHVuZGVmaW5lZCA/ICdub25lJyA6IGxpbmVXaWR0aCAqIHRoaXMucmF0aW87XG5cdHN0YXJ0Tm9kZS5kcmF3aW5nLmxpbmVDYXAgPSAkcmF3RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJykgfHwgJ3JvdW5kJztcblx0c3RhcnROb2RlLmRyYXdpbmcubGluZUpvaW4gPSAkcmF3RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicpIHx8ICdyb3VuZCc7XG5cdHN0YXJ0Tm9kZS5kcmF3aW5nLm9wYWNpdHkgPSBvcGFjaXR5ID8gb3BhY2l0eSA6IHVuZGVmaW5lZDtcblx0c3RhcnROb2RlLmRyYXdpbmcuY2xvc2VQYXRoID0gJGdyb3VwLnR5cGUgIT09ICdsaW5lJyAmJiAkZ3JvdXAuc3RydWN0dXJlUHJvcGVydGllcy5yYWRpdXMgPT09IHVuZGVmaW5lZDtcblxuXHRzdGFydE5vZGUuZHJhd2luZy5zdHJva2VHcmFkaWVudCA9IHRoaXMuZ2V0R3JhZGllbnQoc3Ryb2tlKTtcblx0c3RhcnROb2RlLmRyYXdpbmcuZmlsbEdyYWRpZW50ID0gdGhpcy5nZXRHcmFkaWVudChmaWxsKTtcblxuXHRzdGFydE5vZGUuZW5kTm9kZSA9IGVuZE5vZGU7XG5cdHN0YXJ0Tm9kZS5pc1N0YXJ0ID0gdHJ1ZTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuZ2V0R3JhZGllbnQgPSBmdW5jdGlvbiAoJHZhbHVlKVxue1xuXHR2YXIgZ3JhZGllbnRJRCA9IC91cmxcXCgjKC4qKVxcKS9pbS5leGVjKCR2YWx1ZSk7XG5cdGlmIChncmFkaWVudElEKVxuXHR7XG5cdFx0dmFyIGdyYWRpZW50RWxlbWVudCA9IHRoaXMuU1ZHLnF1ZXJ5U2VsZWN0b3IoJyMnICsgZ3JhZGllbnRJRFsxXSk7XG5cdFx0aWYgKGdyYWRpZW50RWxlbWVudC50YWdOYW1lICE9PSAnbGluZWFyR3JhZGllbnQnICYmIGdyYWRpZW50RWxlbWVudC50YWdOYW1lICE9PSAncmFkaWFsR3JhZGllbnQnKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGdyYWRpZW50ID0geyBzdG9wczogW10sIHR5cGU6IGdyYWRpZW50RWxlbWVudC50YWdOYW1lIH07XG5cblx0XHRpZiAoZ3JhZGllbnRFbGVtZW50LnRhZ05hbWUgPT09ICdsaW5lYXJHcmFkaWVudCcpXG5cdFx0e1xuXHRcdFx0Z3JhZGllbnQueDEgPSB0aGlzLmdldENvb3JkWChncmFkaWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4MScpKTtcblx0XHRcdGdyYWRpZW50LnkxID0gdGhpcy5nZXRDb29yZFgoZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgneTEnKSk7XG5cdFx0XHRncmFkaWVudC54MiA9IHRoaXMuZ2V0Q29vcmRYKGdyYWRpZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3gyJykpO1xuXHRcdFx0Z3JhZGllbnQueTIgPSB0aGlzLmdldENvb3JkWChncmFkaWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCd5MicpKTtcblx0XHR9XG5cdFx0aWYgKGdyYWRpZW50RWxlbWVudC50YWdOYW1lID09PSAncmFkaWFsR3JhZGllbnQnKVxuXHRcdHtcblx0XHRcdGdyYWRpZW50LmN4ID0gdGhpcy5nZXRDb29yZFgoZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnY3gnKSk7XG5cdFx0XHRncmFkaWVudC5jeSA9IHRoaXMuZ2V0Q29vcmRYKGdyYWRpZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2N5JykpO1xuXHRcdFx0Z3JhZGllbnQuZnggPSB0aGlzLmdldENvb3JkWChncmFkaWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmeCcpKTtcblx0XHRcdGdyYWRpZW50LmZ5ID0gdGhpcy5nZXRDb29yZFgoZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZnknKSk7XG5cdFx0XHRncmFkaWVudC5yID0gdGhpcy5nZXRDb29yZFgoZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgncicpKTtcblx0XHR9XG5cblx0XHR2YXIgc3RvcHMgPSBncmFkaWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3RvcCcpO1xuXHRcdGZvciAodmFyIGsgPSAwLCBzdG9wTGVuZ3RoID0gc3RvcHMubGVuZ3RoOyBrIDwgc3RvcExlbmd0aDsgayArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyU3RvcCA9IHN0b3BzW2tdO1xuXHRcdFx0dmFyIG9mZnNldCA9IE51bWJlcihjdXJyU3RvcC5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpKTtcblx0XHRcdHZhciBjb2xvciA9IC9zdG9wLWNvbG9yOigjWzAtOUEtRl0rKS9pbS5leGVjKGN1cnJTdG9wLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSlbMV07XG5cdFx0XHRncmFkaWVudC5zdG9wcy5wdXNoKHsgb2Zmc2V0OiBvZmZzZXQsIGNvbG9yOiBjb2xvciB9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZ3JhZGllbnQ7XG5cdH1cbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2VDaXJjbGUgPSBmdW5jdGlvbiAoJHJhd0NpcmNsZSlcbntcblx0dmFyIHhQb3MgPSB0aGlzLmdldENvb3JkWCgkcmF3Q2lyY2xlLmdldEF0dHJpYnV0ZSgnY3gnKSk7XG5cdHZhciB5UG9zID0gdGhpcy5nZXRDb29yZFkoJHJhd0NpcmNsZS5nZXRBdHRyaWJ1dGUoJ2N5JykpO1xuXHR2YXIgcmFkaXVzID0gdGhpcy5nZXRDb29yZFgoJHJhd0NpcmNsZS5nZXRBdHRyaWJ1dGUoJ3InKSk7XG5cdHJldHVybiB7IHR5cGU6ICdjaXJjbGUnLCBwb2ludHM6IFtbeFBvcywgeVBvc11dLCByYWRpdXM6IHJhZGl1cyB9O1xufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpbmUgPSBmdW5jdGlvbiAoJHJhd0xpbmUpXG57XG5cdHZhciB4MSA9IHRoaXMuZ2V0Q29vcmRYKCRyYXdMaW5lLmdldEF0dHJpYnV0ZSgneDEnKSk7XG5cdHZhciB4MiA9IHRoaXMuZ2V0Q29vcmRYKCRyYXdMaW5lLmdldEF0dHJpYnV0ZSgneDInKSk7XG5cdHZhciB5MSA9IHRoaXMuZ2V0Q29vcmRYKCRyYXdMaW5lLmdldEF0dHJpYnV0ZSgneTEnKSk7XG5cdHZhciB5MiA9IHRoaXMuZ2V0Q29vcmRYKCRyYXdMaW5lLmdldEF0dHJpYnV0ZSgneTInKSk7XG5cdHZhciBwb2ludHMgPSBbXTtcblx0cG9pbnRzLnB1c2goW3gxLCB5MV0pO1xuXHRwb2ludHMucHVzaChbeDIsIHkyXSk7XG5cdHZhciB0aGlja25lc3MgPSB0aGlzLmdldENvb3JkWCgkcmF3TGluZS5nZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcpKTtcblx0cmV0dXJuIHsgdHlwZTogJ2xpbmUnLCBwb2ludHM6IHBvaW50cywgdGhpY2tuZXNzOiB0aGlja25lc3MgfTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2VSZWN0ID0gZnVuY3Rpb24gKCRyYXdSZWN0KVxue1xuXHR2YXIgeDEgPSAkcmF3UmVjdC5nZXRBdHRyaWJ1dGUoJ3gnKSA/IHRoaXMuZ2V0Q29vcmRYKCRyYXdSZWN0LmdldEF0dHJpYnV0ZSgneCcpKSA6IDA7XG5cdHZhciB5MSA9ICRyYXdSZWN0LmdldEF0dHJpYnV0ZSgneScpID8gdGhpcy5nZXRDb29yZFkoJHJhd1JlY3QuZ2V0QXR0cmlidXRlKCd5JykpIDogMDtcblx0dmFyIHgyID0geDEgKyB0aGlzLmdldENvb3JkWCgkcmF3UmVjdC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO1xuXHR2YXIgeTIgPSB5MSArIHRoaXMuZ2V0Q29vcmRZKCRyYXdSZWN0LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO1xuXHR2YXIgcG9pbnRzID0gW107XG5cdHBvaW50cy5wdXNoKFt4MSwgeTFdKTtcblx0cG9pbnRzLnB1c2goW3gxLCB5Ml0pO1xuXHRwb2ludHMucHVzaChbeDIsIHkyXSk7XG5cdHBvaW50cy5wdXNoKFt4MiwgeTFdKTtcblxuXHRyZXR1cm4geyB0eXBlOiAncG9seWdvbicsIHBvaW50czogcG9pbnRzIH07XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlUG9seSA9IGZ1bmN0aW9uICgkcmF3UG9seSlcbntcblx0dmFyIHNwbGl0cyA9ICRyYXdQb2x5LmdldEF0dHJpYnV0ZSgncG9pbnRzJykuc3BsaXQoJyAnKTtcblx0dmFyIHBvaW50cyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwLCBzcGxpdHNMZW5ndGggPSBzcGxpdHMubGVuZ3RoOyBpIDwgc3BsaXRzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyclNwbGl0ID0gc3BsaXRzW2ldO1xuXG5cdFx0aWYgKGN1cnJTcGxpdCAhPT0gJycpXG5cdFx0e1xuXHRcdFx0dmFyIHBvaW50ID0gY3VyclNwbGl0LnNwbGl0KCcsJyk7XG5cdFx0XHR2YXIgcG9pbnRYID0gdGhpcy5nZXRDb29yZFgocG9pbnRbMF0pO1xuXHRcdFx0dmFyIHBvaW50WSA9IHRoaXMuZ2V0Q29vcmRZKHBvaW50WzFdKTtcblx0XHRcdHZhciBleGlzdHMgPSBmYWxzZTtcblx0XHRcdGZvciAodmFyIGsgPSAwLCBvdGhlckNvb3Jkc0FycmF5TGVuZ3RoID0gcG9pbnRzLmxlbmd0aDsgayA8IG90aGVyQ29vcmRzQXJyYXlMZW5ndGg7IGsgKz0gMSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIG90aGVyUG9pbnQgPSBwb2ludHNba107XG5cdFx0XHRcdHZhciBvdGhlclggPSBvdGhlclBvaW50WzBdO1xuXHRcdFx0XHR2YXIgb3RoZXJZID0gb3RoZXJQb2ludFsxXTtcblx0XHRcdFx0aWYgKG90aGVyWCA9PT0gcG9pbnRYICYmIG90aGVyWSA9PT0gcG9pbnRZKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZXhpc3RzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGV4aXN0cyA9PT0gZmFsc2UpXG5cdFx0XHR7XG5cdFx0XHRcdHBvaW50cy5wdXNoKFtwb2ludFgsIHBvaW50WV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciB0aGlja25lc3MgPSB0aGlzLmdldENvb3JkWCgkcmF3UG9seS5nZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcpKTtcblx0dmFyIHR5cGUgPSAkcmF3UG9seS50YWdOYW1lID09PSAncG9seWxpbmUnID8gJ2xpbmUnIDogJ3BvbHlnb24nO1xuXHRyZXR1cm4geyB0eXBlOiB0eXBlLCBwb2ludHM6IHBvaW50cywgdGhpY2tuZXNzOiB0aGlja25lc3MgfTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2VQYXRoID0gZnVuY3Rpb24gKCRyYXdQYXRoKVxue1xuXHR2YXIgZCA9ICRyYXdQYXRoLmdldEF0dHJpYnV0ZSgnZCcpO1xuXHR2YXIgcGF0aFJlZyA9IC8oW21sc2N2aF0pKC0/W1xcZFxcLl0qWywtXStbXFxkXFwuXSopLD8oLT9bXFxkXFwuXSosPy0/W1xcZFxcLl0qKSw/KC0/W1xcZFxcLl0qLD8tP1tcXGRcXC5dKikvaWdtO1xuXHR2YXIgcG9pbnRzID0gW107XG5cdHZhciBsYXN0Q29vcmRYID0gdGhpcy5nZXRDb29yZFgoMCk7XG5cdHZhciBsYXN0Q29vcmRZID0gdGhpcy5nZXRDb29yZFkoMCk7XG5cdGZvciAodmFyIGFycmF5ID0gcGF0aFJlZy5leGVjKGQpOyBhcnJheSAhPT0gbnVsbDsgYXJyYXkgPSBwYXRoUmVnLmV4ZWMoZCkpXG5cdHtcblx0XHR2YXIgY29vcmRTdHJpbmc7XG5cdFx0dmFyIG51bWJlckNvb3JkWDtcblx0XHR2YXIgbnVtYmVyQ29vcmRZO1xuXHRcdGlmIChhcnJheVsxXSA9PT0gJ3YnKVxuXHRcdHtcblx0XHRcdG51bWJlckNvb3JkWCA9IGxhc3RDb29yZFg7XG5cdFx0XHRudW1iZXJDb29yZFkgPSBsYXN0Q29vcmRZICsgdGhpcy5nZXRDb29yZFkoYXJyYXlbMl0pO1xuXHRcdH1cblx0XHRlbHNlIGlmIChhcnJheVsxXSA9PT0gJ2gnKVxuXHRcdHtcblx0XHRcdG51bWJlckNvb3JkWCA9IGxhc3RDb29yZFggKyB0aGlzLmdldENvb3JkWShhcnJheVsyXSk7XG5cdFx0XHRudW1iZXJDb29yZFkgPSBsYXN0Q29vcmRZO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0aWYgKGFycmF5WzRdICE9PSAnJylcblx0XHRcdHtcblx0XHRcdFx0Y29vcmRTdHJpbmcgPSBhcnJheVs0XTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGFycmF5WzNdICE9PSAnJylcblx0XHRcdHtcblx0XHRcdFx0Y29vcmRTdHJpbmcgPSBhcnJheVszXTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0Y29vcmRTdHJpbmcgPSBhcnJheVsyXTtcblx0XHRcdH1cblx0XHRcdHZhciBjb29yZFJlZyA9IC8oLT9cXGQrXFwuP1xcZCopL2lnbTtcblx0XHRcdHZhciBjb29yZHMgPSBjb29yZFN0cmluZy5tYXRjaChjb29yZFJlZyk7XG5cblx0XHRcdG51bWJlckNvb3JkWCA9IGxhc3RDb29yZFggKyB0aGlzLmdldENvb3JkWChjb29yZHNbMF0pO1xuXHRcdFx0bnVtYmVyQ29vcmRZID0gbGFzdENvb3JkWSArIHRoaXMuZ2V0Q29vcmRZKGNvb3Jkc1sxXSk7XG5cdFx0fVxuXHRcdC8vY29uc29sZS5sb2cobnVtYmVyQ29vcmRYLCBudW1iZXJDb29yZFkpO1xuXHRcdHBvaW50cy5wdXNoKFtudW1iZXJDb29yZFgsIG51bWJlckNvb3JkWV0pO1xuXG5cdFx0bGFzdENvb3JkWCA9IG51bWJlckNvb3JkWDtcblx0XHRsYXN0Q29vcmRZID0gbnVtYmVyQ29vcmRZO1xuXHR9XG5cblx0dmFyIHRoaWNrbmVzcyA9IHRoaXMuZ2V0Q29vcmRYKCRyYXdQYXRoLmdldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJykpO1xuXHRyZXR1cm4geyB0eXBlOiAnbGluZScsIHBvaW50czogcG9pbnRzLCB0aGlja25lc3M6IHRoaWNrbmVzcyB9O1xufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uICgkbnVtYmVyKVxue1xuXHQvLyB2YXIgbnVtYmVyID0gTnVtYmVyKCRudW1iZXIpO1xuXHQvLyByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIgKiAxMDApIC8gMTAwO1xuXHRyZXR1cm4gJG51bWJlcjtcblx0Ly9yZXR1cm4gTWF0aC5mbG9vcihOdW1iZXIoJG51bWJlcikpO1xufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5nZXRDb29yZFggPSBmdW5jdGlvbiAoJGNvb3JkU1RSKVxue1xuXHR2YXIgbnVtYmVyID0gdGhpcy5yb3VuZCgkY29vcmRTVFIpO1xuXHRyZXR1cm4gbnVtYmVyICogdGhpcy5yYXRpbztcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuZ2V0Q29vcmRZID0gZnVuY3Rpb24gKCRjb29yZFNUUilcbntcblx0dmFyIG51bWJlciA9IHRoaXMucm91bmQoJGNvb3JkU1RSKTtcblx0Ly9udW1iZXIgPSB0aGlzLnZpZXdCb3hIZWlnaHQgLSBudW1iZXI7XG5cdHJldHVybiBudW1iZXIgKiB0aGlzLnJhdGlvO1xufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5wYXJzZUN1c3RvbUpvaW50cyA9IGZ1bmN0aW9uICgkcmF3R3JvdXAsICRncm91cClcbntcblx0dmFyIGNoaWxkcmVuID0gJHJhd0dyb3VwLmNoaWxkTm9kZXM7Ly8kcmF3R3JvdXAucXVlcnlTZWxlY3RvckFsbCgnW2lkKj1cImNvbnN0cmFpbnRcIl0nKTtcblxuXHRmb3IgKHZhciBpID0gMCwgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0aWYgKGNoaWxkcmVuW2ldLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSB8fCBjaGlsZHJlbltpXS5pZC5zZWFyY2goL2pvaW50L2kpIDwgMCkgeyBjb250aW51ZTsgfVxuXG5cdFx0dmFyIGN1cnJSYXdKb2ludCA9IGNoaWxkcmVuW2ldO1xuXHRcdHZhciBwMXggPSB0aGlzLmdldENvb3JkWChjdXJyUmF3Sm9pbnQuZ2V0QXR0cmlidXRlKCd4MScpKTtcblx0XHR2YXIgcDF5ID0gdGhpcy5nZXRDb29yZFkoY3VyclJhd0pvaW50LmdldEF0dHJpYnV0ZSgneTEnKSk7XG5cdFx0dmFyIHAyeCA9IHRoaXMuZ2V0Q29vcmRYKGN1cnJSYXdKb2ludC5nZXRBdHRyaWJ1dGUoJ3gyJykpO1xuXHRcdHZhciBwMnkgPSB0aGlzLmdldENvb3JkWShjdXJyUmF3Sm9pbnQuZ2V0QXR0cmlidXRlKCd5MicpKTtcblxuXHRcdHZhciBuMSA9ICRncm91cC5nZXROb2RlQXRQb2ludChwMXgsIHAxeSkgfHwgJGdyb3VwLmNyZWF0ZU5vZGUocDF4LCBwMXkpO1xuXHRcdHZhciBuMiA9ICRncm91cC5nZXROb2RlQXRQb2ludChwMngsIHAyeSkgfHwgJGdyb3VwLmNyZWF0ZU5vZGUocDJ4LCBwMnkpO1xuXHRcdCRncm91cC5jcmVhdGVKb2ludChuMSwgbjIpO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1BhcnNlcjtcblxuIiwidmFyIFNWSmVsbHlOb2RlID0gcmVxdWlyZSgnLi9TVkplbGx5Tm9kZScpO1xudmFyIFNWSmVsbHlKb2ludCA9IHJlcXVpcmUoJy4vU1ZKZWxseUpvaW50Jyk7XG5cbnZhciBTVkplbGx5R3JvdXAgPSBmdW5jdGlvbiAoJHR5cGUsICRjb25mLCAkSUQpXG57XG5cdHRoaXMucGh5c2ljc01hbmFnZXIgPSB1bmRlZmluZWQ7XG5cdHRoaXMuc3RydWN0dXJlID0gdW5kZWZpbmVkO1xuXHR0aGlzLmNvbmYgPSAkY29uZjtcblx0dGhpcy50eXBlID0gJHR5cGU7XG5cdHRoaXMubm9kZXMgPSBbXTtcblx0dGhpcy5qb2ludHMgPSBbXTtcblx0dGhpcy5JRCA9ICRJRDtcbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuZ2V0Tm9kZUF0UG9pbnQgPSBmdW5jdGlvbiAoJHgsICR5KVxue1xuXHRmb3IgKHZhciBpID0gMCwgbm9kZXNMZW5ndGggPSB0aGlzLm5vZGVzLmxlbmd0aDsgaSA8IG5vZGVzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZXNbaV07XG5cblx0XHRpZiAobm9kZS5vWCA9PT0gJHggJiYgbm9kZS5vWSA9PT0gJHkpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fVxuXHR9XG59O1xuXG5TVkplbGx5R3JvdXAucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAoJHB4LCAkcHksICRvcHRpb25zLCAkb3ZlcndyaXRlKVxue1xuXHR2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZUF0UG9pbnQoJHB4LCAkcHkpO1xuXHRpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmICRvdmVyd3JpdGUpXG5cdHtcblx0XHRub2RlLnNldE9wdGlvbnMoJG9wdGlvbnMpO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdG5vZGUgPSBuZXcgU1ZKZWxseU5vZGUoJHB4LCAkcHksICRvcHRpb25zKTtcblx0XHR0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG5cdH1cblxuXHQvL3RoaXMucGh5c2ljc01hbmFnZXIuYWRkTm9kZVRvV29ybGQobm9kZSk7XG5cblx0cmV0dXJuIG5vZGU7XG59O1xuXG5TVkplbGx5R3JvdXAucHJvdG90eXBlLmdldENsb3Nlc3RQb2ludCA9IGZ1bmN0aW9uICgkcG9pbnRzLCAkbm9kZXMpXG57XG5cdHZhciBub2RlcyA9ICRub2RlcyB8fCB0aGlzLm5vZGVzO1xuXHR2YXIgY2xvc2VzdERpc3QgPSBJbmZpbml0eTtcblx0dmFyIGNsb3Nlc3RQb2ludDtcblx0dmFyIGNsb3Nlc3ROb2RlO1xuXHR2YXIgY2xvc2VzdE9mZnNldFg7XG5cdHZhciBjbG9zZXN0T2Zmc2V0WTtcblxuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gJHBvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyUG9pbnQgPSAkcG9pbnRzW2ldO1xuXHRcdGZvciAodmFyIGsgPSAwLCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDsgayA8IG5vZGVzTGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJOb2RlID0gbm9kZXNba107XG5cdFx0XHR2YXIgb2Zmc2V0WCA9IGN1cnJQb2ludFswXSAtIGN1cnJOb2RlLm9YO1xuXHRcdFx0dmFyIG9mZnNldFkgPSBjdXJyUG9pbnRbMV0gLSBjdXJyTm9kZS5vWTtcblx0XHRcdHZhciBjWCA9IE1hdGguYWJzKG9mZnNldFgpO1xuXHRcdFx0dmFyIGNZID0gTWF0aC5hYnMob2Zmc2V0WSk7XG5cdFx0XHR2YXIgZGlzdCA9IE1hdGguc3FydChjWCAqIGNYICsgY1kgKiBjWSk7XG5cdFx0XHRpZiAoZGlzdCA8IGNsb3Nlc3REaXN0KVxuXHRcdFx0e1xuXHRcdFx0XHRjbG9zZXN0Tm9kZSA9IGN1cnJOb2RlO1xuXHRcdFx0XHRjbG9zZXN0UG9pbnQgPSBjdXJyUG9pbnQ7XG5cdFx0XHRcdGNsb3Nlc3REaXN0ID0gZGlzdDtcblx0XHRcdFx0Y2xvc2VzdE9mZnNldFggPSBvZmZzZXRYO1xuXHRcdFx0XHRjbG9zZXN0T2Zmc2V0WSA9IG9mZnNldFk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNsb3Nlc3RQb2ludDtcbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuZ2V0Q2xvc2VzdE5vZGUgPSBmdW5jdGlvbiAoJGNvb3JkLCAkbm9kZXMpXG57XG5cdHZhciBub2RlcyA9ICRub2RlcyB8fCB0aGlzLm5vZGVzO1xuXHR2YXIgY2xvc2VzdERpc3QgPSBJbmZpbml0eTtcblx0dmFyIGNsb3Nlc3Q7XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBub2RlID0gbm9kZXNbaV07XG5cdFx0dmFyIG9mZnNldFggPSAkY29vcmRbMF0gLSBub2RlLm9YO1xuXHRcdHZhciBvZmZzZXRZID0gJGNvb3JkWzFdIC0gbm9kZS5vWTtcblx0XHR2YXIgY1ggPSBNYXRoLmFicyhvZmZzZXRYKTtcblx0XHR2YXIgY1kgPSBNYXRoLmFicyhvZmZzZXRZKTtcblx0XHR2YXIgZGlzdCA9IE1hdGguc3FydChjWCAqIGNYICsgY1kgKiBjWSk7XG5cdFx0aWYgKGRpc3QgPCBjbG9zZXN0RGlzdClcblx0XHR7XG5cdFx0XHRjbG9zZXN0ID0gbm9kZTtcblx0XHRcdGNsb3Nlc3REaXN0ID0gZGlzdDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGNsb3Nlc3Q7XG59O1xuXG5TVkplbGx5R3JvdXAucHJvdG90eXBlLmdldE5vZGVzSW5zaWRlID0gZnVuY3Rpb24gKCRwb2ludHMpXG57XG5cdHZhciBQb2x5Z29uID0gcmVxdWlyZSgnLi9Qb2x5Z29uJyk7XG5cdHZhciB0b1JldHVybiA9IFtdO1xuXHR2YXIgcG9seWdvbiA9IFBvbHlnb24uaW5pdCgkcG9pbnRzKTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMubm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZXNbaV07XG5cdFx0aWYgKHBvbHlnb24uaXNJbnNpZGUoW25vZGUub1gsIG5vZGUub1ldKSlcblx0XHR7XG5cdFx0XHR0b1JldHVybi5wdXNoKG5vZGUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdG9SZXR1cm47XG59O1xuXG5TVkplbGx5R3JvdXAucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKClcbntcblx0dmFyIG1pblg7XG5cdHZhciBtYXhYO1xuXHR2YXIgbWluWTtcblx0dmFyIG1heFk7XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLm5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIG5vZGUgPSB0aGlzLm5vZGVzW2ldO1xuXHRcdG1pblggPSBtaW5YID4gbm9kZS5vWCB8fCBtaW5YID09PSB1bmRlZmluZWQgPyBub2RlLm9YIDogbWluWDtcblx0XHRtYXhYID0gbWF4WCA8IG5vZGUub1ggfHwgbWF4WCA9PT0gdW5kZWZpbmVkID8gbm9kZS5vWCA6IG1heFg7XG5cdFx0bWluWSA9IG1pblkgPiBub2RlLm9ZIHx8IG1pblkgPT09IHVuZGVmaW5lZCA/IG5vZGUub1kgOiBtaW5ZO1xuXHRcdG1heFkgPSBtYXhZIDwgbm9kZS5vWSB8fCBtYXhZID09PSB1bmRlZmluZWQgPyBub2RlLm9ZIDogbWF4WTtcblx0fVxuXHRyZXR1cm4gW1ttaW5YLCBtaW5ZXSwgW21heFgsIG1heFldXTtcbn07XG5cbi8vVE9ETyA6IHRvIHJlbW92ZVxuU1ZKZWxseUdyb3VwLnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24gKCRwb2ludClcbntcblx0dmFyIGN1cnJYID0gJHBvaW50WzBdO1xuXHR2YXIgY3VyclkgPSAkcG9pbnRbMV07XG5cdHZhciBib3VuZGluZyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3goKTtcblx0aWYgKGN1cnJYID49IGJvdW5kaW5nWzBdWzBdICYmIGN1cnJYIDw9IGJvdW5kaW5nWzFdWzBdICYmXG5cdFx0Y3VyclkgPj0gYm91bmRpbmdbMF1bMV0gJiYgY3VyclkgPD0gYm91bmRpbmdbMV1bMV0pXG5cdHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5TVkplbGx5R3JvdXAucHJvdG90eXBlLmNyZWF0ZUpvaW50ID0gZnVuY3Rpb24gKCRub2RlMSwgJG5vZGUyKVxue1xuXHRmb3IgKHZhciBpID0gMCwgam9pbnRzTGVuZ3RoID0gdGhpcy5qb2ludHMubGVuZ3RoOyBpIDwgam9pbnRzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyckpvaW50ID0gdGhpcy5qb2ludHNbaV07XG5cdFx0aWYgKChjdXJySm9pbnQubm9kZTEgPT09ICRub2RlMSAmJiBjdXJySm9pbnQubm9kZTIgPT09ICRub2RlMikgfHwgKGN1cnJKb2ludC5ub2RlMiA9PT0gJG5vZGUxICYmIGN1cnJKb2ludC5ub2RlMSA9PT0gJG5vZGUyKSlcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0dmFyIGpvaW50ID0gbmV3IFNWSmVsbHlKb2ludCgkbm9kZTEsICRub2RlMik7XG5cblx0dGhpcy5qb2ludHMucHVzaChqb2ludCk7XG5cblx0Ly90aGlzLnBoeXNpY3NNYW5hZ2VyLmFkZEpvaW50VG9Xb3JsZChqb2ludCk7XG59O1xuXG5TVkplbGx5R3JvdXAucHJvdG90eXBlLmNyZWF0ZU5vZGVzRnJvbVBvaW50cyA9IGZ1bmN0aW9uICgkY29vcmRzQXJyYXkpXG57XG5cdHZhciBjb29yZHNBcnJheUxlbmd0aCA9ICRjb29yZHNBcnJheS5sZW5ndGg7XG5cdHZhciB0b1JldHVybiA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkc0FycmF5TGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyclBvaW50ID0gJGNvb3Jkc0FycmF5W2ldO1xuXHRcdHRvUmV0dXJuLnB1c2godGhpcy5jcmVhdGVOb2RlKGN1cnJQb2ludFswXSwgY3VyclBvaW50WzFdLCB1bmRlZmluZWQsIGZhbHNlKSk7XG5cdH1cblx0cmV0dXJuIHRvUmV0dXJuO1xufTtcblxuU1ZKZWxseUdyb3VwLnByb3RvdHlwZS5nZXRCZXN0TWF0Y2hGb3JHcm91cENvbnN0cmFpbnQgPSBmdW5jdGlvbiAoJHBvaW50cywgJGFuY2hvcilcbntcblx0cmV0dXJuIHRoaXMucGh5c2ljc01hbmFnZXIuZ2V0QmVzdE1hdGNoRm9yR3JvdXBDb25zdHJhaW50KCRwb2ludHMsICRhbmNob3IpO1xufTtcblxuU1ZKZWxseUdyb3VwLnByb3RvdHlwZS5jcmVhdGVKb2ludHNGcm9tUG9pbnRzID0gZnVuY3Rpb24gKCRjb29yZHNBcnJheSwgJG5vQ2xvc2UpXG57XG5cdHZhciBjb29yZHNBcnJheUxlbmd0aCA9ICRjb29yZHNBcnJheS5sZW5ndGg7XG5cdGZvciAodmFyIGkgPSAxOyBpIDwgY29vcmRzQXJyYXlMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyUG9pbnQgPSAkY29vcmRzQXJyYXlbaV07XG5cdFx0dmFyIGxhc3RQb2ludCA9ICRjb29yZHNBcnJheVtpIC0gMV07XG5cdFx0dmFyIGxhc3ROb2RlID0gdGhpcy5nZXROb2RlQXRQb2ludChsYXN0UG9pbnRbMF0sIGxhc3RQb2ludFsxXSk7XG5cdFx0dmFyIGN1cnJOb2RlID0gdGhpcy5nZXROb2RlQXRQb2ludChjdXJyUG9pbnRbMF0sIGN1cnJQb2ludFsxXSk7XG5cdFx0dGhpcy5jcmVhdGVKb2ludChsYXN0Tm9kZSwgY3Vyck5vZGUpO1xuXHRcdGlmIChpID09PSBjb29yZHNBcnJheUxlbmd0aCAtIDEgJiYgJG5vQ2xvc2UgIT09IHRydWUpXG5cdFx0e1xuXHRcdFx0dmFyIGZpcnN0Tm9kZSA9IHRoaXMuZ2V0Tm9kZUF0UG9pbnQoJGNvb3Jkc0FycmF5WzBdWzBdLCAkY29vcmRzQXJyYXlbMF1bMV0pO1xuXHRcdFx0dGhpcy5jcmVhdGVKb2ludChjdXJyTm9kZSwgZmlyc3ROb2RlKTtcblx0XHR9XG5cdH1cbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuYWRkTm9kZXNUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0dGhpcy5waHlzaWNzTWFuYWdlci5hZGROb2Rlc1RvV29ybGQoKTtcbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuYWRkSm9pbnRzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdHRoaXMucGh5c2ljc01hbmFnZXIuYWRkSm9pbnRzVG9Xb3JsZCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkplbGx5R3JvdXA7XG5cbiIsInZhciBTVkplbGx5Sm9pbnQgPSBmdW5jdGlvbiAoJG5vZGUxLCAkbm9kZTIpXG57XG5cdHRoaXMubm9kZTEgPSAkbm9kZTE7XG5cdHRoaXMubm9kZTIgPSAkbm9kZTI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWSmVsbHlKb2ludDtcblxuIiwidmFyIFNWSmVsbHlOb2RlID0gZnVuY3Rpb24gKCRvWCwgJG9ZLCAkb3B0aW9ucylcbntcblx0dGhpcy5qb2ludHNBcnJheSA9IFtdO1xuXHR0aGlzLm9YID0gJG9YO1xuXHR0aGlzLm9ZID0gJG9ZO1xuXHR0aGlzLmRyYXdpbmcgPSB1bmRlZmluZWQ7XG5cdHRoaXMuZml4ZWQgPSBmYWxzZTtcblx0dGhpcy5pc1N0YXJ0ID0gZmFsc2U7XG5cdHRoaXMuZW5kTm9kZSA9IHVuZGVmaW5lZDtcblx0dGhpcy5zZXRPcHRpb25zKCRvcHRpb25zKTtcbn07XG5cbi8vcmFjY291cmNpXG5TVkplbGx5Tm9kZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgkb3B0aW9ucylcbntcblx0aWYgKCRvcHRpb25zKVxuXHR7XG5cdFx0Ly8gdmFyID0gJCA9PT0gdW5kZWZpbmVkID8ge30gOiAkb3B0aW9ucztcblx0XHRpZiAoJG9wdGlvbnMuZml4ZWQgIT09IHVuZGVmaW5lZCkgeyB0aGlzLmZpeGVkID0gJG9wdGlvbnMuZml4ZWQ7IH1cblx0fVxufTtcblxuU1ZKZWxseU5vZGUucHJvdG90eXBlLnNldEZpeGVkID0gZnVuY3Rpb24gKCRmaXhlZClcbntcblx0dGhpcy5maXhlZCA9ICRmaXhlZDtcblx0dGhpcy5waHlzaWNzTWFuYWdlci5zZXRGaXhlZCgkZml4ZWQpO1xufTtcblxuU1ZKZWxseU5vZGUucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5waHlzaWNzTWFuYWdlci5nZXRYKCk7XG59O1xuXG4vL3JhY2NvdXJjaVxuU1ZKZWxseU5vZGUucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5waHlzaWNzTWFuYWdlci5nZXRZKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWSmVsbHlOb2RlO1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0ZXh0ZW5kOiBmdW5jdGlvbiAoJHRvRXh0ZW5kLCAkZXh0ZW5zaW9uKVxuXHR7XG5cdFx0dmFyIHJlY3VyID0gZnVuY3Rpb24gKCRvYmplY3QsICRleHRlbmQpXG5cdFx0e1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiAkZXh0ZW5kKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodHlwZW9mICRleHRlbmRbbmFtZV0gPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KCRleHRlbmRbbmFtZV0pICYmICRleHRlbmRbbmFtZV0gIT09IG51bGwpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoJG9iamVjdFtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7ICRvYmplY3RbbmFtZV0gPSB7fTsgfVxuXHRcdFx0XHRcdHJlY3VyKCRvYmplY3RbbmFtZV0sICRleHRlbmRbbmFtZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdCRvYmplY3RbbmFtZV0gPSAkZXh0ZW5kW25hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZWN1cigkdG9FeHRlbmQsICRleHRlbnNpb24pO1xuXG5cdFx0cmV0dXJuICR0b0V4dGVuZDtcblx0fVxufTtcblxuIiwidmFyIFNWSmVsbHlHcm91cCA9IHJlcXVpcmUoJy4vU1ZKZWxseUdyb3VwJyk7XG52YXIgU3RydWN0dXJlID0gcmVxdWlyZSgnLi9TdHJ1Y3R1cmUnKTtcblxudmFyIFNWSmVsbHlXb3JsZCA9IGZ1bmN0aW9uICgkcGh5c2ljc01hbmFnZXIsICRjb25mKVxue1xuXHR0aGlzLnBoeXNpY3NNYW5hZ2VyID0gJHBoeXNpY3NNYW5hZ2VyO1xuXHR0aGlzLmdyb3Vwc0FycmF5ID0gW107XG5cdHRoaXMuY29uZiA9ICRjb25mO1xuXHR0aGlzLndvcmxkTm9kZXMgPSBbXTtcblx0dGhpcy5ncm91cENvbnN0cmFpbnRzID0gW107XG5cdHRoaXMud29ybGRXaWR0aCA9IHRoaXMucGh5c2ljc01hbmFnZXIud29ybGRXaWR0aCA9ICRjb25mLndvcmxkV2lkdGg7XG59O1xuXG5TVkplbGx5V29ybGQucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uICgkaGVpZ2h0KVxue1xuXHR0aGlzLndvcmxkSGVpZ2h0ID0gdGhpcy5waHlzaWNzTWFuYWdlci53b3JsZEhlaWdodCA9ICRoZWlnaHQ7XG59O1xuXG5TVkplbGx5V29ybGQucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMud29ybGRXaWR0aDtcbn07XG5cblNWSmVsbHlXb3JsZC5wcm90b3R5cGUuZ2V0R3JvdXBCeUlEID0gZnVuY3Rpb24gKCRJRClcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZ3JvdXBzQXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3Vyckdyb3VwID0gdGhpcy5ncm91cHNBcnJheVtpXTtcblx0XHRpZiAoY3Vyckdyb3VwLklEID09PSAkSUQpIHsgcmV0dXJuIGN1cnJHcm91cDsgfVxuXHR9XG59O1xuXG5TVkplbGx5V29ybGQucHJvdG90eXBlLmNyZWF0ZUdyb3VwID0gZnVuY3Rpb24gKCR0eXBlLCAkSUQpXG57XG5cdHZhciB0eXBlID0gJHR5cGUgfHwgJ2RlZmF1bHQnO1xuXHR2YXIgZ3JvdXAgPSBuZXcgU1ZKZWxseUdyb3VwKHR5cGUsIHRoaXMuY29uZi5ncm91cHNbdHlwZV0sICRJRCk7XG5cdGdyb3VwLnBoeXNpY3NNYW5hZ2VyID0gdGhpcy5waHlzaWNzTWFuYWdlci5nZXRHcm91cFBoeXNpY3NNYW5hZ2VyKGdyb3VwKTtcblx0Z3JvdXAuc3RydWN0dXJlID0gbmV3IFN0cnVjdHVyZShncm91cCwgdGhpcyk7XG5cdHRoaXMuZ3JvdXBzQXJyYXkucHVzaChncm91cCk7XG5cdHJldHVybiBncm91cDtcbn07XG5cblNWSmVsbHlXb3JsZC5wcm90b3R5cGUuY29uc3RyYWluR3JvdXBzID0gZnVuY3Rpb24gKCRncm91cEEsICRncm91cEIsICRwb2ludHMpXG57XG5cdHZhciBwb2ludHMgPSAkcG9pbnRzO1xuXHR2YXIgZ3JvdXBBID0gJGdyb3VwQTtcblx0dmFyIGdyb3VwQiA9ICRncm91cEI7XG5cblx0aWYgKHBvaW50cy5sZW5ndGggPCAzKVxuXHR7XG5cdFx0dmFyIGFuY2hvckEgPSBncm91cEEucGh5c2ljc01hbmFnZXIuY3JlYXRlQW5jaG9yRnJvbUxpbmUocG9pbnRzKTtcblx0XHRwb2ludHMuc3BsaWNlKHBvaW50cy5pbmRleE9mKGFuY2hvckEucG9pbnQpLCAxKTtcblx0XHR2YXIgYW5jaG9yQiA9IGdyb3VwQiA/IGdyb3VwQi5waHlzaWNzTWFuYWdlci5jcmVhdGVBbmNob3JGcm9tUG9pbnQocG9pbnRzWzBdKSA6IHRoaXMucGh5c2ljc01hbmFnZXIuZ2V0QW5jaG9yUGh5c2ljc01hbmFnZXIocG9pbnRzWzBdKTtcblx0XHR0aGlzLmdyb3VwQ29uc3RyYWludHMucHVzaCh7IGFuY2hvckE6IGFuY2hvckEsIGFuY2hvckI6IGFuY2hvckIgfSk7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0dmFyIGFuY2hvcnNBID0gZ3JvdXBBLnBoeXNpY3NNYW5hZ2VyLmNyZWF0ZUFuY2hvcnMocG9pbnRzKTtcblx0XHQvL2NvbnNvbGUubG9nKCdBJywgZ3JvdXBBLklELCBhbmNob3JzQS5sZW5ndGgsICdCJywgZ3JvdXBCID8gZ3JvdXBCLklEIDogZ3JvdXBCKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbm9kZXNMZW5ndGggPSBhbmNob3JzQS5sZW5ndGg7IGkgPCBub2Rlc0xlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyQW5jaG9yQSA9IGFuY2hvcnNBW2ldO1xuXHRcdFx0aWYgKCFncm91cEIpXG5cdFx0XHR7XG5cdFx0XHRcdGN1cnJBbmNob3JBLnNldEZpeGVkKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgYW5jaG9yc0IgPSBncm91cEIucGh5c2ljc01hbmFnZXIuY3JlYXRlQW5jaG9ycyhwb2ludHMpO1xuXHRcdFx0XHRmb3IgKHZhciBrID0gMCwgYW5jaG9yc0JMZW5ndGggPSBhbmNob3JzQi5sZW5ndGg7IGsgPCBhbmNob3JzQkxlbmd0aDsgayArPSAxKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGN1cnJBbmNob3JCID0gYW5jaG9yc0Jba107XG5cdFx0XHRcdFx0dGhpcy5ncm91cENvbnN0cmFpbnRzLnB1c2goeyBhbmNob3JBOiBjdXJyQW5jaG9yQSwgYW5jaG9yQjogY3VyckFuY2hvckIgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cblNWSmVsbHlXb3JsZC5wcm90b3R5cGUuYWRkR3JvdXBzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdGZvciAodmFyIGkgPSAwLCBncm91cHNBcnJheUxlbmd0aCA9IHRoaXMuZ3JvdXBzQXJyYXkubGVuZ3RoOyBpIDwgZ3JvdXBzQXJyYXlMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyR3JvdXAgPSB0aGlzLmdyb3Vwc0FycmF5W2ldO1xuXHRcdGN1cnJHcm91cC5hZGROb2Rlc1RvV29ybGQoKTtcblx0XHRjdXJyR3JvdXAuYWRkSm9pbnRzVG9Xb3JsZCgpO1xuXHRcdHRoaXMud29ybGROb2RlcyA9IHRoaXMud29ybGROb2Rlcy5jb25jYXQoY3Vyckdyb3VwLm5vZGVzKTtcblx0fVxuXG5cdHZhciB0b0NvbnN0cmFpbkxlbmd0aCA9IHRoaXMuZ3JvdXBDb25zdHJhaW50cy5sZW5ndGg7XG5cdGZvciAoaSA9IDA7IGkgPCB0b0NvbnN0cmFpbkxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJUb0NvbnN0cmFpbiA9IHRoaXMuZ3JvdXBDb25zdHJhaW50c1tpXTtcblx0XHR0aGlzLnBoeXNpY3NNYW5hZ2VyLmNvbnN0cmFpbkdyb3VwcyhjdXJyVG9Db25zdHJhaW4uYW5jaG9yQSwgY3VyclRvQ29uc3RyYWluLmFuY2hvckIpO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWSmVsbHlXb3JsZDtcblxuIiwidmFyIFRyaWFuZ3VsYXRvciA9IHJlcXVpcmUoJy4vVHJpYW5ndWxhdG9yJyk7XG52YXIgUG9seWdvbiA9IHJlcXVpcmUoJy4vUG9seWdvbicpO1xudmFyIEdyaWQgPSByZXF1aXJlKCcuL0dyaWQnKTtcblxudmFyIFN0cnVjdHVyZSA9IGZ1bmN0aW9uICgkZ3JvdXAsICR3b3JsZClcbntcblx0dGhpcy53b3JsZCA9ICR3b3JsZDtcblx0dGhpcy5ncm91cCA9ICRncm91cDtcblx0dGhpcy5pbm5lclN0cnVjdHVyZSA9IHVuZGVmaW5lZDtcbn07XG5cblN0cnVjdHVyZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCRwcm9wZXJ0aWVzKVxue1xuXHR2YXIgbm9kZXNUb0RyYXc7XG5cdHZhciBwb2ludHMgPSAkcHJvcGVydGllcy5wb2ludHM7XG5cdHRoaXMuZ3JvdXAuc3RydWN0dXJlUHJvcGVydGllcyA9ICRwcm9wZXJ0aWVzO1xuXG5cdGlmICgkcHJvcGVydGllcy50eXBlID09PSAncG9seWdvbicpXG5cdHtcblx0XHR2YXIgcG9seWdvbiA9IFBvbHlnb24uaW5pdChwb2ludHMpO1xuXHRcdHRoaXMuZ3JvdXAuc3RydWN0dXJlUHJvcGVydGllcy5hcmVhID0gcG9seWdvbi5nZXRBcmVhKCk7XG5cdH1cblx0ZWxzZSBpZiAoJHByb3BlcnRpZXMudHlwZSA9PT0gJ2xpbmUnKVxuXHR7XG5cdFx0dmFyIGFyZWEgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3VyclBvaW50ID0gdGhpcy5wb2ludHNbaV07XG5cdFx0XHR2YXIgbGFzdFBvaW50ID0gdGhpcy5wb2ludHNbaSAtIDFdO1xuXHRcdFx0dmFyIGRYID0gTWF0aC5hYnMoY3VyclBvaW50WzBdIC0gbGFzdFBvaW50WzBdKTtcblx0XHRcdHZhciBkWSA9IE1hdGguYWJzKGN1cnJQb2ludFsxXSAtIGxhc3RQb2ludFsxXSk7XG5cdFx0XHRhcmVhICs9IE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XG5cdFx0fVxuXHRcdHRoaXMuZ3JvdXAuc3RydWN0dXJlUHJvcGVydGllcy5hcmVhID0gYXJlYTtcblx0fVxuXHRlbHNlIGlmICgkcHJvcGVydGllcy50eXBlID09PSAnY2lyY2xlJylcblx0e1xuXHRcdHRoaXMuZ3JvdXAuc3RydWN0dXJlUHJvcGVydGllcy5hcmVhID0gTWF0aC5wb3coTWF0aC5QSSAqICRwcm9wZXJ0aWVzLnJhZGl1cywgMik7XG5cdH1cblxuXHRzd2l0Y2ggKHRoaXMuZ3JvdXAuY29uZi5zdHJ1Y3R1cmUpXG5cdHtcblx0XHRjYXNlICd0cmlhbmd1bGF0ZSc6XG5cdFx0XHRub2Rlc1RvRHJhdyA9IHRoaXMuZ3JvdXAuY3JlYXRlTm9kZXNGcm9tUG9pbnRzKHBvaW50cyk7XG5cdFx0XHR0aGlzLmNyZWF0ZUpvaW50c0Zyb21UcmlhbmdsZXMocG9pbnRzKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2xpbmUnOlxuXHRcdFx0bm9kZXNUb0RyYXcgPSB0aGlzLmdyb3VwLmNyZWF0ZU5vZGVzRnJvbVBvaW50cyhwb2ludHMpO1xuXHRcdFx0dGhpcy5ncm91cC5jcmVhdGVKb2ludHNGcm9tUG9pbnRzKHBvaW50cywgdHJ1ZSk7XG5cdFx0XHQvL25vZGVzVG9EcmF3WzBdLmZpeGVkID0gdHJ1ZTsvL3RvIHJlbW92ZSBsYXRlciBtYXliZSA/XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdwcmVjaXNlSGV4YUZpbGwnOlxuXHRcdFx0bm9kZXNUb0RyYXcgPSB0aGlzLmNyZWF0ZVByZWNpc2VIZXhhRmlsbFN0cnVjdHVyZShwb2ludHMpO1xuXHRcdFx0Ly8gc3RydWN0dXJlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoJGVsZW1lbnQpIHsgJGVsZW1lbnQuZHJhd2luZyA9IHsgbm90VG9EcmF3OiB0cnVlIH07IH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnaGV4YUZpbGwnOlxuXHRcdFx0bm9kZXNUb0RyYXcgPSB0aGlzLmNyZWF0ZUhleGFGaWxsU3RydWN0dXJlKHBvaW50cyk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0bm9kZXNUb0RyYXcgPSB0aGlzLmdyb3VwLmNyZWF0ZU5vZGVzRnJvbVBvaW50cyhwb2ludHMpO1xuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRyZXR1cm4gbm9kZXNUb0RyYXc7XG59O1xuXG5TdHJ1Y3R1cmUucHJvdG90eXBlLmNyZWF0ZUhleGFGaWxsU3RydWN0dXJlID0gZnVuY3Rpb24gKCRjb29yZHNBcnJheSlcbntcblx0dGhpcy5jcmVhdGVJbm5lclN0cnVjdHVyZSgkY29vcmRzQXJyYXkpO1xuXHR2YXIgcGF0aCA9IHRoaXMuaW5uZXJTdHJ1Y3R1cmUuZ2V0U2hhcGVQYXRoKCk7XG5cdHZhciBub2Rlc1RvRHJhdyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcGF0aC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdG5vZGVzVG9EcmF3LnB1c2godGhpcy5ncm91cC5nZXROb2RlQXRQb2ludChwYXRoW2ldWzBdLCBwYXRoW2ldWzFdKSk7XG5cdH1cblx0cmV0dXJuIG5vZGVzVG9EcmF3O1xufTtcblxuU3RydWN0dXJlLnByb3RvdHlwZS5jcmVhdGVQcmVjaXNlSGV4YUZpbGxTdHJ1Y3R1cmUgPSBmdW5jdGlvbiAoJGNvb3Jkc0FycmF5KVxue1xuXHR2YXIgbm9kZXNUb0RyYXcgPSB0aGlzLmdyb3VwLmNyZWF0ZU5vZGVzRnJvbVBvaW50cygkY29vcmRzQXJyYXkpO1xuXHR0aGlzLmNyZWF0ZUlubmVyU3RydWN0dXJlKCRjb29yZHNBcnJheSk7XG5cblx0dGhpcy5ncm91cC5jcmVhdGVKb2ludHNGcm9tUG9pbnRzKCRjb29yZHNBcnJheSwgZmFsc2UpO1xuXHR2YXIgaSA9IDA7XG5cdHZhciBsZW5ndGggPSAkY29vcmRzQXJyYXkubGVuZ3RoO1xuXHRmb3IgKGk7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyUG9pbnQgPSAkY29vcmRzQXJyYXlbaV07XG5cdFx0dmFyIGNsb3Nlc3QgPSB0aGlzLmlubmVyU3RydWN0dXJlLmdldENsb3Nlc3QoY3VyclBvaW50WzBdLCBjdXJyUG9pbnRbMV0sIDIpO1xuXHRcdGZvciAodmFyIGsgPSAwLCBjbG9zZXN0TGVuZ3RoID0gY2xvc2VzdC5sZW5ndGg7IGsgPCBjbG9zZXN0TGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJDbG9zZXN0ID0gY2xvc2VzdFtrXTtcblx0XHRcdHZhciBuMSA9IHRoaXMuZ3JvdXAuZ2V0Tm9kZUF0UG9pbnQoY3VyclBvaW50WzBdLCBjdXJyUG9pbnRbMV0pO1xuXHRcdFx0dmFyIG4yID0gdGhpcy5ncm91cC5nZXROb2RlQXRQb2ludChjdXJyQ2xvc2VzdFswXSwgY3VyckNsb3Nlc3RbMV0pO1xuXHRcdFx0dGhpcy5ncm91cC5jcmVhdGVKb2ludChuMSwgbjIpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbm9kZXNUb0RyYXc7XG59O1xuXG5TdHJ1Y3R1cmUucHJvdG90eXBlLmNyZWF0ZUpvaW50c0Zyb21UcmlhbmdsZXMgPSBmdW5jdGlvbiAoJGNvb3Jkc0FycmF5KVxue1xuXHR2YXIgdHJpYW5ndWxhdG9yID0gbmV3IFRyaWFuZ3VsYXRvcigpO1xuXHR2YXIgdHJpYW5nbGVzID0gdHJpYW5ndWxhdG9yLnRyaWFuZ3VsYXRlKCRjb29yZHNBcnJheSk7XG5cblx0dmFyIHRyaWFuZ2xlc0xlbmd0aCA9IHRyaWFuZ2xlcy5sZW5ndGg7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdHJpYW5nbGVzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyclRyaWFuZ2xlID0gdHJpYW5nbGVzW2ldO1xuXHRcdHZhciBuMCA9IHRoaXMuZ3JvdXAuZ2V0Tm9kZUF0UG9pbnQoY3VyclRyaWFuZ2xlWzBdLngsIGN1cnJUcmlhbmdsZVswXS55KTtcblx0XHR2YXIgbjEgPSB0aGlzLmdyb3VwLmdldE5vZGVBdFBvaW50KGN1cnJUcmlhbmdsZVsxXS54LCBjdXJyVHJpYW5nbGVbMV0ueSk7XG5cdFx0dmFyIG4yID0gdGhpcy5ncm91cC5nZXROb2RlQXRQb2ludChjdXJyVHJpYW5nbGVbMl0ueCwgY3VyclRyaWFuZ2xlWzJdLnkpO1xuXHRcdHRoaXMuZ3JvdXAuY3JlYXRlSm9pbnQobjAsIG4xKTtcblx0XHR0aGlzLmdyb3VwLmNyZWF0ZUpvaW50KG4xLCBuMik7XG5cdFx0dGhpcy5ncm91cC5jcmVhdGVKb2ludChuMiwgbjApO1xuXHR9XG59O1xuXG5TdHJ1Y3R1cmUucHJvdG90eXBlLmNyZWF0ZUlubmVyU3RydWN0dXJlID0gZnVuY3Rpb24gKCRjb29yZHNBcnJheSlcbntcblx0dmFyIHBvbHlnb24gPSBQb2x5Z29uLmluaXQoJGNvb3Jkc0FycmF5KTtcblx0dmFyIGRpYW0gPSB0aGlzLndvcmxkLmdldFdpZHRoKCkgKiB0aGlzLmdyb3VwLmNvbmYuaW5uZXJTdHJ1Y3R1cmVEZWY7Ly93aWR0aCAvIDEwOy8vdGhpcy53b3JsZC5nZXRXaWR0aCgpIC8gMzA7XG5cdHRoaXMuaW5uZXJTdHJ1Y3R1cmUgPSBHcmlkLmNyZWF0ZUZyb21Qb2x5Z29uKHBvbHlnb24sIGRpYW0sIHRydWUpO1xuXHR2YXIgc3RydWN0dXJlTm9kZXMgPSB0aGlzLmdyb3VwLmNyZWF0ZU5vZGVzRnJvbVBvaW50cyh0aGlzLmlubmVyU3RydWN0dXJlLmdldE5vZGVzQXJyYXkoKSk7XG5cblx0dmFyIG5ldHdvcmsgPSB0aGlzLmlubmVyU3RydWN0dXJlLmdldE5ldHdvcmsoKTtcblx0dmFyIGkgPSAwO1xuXHR2YXIgbGVuZ3RoID0gbmV0d29yay5sZW5ndGg7XG5cdGZvciAoaTsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJMaW5rID0gbmV0d29ya1tpXTtcblx0XHR2YXIgbjEgPSB0aGlzLmdyb3VwLmdldE5vZGVBdFBvaW50KGN1cnJMaW5rWzBdWzBdLCBjdXJyTGlua1swXVsxXSk7XG5cdFx0dmFyIG4yID0gdGhpcy5ncm91cC5nZXROb2RlQXRQb2ludChjdXJyTGlua1sxXVswXSwgY3VyckxpbmtbMV1bMV0pO1xuXHRcdHRoaXMuZ3JvdXAuY3JlYXRlSm9pbnQobjEsIG4yKTtcblx0fVxuXHRyZXR1cm4gc3RydWN0dXJlTm9kZXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cnVjdHVyZTtcblxuIiwidmFyIHBvbHkydHJpID0gcmVxdWlyZSgnLi4vLi4vbGlicy9wb2x5MnRyaS9kaXN0L3BvbHkydHJpJyk7XG5cbnZhciBUcmlhbmd1bGF0b3IgPSBmdW5jdGlvbiAoKVxue1xufTtcblxuVHJpYW5ndWxhdG9yLnByb3RvdHlwZS50cmlhbmd1bGF0ZSA9IGZ1bmN0aW9uICgkY29vcmRzKVxue1xuXHR2YXIgcG9seTJ0cmlDb250b3VyID0gW107XG5cdC8vZGVidWdnZXI7XG5cblx0Zm9yICh2YXIgaSA9IDAsIHBvaW50c0xlbmd0aCA9ICRjb29yZHMubGVuZ3RoOyBpIDwgcG9pbnRzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgcG9pbnQgPSAkY29vcmRzW2ldO1xuXHRcdHBvbHkydHJpQ29udG91ci5wdXNoKG5ldyBwb2x5MnRyaS5Qb2ludChwb2ludFswXSwgcG9pbnRbMV0pKTtcblx0fVxuXG5cdHZhciBzd2N0eDtcblx0dHJ5XG5cdHtcblx0XHQvLyBwcmVwYXJlIFN3ZWVwQ29udGV4dFxuXHRcdHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChwb2x5MnRyaUNvbnRvdXIsIHsgY2xvbmVBcnJheXM6IHRydWUgfSk7XG5cblx0XHQvLyB0cmlhbmd1bGF0ZVxuXHRcdHN3Y3R4LnRyaWFuZ3VsYXRlKCk7XG5cdH1cblx0Y2F0Y2ggKGUpXG5cdHtcblx0XHR0aHJvdyBlO1xuXHRcdC8vIGNvbnNvbGUubG9nKGUpO1xuXHRcdC8vIGNvbnNvbGUubG9nKGUucG9pbnRzKTtcblx0fVxuXHR2YXIgdHJpYW5nbGVzID0gc3djdHguZ2V0VHJpYW5nbGVzKCk7XG5cblx0dmFyIHBvaW50c0FycmF5ID0gW107XG5cblx0dmFyIHRyaWFuZ2xlc0xlbmd0aCA9IHRyaWFuZ2xlcy5sZW5ndGg7XG5cdGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyVHJpYW5nbGUgPSB0cmlhbmdsZXNbaV07XG5cdFx0Lypqc2hpbnQgY2FtZWxjYXNlOmZhbHNlKi9cblx0XHQvL2pzY3M6ZGlzYWJsZSBkaXNhbGxvd0RhbmdsaW5nVW5kZXJzY29yZXNcblx0XHRwb2ludHNBcnJheS5wdXNoKGN1cnJUcmlhbmdsZS5wb2ludHNfKTtcblx0XHQvL2pzY3M6ZW5hYmxlIGRpc2FsbG93RGFuZ2xpbmdVbmRlcnNjb3Jlc1xuXHRcdC8qanNoaW50IGNhbWVsY2FzZTp0cnVlKi9cblx0fVxuXG5cdHJldHVybiBwb2ludHNBcnJheTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJpYW5ndWxhdG9yO1xuXG4iLCJ2YXIgQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKCRwMiwgJHAyV29ybGQsICR3b3JsZEhlaWdodClcbntcblx0dGhpcy5wMiA9ICRwMjtcblx0dGhpcy5wMldvcmxkID0gJHAyV29ybGQ7XG5cdHRoaXMub2Zmc2V0ID0gWzAsIDBdO1xuXHR0aGlzLndvcmxkSGVpZ2h0ID0gJHdvcmxkSGVpZ2h0O1xufTtcblxuQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zZXRGcm9tUG9pbnQgPSBmdW5jdGlvbiAoJHBvaW50KVxue1xuXHR0aGlzLnBvaW50ID0gJHBvaW50O1xufTtcblxuQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hZGRUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0dGhpcy5ib2R5ID0gbmV3IHRoaXMucDIuQm9keSh7XG5cdFx0cG9zaXRpb246IFt0aGlzLnBvaW50WzBdLCB0aGlzLndvcmxkSGVpZ2h0IC0gdGhpcy5wb2ludFsxXV1cblx0fSk7XG5cdHRoaXMucDJXb3JsZC5hZGRCb2R5KHRoaXMuYm9keSk7XG59O1xuXG5BbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ib2R5LnBvc2l0aW9uWzBdO1xufTtcblxuQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMud29ybGRIZWlnaHQgLSB0aGlzLmJvZHkucG9zaXRpb25bMV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlcjtcbiIsInZhciBBbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkZ3JvdXApIHsgdGhpcy5ncm91cCA9ICRncm91cDsgfTtcblxuQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldEZyb21Qb2ludCA9IGZ1bmN0aW9uICgkcG9pbnQpXG57XG5cdHRoaXMucG9pbnQgPSAkcG9pbnQ7XG59O1xuXG5BbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdHRoaXMuYm9keSA9IHRoaXMuZ3JvdXAucGh5c2ljc01hbmFnZXIuYm9keTtcblx0dGhpcy53b3JsZEhlaWdodCA9IHRoaXMuZ3JvdXAucGh5c2ljc01hbmFnZXIud29ybGRIZWlnaHQ7XG5cdHRoaXMub2Zmc2V0ID0gW3RoaXMucG9pbnRbMF0gLSB0aGlzLmJvZHkucG9zaXRpb25bMF0sICh0aGlzLndvcmxkSGVpZ2h0IC0gdGhpcy5wb2ludFsxXSkgLSB0aGlzLmJvZHkucG9zaXRpb25bMV1dO1xuXHR2YXIgZFggPSB0aGlzLm9mZnNldFswXTtcblx0dmFyIGRZID0gdGhpcy5vZmZzZXRbMV07XG5cdHRoaXMuYW5nbGUgPSBNYXRoLmF0YW4yKGRZLCBkWCk7XG5cdHRoaXMuaHlwID0gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcbn07XG5cbkFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zZXRGaXhlZCA9IGZ1bmN0aW9uICgkZml4ZWQpXG57XG5cdHRoaXMuZ3JvdXAuZml4ZWQgPSAkZml4ZWQ7XG59O1xuXG5BbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmJvZHkucG9zaXRpb25bMF0gKyB0aGlzLmh5cCAqIE1hdGguY29zKHRoaXMuYm9keS5hbmdsZSArIHRoaXMuYW5nbGUpO1xufTtcblxuQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy53b3JsZEhlaWdodCAtICh0aGlzLmJvZHkucG9zaXRpb25bMV0gKyB0aGlzLmh5cCAqIE1hdGguc2luKHRoaXMuYm9keS5hbmdsZSArIHRoaXMuYW5nbGUpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXI7XG4iLCJ2YXIgQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJGdyb3VwKSB7IHRoaXMuZ3JvdXAgPSAkZ3JvdXA7IH07XG5cbkFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zZXRGcm9tUG9pbnQgPSBmdW5jdGlvbiAoJHBvaW50KVxue1xuXHR0aGlzLnBvaW50ID0gJHBvaW50O1xuXHR0aGlzLm5vZGUgPSB0aGlzLmdyb3VwLmdldENsb3Nlc3ROb2RlKCRwb2ludCk7XG5cdHRoaXMud29ybGRIZWlnaHQgPSB0aGlzLmdyb3VwLnBoeXNpY3NNYW5hZ2VyLndvcmxkSGVpZ2h0O1xuXHR0aGlzLm9mZnNldCA9IFswLCAwXTtcbn07XG5cbkFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hZGRUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0dGhpcy5ib2R5ID0gdGhpcy5ub2RlLnBoeXNpY3NNYW5hZ2VyLmJvZHk7XG59O1xuXG5BbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuc2V0Rml4ZWQgPSBmdW5jdGlvbiAoJGZpeGVkKVxue1xuXHR0aGlzLm5vZGUuZml4ZWQgPSAkZml4ZWQ7XG59O1xuXG5BbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmJvZHkucG9zaXRpb25bMF07XG59O1xuXG5BbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLndvcmxkSGVpZ2h0IC0gdGhpcy5ib2R5LnBvc2l0aW9uWzFdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlcjtcbiIsInZhciBHcm91cEdob3N0UGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJGdyb3VwKVxue1xuXHR0aGlzLmdyb3VwID0gJGdyb3VwO1xufTtcblxuR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hZGRKb2ludHNUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIG51bGw7XG59O1xuXG5Hcm91cEdob3N0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZE5vZGVzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciBnZXRYID0gZnVuY3Rpb24gKCRub2RlT1gpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICRub2RlT1g7IH07IH07XG5cdHZhciBnZXRZID0gZnVuY3Rpb24gKCRub2RlT1kpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICRub2RlT1k7IH07IH07XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmdyb3VwLm5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIG5vZGUgPSB0aGlzLmdyb3VwLm5vZGVzW2ldO1xuXHRcdHZhciBtYW5hZ2VyID0ge307XG5cdFx0bWFuYWdlci5nZXRYID0gZ2V0WChub2RlLm9YKTtcblx0XHRtYW5hZ2VyLmdldFkgPSBnZXRZKG5vZGUub1kpO1xuXHRcdG5vZGUucGh5c2ljc01hbmFnZXIgPSBtYW5hZ2VyO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwR2hvc3RQaHlzaWNzTWFuYWdlcjtcblxuIiwiLy8ganNjczpkaXNhYmxlIHJlcXVpcmVDYW1lbENhc2VPclVwcGVyQ2FzZUlkZW50aWZpZXJzXG4vKmpzaGludCBjYW1lbGNhc2U6ZmFsc2UqL1xuXG52YXIgcDIgPSByZXF1aXJlKCcuLi8uLi8uLi9saWJzL3AyJyk7XG52YXIgTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi9Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXInKTtcbnZhciBBbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlciA9IHJlcXVpcmUoJy4vQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXInKTtcblxudmFyIEdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJFAyV29ybGQsICR3b3JsZEhlaWdodCwgJGdyb3VwLCAkY29uZilcbntcblx0dGhpcy5ncm91cCA9ICRncm91cDtcblx0dGhpcy5ncm91cC5maXhlZCA9IHRoaXMuZ3JvdXAuY29uZi5maXhlZDtcblx0dGhpcy53b3JsZEhlaWdodCA9ICR3b3JsZEhlaWdodDtcblx0dGhpcy5QMldvcmxkID0gJFAyV29ybGQ7XG5cdHRoaXMuY29uZiA9ICRjb25mO1xufTtcblxuR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlQW5jaG9yRnJvbVBvaW50ID0gZnVuY3Rpb24gKCRwb2ludClcbntcblx0dmFyIGFuY2hvciA9IG5ldyBBbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlcih0aGlzLmdyb3VwKTtcblx0YW5jaG9yLnNldEZyb21Qb2ludCgkcG9pbnQpO1xuXHRyZXR1cm4gYW5jaG9yO1xufTtcblxuR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlQW5jaG9yRnJvbUxpbmUgPSBmdW5jdGlvbiAoJGxpbmVQb2ludHMpXG57XG5cdHZhciBjbG9zZXN0UG9pbnQgPSB0aGlzLmdyb3VwLmdldENsb3Nlc3RQb2ludCgkbGluZVBvaW50cyk7XG5cdHZhciBhbmNob3IgPSBuZXcgQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIodGhpcy5ncm91cCk7XG5cdGFuY2hvci5zZXRGcm9tUG9pbnQoY2xvc2VzdFBvaW50KTtcblx0cmV0dXJuIGFuY2hvcjtcbn07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUFuY2hvcnMgPSBmdW5jdGlvbiAoJHBvaW50cylcbntcblx0dmFyIHRvUmV0dXJuID0gW107XG5cdHZhciBub2RlcyA9IHRoaXMuZ3JvdXAuZ2V0Tm9kZXNJbnNpZGUoJHBvaW50cyk7XG5cdGlmICghbm9kZXMubGVuZ3RoKVxuXHR7XG5cdFx0dmFyIGRlZmF1bHRBbmNob3IgPSBuZXcgQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIodGhpcy5ncm91cCk7XG5cdFx0dmFyIGNsb3Nlc3QgPSB0aGlzLmdyb3VwLmdldENsb3Nlc3RQb2ludCgkcG9pbnRzKTtcblx0XHRkZWZhdWx0QW5jaG9yLnNldEZyb21Qb2ludChjbG9zZXN0KTtcblx0XHRyZXR1cm4gW2RlZmF1bHRBbmNob3JdO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBub2RlID0gbm9kZXNbaV07XG5cdFx0dmFyIGN1cnJBbmNob3JBID0gbmV3IEFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyKHRoaXMuZ3JvdXApO1xuXHRcdGN1cnJBbmNob3JBLnNldEZyb21Qb2ludChbbm9kZS5vWCwgbm9kZS5vWV0pO1xuXHRcdHRvUmV0dXJuLnB1c2goY3VyckFuY2hvckEpO1xuXHR9XG5cdHJldHVybiB0b1JldHVybjtcbn07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZEpvaW50c1RvV29ybGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcblxuR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkTm9kZXNUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0dmFyIHBhdGggPSBbXTtcblx0dmFyIGJvdW5kaW5nQm94ID0gdGhpcy5ncm91cC5nZXRCb3VuZGluZ0JveCgpO1xuXHR2YXIgd2lkdGggPSBib3VuZGluZ0JveFsxXVswXSAtIGJvdW5kaW5nQm94WzBdWzBdO1xuXHR2YXIgaGVpZ2h0ID0gYm91bmRpbmdCb3hbMV1bMV0gLSBib3VuZGluZ0JveFswXVsxXTtcblx0dmFyIHN0YXJ0WCA9IGJvdW5kaW5nQm94WzBdWzBdICsgd2lkdGggKiAwLjU7XG5cdHZhciBzdGFydFkgPSBib3VuZGluZ0JveFswXVsxXSArIGhlaWdodCAqIDAuNTtcblxuXHQvL3N0YXJ0WCA9IHRoaXMuZ3JvdXAubm9kZXNbMF0ub1g7XG5cdC8vc3RhcnRZID0gdGhpcy5ncm91cC5ub2Rlc1swXS5vWTtcblx0dmFyIGluaXRYID0gc3RhcnRYO1xuXHR2YXIgaW5pdFkgPSB0aGlzLndvcmxkSGVpZ2h0IC0gc3RhcnRZO1xuXG5cdHRoaXMuYm9keSA9IG5ldyBwMi5Cb2R5KHtcblx0XHRtYXNzOiB0aGlzLmdyb3VwLmZpeGVkID8gMCA6IDEsXG5cdFx0cG9zaXRpb246IFtzdGFydFgsIHRoaXMud29ybGRIZWlnaHQgLSBzdGFydFldXG5cdH0pO1xuXHR2YXIgbm9kZTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHRub2RlID0gdGhpcy5ncm91cC5ub2Rlc1tpXTtcblx0XHR2YXIgcG9zID0gW25vZGUub1ggLSBzdGFydFgsIC0obm9kZS5vWSAtIHN0YXJ0WSldO1xuXHRcdG5vZGUucGh5c2ljc01hbmFnZXIgPSBuZXcgTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyKHRoaXMuYm9keSwgcG9zLCB0aGlzLndvcmxkSGVpZ2h0KTtcblx0XHRwYXRoLnB1c2gocG9zKTtcblx0fVxuXG5cdGlmIChsZW5ndGggPiAxKVxuXHR7XG5cdFx0dGhpcy5ib2R5LmZyb21Qb2x5Z29uKHBhdGgpO1xuXHRcdHZhciBvZmZzZXQgPSBbaW5pdFggLSB0aGlzLmJvZHkucG9zaXRpb25bMF0sIHRoaXMuYm9keS5wb3NpdGlvblsxXSAtIGluaXRZXTtcblx0XHRpID0gMDtcblx0XHRmb3IgKGk7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHRub2RlID0gdGhpcy5ncm91cC5ub2Rlc1tpXTtcblx0XHRcdG5vZGUucGh5c2ljc01hbmFnZXIuc2V0T2Zmc2V0KG9mZnNldCk7XG5cdFx0fVxuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdHZhciByYWRpdXMgPSB0aGlzLmdyb3VwLnN0cnVjdHVyZVByb3BlcnRpZXMucmFkaXVzO1xuXHRcdHZhciBjaXJjbGVTaGFwZSA9IG5ldyBwMi5DaXJjbGUocmFkaXVzKTtcblx0XHR0aGlzLmJvZHkuYWRkU2hhcGUoY2lyY2xlU2hhcGUpO1xuXHR9XG5cblx0dGhpcy5ib2R5LmdyYXZpdHlTY2FsZSA9IHRoaXMuY29uZi5ncmF2aXR5U2NhbGUgfHwgMTtcblx0Ly8gY29uc29sZS5sb2coc3RhcnRYLCB0aGlzLndvcmxkSGVpZ2h0IC0gc3RhcnRZLCB0aGlzLmJvZHkucG9zaXRpb25bMF0sIHRoaXMuYm9keS5wb3NpdGlvblsxXSk7XG5cdC8vdGhpcy5ib2R5Lm1hc3MgPSB0aGlzLmNvbmYubWFzcztcblx0Ly9pZiAodGhpcy5ncm91cC5jb25mLmZpeGVkKSB7IG5vZGUucGh5c2ljc01hbmFnZXIuc2V0Rml4ZWQodGhpcy5ncm91cC5jb25mLmZpeGVkKTsgfVxuXHQvL3RoaXMuYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuXHR0aGlzLlAyV29ybGQuYWRkQm9keSh0aGlzLmJvZHkpO1xuXHR0aGlzLmJvZHkubWFzcyA9IHRoaXMuYm9keS5nZXRBcmVhKCkgKiB0aGlzLmNvbmYubWFzcztcblx0dGhpcy5ib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG5cdHRoaXMuYm9keS5jb2xsaXNpb25SZXNwb25zZSA9IGZhbHNlO1xuXHQvL25vZGUucGh5c2ljc01hbmFnZXIuc2V0Rml4ZWQodGhpcy5ncm91cC5jb25mLmZpeGVkKTtcblx0Ly8gY29uc29sZS5sb2codGhpcy5ib2R5LnNoYXBlcyk7XG5cdC8vIGRlYnVnZ2VyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyO1xuXG4iLCIvLyBqc2NzOmRpc2FibGUgcmVxdWlyZUNhbWVsQ2FzZU9yVXBwZXJDYXNlSWRlbnRpZmllcnNcbi8qanNoaW50IGNhbWVsY2FzZTpmYWxzZSovXG5cbnZhciBwMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYnMvcDInKTtcbnZhciBOb2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL05vZGVQMlNvZnRQaHlzaWNzTWFuYWdlcicpO1xudmFyIEFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi9BbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlcicpO1xuXG52YXIgR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkd29ybGQsICR3b3JsZEhlaWdodCwgJGdyb3VwLCAkY29uZilcbntcblx0dGhpcy5ncm91cCA9ICRncm91cDtcblx0dGhpcy53b3JsZCA9ICR3b3JsZDtcblx0dGhpcy53b3JsZEhlaWdodCA9ICR3b3JsZEhlaWdodDtcblx0dGhpcy5jb25mID0gJGNvbmY7XG5cdC8vdGhpcy5ub2Rlc0RpYW1ldGVyID0gdGhpcy5jb25mLm5vZGVzRGlhbWV0ZXI7XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmNob3JGcm9tUG9pbnQgPSBmdW5jdGlvbiAoJHBvaW50KVxue1xuXHR2YXIgYW5jaG9yID0gbmV3IEFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyKHRoaXMuZ3JvdXApO1xuXHRhbmNob3Iuc2V0RnJvbVBvaW50KCRwb2ludCk7XG5cdHJldHVybiBhbmNob3I7XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmNob3JGcm9tTGluZSA9IGZ1bmN0aW9uICgkbGluZVBvaW50cylcbntcblx0dmFyIGNsb3Nlc3RQb2ludCA9IHRoaXMuZ3JvdXAuZ2V0Q2xvc2VzdFBvaW50KCRsaW5lUG9pbnRzKTtcblx0dmFyIGFuY2hvciA9IG5ldyBBbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlcih0aGlzLmdyb3VwKTtcblx0YW5jaG9yLnNldEZyb21Qb2ludChjbG9zZXN0UG9pbnQpO1xuXHRyZXR1cm4gYW5jaG9yO1xufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlQW5jaG9ycyA9IGZ1bmN0aW9uICgkcG9pbnRzKVxue1xuXHR2YXIgdG9SZXR1cm4gPSBbXTtcblx0dmFyIG5vZGVzID0gdGhpcy5ncm91cC5nZXROb2Rlc0luc2lkZSgkcG9pbnRzKTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIG5vZGUgPSBub2Rlc1tpXTtcblx0XHR2YXIgY3VyckFuY2hvckEgPSBuZXcgQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIodGhpcy5ncm91cCk7XG5cdFx0Y3VyckFuY2hvckEuc2V0RnJvbVBvaW50KFtub2RlLm9YLCBub2RlLm9ZXSk7XG5cdFx0dG9SZXR1cm4ucHVzaChjdXJyQW5jaG9yQSk7XG5cdH1cblx0cmV0dXJuIHRvUmV0dXJuO1xufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkSm9pbnRzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmdyb3VwLmpvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBqb2ludCA9IHRoaXMuZ3JvdXAuam9pbnRzW2ldO1xuXHRcdHZhciBsb2NrID0gdGhpcy5jb25mLmxvY2tDb25zdHJhaW50O1xuXHRcdHZhciBkaXN0YW5jZSA9IHRoaXMuY29uZi5kaXN0YW5jZUNvbnN0cmFpbnQ7XG5cdFx0dmFyIGxpbmVhclNwcmluZyA9IHRoaXMuY29uZi5saW5lYXJTcHJpbmc7XG5cdFx0dmFyIHJvdGF0aW9uYWxTcHJpbmcgPSB0aGlzLmNvbmYucm90YXRpb25hbFNwcmluZztcblxuXHRcdGlmIChsb2NrKVxuXHRcdHtcblx0XHRcdHZhciBjb25zdHJhaW50MSA9IG5ldyBwMi5Mb2NrQ29uc3RyYWludChqb2ludC5ub2RlMS5waHlzaWNzTWFuYWdlci5ib2R5LCBqb2ludC5ub2RlMi5waHlzaWNzTWFuYWdlci5ib2R5KTtcblx0XHRcdGlmIChsb2NrLnN0aWZmbmVzcykgeyBjb25zdHJhaW50MS5zZXRTdGlmZm5lc3MobG9jay5zdGlmZm5lc3MpOyB9IC8vZGVmYXVsdCAyMFxuXHRcdFx0aWYgKGxvY2sucmVsYXhhdGlvbikgeyBjb25zdHJhaW50MS5zZXRSZWxheGF0aW9uKGxvY2sucmVsYXhhdGlvbik7IH1cblx0XHRcdHRoaXMud29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50MSk7XG5cdFx0fVxuXHRcdGlmIChkaXN0YW5jZSlcblx0XHR7XG5cdFx0XHR2YXIgY29uc3RyYWludDIgPSBuZXcgcDIuRGlzdGFuY2VDb25zdHJhaW50KGpvaW50Lm5vZGUxLnBoeXNpY3NNYW5hZ2VyLmJvZHksIGpvaW50Lm5vZGUyLnBoeXNpY3NNYW5hZ2VyLmJvZHkpO1xuXHRcdFx0aWYgKGRpc3RhbmNlLnN0aWZmbmVzcykgeyBjb25zdHJhaW50Mi5zZXRTdGlmZm5lc3MoZGlzdGFuY2Uuc3RpZmZuZXNzKTsgfSAvLyBkZWZhdWx0IDUwMFxuXHRcdFx0aWYgKGRpc3RhbmNlLnJlbGF4YXRpb24pIHsgY29uc3RyYWludDIuc2V0UmVsYXhhdGlvbihkaXN0YW5jZS5yZWxheGF0aW9uKTsgfS8vIGRlZmF1bHQgMC4xXG5cdFx0XHR0aGlzLndvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludDIpO1xuXHRcdH1cblx0XHRpZiAobGluZWFyU3ByaW5nKVxuXHRcdHtcblx0XHRcdHZhciBjb25zdHJhaW50MyA9IG5ldyBwMi5MaW5lYXJTcHJpbmcoam9pbnQubm9kZTEucGh5c2ljc01hbmFnZXIuYm9keSwgam9pbnQubm9kZTIucGh5c2ljc01hbmFnZXIuYm9keSk7XG5cdFx0XHRpZiAobGluZWFyU3ByaW5nLnN0aWZmbmVzcykgeyBjb25zdHJhaW50My5zdGlmZm5lc3MgPSBsaW5lYXJTcHJpbmcuc3RpZmZuZXNzOyB9XG5cdFx0XHRpZiAobGluZWFyU3ByaW5nLmRhbXBpbmcpIHsgY29uc3RyYWludDMuZGFtcGluZyA9IGxpbmVhclNwcmluZy5kYW1waW5nOyB9XG5cdFx0XHR0aGlzLndvcmxkLmFkZFNwcmluZyhjb25zdHJhaW50Myk7XG5cdFx0fVxuXHRcdGlmIChyb3RhdGlvbmFsU3ByaW5nKVxuXHRcdHtcblx0XHRcdGNvbnNvbGUubG9nKHJvdGF0aW9uYWxTcHJpbmcuc3RpZmZuZXNzLCByb3RhdGlvbmFsU3ByaW5nLmRhbXBpbmcpO1xuXHRcdFx0dmFyIGNvbnN0cmFpbnQ0ID0gbmV3IHAyLlJvdGF0aW9uYWxTcHJpbmcoam9pbnQubm9kZTEucGh5c2ljc01hbmFnZXIuYm9keSwgam9pbnQubm9kZTIucGh5c2ljc01hbmFnZXIuYm9keSk7XG5cdFx0XHRpZiAocm90YXRpb25hbFNwcmluZy5zdGlmZm5lc3MpIHsgY29uc3RyYWludDQuc3RpZmZuZXNzID0gcm90YXRpb25hbFNwcmluZy5zdGlmZm5lc3M7IH1cblx0XHRcdGlmIChyb3RhdGlvbmFsU3ByaW5nLmRhbXBpbmcpIHsgY29uc3RyYWludDQuZGFtcGluZyA9IHJvdGF0aW9uYWxTcHJpbmcuZGFtcGluZzsgfVxuXHRcdFx0Ly90aGlzLndvcmxkLmFkZFNwcmluZyhjb25zdHJhaW50NCk7XG5cdFx0fVxuXHR9XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hZGROb2Rlc1RvV29ybGQgPSBmdW5jdGlvbiAoKVxue1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5ncm91cC5ub2Rlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBub2RlID0gdGhpcy5ncm91cC5ub2Rlc1tpXTtcblx0XHQvL3ZhciBmcmFjdGlvbk1hc3MgPSB0aGlzLmNvbmYubWFzcyAvIHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoO1xuXHRcdHZhciBhcmVhID0gdGhpcy5ncm91cC5zdHJ1Y3R1cmVQcm9wZXJ0aWVzLmFyZWE7XG5cdFx0dmFyIG5vZGVNYXNzID0gYXJlYSAqIHRoaXMuY29uZi5tYXNzIC8gdGhpcy5ncm91cC5ub2Rlcy5sZW5ndGg7XG5cdFx0Ly92YXIgbWFzcyA9IDUwMDtcblx0XHQvL3ZhciBtYXNzID0gdGhpcy5jb25mLm1hc3M7Ly9NYXRoLnJhbmRvbSgpICogMTAgKyAxO1xuXHRcdHZhciBib2R5ID0gbmV3IHAyLkJvZHkoe1xuXHRcdFx0bWFzczogbm9kZS5maXhlZCA/IDAgOiBub2RlTWFzcyxcblx0XHRcdHBvc2l0aW9uOiBbbm9kZS5vWCwgdGhpcy53b3JsZEhlaWdodCAtIG5vZGUub1ldXG5cdFx0fSk7XG5cdFx0Ly9pZiAobm9kZS5maXhlZCkgeyBib2R5LnR5cGUgPSBwMi5Cb2R5LlNUQVRJQzsgfVxuXHRcdC8vY29uc29sZS5sb2cobm9kZS5vWCwgbm9kZS5vWSk7XG5cdFx0Ly90aGlzLmJvZHkuZml4ZWRSb3RhdGlvbiA9IHRydWU7XG5cdFx0Ym9keS5ncmF2aXR5U2NhbGUgPSB0aGlzLmNvbmYuZ3Jhdml0eVNjYWxlIHx8IDE7Ly8wOy8vIC0xO1xuXG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMuY29uZi5ub2RlUmFkaXVzO1xuXHRcdHZhciBjaXJjbGVTaGFwZSA9IG5ldyBwMi5DaXJjbGUocmFkaXVzKTtcblx0XHRib2R5LmFkZFNoYXBlKGNpcmNsZVNoYXBlKTtcblx0XHQvLyB2YXIgcGFydGljbGVTaGFwZSA9IG5ldyBwMi5QYXJ0aWNsZSgpO1xuXHRcdC8vIGJvZHkuYWRkU2hhcGUocGFydGljbGVTaGFwZSk7XG5cblx0XHQvL2NvbnNvbGUubG9nKHRoaXMuYm9keS5nZXRBcmVhKCkpO1xuXG5cdFx0Ly90aGlzLmJvZHkuc2V0RGVuc2l0eShub2RlLnR5cGUgPT09ICdsaW5lJyA/IDEgOiA1MDAwKTtcblxuXHRcdC8vIHRoaXMuYm9keS5kYW1waW5nID0gMC44O1xuXHRcdC8vYm9keS5tYXNzID0gbWFzcztcblx0XHRub2RlLnBoeXNpY3NNYW5hZ2VyID0gbmV3IE5vZGVQMlNvZnRQaHlzaWNzTWFuYWdlcihwMiwgYm9keSwgdGhpcy53b3JsZEhlaWdodCk7XG5cdFx0Ly9ub2RlLnBoeXNpY3NNYW5hZ2VyLnNldEZpeGVkKG5vZGUuZml4ZWQpO1xuXHRcdHRoaXMud29ybGQuYWRkQm9keShib2R5KTtcblx0XHQvL2JvZHkubWFzcyA9IGJvZHkuZ2V0QXJlYSgpICogdGhpcy5jb25mLm1hc3M7XG5cdFx0Ly9ib2R5LmdyYXZpdHlTY2FsZSA9IDAuMTtcblx0XHQvL2JvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcblx0XHQvLyBib2R5Lm1hc3MgPSAwO1xuXHRcdC8vIGJvZHkuc2V0RGVuc2l0eSgwKTtcblx0XHQvL25vZGUucGh5c2ljc01hbmFnZXIuYXBwbHlGb3JjZShbMCwgMF0pO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXI7XG5cbiIsIi8vIGpzY3M6ZGlzYWJsZSByZXF1aXJlQ2FtZWxDYXNlT3JVcHBlckNhc2VJZGVudGlmaWVyc1xuLypqc2hpbnQgY2FtZWxjYXNlOmZhbHNlKi9cbnZhciBwMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYnMvcDInKTtcblxudmFyIE5vZGVQMkhhcmRQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkYm9keSwgJHBvc2l0aW9uLCAkd29ybGRIZWlnaHQpXG57XG5cdHRoaXMuYm9keSA9ICRib2R5O1xuXHR0aGlzLnBvc2l0aW9uID0gJHBvc2l0aW9uO1xuXHR0aGlzLndvcmxkSGVpZ2h0ID0gJHdvcmxkSGVpZ2h0O1xuXHR0aGlzLm9mZnNldCA9IFswLCAwXTtcblx0dGhpcy5nZXRYID0gdGhpcy5nZXRYU2ltcGxlO1xuXHR0aGlzLmdldFkgPSB0aGlzLmdldFlTaW1wbGU7XG59O1xuXG5Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldEZpeGVkID0gZnVuY3Rpb24gKCRmaXhlZClcbntcblx0aWYgKCRmaXhlZClcblx0e1xuXHRcdHRoaXMuYm9keS50eXBlID0gcDIuQm9keS5TVEFUSUM7XG5cdFx0dGhpcy5ib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG5cdH1cbn07XG5cbk5vZGVQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuc2V0T2Zmc2V0ID0gZnVuY3Rpb24gKCRvZmZzZXQpXG57XG5cdHZhciBkWCA9IHRoaXMucG9zaXRpb25bMF0gKyAkb2Zmc2V0WzBdO1xuXHR2YXIgZFkgPSB0aGlzLnBvc2l0aW9uWzFdIC0gJG9mZnNldFsxXTtcblx0dGhpcy5hbmdsZSA9IE1hdGguYXRhbjIoZFksIGRYKTtcblx0dGhpcy5oeXAgPSBNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpO1xuXHR0aGlzLmdldFggPSB0aGlzLmdldFhPZmZzZXQ7XG5cdHRoaXMuZ2V0WSA9IHRoaXMuZ2V0WU9mZnNldDtcbn07XG5cbk5vZGVQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WFNpbXBsZSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmJvZHkucG9zaXRpb25bMF07XG59O1xuXG5Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFlTaW1wbGUgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy53b3JsZEhlaWdodCAtIHRoaXMuYm9keS5wb3NpdGlvblsxXTtcbn07XG5cbk5vZGVQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WE9mZnNldCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmJvZHkucG9zaXRpb25bMF0gKyB0aGlzLmh5cCAqIE1hdGguY29zKHRoaXMuYm9keS5hbmdsZSArIHRoaXMuYW5nbGUpO1xufTtcblxuTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRZT2Zmc2V0ID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMud29ybGRIZWlnaHQgLSAodGhpcy5ib2R5LnBvc2l0aW9uWzFdICsgdGhpcy5oeXAgKiBNYXRoLnNpbih0aGlzLmJvZHkuYW5nbGUgKyB0aGlzLmFuZ2xlKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVQMkhhcmRQaHlzaWNzTWFuYWdlcjtcblxuIiwiLy8ganNjczpkaXNhYmxlIHJlcXVpcmVDYW1lbENhc2VPclVwcGVyQ2FzZUlkZW50aWZpZXJzXG4vKmpzaGludCBjYW1lbGNhc2U6ZmFsc2UqL1xuXG52YXIgTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKCRwMiwgJGJvZHksICR3b3JsZEhlaWdodClcbntcblx0dGhpcy5wMiA9ICRwMjtcblx0dGhpcy5ib2R5ID0gJGJvZHk7XG5cdHRoaXMud29ybGRIZWlnaHQgPSAkd29ybGRIZWlnaHQ7XG59O1xuXG5Ob2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoJHZlYylcbntcblx0Ly9jb25zb2xlLmxvZygnbm9wJywgdGhpcy5ib2R5LmFwcGx5Rm9yY2VMb2NhbCwgJHZlYyk7XG5cdHZhciBsb2MgPSBbXTtcblx0dGhpcy5ib2R5LnRvV29ybGRGcmFtZShsb2MsIFswLCAwXSk7XG5cdHRoaXMuYm9keS5hcHBseUZvcmNlKCR2ZWMsIGxvYyk7XG59O1xuXG5Ob2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldEZpeGVkID0gZnVuY3Rpb24gKCRmaXhlZClcbntcblx0aWYgKCRmaXhlZClcblx0e1xuXHRcdHRoaXMuYm9keS50eXBlID0gdGhpcy5wMi5Cb2R5LlNUQVRJQztcblx0fVxufTtcblxuTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKClcbntcblx0Ly9jb25zb2xlLmxvZyh0aGlzLmJvZHkuR2V0V29ybGRDZW50ZXIoKS5nZXRfeCgpKTtcblx0cmV0dXJuIHRoaXMuYm9keS5wb3NpdGlvblswXTtcbn07XG5cbk5vZGVQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLndvcmxkSGVpZ2h0IC0gdGhpcy5ib2R5LnBvc2l0aW9uWzFdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlUDJTb2Z0UGh5c2ljc01hbmFnZXI7XG5cbiIsIi8vIGpzY3M6ZGlzYWJsZSByZXF1aXJlQ2FtZWxDYXNlT3JVcHBlckNhc2VJZGVudGlmaWVyc1xuLypqc2hpbnQgY2FtZWxjYXNlOmZhbHNlKi9cblxudmFyIHAyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGlicy9wMicpO1xudmFyIEdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL0dyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXInKTtcbnZhciBHcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi9Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi9Hcm91cEdob3N0UGh5c2ljc01hbmFnZXInKTtcbnZhciBBbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlciA9IHJlcXVpcmUoJy4vQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXInKTtcbnZhciBBbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlciA9IHJlcXVpcmUoJy4vQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXInKTtcbnZhciBBbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL0FuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlcicpO1xuXG52YXIgUDJQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkY29uZilcbntcblx0dGhpcy5wMldvcmxkID0gbmV3IHAyLldvcmxkKCRjb25mKTtcblx0dGhpcy5wMiA9IHAyO1xuXHR0aGlzLmNvbmYgPSAkY29uZjtcblx0dGhpcy53b3JsZFdpZHRoID0gdW5kZWZpbmVkO1xuXHR0aGlzLndvcmxkSGVpZ2h0ID0gdW5kZWZpbmVkO1xuXHQvL3RoaXMucDJXb3JsZC5ncmF2aXR5ID0gdGhpcy5jb25mLmdyYXZpdHk7XG59O1xuXG5QMlBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKCR0aW1lKVxue1xuXHR0aGlzLnAyV29ybGQuc3RlcCgkdGltZSk7XG59O1xuXG5QMlBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJhaW5Hcm91cHMgPSBmdW5jdGlvbiAoJGFuY2hvckEsICRhbmNob3JCKVxue1xuXHQkYW5jaG9yQS5hZGRUb1dvcmxkKCk7XG5cdCRhbmNob3JCLmFkZFRvV29ybGQoKTtcblx0dmFyIGNvbnN0cmFpbnQgPSBuZXcgcDIuRGlzdGFuY2VDb25zdHJhaW50KCRhbmNob3JBLmJvZHksICRhbmNob3JCLmJvZHksXG5cdHtcblx0XHRsb2NhbEFuY2hvckE6ICRhbmNob3JBLm9mZnNldCwgLy8gUG9pbnQgb24gYm9keUFcblx0XHRsb2NhbEFuY2hvckI6ICRhbmNob3JCLm9mZnNldCAvLyBQb2ludCBvbiBib2R5QlxuXHR9KTtcblx0dGhpcy5wMldvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG59O1xuXG5QMlBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbmNob3JQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkZ3JvdXApXG57XG5cdGlmICghJGdyb3VwKSB7IHJldHVybiBuZXcgQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyKHRoaXMucDIsIHRoaXMucDJXb3JsZCwgdGhpcy53b3JsZEhlaWdodCk7IH1cblxuXHRzd2l0Y2ggKCRncm91cC5jb25mLnBoeXNpY3MuYm9keVR5cGUpXG5cdHtcblx0XHRjYXNlICdoYXJkJzogcmV0dXJuIG5ldyBBbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlcigkZ3JvdXApO1xuXHRcdGRlZmF1bHQ6IHJldHVybiBuZXcgQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIoJGdyb3VwKTtcblx0fVxufTtcblxuUDJQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0R3JvdXBQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkZ3JvdXApXG57XG5cdHN3aXRjaCAoJGdyb3VwLmNvbmYucGh5c2ljcy5ib2R5VHlwZSlcblx0e1xuXHRcdGNhc2UgJ2dob3N0JzogcmV0dXJuIG5ldyBHcm91cEdob3N0UGh5c2ljc01hbmFnZXIoJGdyb3VwKTtcblx0XHRjYXNlICdoYXJkJzogcmV0dXJuIG5ldyBHcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyKHRoaXMucDJXb3JsZCwgdGhpcy53b3JsZEhlaWdodCwgJGdyb3VwLCAkZ3JvdXAuY29uZi5waHlzaWNzKTtcblx0XHRkZWZhdWx0OiByZXR1cm4gbmV3IEdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIodGhpcy5wMldvcmxkLCB0aGlzLndvcmxkSGVpZ2h0LCAkZ3JvdXAsICRncm91cC5jb25mLnBoeXNpY3MpO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFAyUGh5c2ljc01hbmFnZXI7XG5cbiIsInZhciBTVkplbGx5UmVuZGVyZXIgPSBmdW5jdGlvbiAoJHdvcmxkLCAkY2FudmFzKVxue1xuXHR0aGlzLmNhbnZhcyA9ICRjYW52YXM7XG5cdHRoaXMud29ybGQgPSAkd29ybGQ7XG5cdHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdHRoaXMuZGVidWcgPSAkd29ybGQuY29uZi5kZWJ1Zztcblx0dGhpcy5jYWNoZWQgPSBbXTtcblxuXHR0aGlzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG5cdHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXHR0aGlzLmRyYXdTY2FsZVggPSB0aGlzLmRyYXdTY2FsZVkgPSB0aGlzLmNhbnZhcy53aWR0aCAvIHRoaXMud29ybGQuZ2V0V2lkdGgoKTtcblxuXHR0aGlzLmRyYXdpbmdHcm91cHMgPSBbXTtcblx0dmFyIGsgPSAwO1xuXHR2YXIgaTtcblx0dmFyIGRyYXdpbmdHcm91cDtcblx0Zm9yICh2YXIgZ3JvdXBzTGVuZ3RoID0gdGhpcy53b3JsZC5ncm91cHNBcnJheS5sZW5ndGg7IGsgPCBncm91cHNMZW5ndGg7IGsgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyR3JvdXAgPSB0aGlzLndvcmxkLmdyb3Vwc0FycmF5W2tdO1xuXG5cdFx0aSA9IDA7XG5cdFx0Zm9yICh2YXIgbm9kZXNMZW5ndGggPSBjdXJyR3JvdXAubm9kZXMubGVuZ3RoOyBpIDwgbm9kZXNMZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3Vyck5vZGUgPSBjdXJyR3JvdXAubm9kZXNbaV07XG5cdFx0XHRpZiAoY3Vyck5vZGUuZHJhd2luZylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGN1cnJOb2RlLmRyYXdpbmcuZmlsbCB8fCBjdXJyTm9kZS5kcmF3aW5nLnN0cm9rZSkvLyAmJiAhY3Vyck5vZGUuZHJhd2luZy5ub3RUb0RyYXcpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRkcmF3aW5nR3JvdXAgPVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHByb3BlcnRpZXM6IGN1cnJOb2RlLmRyYXdpbmcsXG5cdFx0XHRcdFx0XHRub2RlczogW10sXG5cdFx0XHRcdFx0XHR0eXBlOiBjdXJyR3JvdXAudHlwZSxcblx0XHRcdFx0XHRcdHN0cnVjdHVyZTogY3Vyckdyb3VwLmNvbmYuc3RydWN0dXJlLFxuXHRcdFx0XHRcdFx0Zml4ZWQ6IGN1cnJHcm91cC5jb25mLmZpeGVkXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR0aGlzLmRyYXdpbmdHcm91cHMucHVzaChkcmF3aW5nR3JvdXApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRyYXdpbmdHcm91cC5ub2Rlcy5wdXNoKGN1cnJOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0dGhpcy5kcmF3aW5nR3JvdXBMZW5ndGggPSB0aGlzLmRyYXdpbmdHcm91cHMubGVuZ3RoO1xuXG5cdC8vY2FjaGluZyBncmFkaWVudHNcblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuZHJhd2luZ0dyb3VwTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHRkcmF3aW5nR3JvdXAgPSB0aGlzLmRyYXdpbmdHcm91cHNbaV07XG5cdFx0aWYgKGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLnN0cm9rZUdyYWRpZW50KVxuXHRcdHtcblx0XHRcdGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLnN0cm9rZSA9IHRoaXMuY3JlYXRlR3JhZGllbnQoZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuc3Ryb2tlR3JhZGllbnQpO1xuXHRcdH1cblx0XHRpZiAoZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuZmlsbEdyYWRpZW50KVxuXHRcdHtcblx0XHRcdGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmZpbGwgPSB0aGlzLmNyZWF0ZUdyYWRpZW50KGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmZpbGxHcmFkaWVudCk7XG5cdFx0fVxuXHR9XG5cblx0Ly9jYWNoaW5nIGdob3N0c1xuXHRpID0gMDtcblx0dmFyIHByZXZpb3VzRHJhd2luZ0dyb3VwO1xuXHRmb3IgKGk7IGkgPCB0aGlzLmRyYXdpbmdHcm91cExlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0ZHJhd2luZ0dyb3VwID0gdGhpcy5kcmF3aW5nR3JvdXBzW2ldO1xuXHRcdGlmIChkcmF3aW5nR3JvdXAudHlwZSA9PT0gJ2dob3N0JyB8fCBkcmF3aW5nR3JvdXAuZml4ZWQgPT09IHRydWUpXG5cdFx0e1xuXHRcdFx0dmFyIGNhbnZhcztcblx0XHRcdGlmICh0aGlzLmNhY2hlZFtpIC0gMV0gPT09IHVuZGVmaW5lZClcblx0XHRcdHtcblx0XHRcdFx0Y2FudmFzID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdFx0XHRjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdC8vaWYgc29tZSBnaG9zdCBsYXllcnMgYXJlIG9uIHRvcCBvZiBlYWNoIG90aGVyLCBubyBuZWVkIHRvIGNyZWF0ZVxuXHRcdFx0XHQvL2EgbmV3IGNhbnZhcywgeW91IGNhbiBqdXN0IGRyYXcgdGhlIGxheWVycyBvbiB0aGUgc2FtZSBvbmVcblx0XHRcdFx0Y2FudmFzID0gdGhpcy5jYWNoZWRbaSAtIDFdO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdFx0dGhpcy5kcmF3R3JvdXAoZHJhd2luZ0dyb3VwLCBjb250ZXh0KTtcblx0XHRcdHRoaXMuY2FjaGVkW2ldID0gY2FudmFzO1xuXHRcdH1cblx0XHRwcmV2aW91c0RyYXdpbmdHcm91cCA9IGRyYXdpbmdHcm91cDtcblx0fVxufTtcblxuU1ZKZWxseVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVHcmFkaWVudCA9IGZ1bmN0aW9uICgkcHJvcGVydGllcylcbntcblx0dmFyIHgxID0gJHByb3BlcnRpZXMueDEgKiB0aGlzLmRyYXdTY2FsZVg7XG5cdHZhciB5MSA9ICRwcm9wZXJ0aWVzLnkxICogdGhpcy5kcmF3U2NhbGVZO1xuXHR2YXIgeDIgPSAkcHJvcGVydGllcy54MiAqIHRoaXMuZHJhd1NjYWxlWDtcblx0dmFyIHkyID0gJHByb3BlcnRpZXMueTIgKiB0aGlzLmRyYXdTY2FsZVk7XG5cblx0dmFyIGN4ID0gJHByb3BlcnRpZXMuY3ggKiB0aGlzLmRyYXdTY2FsZVg7XG5cdHZhciBjeSA9ICRwcm9wZXJ0aWVzLmN5ICogdGhpcy5kcmF3U2NhbGVZO1xuXHR2YXIgZnggPSAkcHJvcGVydGllcy5meCAqIHRoaXMuZHJhd1NjYWxlWCB8fCBjeDtcblx0dmFyIGZ5ID0gJHByb3BlcnRpZXMuZnkgKiB0aGlzLmRyYXdTY2FsZVkgfHwgY3k7XG5cdHZhciByID0gJHByb3BlcnRpZXMuciAqIHRoaXMuZHJhd1NjYWxlWDtcblxuXHR2YXIgZ3JhZGllbnQgPSAkcHJvcGVydGllcy50eXBlID09PSAnbGluZWFyR3JhZGllbnQnID8gdGhpcy5jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKSA6IHRoaXMuY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChjeCwgY3ksIDAsIGZ4LCBmeSwgcik7XG5cblx0Ly9ncmFkaWVudCA9IHRoaXMuY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCA1MDAsIDUwMCk7XG5cblx0Zm9yICh2YXIgc3RvcE4gPSAwLCBzdG9wTGVuZ3RoID0gJHByb3BlcnRpZXMuc3RvcHMubGVuZ3RoOyBzdG9wTiA8IHN0b3BMZW5ndGg7IHN0b3BOICs9IDEpXG5cdHtcblx0XHRncmFkaWVudC5hZGRDb2xvclN0b3AoJHByb3BlcnRpZXMuc3RvcHNbc3RvcE5dLm9mZnNldCwgJHByb3BlcnRpZXMuc3RvcHNbc3RvcE5dLmNvbG9yKTtcblx0fVxuXG5cdC8vIHZhciBndWV1Z3VldSA9IHRoaXMuY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCA1MDAsIDUwMCk7XG5cdC8vIGd1ZXVndWV1LmFkZENvbG9yU3RvcCgwLCAncmVkJyk7XG5cdC8vIGd1ZXVndWV1LmFkZENvbG9yU3RvcCgxLCAnYmx1ZScpO1xuXHRyZXR1cm4gZ3JhZGllbnQ7XG59O1xuXG5TVkplbGx5UmVuZGVyZXIucHJvdG90eXBlLmdldERyYXdpbmdHcm91cCA9IGZ1bmN0aW9uICgkY29tcGFyaXNvbilcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZHJhd2luZ0dyb3Vwcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyR3JvdXAgPSB0aGlzLmRyYXdpbmdHcm91cHNbaV07XG5cdFx0aWYgKHRoaXMuY29tcGFyZVByb3BlcnRpZXMoY3Vyckdyb3VwLnByb3BlcnRpZXMsICRjb21wYXJpc29uKSkgeyByZXR1cm4gY3Vyckdyb3VwOyB9XG5cdH1cbn07XG5cblNWSmVsbHlSZW5kZXJlci5wcm90b3R5cGUuY29tcGFyZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoJG9uZSwgJHR3bylcbntcblx0dmFyIGNvbXBhcmlzb24gPSB0cnVlO1xuXHRmb3IgKHZhciBuYW1lIGluICR0d28pXG5cdHtcblx0XHRpZiAoJG9uZVtuYW1lXSAhPT0gJHR3b1tuYW1lXSkgeyBjb21wYXJpc29uID0gZmFsc2U7IH1cblx0fVxuXHRyZXR1cm4gY29tcGFyaXNvbjtcbn07XG5cblNWSmVsbHlSZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICgpXG57XG5cdHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR0aGlzLmNvbnRleHQubWl0ZXJMaW1pdCA9IDE7XG5cdHZhciBwcmV2aW91c0NhY2hlZDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRyYXdpbmdHcm91cExlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGRyYXdpbmdHcm91cCA9IHRoaXMuZHJhd2luZ0dyb3Vwc1tpXTtcblx0XHRpZiAodGhpcy5jYWNoZWRbaV0gJiYgdGhpcy5jYWNoZWRbaV0gIT09IHByZXZpb3VzQ2FjaGVkKVxuXHRcdHtcblx0XHRcdHRoaXMuY29udGV4dC5kcmF3SW1hZ2UodGhpcy5jYWNoZWRbaV0sIDAsIDApO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy5kcmF3R3JvdXAoZHJhd2luZ0dyb3VwLCB0aGlzLmNvbnRleHQpO1xuXHRcdH1cblx0XHRwcmV2aW91c0NhY2hlZCA9IHRoaXMuY2FjaGVkW2ldO1xuXHR9XG5cblx0aWYgKHRoaXMuZGVidWcpIHsgdGhpcy5kZWJ1Z0RyYXcoKTsgfVxufTtcblxuU1ZKZWxseVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3R3JvdXAgPSBmdW5jdGlvbiAoJGRyYXdpbmdHcm91cCwgJGNvbnRleHQpXG57XG5cdHZhciBub2Rlc0xlbmd0aCA9ICRkcmF3aW5nR3JvdXAubm9kZXMubGVuZ3RoO1xuXHQkY29udGV4dC5iZWdpblBhdGgoKTtcblxuXHQvLyBjb25zb2xlLmxvZygkY29udGV4dC5maWxsU3R5bGUsICRjb250ZXh0LnN0cm9rZVN0eWxlKTtcblx0Ly8gY29uc29sZS5sb2coJGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmZpbGwsICRkcmF3aW5nR3JvdXAucHJvcGVydGllcy5zdHJva2UpO1xuXHQvLyBkZWJ1Z2dlcjtcblxuXHQvLyBpZiAoJGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmZpbGwgIT09ICdub25lJykgeyAkY29udGV4dC5maWxsU3R5bGUgPSAkZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuZmlsbDsgfVxuXHQvLyBpZiAoJGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLnN0cm9rZSAhPT0gJ25vbmUnKSB7ICRjb250ZXh0LnN0cm9rZVN0eWxlID0gJGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLnN0cm9rZTsgfVxuXHRpZiAoJGNvbnRleHQuZmlsbFN0eWxlICE9PSAkZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuZmlsbCkgeyAkY29udGV4dC5maWxsU3R5bGUgPSAkZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuZmlsbDsgfVxuXHRpZiAoJGNvbnRleHQuc3Ryb2tlU3R5bGUgIT09ICRkcmF3aW5nR3JvdXAucHJvcGVydGllcy5zdHJva2UpIHsgJGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAkZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuc3Ryb2tlOyB9XG5cblx0aWYgKCRkcmF3aW5nR3JvdXAucHJvcGVydGllcy5saW5lV2lkdGggIT09ICdub25lJykgeyAkY29udGV4dC5saW5lV2lkdGggPSAkZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMubGluZVdpZHRoICogdGhpcy5kcmF3U2NhbGVYOyB9XG5cdGlmICgkZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMubGluZUNhcCkgeyAkY29udGV4dC5saW5lQ2FwID0gJGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmxpbmVDYXA7IH1cblx0aWYgKCRkcmF3aW5nR3JvdXAucHJvcGVydGllcy5saW5lSm9pbikgeyAkY29udGV4dC5saW5lSm9pbiA9ICRkcmF3aW5nR3JvdXAucHJvcGVydGllcy5saW5lSm9pbjsgfVxuXHQkY29udGV4dC5nbG9iYWxBbHBoYSA9ICRkcmF3aW5nR3JvdXAucHJvcGVydGllcy5vcGFjaXR5ID8gJGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLm9wYWNpdHkgOiAxO1xuXG5cdGZvciAodmFyIGsgPSAwOyBrIDwgbm9kZXNMZW5ndGg7IGsgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyTm9kZSA9ICRkcmF3aW5nR3JvdXAubm9kZXNba107XG5cdFx0aWYgKGN1cnJOb2RlLmRyYXdpbmcgJiYgY3Vyck5vZGUuZHJhd2luZy5ub3RUb0RyYXcpIHsgY29udGludWU7IH1cblx0XHRpZiAoY3Vyck5vZGUuaXNTdGFydClcblx0XHR7XG5cdFx0XHQvL2xpbmUgZ3JhZGllbnRcblx0XHRcdGlmICgkZHJhd2luZ0dyb3VwLnR5cGUgPT09ICdsaW5lJyAmJiAkZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuc3Ryb2tlR3JhZGllbnQpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciB4MSA9IGN1cnJOb2RlLmdldFgoKSAqIHRoaXMuZHJhd1NjYWxlWDtcblx0XHRcdFx0dmFyIHkxID0gY3Vyck5vZGUuZ2V0WSgpICogdGhpcy5kcmF3U2NhbGVZO1xuXHRcdFx0XHR2YXIgeDIgPSBjdXJyTm9kZS5lbmROb2RlLmdldFgoKSAqIHRoaXMuZHJhd1NjYWxlWDtcblx0XHRcdFx0dmFyIHkyID0gY3Vyck5vZGUuZW5kTm9kZS5nZXRZKCkgKiB0aGlzLmRyYXdTY2FsZVk7XG5cdFx0XHRcdHZhciBncmFkaWVudCA9ICRjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKTtcblx0XHRcdFx0Zm9yICh2YXIgc3RvcE4gPSAwLCBzdG9wTGVuZ3RoID0gY3Vyck5vZGUuZHJhd2luZy5zdHJva2VHcmFkaWVudC5sZW5ndGg7IHN0b3BOIDwgc3RvcExlbmd0aDsgc3RvcE4gKz0gMSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGdyYWRpZW50LmFkZENvbG9yU3RvcCgxIC0gY3Vyck5vZGUuZHJhd2luZy5zdHJva2VHcmFkaWVudFtzdG9wTl0ub2Zmc2V0LCBjdXJyTm9kZS5kcmF3aW5nLnN0cm9rZUdyYWRpZW50W3N0b3BOXS5jb2xvcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0JGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBncmFkaWVudDtcblx0XHRcdH1cblx0XHRcdC8vXG5cblx0XHRcdCRjb250ZXh0Lm1vdmVUbyhjdXJyTm9kZS5nZXRYKCkgKiB0aGlzLmRyYXdTY2FsZVgsIGN1cnJOb2RlLmdldFkoKSAqIHRoaXMuZHJhd1NjYWxlWSk7XG5cdFx0XHRpZiAoJGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLnJhZGl1cylcblx0XHRcdHtcblx0XHRcdFx0JGNvbnRleHQuYXJjKGN1cnJOb2RlLmdldFgoKSAqIHRoaXMuZHJhd1NjYWxlWCwgY3Vyck5vZGUuZ2V0WSgpICogdGhpcy5kcmF3U2NhbGVZLCAkZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMucmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQkY29udGV4dC5saW5lVG8oY3Vyck5vZGUuZ2V0WCgpICogdGhpcy5kcmF3U2NhbGVYLCBjdXJyTm9kZS5nZXRZKCkgKiB0aGlzLmRyYXdTY2FsZVkpO1xuXHRcdH1cblx0XHQvLyAkY29udGV4dC5tb3ZlVG8oY3Vyck5vZGUuZ2V0WCgpICogdGhpcy5kcmF3U2NhbGVYLCB0aGlzLmhlaWdodCAtIGN1cnJOb2RlLmdldFkoKSAqIHRoaXMuZHJhd1NjYWxlWSk7XG5cdFx0Ly8gJGNvbnRleHQuYXJjKGN1cnJOb2RlLmdldFgoKSAqIHRoaXMuZHJhd1NjYWxlWCwgdGhpcy5oZWlnaHQgLSBjdXJyTm9kZS5nZXRZKCkgKiB0aGlzLmRyYXdTY2FsZVksIDIsIDAsIE1hdGguUEkgKiAyKTtcblx0fVxuXHRpZiAoJGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmNsb3NlUGF0aCkgeyAkY29udGV4dC5jbG9zZVBhdGgoKTsgfVxuXHRpZiAoJGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmZpbGwgIT09ICdub25lJykgeyAkY29udGV4dC5maWxsKCk7IH1cblx0aWYgKCRkcmF3aW5nR3JvdXAucHJvcGVydGllcy5zdHJva2UgIT09ICdub25lJykgeyAkY29udGV4dC5zdHJva2UoKTsgfVxufTtcblxuU1ZKZWxseVJlbmRlcmVyLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoJGNsZWFyKVxue1xuXHRpZiAoJGNsZWFyICE9PSB1bmRlZmluZWQpIHsgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7IH1cblxuXHR0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMjU1LDEsMSknO1xuXHR0aGlzLmNvbnRleHQubGluZUNhcCA9ICdidXR0Jztcblx0dGhpcy5jb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJztcblx0dGhpcy5jb250ZXh0LmxpbmVXaWR0aCA9IDE7XG5cdHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcblx0dmFyIGN1cnJHcm91cDtcblx0dmFyIGk7XG5cdHZhciBrO1xuXHR2YXIgZ3JvdXBzTGVuZ3RoID0gdGhpcy53b3JsZC5ncm91cHNBcnJheS5sZW5ndGg7XG5cdGZvciAoayA9IDA7IGsgPCBncm91cHNMZW5ndGg7IGsgKz0gMSlcblx0e1xuXHRcdGN1cnJHcm91cCA9IHRoaXMud29ybGQuZ3JvdXBzQXJyYXlba107XG5cblx0XHR2YXIgbm9kZXNMZW5ndGggPSBjdXJyR3JvdXAubm9kZXMubGVuZ3RoO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyTm9kZSA9IGN1cnJHcm91cC5ub2Rlc1tpXTtcblx0XHRcdHRoaXMuY29udGV4dC5tb3ZlVG8oY3Vyck5vZGUuZ2V0WCgpICogdGhpcy5kcmF3U2NhbGVYLCBjdXJyTm9kZS5nZXRZKCkgKiB0aGlzLmRyYXdTY2FsZVkpO1xuXHRcdFx0dGhpcy5jb250ZXh0LmFyYyhjdXJyTm9kZS5nZXRYKCkgKiB0aGlzLmRyYXdTY2FsZVgsIGN1cnJOb2RlLmdldFkoKSAqIHRoaXMuZHJhd1NjYWxlWSwgY3Vyckdyb3VwLmNvbmYucGh5c2ljcy5ub2RlUmFkaXVzICogdGhpcy5kcmF3U2NhbGVYLCAwLCBNYXRoLlBJICogMik7XG5cdFx0fVxuXHR9XG5cdHRoaXMuY29udGV4dC5zdHJva2UoKTtcblxuXHR0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMSwxLDEpJztcblx0dGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRmb3IgKGsgPSAwOyBrIDwgZ3JvdXBzTGVuZ3RoOyBrICs9IDEpXG5cdHtcblx0XHRjdXJyR3JvdXAgPSB0aGlzLndvcmxkLmdyb3Vwc0FycmF5W2tdO1xuXHRcdHZhciBqb2ludHNMZW5ndGggPSBjdXJyR3JvdXAuam9pbnRzLmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBqb2ludHNMZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3VyckpvaW50ID0gY3Vyckdyb3VwLmpvaW50c1tpXTtcblx0XHRcdHRoaXMuY29udGV4dC5tb3ZlVG8oY3VyckpvaW50Lm5vZGUxLmdldFgoKSAqIHRoaXMuZHJhd1NjYWxlWCwgY3VyckpvaW50Lm5vZGUxLmdldFkoKSAqIHRoaXMuZHJhd1NjYWxlWSk7XG5cdFx0XHR0aGlzLmNvbnRleHQubGluZVRvKGN1cnJKb2ludC5ub2RlMi5nZXRYKCkgKiB0aGlzLmRyYXdTY2FsZVgsIGN1cnJKb2ludC5ub2RlMi5nZXRZKCkgKiB0aGlzLmRyYXdTY2FsZVkpO1xuXHRcdH1cblx0fVxuXHR0aGlzLmNvbnRleHQuc3Ryb2tlKCk7XG5cblx0dGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuXHR0aGlzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG5cdHZhciBsZW5ndGggPSB0aGlzLndvcmxkLmdyb3VwQ29uc3RyYWludHMubGVuZ3RoO1xuXHRmb3IgKGsgPSAwOyBrIDwgbGVuZ3RoOyBrICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyckxvY2sgPSB0aGlzLndvcmxkLmdyb3VwQ29uc3RyYWludHNba107XG5cdFx0dGhpcy5jb250ZXh0Lm1vdmVUbyhjdXJyTG9jay5hbmNob3JBLmdldFgoKSAqIHRoaXMuZHJhd1NjYWxlWCwgY3VyckxvY2suYW5jaG9yQS5nZXRZKCkgKiB0aGlzLmRyYXdTY2FsZVkpO1xuXHRcdHRoaXMuY29udGV4dC5saW5lVG8oY3VyckxvY2suYW5jaG9yQi5nZXRYKCkgKiB0aGlzLmRyYXdTY2FsZVgsIGN1cnJMb2NrLmFuY2hvckIuZ2V0WSgpICogdGhpcy5kcmF3U2NhbGVZKTtcblx0fVxuXHR0aGlzLmNvbnRleHQuc3Ryb2tlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWSmVsbHlSZW5kZXJlcjtcblxuIiwidmFyIFNWSmVsbHlXb3JsZCA9IHJlcXVpcmUoJy4vY29yZS9TVkplbGx5V29ybGQnKTtcbnZhciBTVkplbGx5UmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVyL3N2amVsbHkvU1ZKZWxseVJlbmRlcmVyJyk7XG52YXIgU1ZHUGFyc2VyID0gcmVxdWlyZSgnLi9jb3JlL1NWR1BhcnNlcicpO1xudmFyIFAyUGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL3BoeXNpY3MvcDJwaHlzaWNzL1AyUGh5c2ljc01hbmFnZXInKTtcbnZhciBTVkplbGx5VXRpbHMgPSByZXF1aXJlKCcuL2NvcmUvU1ZKZWxseVV0aWxzJyk7XG52YXIgY29uZk9iamVjdCA9IHJlcXVpcmUoJy4vY29yZS9Db25mT2JqZWN0Jyk7XG5cbi8vVE9ETyBwcm9taXNlIHBvbHlmaWxsXG52YXIgU1ZKZWxseU1ha2VyID1cbntcblx0Y3JlYXRlRnJvbVVSTDogZnVuY3Rpb24gKCRjYW52YXMsICRVUkwsICRwaHlzaWNzTWFuYWdlciwgJHJlbmRlcmVyKVxuXHR7XG5cdFx0dmFyIHN2amVsbHlNYWtlciA9IE9iamVjdC5jcmVhdGUoU1ZKZWxseU1ha2VyKTtcblx0XHRzdmplbGx5TWFrZXIuY2FudmFzID0gJGNhbnZhcztcblx0XHRzdmplbGx5TWFrZXIucmVuZGVyZXIgPSAkcmVuZGVyZXI7XG5cdFx0c3ZqZWxseU1ha2VyLnBoeXNpY3NNYW5hZ2VyID0gJHBoeXNpY3NNYW5hZ2VyO1xuXHRcdHN2amVsbHlNYWtlci5sb2FkRmlsZSgkVVJMLCBmdW5jdGlvbiAoJFNWRykgeyBzdmplbGx5TWFrZXIuY3JlYXRlKCRTVkcpOyB9LCB0cnVlKTtcblx0XHRyZXR1cm4gc3ZqZWxseU1ha2VyO1xuXHR9LFxuXHRjcmVhdGVGcm9tQ29uZmlnOiBmdW5jdGlvbiAoJGNhbnZhcywgJGNvbmZpZ1VSTCwgJHBoeXNpY3NNYW5hZ2VyLCAkcmVuZGVyZXIpXG5cdHtcblx0XHR2YXIgc3ZqZWxseU1ha2VyID0gT2JqZWN0LmNyZWF0ZShTVkplbGx5TWFrZXIpO1xuXHRcdHN2amVsbHlNYWtlci5jYW52YXMgPSAkY2FudmFzO1xuXHRcdHN2amVsbHlNYWtlci5yZW5kZXJlciA9ICRyZW5kZXJlcjtcblx0XHRzdmplbGx5TWFrZXIucGh5c2ljc01hbmFnZXIgPSAkcGh5c2ljc01hbmFnZXI7XG5cblx0XHRzdmplbGx5TWFrZXIucHJvbWlzZSA9IG5ldyB3aW5kb3cuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSlcblx0XHR7XG5cdFx0XHR2YXIgbG9hZENvbmZpZ0NvbXBsZXRlID0gZnVuY3Rpb24gKCRjb25maWdEYXRhKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgSlNPTkNvbmZpZyA9IEpTT04ucGFyc2UoJGNvbmZpZ0RhdGEpO1xuXHRcdFx0XHRzdmplbGx5TWFrZXIuY29uZiA9IFNWSmVsbHlVdGlscy5leHRlbmQoY29uZk9iamVjdCwgSlNPTkNvbmZpZyk7XG5cblx0XHRcdFx0U1ZKZWxseU1ha2VyLmxvYWRGaWxlKHN2amVsbHlNYWtlci5jb25mLnNvdXJjZSwgZnVuY3Rpb24gKCRTVkcpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzdmplbGx5TWFrZXIuY3JlYXRlKCRTVkcpO1xuXHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0fSwgdHJ1ZSk7XG5cdFx0XHR9O1xuXHRcdFx0U1ZKZWxseU1ha2VyLmxvYWRGaWxlKCRjb25maWdVUkwsIGxvYWRDb25maWdDb21wbGV0ZSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gc3ZqZWxseU1ha2VyO1xuXHR9LFxuXHRjcmVhdGVGcm9tUGFnZVNWRzogZnVuY3Rpb24gKCRwaHlzaWNzTWFuYWdlciwgJHJlbmRlcmVyKVxuXHR7XG5cdFx0dmFyIHN2amVsbGllcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXN2amVsbHldJyk7XG5cblx0XHR2YXIgY3JlYXRlVmlld2VyID0gZnVuY3Rpb24gKCRlbGVtZW50KVxuXHRcdHtcblx0XHRcdHZhciBzdmplbGx5TWFrZXIgPSBPYmplY3QuY3JlYXRlKFNWSmVsbHlNYWtlcik7XG5cdFx0XHR2YXIgY3VyclNWRyA9ICRlbGVtZW50O1xuXHRcdFx0dmFyIGFwcGVuZENhbnZhcyA9IGZ1bmN0aW9uICgkY29uZmlnKVxuXHRcdFx0e1xuXHRcdFx0XHRzdmplbGx5TWFrZXIuY29uZiA9ICRjb25maWc7XG5cdFx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gY3VyclNWRy5jbGllbnRXaWR0aDtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGN1cnJTVkcuY2xpZW50SGVpZ2h0O1xuXHRcdFx0XHRjdXJyU1ZHLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNhbnZhcywgY3VyclNWRyk7XG5cdFx0XHRcdGN1cnJTVkcucmVtb3ZlKCk7XG5cdFx0XHRcdHN2amVsbHlNYWtlci5jYW52YXMgPSBjYW52YXM7XG5cdFx0XHRcdHN2amVsbHlNYWtlci5yZW5kZXJlciA9ICRyZW5kZXJlcjtcblx0XHRcdFx0c3ZqZWxseU1ha2VyLnBoeXNpY3NNYW5hZ2VyID0gJHBoeXNpY3NNYW5hZ2VyO1xuXHRcdFx0XHR2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0XHR3cmFwcGVyLmFwcGVuZENoaWxkKGN1cnJTVkcpO1xuXHRcdFx0XHRzdmplbGx5TWFrZXIuY3JlYXRlKHdyYXBwZXIpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBjb25maWdVUkwgPSBjdXJyU1ZHLmdldEF0dHJpYnV0ZSgnZGF0YS1zdmplbGx5Jyk7XG5cdFx0XHRpZiAoY29uZmlnVVJMKVxuXHRcdFx0e1xuXHRcdFx0XHRTVkplbGx5TWFrZXIubG9hZEZpbGUoY29uZmlnVVJMLCBmdW5jdGlvbiAoJGNvbmZpZ0RhdGEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgSlNPTkNvbmZpZyA9IEpTT04ucGFyc2UoJGNvbmZpZ0RhdGEpO1xuXHRcdFx0XHRcdGFwcGVuZENhbnZhcyhTVkplbGx5VXRpbHMuZXh0ZW5kKGNvbmZPYmplY3QsIEpTT05Db25maWcpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGFwcGVuZENhbnZhcygpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3ZqZWxsaWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyU1ZHID0gc3ZqZWxsaWVzW2ldO1xuXHRcdFx0Y3JlYXRlVmlld2VyKGN1cnJTVkcpO1xuXHRcdH1cblx0fSxcblx0Y3JlYXRlOiBmdW5jdGlvbiAoJFNWRylcblx0e1xuXHRcdHZhciByZXF1ZXN0QW5pbUZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG5cdFx0dmFyIGNhbmNlbEFuaW1GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZTtcblxuXHRcdHZhciBjb25mID0gdGhpcy5jb25mIHx8IGNvbmZPYmplY3Q7XG5cdFx0dmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuXG5cdFx0dGhpcy5waHlzaWNzTWFuYWdlciA9IHRoaXMucGh5c2ljc01hbmFnZXIgfHwgbmV3IFAyUGh5c2ljc01hbmFnZXIoY29uZik7XG5cdFx0dmFyIHN2amVsbHlXb3JsZCA9IHRoaXMuc3ZqZWxseVdvcmxkID0gbmV3IFNWSmVsbHlXb3JsZCh0aGlzLnBoeXNpY3NNYW5hZ2VyLCBjb25mKTtcblxuXHRcdHZhciByZXF1ZXN0SUQgPSAnJztcblxuXHRcdHZhciBjYW52YXNEZWZpbml0aW9uID0gY29uZi5kZWZpbml0aW9uO1xuXHRcdHZhciBzdmdEZWYgPSAkU1ZHLnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpO1xuXHRcdHZhciBwYXJzZXIgPSBuZXcgU1ZHUGFyc2VyKCk7XG5cdFx0cGFyc2VyLnBhcnNlKHN2amVsbHlXb3JsZCwgc3ZnRGVmKTtcblx0XHR2YXIgY2FudmFzV2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGggKiBjYW52YXNEZWZpbml0aW9uO1xuXHRcdHZhciBjYW52YXNIZWlnaHQgPSBjYW52YXMuY2xpZW50V2lkdGggKiAocGFyc2VyLnZpZXdCb3hIZWlnaHQgLyBwYXJzZXIudmlld0JveFdpZHRoKSAqIGNhbnZhc0RlZmluaXRpb247XG5cblx0XHRjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXHRcdGNhbnZhcy5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAwJztcblx0XHRjYW52YXMuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKCcgKyAxIC8gY2FudmFzRGVmaW5pdGlvbiArICcpJztcblxuXHRcdHZhciBSZW5kZXJlciA9IHRoaXMucmVuZGVyZXIgfHwgU1ZKZWxseVJlbmRlcmVyO1xuXHRcdHZhciBzdmplbGx5RHJhdyA9IG5ldyBSZW5kZXJlcihzdmplbGx5V29ybGQsIGNhbnZhcyk7XG5cblx0XHR2YXIgbGFzdFNpbSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblx0XHR2YXIgbGFzdFJlbmRlciA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblx0XHR2YXIgc2ltRGlmZjtcblx0XHR2YXIgZGlmZlJlbmRlcjtcblx0XHR2YXIgc2ltVGFyZ2V0RlBTTWlsbGlTZWNvbmRzID0gMTY7Ly8kY29uZmlnRGF0YS5zaW1SZW5kZXJGcmVxOyAvLzYwZnBzXG5cdFx0dmFyIHJlbmRlclRhcmdldEZQU01pbGxpU2Vjb25kcyA9IDA7XG5cblx0XHR2YXIgdXBkYXRlID0gZnVuY3Rpb24gKCRub3cpXG5cdFx0e1xuXHRcdFx0c2ltRGlmZiA9ICRub3cgLSBsYXN0U2ltO1xuXHRcdFx0ZGlmZlJlbmRlciA9ICRub3cgLSBsYXN0UmVuZGVyO1xuXHRcdFx0aWYgKHNpbURpZmYgPj0gc2ltVGFyZ2V0RlBTTWlsbGlTZWNvbmRzKVxuXHRcdFx0e1xuXHRcdFx0XHRzdmplbGx5V29ybGQucGh5c2ljc01hbmFnZXIuc3RlcChNYXRoLm1pbigxLCBzaW1EaWZmIC8gMTAwMCkpO1xuXHRcdFx0XHRsYXN0U2ltID0gJG5vdztcblx0XHRcdH1cblx0XHRcdGlmIChkaWZmUmVuZGVyID49IHJlbmRlclRhcmdldEZQU01pbGxpU2Vjb25kcylcblx0XHRcdHtcblx0XHRcdFx0c3ZqZWxseURyYXcuZHJhdygpO1xuXHRcdFx0XHRsYXN0UmVuZGVyID0gJG5vdztcblx0XHRcdH1cblx0XHRcdHJlcXVlc3RJRCA9IHJlcXVlc3RBbmltRnJhbWUodXBkYXRlKTtcblx0XHR9O1xuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkgeyByZXF1ZXN0SUQgPSByZXF1ZXN0QW5pbUZyYW1lKHVwZGF0ZSk7IH0pO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKCkgeyBjYW5jZWxBbmltRnJhbWUocmVxdWVzdElEKTsgfSk7XG5cblx0XHRyZXF1ZXN0SUQgPSByZXF1ZXN0QW5pbUZyYW1lKHVwZGF0ZSk7XG5cdH0sXG5cblx0bG9hZEZpbGU6IGZ1bmN0aW9uICgkVVJMLCAkc3VjY2Vzc0NhbGxiYWNrLCAkWE1MKVxuXHR7XG5cdFx0dmFyIGVycm9yID0gZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRjb25zb2xlLmxvZygnZXJyb3InLCAkVVJMKTtcblx0XHR9O1xuXG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdCRzdWNjZXNzQ2FsbGJhY2soJFhNTCA/IHRoaXMucmVzcG9uc2VYTUwgOiB0aGlzLnJlc3BvbnNlVGV4dCk7XG5cdFx0fTtcblxuXHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgaGFuZGxlcik7XG5cdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcblx0XHRyZXF1ZXN0Lm9wZW4oJ2dldCcsICRVUkwsIHRydWUpO1xuXHRcdHJlcXVlc3Quc2VuZCgpO1xuXHR9XG59O1xuXG5pZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtc3ZqZWxseS1hdXRvXScpKVxue1xuXHR2YXIgd2luZG93TG9hZEhhbmRsZXIgPSBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0U1ZKZWxseU1ha2VyLmNyZWF0ZUZyb21QYWdlU1ZHKCk7XG5cdH07XG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgd2luZG93TG9hZEhhbmRsZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNWSmVsbHlNYWtlcjtcbiJdfQ==
